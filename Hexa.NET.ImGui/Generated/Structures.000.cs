// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawChannel
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawCmd CmdBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawIdx IdxBuffer;


		/// <summary>/// To be documented./// </summary>		public unsafe ImDrawChannel(ImVectorImDrawCmd Cmdbuffer = default, ImVectorImDrawIdx Idxbuffer = default)
		{
			CmdBuffer = Cmdbuffer;
			IdxBuffer = Idxbuffer;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawCmd
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawCmd* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImDrawCmd(int size = default, int capacity = default, ImDrawCmd* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawCmd
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 ClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* TextureId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint VtxOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint IdxOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ElemCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserCallback;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserCallbackData;



		/// <summary>/// To be documented./// </summary>		public unsafe ImDrawCmd(Vector4 clipRect = default, void* textureId = default, uint vtxOffset = default, uint idxOffset = default, uint elemCount = default, delegate*<void> userCallback = default, void* userCallbackData = default)
		{
			ClipRect = clipRect;
			TextureId = textureId;
			VtxOffset = vtxOffset;
			IdxOffset = idxOffset;
			ElemCount = elemCount;
			UserCallback = (void*)userCallback;
			UserCallbackData = userCallbackData;
		}


		public unsafe void Destroy()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImTextureID GetTexID()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImTextureID ret = ImGui.GetTexIDNative(@this);
				return ret;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawIdx
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ushort* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImDrawIdx(int size = default, int capacity = default, ushort* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Valid;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CmdListsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TotalIdxCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TotalVtxCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawListPtr CmdLists;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 DisplayPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 DisplaySize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 FramebufferScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiViewport* OwnerViewport;



		/// <summary>/// To be documented./// </summary>		public unsafe ImDrawData(bool valid = default, int cmdListsCount = default, int totalIdxCount = default, int totalVtxCount = default, ImVectorImDrawListPtr cmdLists = default, Vector2 displayPos = default, Vector2 displaySize = default, Vector2 framebufferScale = default, ImGuiViewport* ownerViewport = default)
		{
			Valid = valid ? (byte)1 : (byte)0;
			CmdListsCount = cmdListsCount;
			TotalIdxCount = totalIdxCount;
			TotalVtxCount = totalVtxCount;
			CmdLists = cmdLists;
			DisplayPos = displayPos;
			DisplaySize = displaySize;
			FramebufferScale = framebufferScale;
			OwnerViewport = ownerViewport;
		}


		public unsafe void AddDrawList( ImDrawList* drawList)
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.AddDrawListNative(@this, drawList);
			}
		}

		public unsafe void AddDrawList( ref ImDrawList drawList)
		{
			fixed (ImDrawData* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.AddDrawListNative(@this, (ImDrawList*)pdrawList);
				}
			}
		}

		public unsafe void Clear()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void DeIndexAllBuffers()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.DeIndexAllBuffersNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void ScaleClipRects( Vector2 fbScale)
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.ScaleClipRectsNative(@this, fbScale);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawListPtr
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawList** Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImDrawListPtr(int size = default, int capacity = default, ImDrawList** data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawList
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawCmd CmdBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawIdx IdxBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawVert VtxBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint VtxCurrentIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawListSharedData* Data;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* OwnerName;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawVert* VtxWritePtr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ushort* IdxWritePtr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImVec4 ClipRectStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImTextureID TextureIdStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImVec2 Path;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawCmdHeader CmdHeader;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawListSplitter Splitter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FringeScale;



		/// <summary>/// To be documented./// </summary>		public unsafe ImDrawList(ImVectorImDrawCmd cmdBuffer = default, ImVectorImDrawIdx idxBuffer = default, ImVectorImDrawVert vtxBuffer = default, int flags = default, uint Vtxcurrentidx = default, ImDrawListSharedData* Data = default, byte* Ownername = default, ImDrawVert* Vtxwriteptr = default, ushort* Idxwriteptr = default, ImVectorImVec4 Cliprectstack = default, ImVectorImTextureID Textureidstack = default, ImVectorImVec2 Path = default, ImDrawCmdHeader Cmdheader = default, ImDrawListSplitter Splitter = default, float Fringescale = default)
		{
			CmdBuffer = cmdBuffer;
			IdxBuffer = idxBuffer;
			VtxBuffer = vtxBuffer;
			Flags = flags;
			VtxCurrentIdx = Vtxcurrentidx;
			this.Data = Data;
			OwnerName = Ownername;
			VtxWritePtr = Vtxwriteptr;
			IdxWritePtr = Idxwriteptr;
			ClipRectStack = Cliprectstack;
			TextureIdStack = Textureidstack;
			this.Path = Path;
			CmdHeader = Cmdheader;
			this.Splitter = Splitter;
			FringeScale = Fringescale;
		}


		public unsafe int _CalcCircleAutoSegmentCount( float radius)
		{
			fixed (ImDrawList* @this = &this)
			{
				int ret = ImGui._CalcCircleAutoSegmentCountNative(@this, radius);
				return ret;
			}
		}

		public unsafe void _ClearFreeMemory()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void _OnChangedClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedClipRectNative(@this);
			}
		}

		public unsafe void _OnChangedTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedTextureIDNative(@this);
			}
		}

		public unsafe void _OnChangedVtxOffset()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedVtxOffsetNative(@this);
			}
		}

		public unsafe void _PathArcToFastEx( Vector2 center,  float radius,  int aMinSample,  int aMaxSample,  int aStep)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToFastExNative(@this, center, radius, aMinSample, aMaxSample, aStep);
			}
		}

		public unsafe void _PathArcToN( Vector2 center,  float radius,  float aMin,  float aMax,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToNNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void _PopUnusedDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PopUnusedDrawCmdNative(@this);
			}
		}

		public unsafe void _ResetForNewFrame()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ResetForNewFrameNative(@this);
			}
		}

		public unsafe void _TryMergeDrawCmds()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._TryMergeDrawCmdsNative(@this);
			}
		}

		public unsafe void AddBezierCubic( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col,  float thickness,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, numSegments);
			}
		}

		public unsafe void AddBezierCubic( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, (int)(0));
			}
		}

		public unsafe void AddBezierQuadratic( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col,  float thickness,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, numSegments);
			}
		}

		public unsafe void AddBezierQuadratic( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, (int)(0));
			}
		}

		public unsafe void AddCallback( ImDrawCallback callback,  void* callbackData)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCallbackNative(@this, callback, callbackData);
			}
		}

		public unsafe void AddCircle( Vector2 center,  float radius,  uint col,  int numSegments,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddCircle( Vector2 center,  float radius,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddCircle( Vector2 center,  float radius,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddCircle( Vector2 center,  float radius,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), thickness);
			}
		}

		public unsafe void AddCircleFilled( Vector2 center,  float radius,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddCircleFilled( Vector2 center,  float radius,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, (int)(0));
			}
		}

		public unsafe void AddConvexPolyFilled( Vector2* points,  int numPoints,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddConvexPolyFilledNative(@this, points, numPoints, col);
			}
		}

		public unsafe void AddConvexPolyFilled( ref Vector2 points,  int numPoints,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddConvexPolyFilledNative(@this, (Vector2*)ppoints, numPoints, col);
				}
			}
		}

		public unsafe void AddDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddDrawCmdNative(@this);
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot,  int numSegments,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, rot, numSegments, thickness);
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, rot, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, rot, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, (float)(0.0f), (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, (float)(0.0f), numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, rot, (int)(0), thickness);
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  int numSegments,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, (float)(0.0f), numSegments, thickness);
			}
		}

		public unsafe void AddEllipseFilled( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseFilledNative(@this, center, radiusX, radiusY, col, rot, numSegments);
			}
		}

		public unsafe void AddEllipseFilled( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseFilledNative(@this, center, radiusX, radiusY, col, rot, (int)(0));
			}
		}

		public unsafe void AddEllipseFilled( Vector2 center,  float radiusX,  float radiusY,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseFilledNative(@this, center, radiusX, radiusY, col, (float)(0.0f), (int)(0));
			}
		}

		public unsafe void AddEllipseFilled( Vector2 center,  float radiusX,  float radiusY,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseFilledNative(@this, center, radiusX, radiusY, col, (float)(0.0f), numSegments);
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  Vector2 uvMax,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col);
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  Vector2 uvMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  Vector2 uv3,  Vector2 uv4,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  Vector2 uv3,  Vector2 uv4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  Vector2 uv3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  Vector2 uv3,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageRounded( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  Vector2 uvMax,  uint col,  float rounding,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
			}
		}

		public unsafe void AddImageRounded( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  Vector2 uvMax,  uint col,  float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (int)(0));
			}
		}

		public unsafe void AddLine( Vector2 p1,  Vector2 p2,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, thickness);
			}
		}

		public unsafe void AddLine( Vector2 p1,  Vector2 p2,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, (float)(1.0f));
			}
		}

		public unsafe void AddNgon( Vector2 center,  float radius,  uint col,  int numSegments,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddNgon( Vector2 center,  float radius,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddNgonFilled( Vector2 center,  float radius,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonFilledNative(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddPolyline( Vector2* points,  int numPoints,  uint col,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddPolylineNative(@this, points, numPoints, col, flags, thickness);
			}
		}

		public unsafe void AddPolyline( ref Vector2 points,  int numPoints,  uint col,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddPolylineNative(@this, (Vector2*)ppoints, numPoints, col, flags, thickness);
				}
			}
		}

		public unsafe void AddQuad( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, thickness);
			}
		}

		public unsafe void AddQuad( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, (float)(1.0f));
			}
		}

		public unsafe void AddQuadFilled( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadFilledNative(@this, p1, p2, p3, p4, col);
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, thickness);
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, (float)(1.0f));
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (int)(0), thickness);
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, thickness);
			}
		}

		public unsafe void AddRectFilled( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, flags);
			}
		}

		public unsafe void AddRectFilled( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, (int)(0));
			}
		}

		public unsafe void AddRectFilled( Vector2 pMin,  Vector2 pMax,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), (int)(0));
			}
		}

		public unsafe void AddRectFilled( Vector2 pMin,  Vector2 pMax,  uint col,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), flags);
			}
		}

		public unsafe void AddRectFilledMultiColor( Vector2 pMin,  Vector2 pMax,  uint colUprLeft,  uint colUprRight,  uint colBotRight,  uint colBotLeft)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledMultiColorNative(@this, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, textEnd);
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)(default));
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  string textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  byte* textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  string textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddTriangle( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, thickness);
			}
		}

		public unsafe void AddTriangle( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, (float)(1.0f));
			}
		}

		public unsafe void AddTriangleFilled( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleFilledNative(@this, p1, p2, p3, col);
			}
		}

		public unsafe void ChannelsMerge()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsMergeNative(@this);
			}
		}

		public unsafe void ChannelsSetCurrent( int n)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSetCurrentNative(@this, n);
			}
		}

		public unsafe void ChannelsSplit( int count)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSplitNative(@this, count);
			}
		}

		public unsafe ImDrawList* CloneOutput()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImDrawList* ret = ImGui.CloneOutputNative(@this);
				return ret;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void PathArcTo( Vector2 center,  float radius,  float aMin,  float aMax,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void PathArcTo( Vector2 center,  float radius,  float aMin,  float aMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, (int)(0));
			}
		}

		public unsafe void PathArcToFast( Vector2 center,  float radius,  int aMinOf12,  int aMaxOf12)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToFastNative(@this, center, radius, aMinOf12, aMaxOf12);
			}
		}

		public unsafe void PathBezierCubicCurveTo( Vector2 p2,  Vector2 p3,  Vector2 p4,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, numSegments);
			}
		}

		public unsafe void PathBezierCubicCurveTo( Vector2 p2,  Vector2 p3,  Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, (int)(0));
			}
		}

		public unsafe void PathBezierQuadraticCurveTo( Vector2 p2,  Vector2 p3,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, numSegments);
			}
		}

		public unsafe void PathBezierQuadraticCurveTo( Vector2 p2,  Vector2 p3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, (int)(0));
			}
		}

		public unsafe void PathClear()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathClearNative(@this);
			}
		}

		public unsafe void PathEllipticalArcTo( Vector2 center,  float radiusX,  float radiusY,  float rot,  float aMin,  float aMax,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathEllipticalArcToNative(@this, center, radiusX, radiusY, rot, aMin, aMax, numSegments);
			}
		}

		public unsafe void PathEllipticalArcTo( Vector2 center,  float radiusX,  float radiusY,  float rot,  float aMin,  float aMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathEllipticalArcToNative(@this, center, radiusX, radiusY, rot, aMin, aMax, (int)(0));
			}
		}

		public unsafe void PathFillConvex( uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathFillConvexNative(@this, col);
			}
		}

		public unsafe void PathLineTo( Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToNative(@this, pos);
			}
		}

		public unsafe void PathLineToMergeDuplicate( Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToMergeDuplicateNative(@this, pos);
			}
		}

		public unsafe void PathRect( Vector2 rectMin,  Vector2 rectMax,  float rounding,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, flags);
			}
		}

		public unsafe void PathRect( Vector2 rectMin,  Vector2 rectMax,  float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, (int)(0));
			}
		}

		public unsafe void PathRect( Vector2 rectMin,  Vector2 rectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), (int)(0));
			}
		}

		public unsafe void PathRect( Vector2 rectMin,  Vector2 rectMax,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), flags);
			}
		}

		public unsafe void PathStroke( uint col,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, thickness);
			}
		}

		public unsafe void PathStroke( uint col,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, (float)(1.0f));
			}
		}

		public unsafe void PathStroke( uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void PathStroke( uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (int)(0), thickness);
			}
		}

		public unsafe void PopClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopClipRectNative(@this);
			}
		}

		public unsafe void PopTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopTextureIDNative(@this);
			}
		}

		public unsafe void PrimQuadUV( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 d,  Vector2 uvA,  Vector2 uvB,  Vector2 uvC,  Vector2 uvD,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimQuadUVNative(@this, a, b, c, d, uvA, uvB, uvC, uvD, col);
			}
		}

		public unsafe void PrimRect( Vector2 a,  Vector2 b,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectNative(@this, a, b, col);
			}
		}

		public unsafe void PrimRectUV( Vector2 a,  Vector2 b,  Vector2 uvA,  Vector2 uvB,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectUVNative(@this, a, b, uvA, uvB, col);
			}
		}

		public unsafe void PrimReserve( int idxCount,  int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimReserveNative(@this, idxCount, vtxCount);
			}
		}

		public unsafe void PrimUnreserve( int idxCount,  int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimUnreserveNative(@this, idxCount, vtxCount);
			}
		}

		public unsafe void PrimVtx( Vector2 pos,  Vector2 uv,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimVtxNative(@this, pos, uv, col);
			}
		}

		public unsafe void PrimWriteIdx( ushort idx)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteIdxNative(@this, idx);
			}
		}

		public unsafe void PrimWriteVtx( Vector2 pos,  Vector2 uv,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteVtxNative(@this, pos, uv, col);
			}
		}

		public unsafe void PushClipRect( Vector2 clipRectMin,  Vector2 clipRectMax,  bool intersectWithCurrentClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
			}
		}

		public unsafe void PushClipRect( Vector2 clipRectMin,  Vector2 clipRectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, (byte)(0));
			}
		}

		public unsafe void PushClipRectFullScreen()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectFullScreenNative(@this);
			}
		}

		public unsafe void PushTextureID( ImTextureID textureId)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushTextureIDNative(@this, textureId);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawVert
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawVert* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImDrawVert(int size = default, int capacity = default, ImDrawVert* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawVert
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Uv;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Col;


		/// <summary>/// To be documented./// </summary>		public unsafe ImDrawVert(Vector2 pos = default, Vector2 uv = default, uint col = default)
		{
			Pos = pos;
			Uv = uv;
			Col = col;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawListSharedData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 TexUvWhitePixel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFont* Font;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FontSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CurveTessellationTol;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CircleSegmentMaxError;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 ClipRectFullscreen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int InitialFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImVec2 TempBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ArcFastVtx_0;
		public Vector2 ArcFastVtx_1;
		public Vector2 ArcFastVtx_2;
		public Vector2 ArcFastVtx_3;
		public Vector2 ArcFastVtx_4;
		public Vector2 ArcFastVtx_5;
		public Vector2 ArcFastVtx_6;
		public Vector2 ArcFastVtx_7;
		public Vector2 ArcFastVtx_8;
		public Vector2 ArcFastVtx_9;
		public Vector2 ArcFastVtx_10;
		public Vector2 ArcFastVtx_11;
		public Vector2 ArcFastVtx_12;
		public Vector2 ArcFastVtx_13;
		public Vector2 ArcFastVtx_14;
		public Vector2 ArcFastVtx_15;
		public Vector2 ArcFastVtx_16;
		public Vector2 ArcFastVtx_17;
		public Vector2 ArcFastVtx_18;
		public Vector2 ArcFastVtx_19;
		public Vector2 ArcFastVtx_20;
		public Vector2 ArcFastVtx_21;
		public Vector2 ArcFastVtx_22;
		public Vector2 ArcFastVtx_23;
		public Vector2 ArcFastVtx_24;
		public Vector2 ArcFastVtx_25;
		public Vector2 ArcFastVtx_26;
		public Vector2 ArcFastVtx_27;
		public Vector2 ArcFastVtx_28;
		public Vector2 ArcFastVtx_29;
		public Vector2 ArcFastVtx_30;
		public Vector2 ArcFastVtx_31;
		public Vector2 ArcFastVtx_32;
		public Vector2 ArcFastVtx_33;
		public Vector2 ArcFastVtx_34;
		public Vector2 ArcFastVtx_35;
		public Vector2 ArcFastVtx_36;
		public Vector2 ArcFastVtx_37;
		public Vector2 ArcFastVtx_38;
		public Vector2 ArcFastVtx_39;
		public Vector2 ArcFastVtx_40;
		public Vector2 ArcFastVtx_41;
		public Vector2 ArcFastVtx_42;
		public Vector2 ArcFastVtx_43;
		public Vector2 ArcFastVtx_44;
		public Vector2 ArcFastVtx_45;
		public Vector2 ArcFastVtx_46;
		public Vector2 ArcFastVtx_47;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ArcFastRadiusCutoff;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CircleSegmentCounts_0;
		public byte CircleSegmentCounts_1;
		public byte CircleSegmentCounts_2;
		public byte CircleSegmentCounts_3;
		public byte CircleSegmentCounts_4;
		public byte CircleSegmentCounts_5;
		public byte CircleSegmentCounts_6;
		public byte CircleSegmentCounts_7;
		public byte CircleSegmentCounts_8;
		public byte CircleSegmentCounts_9;
		public byte CircleSegmentCounts_10;
		public byte CircleSegmentCounts_11;
		public byte CircleSegmentCounts_12;
		public byte CircleSegmentCounts_13;
		public byte CircleSegmentCounts_14;
		public byte CircleSegmentCounts_15;
		public byte CircleSegmentCounts_16;
		public byte CircleSegmentCounts_17;
		public byte CircleSegmentCounts_18;
		public byte CircleSegmentCounts_19;
		public byte CircleSegmentCounts_20;
		public byte CircleSegmentCounts_21;
		public byte CircleSegmentCounts_22;
		public byte CircleSegmentCounts_23;
		public byte CircleSegmentCounts_24;
		public byte CircleSegmentCounts_25;
		public byte CircleSegmentCounts_26;
		public byte CircleSegmentCounts_27;
		public byte CircleSegmentCounts_28;
		public byte CircleSegmentCounts_29;
		public byte CircleSegmentCounts_30;
		public byte CircleSegmentCounts_31;
		public byte CircleSegmentCounts_32;
		public byte CircleSegmentCounts_33;
		public byte CircleSegmentCounts_34;
		public byte CircleSegmentCounts_35;
		public byte CircleSegmentCounts_36;
		public byte CircleSegmentCounts_37;
		public byte CircleSegmentCounts_38;
		public byte CircleSegmentCounts_39;
		public byte CircleSegmentCounts_40;
		public byte CircleSegmentCounts_41;
		public byte CircleSegmentCounts_42;
		public byte CircleSegmentCounts_43;
		public byte CircleSegmentCounts_44;
		public byte CircleSegmentCounts_45;
		public byte CircleSegmentCounts_46;
		public byte CircleSegmentCounts_47;
		public byte CircleSegmentCounts_48;
		public byte CircleSegmentCounts_49;
		public byte CircleSegmentCounts_50;
		public byte CircleSegmentCounts_51;
		public byte CircleSegmentCounts_52;
		public byte CircleSegmentCounts_53;
		public byte CircleSegmentCounts_54;
		public byte CircleSegmentCounts_55;
		public byte CircleSegmentCounts_56;
		public byte CircleSegmentCounts_57;
		public byte CircleSegmentCounts_58;
		public byte CircleSegmentCounts_59;
		public byte CircleSegmentCounts_60;
		public byte CircleSegmentCounts_61;
		public byte CircleSegmentCounts_62;
		public byte CircleSegmentCounts_63;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Vector4* TexUvLines;


		/// <summary>/// To be documented./// </summary>		public unsafe ImDrawListSharedData(Vector2 texUvWhitePixel = default, ImFont* font = default, float fontSize = default, float curveTessellationTol = default, float circleSegmentMaxError = default, Vector4 clipRectFullscreen = default, int initialFlags = default, ImVectorImVec2 tempBuffer = default, Vector2* arcFastVtx = default, float arcFastRadiusCutoff = default, byte* circleSegmentCounts = default, Vector4* texUvLines = default)
		{
			TexUvWhitePixel = texUvWhitePixel;
			Font = font;
			FontSize = fontSize;
			CurveTessellationTol = curveTessellationTol;
			CircleSegmentMaxError = circleSegmentMaxError;
			ClipRectFullscreen = clipRectFullscreen;
			InitialFlags = initialFlags;
			TempBuffer = tempBuffer;
			if (arcFastVtx != default)
			{
				ArcFastVtx_0 = arcFastVtx[0];
				ArcFastVtx_1 = arcFastVtx[1];
				ArcFastVtx_2 = arcFastVtx[2];
				ArcFastVtx_3 = arcFastVtx[3];
				ArcFastVtx_4 = arcFastVtx[4];
				ArcFastVtx_5 = arcFastVtx[5];
				ArcFastVtx_6 = arcFastVtx[6];
				ArcFastVtx_7 = arcFastVtx[7];
				ArcFastVtx_8 = arcFastVtx[8];
				ArcFastVtx_9 = arcFastVtx[9];
				ArcFastVtx_10 = arcFastVtx[10];
				ArcFastVtx_11 = arcFastVtx[11];
				ArcFastVtx_12 = arcFastVtx[12];
				ArcFastVtx_13 = arcFastVtx[13];
				ArcFastVtx_14 = arcFastVtx[14];
				ArcFastVtx_15 = arcFastVtx[15];
				ArcFastVtx_16 = arcFastVtx[16];
				ArcFastVtx_17 = arcFastVtx[17];
				ArcFastVtx_18 = arcFastVtx[18];
				ArcFastVtx_19 = arcFastVtx[19];
				ArcFastVtx_20 = arcFastVtx[20];
				ArcFastVtx_21 = arcFastVtx[21];
				ArcFastVtx_22 = arcFastVtx[22];
				ArcFastVtx_23 = arcFastVtx[23];
				ArcFastVtx_24 = arcFastVtx[24];
				ArcFastVtx_25 = arcFastVtx[25];
				ArcFastVtx_26 = arcFastVtx[26];
				ArcFastVtx_27 = arcFastVtx[27];
				ArcFastVtx_28 = arcFastVtx[28];
				ArcFastVtx_29 = arcFastVtx[29];
				ArcFastVtx_30 = arcFastVtx[30];
				ArcFastVtx_31 = arcFastVtx[31];
				ArcFastVtx_32 = arcFastVtx[32];
				ArcFastVtx_33 = arcFastVtx[33];
				ArcFastVtx_34 = arcFastVtx[34];
				ArcFastVtx_35 = arcFastVtx[35];
				ArcFastVtx_36 = arcFastVtx[36];
				ArcFastVtx_37 = arcFastVtx[37];
				ArcFastVtx_38 = arcFastVtx[38];
				ArcFastVtx_39 = arcFastVtx[39];
				ArcFastVtx_40 = arcFastVtx[40];
				ArcFastVtx_41 = arcFastVtx[41];
				ArcFastVtx_42 = arcFastVtx[42];
				ArcFastVtx_43 = arcFastVtx[43];
				ArcFastVtx_44 = arcFastVtx[44];
				ArcFastVtx_45 = arcFastVtx[45];
				ArcFastVtx_46 = arcFastVtx[46];
				ArcFastVtx_47 = arcFastVtx[47];
			}
			ArcFastRadiusCutoff = arcFastRadiusCutoff;
			if (circleSegmentCounts != default)
			{
				CircleSegmentCounts_0 = circleSegmentCounts[0];
				CircleSegmentCounts_1 = circleSegmentCounts[1];
				CircleSegmentCounts_2 = circleSegmentCounts[2];
				CircleSegmentCounts_3 = circleSegmentCounts[3];
				CircleSegmentCounts_4 = circleSegmentCounts[4];
				CircleSegmentCounts_5 = circleSegmentCounts[5];
				CircleSegmentCounts_6 = circleSegmentCounts[6];
				CircleSegmentCounts_7 = circleSegmentCounts[7];
				CircleSegmentCounts_8 = circleSegmentCounts[8];
				CircleSegmentCounts_9 = circleSegmentCounts[9];
				CircleSegmentCounts_10 = circleSegmentCounts[10];
				CircleSegmentCounts_11 = circleSegmentCounts[11];
				CircleSegmentCounts_12 = circleSegmentCounts[12];
				CircleSegmentCounts_13 = circleSegmentCounts[13];
				CircleSegmentCounts_14 = circleSegmentCounts[14];
				CircleSegmentCounts_15 = circleSegmentCounts[15];
				CircleSegmentCounts_16 = circleSegmentCounts[16];
				CircleSegmentCounts_17 = circleSegmentCounts[17];
				CircleSegmentCounts_18 = circleSegmentCounts[18];
				CircleSegmentCounts_19 = circleSegmentCounts[19];
				CircleSegmentCounts_20 = circleSegmentCounts[20];
				CircleSegmentCounts_21 = circleSegmentCounts[21];
				CircleSegmentCounts_22 = circleSegmentCounts[22];
				CircleSegmentCounts_23 = circleSegmentCounts[23];
				CircleSegmentCounts_24 = circleSegmentCounts[24];
				CircleSegmentCounts_25 = circleSegmentCounts[25];
				CircleSegmentCounts_26 = circleSegmentCounts[26];
				CircleSegmentCounts_27 = circleSegmentCounts[27];
				CircleSegmentCounts_28 = circleSegmentCounts[28];
				CircleSegmentCounts_29 = circleSegmentCounts[29];
				CircleSegmentCounts_30 = circleSegmentCounts[30];
				CircleSegmentCounts_31 = circleSegmentCounts[31];
				CircleSegmentCounts_32 = circleSegmentCounts[32];
				CircleSegmentCounts_33 = circleSegmentCounts[33];
				CircleSegmentCounts_34 = circleSegmentCounts[34];
				CircleSegmentCounts_35 = circleSegmentCounts[35];
				CircleSegmentCounts_36 = circleSegmentCounts[36];
				CircleSegmentCounts_37 = circleSegmentCounts[37];
				CircleSegmentCounts_38 = circleSegmentCounts[38];
				CircleSegmentCounts_39 = circleSegmentCounts[39];
				CircleSegmentCounts_40 = circleSegmentCounts[40];
				CircleSegmentCounts_41 = circleSegmentCounts[41];
				CircleSegmentCounts_42 = circleSegmentCounts[42];
				CircleSegmentCounts_43 = circleSegmentCounts[43];
				CircleSegmentCounts_44 = circleSegmentCounts[44];
				CircleSegmentCounts_45 = circleSegmentCounts[45];
				CircleSegmentCounts_46 = circleSegmentCounts[46];
				CircleSegmentCounts_47 = circleSegmentCounts[47];
				CircleSegmentCounts_48 = circleSegmentCounts[48];
				CircleSegmentCounts_49 = circleSegmentCounts[49];
				CircleSegmentCounts_50 = circleSegmentCounts[50];
				CircleSegmentCounts_51 = circleSegmentCounts[51];
				CircleSegmentCounts_52 = circleSegmentCounts[52];
				CircleSegmentCounts_53 = circleSegmentCounts[53];
				CircleSegmentCounts_54 = circleSegmentCounts[54];
				CircleSegmentCounts_55 = circleSegmentCounts[55];
				CircleSegmentCounts_56 = circleSegmentCounts[56];
				CircleSegmentCounts_57 = circleSegmentCounts[57];
				CircleSegmentCounts_58 = circleSegmentCounts[58];
				CircleSegmentCounts_59 = circleSegmentCounts[59];
				CircleSegmentCounts_60 = circleSegmentCounts[60];
				CircleSegmentCounts_61 = circleSegmentCounts[61];
				CircleSegmentCounts_62 = circleSegmentCounts[62];
				CircleSegmentCounts_63 = circleSegmentCounts[63];
			}
			TexUvLines = texUvLines;
		}

		/// <summary>/// To be documented./// </summary>		public unsafe ImDrawListSharedData(Vector2 texUvWhitePixel = default, ImFont* font = default, float fontSize = default, float curveTessellationTol = default, float circleSegmentMaxError = default, Vector4 clipRectFullscreen = default, int initialFlags = default, ImVectorImVec2 tempBuffer = default, Span<Vector2> arcFastVtx = default, float arcFastRadiusCutoff = default, Span<byte> circleSegmentCounts = default, Vector4* texUvLines = default)
		{
			TexUvWhitePixel = texUvWhitePixel;
			Font = font;
			FontSize = fontSize;
			CurveTessellationTol = curveTessellationTol;
			CircleSegmentMaxError = circleSegmentMaxError;
			ClipRectFullscreen = clipRectFullscreen;
			InitialFlags = initialFlags;
			TempBuffer = tempBuffer;
			if (arcFastVtx != default)
			{
				ArcFastVtx_0 = arcFastVtx[0];
				ArcFastVtx_1 = arcFastVtx[1];
				ArcFastVtx_2 = arcFastVtx[2];
				ArcFastVtx_3 = arcFastVtx[3];
				ArcFastVtx_4 = arcFastVtx[4];
				ArcFastVtx_5 = arcFastVtx[5];
				ArcFastVtx_6 = arcFastVtx[6];
				ArcFastVtx_7 = arcFastVtx[7];
				ArcFastVtx_8 = arcFastVtx[8];
				ArcFastVtx_9 = arcFastVtx[9];
				ArcFastVtx_10 = arcFastVtx[10];
				ArcFastVtx_11 = arcFastVtx[11];
				ArcFastVtx_12 = arcFastVtx[12];
				ArcFastVtx_13 = arcFastVtx[13];
				ArcFastVtx_14 = arcFastVtx[14];
				ArcFastVtx_15 = arcFastVtx[15];
				ArcFastVtx_16 = arcFastVtx[16];
				ArcFastVtx_17 = arcFastVtx[17];
				ArcFastVtx_18 = arcFastVtx[18];
				ArcFastVtx_19 = arcFastVtx[19];
				ArcFastVtx_20 = arcFastVtx[20];
				ArcFastVtx_21 = arcFastVtx[21];
				ArcFastVtx_22 = arcFastVtx[22];
				ArcFastVtx_23 = arcFastVtx[23];
				ArcFastVtx_24 = arcFastVtx[24];
				ArcFastVtx_25 = arcFastVtx[25];
				ArcFastVtx_26 = arcFastVtx[26];
				ArcFastVtx_27 = arcFastVtx[27];
				ArcFastVtx_28 = arcFastVtx[28];
				ArcFastVtx_29 = arcFastVtx[29];
				ArcFastVtx_30 = arcFastVtx[30];
				ArcFastVtx_31 = arcFastVtx[31];
				ArcFastVtx_32 = arcFastVtx[32];
				ArcFastVtx_33 = arcFastVtx[33];
				ArcFastVtx_34 = arcFastVtx[34];
				ArcFastVtx_35 = arcFastVtx[35];
				ArcFastVtx_36 = arcFastVtx[36];
				ArcFastVtx_37 = arcFastVtx[37];
				ArcFastVtx_38 = arcFastVtx[38];
				ArcFastVtx_39 = arcFastVtx[39];
				ArcFastVtx_40 = arcFastVtx[40];
				ArcFastVtx_41 = arcFastVtx[41];
				ArcFastVtx_42 = arcFastVtx[42];
				ArcFastVtx_43 = arcFastVtx[43];
				ArcFastVtx_44 = arcFastVtx[44];
				ArcFastVtx_45 = arcFastVtx[45];
				ArcFastVtx_46 = arcFastVtx[46];
				ArcFastVtx_47 = arcFastVtx[47];
			}
			ArcFastRadiusCutoff = arcFastRadiusCutoff;
			if (circleSegmentCounts != default)
			{
				CircleSegmentCounts_0 = circleSegmentCounts[0];
				CircleSegmentCounts_1 = circleSegmentCounts[1];
				CircleSegmentCounts_2 = circleSegmentCounts[2];
				CircleSegmentCounts_3 = circleSegmentCounts[3];
				CircleSegmentCounts_4 = circleSegmentCounts[4];
				CircleSegmentCounts_5 = circleSegmentCounts[5];
				CircleSegmentCounts_6 = circleSegmentCounts[6];
				CircleSegmentCounts_7 = circleSegmentCounts[7];
				CircleSegmentCounts_8 = circleSegmentCounts[8];
				CircleSegmentCounts_9 = circleSegmentCounts[9];
				CircleSegmentCounts_10 = circleSegmentCounts[10];
				CircleSegmentCounts_11 = circleSegmentCounts[11];
				CircleSegmentCounts_12 = circleSegmentCounts[12];
				CircleSegmentCounts_13 = circleSegmentCounts[13];
				CircleSegmentCounts_14 = circleSegmentCounts[14];
				CircleSegmentCounts_15 = circleSegmentCounts[15];
				CircleSegmentCounts_16 = circleSegmentCounts[16];
				CircleSegmentCounts_17 = circleSegmentCounts[17];
				CircleSegmentCounts_18 = circleSegmentCounts[18];
				CircleSegmentCounts_19 = circleSegmentCounts[19];
				CircleSegmentCounts_20 = circleSegmentCounts[20];
				CircleSegmentCounts_21 = circleSegmentCounts[21];
				CircleSegmentCounts_22 = circleSegmentCounts[22];
				CircleSegmentCounts_23 = circleSegmentCounts[23];
				CircleSegmentCounts_24 = circleSegmentCounts[24];
				CircleSegmentCounts_25 = circleSegmentCounts[25];
				CircleSegmentCounts_26 = circleSegmentCounts[26];
				CircleSegmentCounts_27 = circleSegmentCounts[27];
				CircleSegmentCounts_28 = circleSegmentCounts[28];
				CircleSegmentCounts_29 = circleSegmentCounts[29];
				CircleSegmentCounts_30 = circleSegmentCounts[30];
				CircleSegmentCounts_31 = circleSegmentCounts[31];
				CircleSegmentCounts_32 = circleSegmentCounts[32];
				CircleSegmentCounts_33 = circleSegmentCounts[33];
				CircleSegmentCounts_34 = circleSegmentCounts[34];
				CircleSegmentCounts_35 = circleSegmentCounts[35];
				CircleSegmentCounts_36 = circleSegmentCounts[36];
				CircleSegmentCounts_37 = circleSegmentCounts[37];
				CircleSegmentCounts_38 = circleSegmentCounts[38];
				CircleSegmentCounts_39 = circleSegmentCounts[39];
				CircleSegmentCounts_40 = circleSegmentCounts[40];
				CircleSegmentCounts_41 = circleSegmentCounts[41];
				CircleSegmentCounts_42 = circleSegmentCounts[42];
				CircleSegmentCounts_43 = circleSegmentCounts[43];
				CircleSegmentCounts_44 = circleSegmentCounts[44];
				CircleSegmentCounts_45 = circleSegmentCounts[45];
				CircleSegmentCounts_46 = circleSegmentCounts[46];
				CircleSegmentCounts_47 = circleSegmentCounts[47];
				CircleSegmentCounts_48 = circleSegmentCounts[48];
				CircleSegmentCounts_49 = circleSegmentCounts[49];
				CircleSegmentCounts_50 = circleSegmentCounts[50];
				CircleSegmentCounts_51 = circleSegmentCounts[51];
				CircleSegmentCounts_52 = circleSegmentCounts[52];
				CircleSegmentCounts_53 = circleSegmentCounts[53];
				CircleSegmentCounts_54 = circleSegmentCounts[54];
				CircleSegmentCounts_55 = circleSegmentCounts[55];
				CircleSegmentCounts_56 = circleSegmentCounts[56];
				CircleSegmentCounts_57 = circleSegmentCounts[57];
				CircleSegmentCounts_58 = circleSegmentCounts[58];
				CircleSegmentCounts_59 = circleSegmentCounts[59];
				CircleSegmentCounts_60 = circleSegmentCounts[60];
				CircleSegmentCounts_61 = circleSegmentCounts[61];
				CircleSegmentCounts_62 = circleSegmentCounts[62];
				CircleSegmentCounts_63 = circleSegmentCounts[63];
			}
			TexUvLines = texUvLines;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Vector2> ArcFastVtx
		
		{
			get
			{
				fixed (Vector2* p = &this.ArcFastVtx_0)
				{
					return new Span<Vector2>(p, 48);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFont
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorFloat IndexAdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FallbackAdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FontSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImWchar IndexLookup;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImFontGlyph Glyphs;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontGlyph* FallbackGlyph;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontAtlas* ContainerAtlas;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontConfig* ConfigData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ConfigDataCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort FallbackChar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort EllipsisChar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short EllipsisCharCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float EllipsisWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float EllipsisCharStep;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DirtyLookupTables;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Scale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Ascent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Descent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MetricsTotalSurface;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Used4kPagesMap_0;
		public byte Used4kPagesMap_1;



		/// <summary>/// To be documented./// </summary>		public unsafe ImFont(ImVectorFloat indexAdvanceX = default, float fallbackAdvanceX = default, float fontSize = default, ImVectorImWchar indexLookup = default, ImVectorImFontGlyph glyphs = default, ImFontGlyph* fallbackGlyph = default, ImFontAtlas* containerAtlas = default, ImFontConfig* configData = default, short configDataCount = default, ushort fallbackChar = default, ushort ellipsisChar = default, short ellipsisCharCount = default, float ellipsisWidth = default, float ellipsisCharStep = default, bool dirtyLookupTables = default, float scale = default, float ascent = default, float descent = default, int metricsTotalSurface = default, byte* used4KPagesMap = default)
		{
			IndexAdvanceX = indexAdvanceX;
			FallbackAdvanceX = fallbackAdvanceX;
			FontSize = fontSize;
			IndexLookup = indexLookup;
			Glyphs = glyphs;
			FallbackGlyph = fallbackGlyph;
			ContainerAtlas = containerAtlas;
			ConfigData = configData;
			ConfigDataCount = configDataCount;
			FallbackChar = fallbackChar;
			EllipsisChar = ellipsisChar;
			EllipsisCharCount = ellipsisCharCount;
			EllipsisWidth = ellipsisWidth;
			EllipsisCharStep = ellipsisCharStep;
			DirtyLookupTables = dirtyLookupTables ? (byte)1 : (byte)0;
			Scale = scale;
			Ascent = ascent;
			Descent = descent;
			MetricsTotalSurface = metricsTotalSurface;
			if (used4KPagesMap != default)
			{
				Used4kPagesMap_0 = used4KPagesMap[0];
				Used4kPagesMap_1 = used4KPagesMap[1];
			}
		}

		/// <summary>/// To be documented./// </summary>		public unsafe ImFont(ImVectorFloat indexAdvanceX = default, float fallbackAdvanceX = default, float fontSize = default, ImVectorImWchar indexLookup = default, ImVectorImFontGlyph glyphs = default, ImFontGlyph* fallbackGlyph = default, ImFontAtlas* containerAtlas = default, ImFontConfig* configData = default, short configDataCount = default, ushort fallbackChar = default, ushort ellipsisChar = default, short ellipsisCharCount = default, float ellipsisWidth = default, float ellipsisCharStep = default, bool dirtyLookupTables = default, float scale = default, float ascent = default, float descent = default, int metricsTotalSurface = default, Span<byte> used4KPagesMap = default)
		{
			IndexAdvanceX = indexAdvanceX;
			FallbackAdvanceX = fallbackAdvanceX;
			FontSize = fontSize;
			IndexLookup = indexLookup;
			Glyphs = glyphs;
			FallbackGlyph = fallbackGlyph;
			ContainerAtlas = containerAtlas;
			ConfigData = configData;
			ConfigDataCount = configDataCount;
			FallbackChar = fallbackChar;
			EllipsisChar = ellipsisChar;
			EllipsisCharCount = ellipsisCharCount;
			EllipsisWidth = ellipsisWidth;
			EllipsisCharStep = ellipsisCharStep;
			DirtyLookupTables = dirtyLookupTables ? (byte)1 : (byte)0;
			Scale = scale;
			Ascent = ascent;
			Descent = descent;
			MetricsTotalSurface = metricsTotalSurface;
			if (used4KPagesMap != default)
			{
				Used4kPagesMap_0 = used4KPagesMap[0];
				Used4kPagesMap_1 = used4KPagesMap[1];
			}
		}
	}
}
