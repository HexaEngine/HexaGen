// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_Clear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearNative(ImFontAtlas* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_Build")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BuildNative(ImFontAtlas* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetTexDataAsAlpha8")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetTexDataAsAlpha8Native(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel);

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			GetTexDataAsAlpha8Native(self, outPixels, outWidth, outHeight, outBytesPerPixel);
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  int* outHeight)
		{
			GetTexDataAsAlpha8Native(self, outPixels, outWidth, outHeight, (int*)(default));
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsAlpha8Native(self, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsAlpha8Native(self, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				GetTexDataAsAlpha8Native(self, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsAlpha8Native(self, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsAlpha8Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsAlpha8( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsAlpha8Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetTexDataAsRGBA32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetTexDataAsRGBA32Native(ImFontAtlas* self, byte** outPixels, int* outWidth, int* outHeight, int* outBytesPerPixel);

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			GetTexDataAsRGBA32Native(self, outPixels, outWidth, outHeight, outBytesPerPixel);
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  int* outHeight)
		{
			GetTexDataAsRGBA32Native(self, outPixels, outWidth, outHeight, (int*)(default));
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, outHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsRGBA32Native(self, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (int* poutHeight = &outHeight)
			{
				GetTexDataAsRGBA32Native(self, outPixels, outWidth, (int*)poutHeight, (int*)(default));
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (int* poutBytesPerPixel = &outBytesPerPixel)
			{
				GetTexDataAsRGBA32Native(self, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (int* poutHeight = &outHeight)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					GetTexDataAsRGBA32Native(self, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32Native(self, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  byte** outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (int* poutWidth = &outWidth)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						GetTexDataAsRGBA32Native(self, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public static void GetTexDataAsRGBA32( ImFontAtlas* self,  ref byte* outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (byte** poutPixels = &outPixels)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							GetTexDataAsRGBA32Native(self, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_IsBuilt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsBuiltNative(ImFontAtlas* self);

		public static bool IsBuilt( ImFontAtlas* self)
		{
			byte ret = IsBuiltNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_SetTexID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetTexIDNative(ImFontAtlas* self, ImTextureID id);

		public static void SetTexID( ImFontAtlas* self,  ImTextureID id)
		{
			SetTexIDNative(self, id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetGlyphRangesDefault")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* GetGlyphRangesDefaultNative(ImFontAtlas* self);

		public static char* GetGlyphRangesDefault( ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesDefaultNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetGlyphRangesGreek")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* GetGlyphRangesGreekNative(ImFontAtlas* self);

		public static char* GetGlyphRangesGreek( ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesGreekNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetGlyphRangesKorean")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* GetGlyphRangesKoreanNative(ImFontAtlas* self);

		public static char* GetGlyphRangesKorean( ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesKoreanNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetGlyphRangesJapanese")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* GetGlyphRangesJapaneseNative(ImFontAtlas* self);

		public static char* GetGlyphRangesJapanese( ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesJapaneseNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetGlyphRangesChineseFull")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* GetGlyphRangesChineseFullNative(ImFontAtlas* self);

		public static char* GetGlyphRangesChineseFull( ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesChineseFullNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* GetGlyphRangesChineseSimplifiedCommonNative(ImFontAtlas* self);

		public static char* GetGlyphRangesChineseSimplifiedCommon( ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesChineseSimplifiedCommonNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetGlyphRangesCyrillic")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* GetGlyphRangesCyrillicNative(ImFontAtlas* self);

		public static char* GetGlyphRangesCyrillic( ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesCyrillicNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetGlyphRangesThai")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* GetGlyphRangesThaiNative(ImFontAtlas* self);

		public static char* GetGlyphRangesThai( ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesThaiNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetGlyphRangesVietnamese")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* GetGlyphRangesVietnameseNative(ImFontAtlas* self);

		public static char* GetGlyphRangesVietnamese( ImFontAtlas* self)
		{
			char* ret = GetGlyphRangesVietnameseNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_AddCustomRectRegular")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int AddCustomRectRegularNative(ImFontAtlas* self, int width, int height);

		public static int AddCustomRectRegular( ImFontAtlas* self,  int width,  int height)
		{
			int ret = AddCustomRectRegularNative(self, width, height);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_AddCustomRectFontGlyph")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int AddCustomRectFontGlyphNative(ImFontAtlas* self, ImFont* font, char id, int width, int height, float advanceX, Vector2 offset);

		public static int AddCustomRectFontGlyph( ImFontAtlas* self,  ImFont* font,  char id,  int width,  int height,  float advanceX,  Vector2 offset)
		{
			int ret = AddCustomRectFontGlyphNative(self, font, id, width, height, advanceX, offset);
			return ret;
		}

		public static int AddCustomRectFontGlyph( ImFontAtlas* self,  ImFont* font,  char id,  int width,  int height,  float advanceX)
		{
			int ret = AddCustomRectFontGlyphNative(self, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
			return ret;
		}

		public static int AddCustomRectFontGlyph( ImFontAtlas* self,  ref ImFont font,  char id,  int width,  int height,  float advanceX,  Vector2 offset)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = AddCustomRectFontGlyphNative(self, (ImFont*)pfont, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public static int AddCustomRectFontGlyph( ImFontAtlas* self,  ref ImFont font,  char id,  int width,  int height,  float advanceX)
		{
			fixed (ImFont* pfont = &font)
			{
				int ret = AddCustomRectFontGlyphNative(self, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetCustomRectByIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImFontAtlasCustomRect* GetCustomRectByIndexNative(ImFontAtlas* self, int index);

		public static ImFontAtlasCustomRect* GetCustomRectByIndex( ImFontAtlas* self,  int index)
		{
			ImFontAtlasCustomRect* ret = GetCustomRectByIndexNative(self, index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_CalcCustomRectUV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void CalcCustomRectUVNative(ImFontAtlas* self, ImFontAtlasCustomRect* rect, Vector2* outUvMin, Vector2* outUvMax);

		public static void CalcCustomRectUV( ImFontAtlas* self,  ImFontAtlasCustomRect* rect,  Vector2* outUvMin,  Vector2* outUvMax)
		{
			CalcCustomRectUVNative(self, rect, outUvMin, outUvMax);
		}

		public static void CalcCustomRectUV( ImFontAtlas* self,  ref ImFontAtlasCustomRect rect,  Vector2* outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				CalcCustomRectUVNative(self, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
			}
		}

		public static void CalcCustomRectUV( ImFontAtlas* self,  ImFontAtlasCustomRect* rect,  ref Vector2 outUvMin,  Vector2* outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				CalcCustomRectUVNative(self, rect, (Vector2*)poutUvMin, outUvMax);
			}
		}

		public static void CalcCustomRectUV( ImFontAtlas* self,  ref ImFontAtlasCustomRect rect,  ref Vector2 outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					CalcCustomRectUVNative(self, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public static void CalcCustomRectUV( ImFontAtlas* self,  ImFontAtlasCustomRect* rect,  Vector2* outUvMin,  ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMax = &outUvMax)
			{
				CalcCustomRectUVNative(self, rect, outUvMin, (Vector2*)poutUvMax);
			}
		}

		public static void CalcCustomRectUV( ImFontAtlas* self,  ref ImFontAtlasCustomRect rect,  Vector2* outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					CalcCustomRectUVNative(self, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public static void CalcCustomRectUV( ImFontAtlas* self,  ImFontAtlasCustomRect* rect,  ref Vector2 outUvMin,  ref Vector2 outUvMax)
		{
			fixed (Vector2* poutUvMin = &outUvMin)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					CalcCustomRectUVNative(self, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public static void CalcCustomRectUV( ImFontAtlas* self,  ref ImFontAtlasCustomRect rect,  ref Vector2 outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlasCustomRect* prect = &rect)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						CalcCustomRectUVNative(self, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFontAtlas_GetMouseCursorTexData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte GetMouseCursorTexDataNative(ImFontAtlas* self, int cursor, Vector2* outOffset, Vector2* outSize, Vector2* outUvBorder, Vector2* outUvFill);

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  Vector2* outOffset,  Vector2* outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, outSize, outUvBorder, outUvFill);
			return ret != 0;
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  ref Vector2 outOffset,  Vector2* outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  Vector2* outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  Vector2* outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  ref Vector2 outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  Vector2* outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  Vector2* outOffset,  Vector2* outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvFill = &outUvFill)
			{
				byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
				return ret != 0;
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  ref Vector2 outOffset,  Vector2* outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  Vector2* outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  Vector2* outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (Vector2* poutUvBorder = &outUvBorder)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  ref Vector2 outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  Vector2* outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (Vector2* poutSize = &outSize)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = GetMouseCursorTexDataNative(self, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public static bool GetMouseCursorTexData( ImFontAtlas* self,  int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (Vector2* poutOffset = &outOffset)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = GetMouseCursorTexDataNative(self, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_ImFont")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImFont* ImFontNative();

		public static ImFont* ImFont()
		{
			ImFont* ret = ImFontNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImFont* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_FindGlyph")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImFontGlyph* FindGlyphNative(ImFont* self, char c);

		public static ImFontGlyph* FindGlyph( ImFont* self,  char c)
		{
			ImFontGlyph* ret = FindGlyphNative(self, c);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_FindGlyphNoFallback")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImFontGlyph* FindGlyphNoFallbackNative(ImFont* self, char c);

		public static ImFontGlyph* FindGlyphNoFallback( ImFont* self,  char c)
		{
			ImFontGlyph* ret = FindGlyphNoFallbackNative(self, c);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_GetCharAdvance")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetCharAdvanceNative(ImFont* self, char c);

		public static float GetCharAdvance( ImFont* self,  char c)
		{
			float ret = GetCharAdvanceNative(self, c);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_IsLoaded")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsLoadedNative(ImFont* self);

		public static bool IsLoaded( ImFont* self)
		{
			byte ret = IsLoadedNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_GetDebugName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* GetDebugNameNative(ImFont* self);

		public static byte* GetDebugName( ImFont* self)
		{
			byte* ret = GetDebugNameNative(self);
			return ret;
		}

		public static string GetDebugNameS( ImFont* self)
		{
			string ret = Utils.DecodeStringUTF8(GetDebugNameNative(self));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_CalcTextSizeA")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void CalcTextSizeANative(Vector2* pOut, ImFont* self, float size, float maxWidth, float wrapWidth, byte* textBegin, byte* textEnd, byte** remaining);

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  byte* textEnd,  byte** remaining)
		{
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  byte* textEnd)
		{
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)(default));
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin)
		{
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, (byte*)(default), (byte**)(default));
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  byte** remaining)
		{
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, (byte*)(default), remaining);
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  byte* textEnd,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, remaining);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)(default));
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin)
		{
			fixed (ImFont* pself = &self)
			{
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)(default), (byte**)(default));
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)(default), remaining);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  byte* textEnd,  byte** remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(default));
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), (byte**)(default));
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  byte** remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), remaining);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  byte* textEnd,  byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  string textBegin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, pStr0, (byte*)(default), (byte**)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, pStr0, (byte*)(default), remaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  byte* textEnd,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)(default));
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), (byte**)(default));
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), remaining);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  byte* textEnd,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  byte* textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  string textBegin)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, (byte*)(default), (byte**)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, (byte*)(default), remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  ref byte textEnd,  byte** remaining)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(default));
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  string textEnd,  byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  ref byte textEnd,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)(default));
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  string textEnd,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, remaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  ref byte textEnd,  byte** remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(default));
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  string textEnd,  byte** remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(default));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  ref byte textEnd,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, remaining);
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)(default));
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  string textEnd,  byte** remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, remaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  string textEnd)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  byte* textEnd,  ref byte* remaining)
		{
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  ref byte* remaining)
		{
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, (byte*)(default), (byte**)premaining);
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  byte* textEnd,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, textEnd, (byte**)premaining);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)(default), (byte**)premaining);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  byte* textEnd,  ref byte* remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  ref byte* remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), (byte**)premaining);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  byte* textEnd,  ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, pStr0, (byte*)(default), (byte**)premaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  byte* textEnd,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, textEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)(default), (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  byte* textEnd,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, textEnd, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, (byte*)(default), (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  ref byte textEnd,  ref byte* remaining)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  string textEnd,  ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  ref byte textEnd,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, (byte*)ptextEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  byte* textBegin,  string textEnd,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, textBegin, pStr0, (byte**)premaining);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  ref byte textEnd,  ref byte* remaining)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (byte** premaining = &remaining)
					{
						CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ImFont* self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  string textEnd,  ref byte* remaining)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** premaining = &remaining)
			{
				CalcTextSizeANative(pOut, self, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  ref byte textBegin,  ref byte textEnd,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (byte** premaining = &remaining)
						{
							CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, (byte*)ptextBegin, (byte*)ptextEnd, (byte**)premaining);
						}
					}
				}
			}
		}

		public static void CalcTextSizeA( Vector2* pOut,  ref ImFont self,  float size,  float maxWidth,  float wrapWidth,  string textBegin,  string textEnd,  ref byte* remaining)
		{
			fixed (ImFont* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (byte** premaining = &remaining)
				{
					CalcTextSizeANative(pOut, (ImFont*)pself, size, maxWidth, wrapWidth, pStr0, pStr1, (byte**)premaining);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_CalcWordWrapPositionA")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* CalcWordWrapPositionANative(ImFont* self, float scale, byte* text, byte* textEnd, float wrapWidth);

		public static byte* CalcWordWrapPositionA( ImFont* self,  float scale,  byte* text,  byte* textEnd,  float wrapWidth)
		{
			byte* ret = CalcWordWrapPositionANative(self, scale, text, textEnd, wrapWidth);
			return ret;
		}

		public static string CalcWordWrapPositionAS( ImFont* self,  float scale,  byte* text,  byte* textEnd,  float wrapWidth)
		{
			string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, text, textEnd, wrapWidth));
			return ret;
		}

		public static byte* CalcWordWrapPositionA( ImFont* self,  float scale,  ref byte text,  byte* textEnd,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				byte* ret = CalcWordWrapPositionANative(self, scale, (byte*)ptext, textEnd, wrapWidth);
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS( ImFont* self,  float scale,  ref byte text,  byte* textEnd,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, (byte*)ptext, textEnd, wrapWidth));
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA( ImFont* self,  float scale,  string text,  byte* textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = CalcWordWrapPositionANative(self, scale, pStr0, textEnd, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string CalcWordWrapPositionAS( ImFont* self,  float scale,  string text,  byte* textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, pStr0, textEnd, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* CalcWordWrapPositionA( ImFont* self,  float scale,  byte* text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte* ret = CalcWordWrapPositionANative(self, scale, text, (byte*)ptextEnd, wrapWidth);
				return ret;
			}
		}

		public static string CalcWordWrapPositionAS( ImFont* self,  float scale,  byte* text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, text, (byte*)ptextEnd, wrapWidth));
				return ret;
			}
		}

		public static byte* CalcWordWrapPositionA( ImFont* self,  float scale,  byte* text,  string textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = CalcWordWrapPositionANative(self, scale, text, pStr0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string CalcWordWrapPositionAS( ImFont* self,  float scale,  byte* text,  string textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, text, pStr0, wrapWidth));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static byte* CalcWordWrapPositionA( ImFont* self,  float scale,  ref byte text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = CalcWordWrapPositionANative(self, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public static string CalcWordWrapPositionAS( ImFont* self,  float scale,  ref byte text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public static byte* CalcWordWrapPositionA( ImFont* self,  float scale,  string text,  string textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = CalcWordWrapPositionANative(self, scale, pStr0, pStr1, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static string CalcWordWrapPositionAS( ImFont* self,  float scale,  string text,  string textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(CalcWordWrapPositionANative(self, scale, pStr0, pStr1, wrapWidth));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_RenderChar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderCharNative(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, char c);

		public static void RenderChar( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  char c)
		{
			RenderCharNative(self, drawList, size, pos, col, c);
		}

		public static void RenderChar( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  char c)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderCharNative(self, (ImDrawList*)pdrawList, size, pos, col, c);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_RenderText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderTextNative(ImFont* self, ImDrawList* drawList, float size, Vector2 pos, uint col, Vector4 clipRect, byte* textBegin, byte* textEnd, float wrapWidth, byte cpuFineClip);

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd)
		{
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (byte* ptextBegin = &textBegin)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					RenderTextNative(self, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  bool cpuFineClip)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textBegin != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textBegin);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			RenderTextNative(self, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void RenderText( ImFont* self,  ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				RenderTextNative(self, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_BuildLookupTable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BuildLookupTableNative(ImFont* self);

		public static void BuildLookupTable( ImFont* self)
		{
			BuildLookupTableNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_ClearOutputData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearOutputDataNative(ImFont* self);

		public static void ClearOutputData( ImFont* self)
		{
			ClearOutputDataNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_GrowIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GrowIndexNative(ImFont* self, int newSize);

		public static void GrowIndex( ImFont* self,  int newSize)
		{
			GrowIndexNative(self, newSize);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_AddGlyph")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddGlyphNative(ImFont* self, ImFontConfig* srcCfg, char c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advanceX);

		public static void AddGlyph( ImFont* self,  ImFontConfig* srcCfg,  char c,  float x0,  float y0,  float x1,  float y1,  float u0,  float v0,  float u1,  float v1,  float advanceX)
		{
			AddGlyphNative(self, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
		}

		public static void AddGlyph( ImFont* self,  ref ImFontConfig srcCfg,  char c,  float x0,  float y0,  float x1,  float y1,  float u0,  float v0,  float u1,  float v1,  float advanceX)
		{
			fixed (ImFontConfig* psrcCfg = &srcCfg)
			{
				AddGlyphNative(self, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_AddRemapChar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddRemapCharNative(ImFont* self, char dst, char src, byte overwriteDst);

		public static void AddRemapChar( ImFont* self,  char dst,  char src,  bool overwriteDst)
		{
			AddRemapCharNative(self, dst, src, overwriteDst ? (byte)1 : (byte)0);
		}

		public static void AddRemapChar( ImFont* self,  char dst,  char src)
		{
			AddRemapCharNative(self, dst, src, (byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_SetGlyphVisible")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetGlyphVisibleNative(ImFont* self, char c, byte visible);

		public static void SetGlyphVisible( ImFont* self,  char c,  bool visible)
		{
			SetGlyphVisibleNative(self, c, visible ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImFont_IsGlyphRangeUnused")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsGlyphRangeUnusedNative(ImFont* self, uint cBegin, uint cLast);

		public static bool IsGlyphRangeUnused( ImFont* self,  uint cBegin,  uint cLast)
		{
			byte ret = IsGlyphRangeUnusedNative(self, cBegin, cLast);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiViewport_ImGuiViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiViewport* ImGuiViewportNative();

		public static ImGuiViewport* ImGuiViewport()
		{
			ImGuiViewport* ret = ImGuiViewportNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiViewport_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiViewport* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiViewport_GetCenter")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetCenterNative(Vector2* pOut, ImGuiViewport* self);

		public static void GetCenter( Vector2* pOut,  ImGuiViewport* self)
		{
			GetCenterNative(pOut, self);
		}

		public static void GetCenter( Vector2* pOut,  ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				GetCenterNative(pOut, (ImGuiViewport*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiViewport_GetWorkCenter")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetWorkCenterNative(Vector2* pOut, ImGuiViewport* self);

		public static void GetWorkCenter( Vector2* pOut,  ImGuiViewport* self)
		{
			GetWorkCenterNative(pOut, self);
		}

		public static void GetWorkCenter( Vector2* pOut,  ref ImGuiViewport self)
		{
			fixed (ImGuiViewport* pself = &self)
			{
				GetWorkCenterNative(pOut, (ImGuiViewport*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPlatformIO_ImGuiPlatformIO")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPlatformIO* ImGuiPlatformIONative();

		public static ImGuiPlatformIO* ImGuiPlatformIO()
		{
			ImGuiPlatformIO* ret = ImGuiPlatformIONative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPlatformIO_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiPlatformIO* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPlatformMonitor_ImGuiPlatformMonitor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPlatformMonitor* ImGuiPlatformMonitorNative();

		public static ImGuiPlatformMonitor* ImGuiPlatformMonitor()
		{
			ImGuiPlatformMonitor* ret = ImGuiPlatformMonitorNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPlatformMonitor_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiPlatformMonitor* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPlatformImeData_ImGuiPlatformImeData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPlatformImeData* ImGuiPlatformImeDataNative();

		public static ImGuiPlatformImeData* ImGuiPlatformImeData()
		{
			ImGuiPlatformImeData* ret = ImGuiPlatformImeDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPlatformImeData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiPlatformImeData* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetKeyIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKey GetKeyIndexNative(ImGuiKey key);

		public static ImGuiKey GetKeyIndex( ImGuiKey key)
		{
			ImGuiKey ret = GetKeyIndexNative(key);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImHashData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImHashDataNative(void* data, ulong dataSize, uint seed);

		/// <summary>/// To be documented./// </summary>		public static uint ImHashData( void* data,  ulong dataSize,  uint seed)
		{
			uint ret = ImHashDataNative(data, dataSize, seed);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static uint ImHashData( void* data,  nuint dataSize,  uint seed)
		{
			uint ret = ImHashDataNative(data, dataSize, seed);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImHashStr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImHashNative(byte* data, ulong dataSize, uint seed);

		/// <summary>/// To be documented./// </summary>		public static uint ImHash( byte* data,  ulong dataSize,  uint seed)
		{
			uint ret = ImHashNative(data, dataSize, seed);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static uint ImHash( byte* data,  nuint dataSize,  uint seed)
		{
			uint ret = ImHashNative(data, dataSize, seed);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImQsort")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImQsortNative(void* baseValue, ulong count, ulong sizeOfElement, delegate*<void*, ulong, ulong, delegate*<void*, void*, int>, int> compareFunc);

		/// <summary>/// To be documented./// </summary>		public static void ImQsort( void* baseValue,  ulong count,  ulong sizeOfElement,  delegate*<void*, ulong, ulong, delegate*<void*, void*, int>, int> compareFunc)
		{
			ImQsortNative(baseValue, count, sizeOfElement, compareFunc);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImQsort( void* baseValue,  nuint count,  ulong sizeOfElement,  delegate*<void*, ulong, ulong, delegate*<void*, void*, int>, int> compareFunc)
		{
			ImQsortNative(baseValue, count, sizeOfElement, compareFunc);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImQsort( void* baseValue,  ulong count,  nuint sizeOfElement,  delegate*<void*, ulong, ulong, delegate*<void*, void*, int>, int> compareFunc)
		{
			ImQsortNative(baseValue, count, sizeOfElement, compareFunc);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImQsort( void* baseValue,  nuint count,  nuint sizeOfElement,  delegate*<void*, ulong, ulong, delegate*<void*, void*, int>, int> compareFunc)
		{
			ImQsortNative(baseValue, count, sizeOfElement, compareFunc);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImAlphaBlendColors")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ImAlphaBlendColorsNative(uint colA, uint colB);

		/// <summary>/// To be documented./// </summary>		public static uint ImAlphaBlendColors( uint colA,  uint colB)
		{
			uint ret = ImAlphaBlendColorsNative(colA, colB);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImIsPowerOfTwo_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImIsPowerOfTwoIntNative(int v);

		/// <summary>/// To be documented./// </summary>		public static bool ImIsPowerOfTwoInt( int v)
		{
			byte ret = ImIsPowerOfTwoIntNative(v);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImIsPowerOfTwo_U64")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImIsPowerOfTwoU64Native(ulong v);

		/// <summary>/// To be documented./// </summary>		public static bool ImIsPowerOfTwoU64( ulong v)
		{
			byte ret = ImIsPowerOfTwoU64Native(v);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImUpperPowerOfTwo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImUpperPowerOfTwoNative(int v);

		/// <summary>/// To be documented./// </summary>		public static int ImUpperPowerOfTwo( int v)
		{
			int ret = ImUpperPowerOfTwoNative(v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStricmp")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImStricmpNative(byte* str1, byte* str2);

		/// <summary>/// To be documented./// </summary>		public static int ImStricmp( byte* str1,  byte* str2)
		{
			int ret = ImStricmpNative(str1, str2);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImStricmp( byte* str1,  ref byte str2)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImStricmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static int ImStricmp( byte* str1,  string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStricmpNative(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStrnicmp")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImStrnicmpNative(byte* str1, byte* str2, ulong count);

		/// <summary>/// To be documented./// </summary>		public static int ImStrnicmp( byte* str1,  byte* str2,  ulong count)
		{
			int ret = ImStrnicmpNative(str1, str2, count);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImStrnicmp( byte* str1,  ref byte str2,  ulong count)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImStrnicmpNative(str1, (byte*)pstr2, count);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static int ImStrnicmp( byte* str1,  string str2,  ulong count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStrnicmpNative(str1, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImStrnicmp( byte* str1,  byte* str2,  nuint count)
		{
			int ret = ImStrnicmpNative(str1, str2, count);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImStrnicmp( byte* str1,  ref byte str2,  nuint count)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = ImStrnicmpNative(str1, (byte*)pstr2, count);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static int ImStrnicmp( byte* str1,  string str2,  nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImStrnicmpNative(str1, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStrncpy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImStrncpyNative(byte* dst, byte* src, ulong count);

		/// <summary>/// To be documented./// </summary>		public static void ImStrncpy( byte* dst,  byte* src,  ulong count)
		{
			ImStrncpyNative(dst, src, count);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImStrncpy( byte* dst,  ref byte src,  ulong count)
		{
			fixed (byte* psrc = &src)
			{
				ImStrncpyNative(dst, (byte*)psrc, count);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImStrncpy( byte* dst,  string src,  ulong count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImStrncpyNative(dst, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImStrncpy( byte* dst,  byte* src,  nuint count)
		{
			ImStrncpyNative(dst, src, count);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImStrncpy( byte* dst,  ref byte src,  nuint count)
		{
			fixed (byte* psrc = &src)
			{
				ImStrncpyNative(dst, (byte*)psrc, count);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImStrncpy( byte* dst,  string src,  nuint count)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImStrncpyNative(dst, pStr0, count);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStrdup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImStrdupNative(byte* str);

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrdup( byte* str)
		{
			byte* ret = ImStrdupNative(str);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrdupS( byte* str)
		{
			string ret = Utils.DecodeStringUTF8(ImStrdupNative(str));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStrdupcpy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImStrdupcpyNative(byte* dst, ulong* pDstSize, byte* str);

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrdupcpy( byte* dst,  ulong* pDstSize,  byte* str)
		{
			byte* ret = ImStrdupcpyNative(dst, pDstSize, str);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrdupcpyS( byte* dst,  ulong* pDstSize,  byte* str)
		{
			string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, pDstSize, str));
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrdupcpy( byte* dst,  ref nuint pDstSize,  byte* str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* ret = ImStrdupcpyNative(dst, (ulong*)ppDstSize, str);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrdupcpyS( byte* dst,  ref nuint pDstSize,  byte* str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, (ulong*)ppDstSize, str));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrdupcpy( byte* dst,  ulong* pDstSize,  ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = ImStrdupcpyNative(dst, pDstSize, (byte*)pstr);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrdupcpyS( byte* dst,  ulong* pDstSize,  ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, pDstSize, (byte*)pstr));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrdupcpy( byte* dst,  ulong* pDstSize,  string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrdupcpyNative(dst, pDstSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrdupcpyS( byte* dst,  ulong* pDstSize,  string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, pDstSize, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrdupcpy( byte* dst,  ref nuint pDstSize,  ref byte str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				fixed (byte* pstr = &str)
				{
					byte* ret = ImStrdupcpyNative(dst, (ulong*)ppDstSize, (byte*)pstr);
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrdupcpyS( byte* dst,  ref nuint pDstSize,  ref byte str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				fixed (byte* pstr = &str)
				{
					string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, (ulong*)ppDstSize, (byte*)pstr));
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrdupcpy( byte* dst,  ref nuint pDstSize,  string str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImStrdupcpyNative(dst, (ulong*)ppDstSize, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrdupcpyS( byte* dst,  ref nuint pDstSize,  string str)
		{
			fixed (nuint* ppDstSize = &pDstSize)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImStrdupcpyNative(dst, (ulong*)ppDstSize, pStr0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStrchrRange")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImStrchrRangeNative(byte* strBegin, byte* strEnd, byte c);

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrchrRange( byte* strBegin,  byte* strEnd,  byte c)
		{
			byte* ret = ImStrchrRangeNative(strBegin, strEnd, c);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrchrRangeS( byte* strBegin,  byte* strEnd,  byte c)
		{
			string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative(strBegin, strEnd, c));
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrchrRange( byte* strBegin,  ref byte strEnd,  byte c)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				byte* ret = ImStrchrRangeNative(strBegin, (byte*)pstrEnd, c);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrchrRangeS( byte* strBegin,  ref byte strEnd,  byte c)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative(strBegin, (byte*)pstrEnd, c));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStrchrRange( byte* strBegin,  string strEnd,  byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStrchrRangeNative(strBegin, pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStrchrRangeS( byte* strBegin,  string strEnd,  byte c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStrchrRangeNative(strBegin, pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStreolRange")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImStreolRangeNative(byte* str, byte* strEnd);

		/// <summary>/// To be documented./// </summary>		public static byte* ImStreolRange( byte* str,  byte* strEnd)
		{
			byte* ret = ImStreolRangeNative(str, strEnd);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStreolRangeS( byte* str,  byte* strEnd)
		{
			string ret = Utils.DecodeStringUTF8(ImStreolRangeNative(str, strEnd));
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStreolRange( byte* str,  ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				byte* ret = ImStreolRangeNative(str, (byte*)pstrEnd);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStreolRangeS( byte* str,  ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImStreolRangeNative(str, (byte*)pstrEnd));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStreolRange( byte* str,  string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStreolRangeNative(str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStreolRangeS( byte* str,  string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStreolRangeNative(str, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStristr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImStristrNative(byte* haystack, byte* haystackEnd, byte* needle, byte* needleEnd);

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  byte* haystackEnd,  byte* needle,  byte* needleEnd)
		{
			byte* ret = ImStristrNative(haystack, haystackEnd, needle, needleEnd);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  byte* haystackEnd,  byte* needle,  byte* needleEnd)
		{
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, needle, needleEnd));
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  ref byte haystackEnd,  byte* needle,  byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				byte* ret = ImStristrNative(haystack, (byte*)phaystackEnd, needle, needleEnd);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  ref byte haystackEnd,  byte* needle,  byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, (byte*)phaystackEnd, needle, needleEnd));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  string haystackEnd,  byte* needle,  byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristrNative(haystack, pStr0, needle, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  string haystackEnd,  byte* needle,  byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, pStr0, needle, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  byte* haystackEnd,  ref byte needle,  byte* needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = ImStristrNative(haystack, haystackEnd, (byte*)pneedle, needleEnd);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  byte* haystackEnd,  ref byte needle,  byte* needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, (byte*)pneedle, needleEnd));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  byte* haystackEnd,  string needle,  byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristrNative(haystack, haystackEnd, pStr0, needleEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
