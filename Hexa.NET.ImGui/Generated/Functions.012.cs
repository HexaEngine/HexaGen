// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  byte* haystackEnd,  string needle,  byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, pStr0, needleEnd));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  ref byte haystackEnd,  ref byte needle,  byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = ImStristrNative(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd);
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  ref byte haystackEnd,  ref byte needle,  byte* needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, (byte*)phaystackEnd, (byte*)pneedle, needleEnd));
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  string haystackEnd,  string needle,  byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristrNative(haystack, pStr0, pStr1, needleEnd);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  string haystackEnd,  string needle,  byte* needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, pStr0, pStr1, needleEnd));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  byte* haystackEnd,  byte* needle,  ref byte needleEnd)
		{
			fixed (byte* pneedleEnd = &needleEnd)
			{
				byte* ret = ImStristrNative(haystack, haystackEnd, needle, (byte*)pneedleEnd);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  byte* haystackEnd,  byte* needle,  ref byte needleEnd)
		{
			fixed (byte* pneedleEnd = &needleEnd)
			{
				string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, needle, (byte*)pneedleEnd));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  byte* haystackEnd,  byte* needle,  string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needleEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImStristrNative(haystack, haystackEnd, needle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  byte* haystackEnd,  byte* needle,  string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needleEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needleEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, needle, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  ref byte haystackEnd,  byte* needle,  ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImStristrNative(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  ref byte haystackEnd,  byte* needle,  ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, (byte*)phaystackEnd, needle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  string haystackEnd,  byte* needle,  string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristrNative(haystack, pStr0, needle, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  string haystackEnd,  byte* needle,  string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, pStr0, needle, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  byte* haystackEnd,  ref byte needle,  ref byte needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					byte* ret = ImStristrNative(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  byte* haystackEnd,  ref byte needle,  ref byte needleEnd)
		{
			fixed (byte* pneedle = &needle)
			{
				fixed (byte* pneedleEnd = &needleEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  byte* haystackEnd,  string needle,  string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImStristrNative(haystack, haystackEnd, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  byte* haystackEnd,  string needle,  string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needleEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needleEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, haystackEnd, pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  ref byte haystackEnd,  ref byte needle,  ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						byte* ret = ImStristrNative(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  ref byte haystackEnd,  ref byte needle,  ref byte needleEnd)
		{
			fixed (byte* phaystackEnd = &haystackEnd)
			{
				fixed (byte* pneedle = &needle)
				{
					fixed (byte* pneedleEnd = &needleEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, (byte*)phaystackEnd, (byte*)pneedle, (byte*)pneedleEnd));
						return ret;
					}
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImStristr( byte* haystack,  string haystackEnd,  string needle,  string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = ImStristrNative(haystack, pStr0, pStr1, pStr2);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImStristrS( byte* haystack,  string haystackEnd,  string needle,  string needleEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystackEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystackEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystackEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (needleEnd != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(needleEnd);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(needleEnd, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImStristrNative(haystack, pStr0, pStr1, pStr2));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStrTrimBlanks")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImTrimBlanksNative(byte* str);

		/// <summary>/// To be documented./// </summary>		public static void ImTrimBlanks( byte* str)
		{
			ImTrimBlanksNative(str);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStrSkipBlank")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImSkipBlankNative(byte* str);

		/// <summary>/// To be documented./// </summary>		public static byte* ImSkipBlank( byte* str)
		{
			byte* ret = ImSkipBlankNative(str);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImSkipBlankS( byte* str)
		{
			string ret = Utils.DecodeStringUTF8(ImSkipBlankNative(str));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStrlenW")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImStrlenWNative(char* str);

		/// <summary>/// To be documented./// </summary>		public static int ImStrlenW( char* str)
		{
			int ret = ImStrlenWNative(str);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImStrbolW")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial char* ImStrbolWNative(char* bufMidLine, char* bufBegin);

		/// <summary>/// To be documented./// </summary>		public static char* ImStrbolW( char* bufMidLine,  char* bufBegin)
		{
			char* ret = ImStrbolWNative(bufMidLine, bufBegin);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static char* ImStrbolW( char* bufMidLine,  ref char bufBegin)
		{
			fixed (char* pbufBegin = &bufBegin)
			{
				char* ret = ImStrbolWNative(bufMidLine, (char*)pbufBegin);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImToUpper")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImToUpperNative(byte c);

		/// <summary>/// To be documented./// </summary>		public static byte ImToUpper( byte c)
		{
			byte ret = ImToUpperNative(c);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImCharIsBlankA")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImCharIsBlankANative(byte c);

		/// <summary>/// To be documented./// </summary>		public static bool ImCharIsBlankA( byte c)
		{
			byte ret = ImCharIsBlankANative(c);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImCharIsBlankW")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImCharIsBlankWNative(uint c);

		/// <summary>/// To be documented./// </summary>		public static bool ImCharIsBlankW( uint c)
		{
			byte ret = ImCharIsBlankWNative(c);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFormatStringToTempBuffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImFormatStringToTempBufferNative(byte** outBuf, byte** outBufEnd, byte* fmt);

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBuffer( byte** outBuf,  byte** outBufEnd,  byte* fmt)
		{
			ImFormatStringToTempBufferNative(outBuf, outBufEnd, fmt);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBuffer( byte** outBuf,  ref byte* outBufEnd,  byte* fmt)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				ImFormatStringToTempBufferNative(outBuf, (byte**)poutBufEnd, fmt);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBuffer( byte** outBuf,  byte** outBufEnd,  ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImFormatStringToTempBufferNative(outBuf, outBufEnd, (byte*)pfmt);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBuffer( byte** outBuf,  byte** outBufEnd,  string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFormatStringToTempBufferNative(outBuf, outBufEnd, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBuffer( byte** outBuf,  ref byte* outBufEnd,  ref byte fmt)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBufferNative(outBuf, (byte**)poutBufEnd, (byte*)pfmt);
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBuffer( byte** outBuf,  ref byte* outBufEnd,  string fmt)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBufferNative(outBuf, (byte**)poutBufEnd, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFormatStringToTempBufferV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImFormatStringToTempBufferVNative(byte** outBuf, byte** outBufEnd, byte* fmt, nuint args);

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBufferV( byte** outBuf,  byte** outBufEnd,  byte* fmt,  nuint args)
		{
			ImFormatStringToTempBufferVNative(outBuf, outBufEnd, fmt, args);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBufferV( byte** outBuf,  ref byte* outBufEnd,  byte* fmt,  nuint args)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				ImFormatStringToTempBufferVNative(outBuf, (byte**)poutBufEnd, fmt, args);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBufferV( byte** outBuf,  byte** outBufEnd,  ref byte fmt,  nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				ImFormatStringToTempBufferVNative(outBuf, outBufEnd, (byte*)pfmt, args);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBufferV( byte** outBuf,  byte** outBufEnd,  string fmt,  nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFormatStringToTempBufferVNative(outBuf, outBufEnd, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBufferV( byte** outBuf,  ref byte* outBufEnd,  ref byte fmt,  nuint args)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImFormatStringToTempBufferVNative(outBuf, (byte**)poutBufEnd, (byte*)pfmt, args);
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImFormatStringToTempBufferV( byte** outBuf,  ref byte* outBufEnd,  string fmt,  nuint args)
		{
			fixed (byte** poutBufEnd = &outBufEnd)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFormatStringToTempBufferVNative(outBuf, (byte**)poutBufEnd, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImParseFormatFindStart")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImParseFormatFindStartNative(byte* format);

		/// <summary>/// To be documented./// </summary>		public static byte* ImParseFormatFindStart( byte* format)
		{
			byte* ret = ImParseFormatFindStartNative(format);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImParseFormatFindStartS( byte* format)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatFindStartNative(format));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImParseFormatFindEnd")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImParseFormatFindEndNative(byte* format);

		/// <summary>/// To be documented./// </summary>		public static byte* ImParseFormatFindEnd( byte* format)
		{
			byte* ret = ImParseFormatFindEndNative(format);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImParseFormatFindEndS( byte* format)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatFindEndNative(format));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImParseFormatSanitizeForPrinting")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImParseFormatSanitizeForPrintingNative(byte* fmtIn, byte* fmtOut, ulong fmtOutSize);

		/// <summary>/// To be documented./// </summary>		public static void ImParseFormatSanitizeForPrinting( byte* fmtIn,  byte* fmtOut,  ulong fmtOutSize)
		{
			ImParseFormatSanitizeForPrintingNative(fmtIn, fmtOut, fmtOutSize);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImParseFormatSanitizeForPrinting( byte* fmtIn,  ref byte fmtOut,  ulong fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				ImParseFormatSanitizeForPrintingNative(fmtIn, (byte*)pfmtOut, fmtOutSize);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImParseFormatSanitizeForPrinting( byte* fmtIn,  ref string fmtOut,  ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImParseFormatSanitizeForPrintingNative(fmtIn, pStr0, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImParseFormatSanitizeForPrinting( byte* fmtIn,  byte* fmtOut,  nuint fmtOutSize)
		{
			ImParseFormatSanitizeForPrintingNative(fmtIn, fmtOut, fmtOutSize);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImParseFormatSanitizeForPrinting( byte* fmtIn,  ref byte fmtOut,  nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				ImParseFormatSanitizeForPrintingNative(fmtIn, (byte*)pfmtOut, fmtOutSize);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImParseFormatSanitizeForPrinting( byte* fmtIn,  ref string fmtOut,  nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImParseFormatSanitizeForPrintingNative(fmtIn, pStr0, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImParseFormatSanitizeForScanning")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImParseFormatSanitizeForScanningNative(byte* fmtIn, byte* fmtOut, ulong fmtOutSize);

		/// <summary>/// To be documented./// </summary>		public static byte* ImParseFormatSanitizeForScanning( byte* fmtIn,  byte* fmtOut,  ulong fmtOutSize)
		{
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImParseFormatSanitizeForScanningS( byte* fmtIn,  byte* fmtOut,  ulong fmtOutSize)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize));
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImParseFormatSanitizeForScanning( byte* fmtIn,  ref byte fmtOut,  ulong fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImParseFormatSanitizeForScanningS( byte* fmtIn,  ref byte fmtOut,  ulong fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImParseFormatSanitizeForScanning( byte* fmtIn,  ref string fmtOut,  ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImParseFormatSanitizeForScanningS( byte* fmtIn,  ref string fmtOut,  ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize));
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImParseFormatSanitizeForScanning( byte* fmtIn,  byte* fmtOut,  nuint fmtOutSize)
		{
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImParseFormatSanitizeForScanningS( byte* fmtIn,  byte* fmtOut,  nuint fmtOutSize)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize));
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImParseFormatSanitizeForScanning( byte* fmtIn,  ref byte fmtOut,  nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImParseFormatSanitizeForScanningS( byte* fmtIn,  ref byte fmtOut,  nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImParseFormatSanitizeForScanning( byte* fmtIn,  ref string fmtOut,  nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImParseFormatSanitizeForScanningS( byte* fmtIn,  ref string fmtOut,  nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize));
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImParseFormatPrecision")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImParseFormatPrecisionNative(byte* format, int defaultValue);

		/// <summary>/// To be documented./// </summary>		public static int ImParseFormatPrecision( byte* format,  int defaultValue)
		{
			int ret = ImParseFormatPrecisionNative(format, defaultValue);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTextCharToUtf8")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImTextCharToUtf8Native(byte* outBuf, uint c);

		/// <summary>/// To be documented./// </summary>		public static byte* ImTextCharToUtf8( byte* outBuf,  uint c)
		{
			byte* ret = ImTextCharToUtf8Native(outBuf, c);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImTextCharToUtf8S( byte* outBuf,  uint c)
		{
			string ret = Utils.DecodeStringUTF8(ImTextCharToUtf8Native(outBuf, c));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTextCharFromUtf8")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImTextCharFromUtf8Native(uint* outChar, byte* inText, byte* inTextEnd);

		/// <summary>/// To be documented./// </summary>		public static int ImTextCharFromUtf8( uint* outChar,  byte* inText,  byte* inTextEnd)
		{
			int ret = ImTextCharFromUtf8Native(outChar, inText, inTextEnd);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCharFromUtf8( uint* outChar,  ref byte inText,  byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, inTextEnd);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCharFromUtf8( uint* outChar,  string inText,  byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCharFromUtf8Native(outChar, pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCharFromUtf8( uint* outChar,  byte* inText,  ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCharFromUtf8Native(outChar, inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCharFromUtf8( uint* outChar,  byte* inText,  string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCharFromUtf8Native(outChar, inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCharFromUtf8( uint* outChar,  ref byte inText,  ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCharFromUtf8( uint* outChar,  string inText,  string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCharFromUtf8Native(outChar, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTextCountCharsFromUtf8")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImTextCountCharsFromUtf8Native(byte* inText, byte* inTextEnd);

		/// <summary>/// To be documented./// </summary>		public static int ImTextCountCharsFromUtf8( byte* inText,  byte* inTextEnd)
		{
			int ret = ImTextCountCharsFromUtf8Native(inText, inTextEnd);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCountCharsFromUtf8( byte* inText,  ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountCharsFromUtf8Native(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCountCharsFromUtf8( byte* inText,  string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountCharsFromUtf8Native(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTextCountUtf8BytesFromChar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImTextCountUtf8BytesFromCharNative(byte* inText, byte* inTextEnd);

		/// <summary>/// To be documented./// </summary>		public static int ImTextCountUtf8BytesFromChar( byte* inText,  byte* inTextEnd)
		{
			int ret = ImTextCountUtf8BytesFromCharNative(inText, inTextEnd);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCountUtf8BytesFromChar( byte* inText,  ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromCharNative(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCountUtf8BytesFromChar( byte* inText,  string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountUtf8BytesFromCharNative(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTextCountUtf8BytesFromStr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImTextCountUtf8BytesFromNative(char* inText, char* inTextEnd);

		/// <summary>/// To be documented./// </summary>		public static int ImTextCountUtf8BytesFrom( char* inText,  char* inTextEnd)
		{
			int ret = ImTextCountUtf8BytesFromNative(inText, inTextEnd);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static int ImTextCountUtf8BytesFrom( char* inText,  ref char inTextEnd)
		{
			fixed (char* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromNative(inText, (char*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTextFindPreviousUtf8Codepoint")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImTextFindPreviousUtf8CodepointNative(byte* inTextStart, byte* inTextCurr);

		/// <summary>/// To be documented./// </summary>		public static byte* ImTextFindPreviousUtf8Codepoint( byte* inTextStart,  byte* inTextCurr)
		{
			byte* ret = ImTextFindPreviousUtf8CodepointNative(inTextStart, inTextCurr);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImTextFindPreviousUtf8CodepointS( byte* inTextStart,  byte* inTextCurr)
		{
			string ret = Utils.DecodeStringUTF8(ImTextFindPreviousUtf8CodepointNative(inTextStart, inTextCurr));
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImTextFindPreviousUtf8Codepoint( byte* inTextStart,  ref byte inTextCurr)
		{
			fixed (byte* pinTextCurr = &inTextCurr)
			{
				byte* ret = ImTextFindPreviousUtf8CodepointNative(inTextStart, (byte*)pinTextCurr);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImTextFindPreviousUtf8CodepointS( byte* inTextStart,  ref byte inTextCurr)
		{
			fixed (byte* pinTextCurr = &inTextCurr)
			{
				string ret = Utils.DecodeStringUTF8(ImTextFindPreviousUtf8CodepointNative(inTextStart, (byte*)pinTextCurr));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImTextFindPreviousUtf8Codepoint( byte* inTextStart,  string inTextCurr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextCurr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextCurr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextCurr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImTextFindPreviousUtf8CodepointNative(inTextStart, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImTextFindPreviousUtf8CodepointS( byte* inTextStart,  string inTextCurr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextCurr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextCurr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextCurr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImTextFindPreviousUtf8CodepointNative(inTextStart, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFileOpen")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImFileHandle ImFileOpenNative(byte* filename, byte* mode);

		/// <summary>/// To be documented./// </summary>		public static ImFileHandle ImFileOpen( byte* filename,  byte* mode)
		{
			ImFileHandle ret = ImFileOpenNative(filename, mode);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static ImFileHandle ImFileOpen( byte* filename,  ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				ImFileHandle ret = ImFileOpenNative(filename, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static ImFileHandle ImFileOpen( byte* filename,  string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFileHandle ret = ImFileOpenNative(filename, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFileClose")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImFileCloseNative(ImFileHandle file);

		/// <summary>/// To be documented./// </summary>		public static bool ImFileClose( ImFileHandle file)
		{
			byte ret = ImFileCloseNative(file);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFileGetSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong ImFileGetSizeNative(ImFileHandle file);

		/// <summary>/// To be documented./// </summary>		public static ulong ImFileGetSize( ImFileHandle file)
		{
			ulong ret = ImFileGetSizeNative(file);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFileRead")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong ImFileReadNative(void* data, ulong size, ulong count, ImFileHandle file);

		/// <summary>/// To be documented./// </summary>		public static ulong ImFileRead( void* data,  ulong size,  ulong count,  ImFileHandle file)
		{
			ulong ret = ImFileReadNative(data, size, count, file);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFileWrite")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong ImFileWriteNative(void* data, ulong size, ulong count, ImFileHandle file);

		/// <summary>/// To be documented./// </summary>		public static ulong ImFileWrite( void* data,  ulong size,  ulong count,  ImFileHandle file)
		{
			ulong ret = ImFileWriteNative(data, size, count, file);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFileLoadToMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* ImFileLoadToMemoryNative(byte* filename, byte* mode, ulong* outFileSize, int paddingBytes);

		/// <summary>/// To be documented./// </summary>		public static void* ImFileLoadToMemory( byte* filename,  byte* mode,  ulong* outFileSize,  int paddingBytes)
		{
			void* ret = ImFileLoadToMemoryNative(filename, mode, outFileSize, paddingBytes);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static void* ImFileLoadToMemory( byte* filename,  ref byte mode,  ulong* outFileSize,  int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, outFileSize, paddingBytes);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void* ImFileLoadToMemory( byte* filename,  string mode,  ulong* outFileSize,  int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(filename, pStr0, outFileSize, paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static void* ImFileLoadToMemory( byte* filename,  byte* mode,  ref nuint outFileSize,  int paddingBytes)
		{
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemoryNative(filename, mode, (ulong*)poutFileSize, paddingBytes);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void* ImFileLoadToMemory( byte* filename,  ref byte mode,  ref nuint outFileSize,  int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				fixed (nuint* poutFileSize = &outFileSize)
				{
					void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, (ulong*)poutFileSize, paddingBytes);
					return ret;
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void* ImFileLoadToMemory( byte* filename,  string mode,  ref nuint outFileSize,  int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* poutFileSize = &outFileSize)
			{
				void* ret = ImFileLoadToMemoryNative(filename, pStr0, (ulong*)poutFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImPow_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImPowFloatNative(float x, float y);

		/// <summary>/// To be documented./// </summary>		public static float ImPowFloat( float x,  float y)
		{
			float ret = ImPowFloatNative(x, y);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImPow_double")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImPowDoubleNative(double x, double y);

		/// <summary>/// To be documented./// </summary>		public static double ImPowDouble( double x,  double y)
		{
			double ret = ImPowDoubleNative(x, y);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImLog_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImLogFloatNative(float x);

		/// <summary>/// To be documented./// </summary>		public static float ImLogFloat( float x)
		{
			float ret = ImLogFloatNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImLog_double")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImLogDoubleNative(double x);

		/// <summary>/// To be documented./// </summary>		public static double ImLogDouble( double x)
		{
			double ret = ImLogDoubleNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImAbs_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImAbsIntNative(int x);

		/// <summary>/// To be documented./// </summary>		public static int ImAbsInt( int x)
		{
			int ret = ImAbsIntNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImAbs_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImAbsFloatNative(float x);

		/// <summary>/// To be documented./// </summary>		public static float ImAbsFloat( float x)
		{
			float ret = ImAbsFloatNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImAbs_double")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImAbsDoubleNative(double x);

		/// <summary>/// To be documented./// </summary>		public static double ImAbsDouble( double x)
		{
			double ret = ImAbsDoubleNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImSign_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImSignFloatNative(float x);

		/// <summary>/// To be documented./// </summary>		public static float ImSignFloat( float x)
		{
			float ret = ImSignFloatNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImSign_double")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImSignDoubleNative(double x);

		/// <summary>/// To be documented./// </summary>		public static double ImSignDouble( double x)
		{
			double ret = ImSignDoubleNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImRsqrt_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImRsqrtFloatNative(float x);

		/// <summary>/// To be documented./// </summary>		public static float ImRsqrtFloat( float x)
		{
			float ret = ImRsqrtFloatNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImRsqrt_double")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double ImRsqrtDoubleNative(double x);

		/// <summary>/// To be documented./// </summary>		public static double ImRsqrtDouble( double x)
		{
			double ret = ImRsqrtDoubleNative(x);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImMin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImMinNative(Vector2* pOut, Vector2 lhs, Vector2 rhs);

		/// <summary>/// To be documented./// </summary>		public static void ImMin( Vector2* pOut,  Vector2 lhs,  Vector2 rhs)
		{
			ImMinNative(pOut, lhs, rhs);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImMax")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImMaxNative(Vector2* pOut, Vector2 lhs, Vector2 rhs);

		/// <summary>/// To be documented./// </summary>		public static void ImMax( Vector2* pOut,  Vector2 lhs,  Vector2 rhs)
		{
			ImMaxNative(pOut, lhs, rhs);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImClamp")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImClampNative(Vector2* pOut, Vector2 v, Vector2 mn, Vector2 mx);

		/// <summary>/// To be documented./// </summary>		public static void ImClamp( Vector2* pOut,  Vector2 v,  Vector2 mn,  Vector2 mx)
		{
			ImClampNative(pOut, v, mn, mx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImLerp_Vec2Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImLerpVec2FloatNative(Vector2* pOut, Vector2 a, Vector2 b, float t);

		/// <summary>/// To be documented./// </summary>		public static void ImLerpVec2Float( Vector2* pOut,  Vector2 a,  Vector2 b,  float t)
		{
			ImLerpVec2FloatNative(pOut, a, b, t);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImLerp_Vec2Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImLerpVec2Vec2Native(Vector2* pOut, Vector2 a, Vector2 b, Vector2 t);

		/// <summary>/// To be documented./// </summary>		public static void ImLerpVec2Vec2( Vector2* pOut,  Vector2 a,  Vector2 b,  Vector2 t)
		{
			ImLerpVec2Vec2Native(pOut, a, b, t);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImLerp_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImLerpVec4Native(Vector4* pOut, Vector4 a, Vector4 b, float t);

		/// <summary>/// To be documented./// </summary>		public static void ImLerpVec4( Vector4* pOut,  Vector4 a,  Vector4 b,  float t)
		{
			ImLerpVec4Native(pOut, a, b, t);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImSaturate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImSaturateNative(float f);

		/// <summary>/// To be documented./// </summary>		public static float ImSaturate( float f)
		{
			float ret = ImSaturateNative(f);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImLengthSqr_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImLengthSqrVec2Native(Vector2 lhs);

		/// <summary>/// To be documented./// </summary>		public static float ImLengthSqrVec2( Vector2 lhs)
		{
			float ret = ImLengthSqrVec2Native(lhs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImLengthSqr_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImLengthSqrVec4Native(Vector4 lhs);

		/// <summary>/// To be documented./// </summary>		public static float ImLengthSqrVec4( Vector4 lhs)
		{
			float ret = ImLengthSqrVec4Native(lhs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImInvLength")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImInvLengthNative(Vector2 lhs, float failValue);

		/// <summary>/// To be documented./// </summary>		public static float ImInvLength( Vector2 lhs,  float failValue)
		{
			float ret = ImInvLengthNative(lhs, failValue);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTrunc_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImTruncFloatNative(float f);

		/// <summary>/// To be documented./// </summary>		public static float ImTruncFloat( float f)
		{
			float ret = ImTruncFloatNative(f);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTrunc_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImTruncVec2Native(Vector2* pOut, Vector2 v);

		/// <summary>/// To be documented./// </summary>		public static void ImTruncVec2( Vector2* pOut,  Vector2 v)
		{
			ImTruncVec2Native(pOut, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFloor_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImFloorFloatNative(float f);

		/// <summary>/// To be documented./// </summary>		public static float ImFloorFloat( float f)
		{
			float ret = ImFloorFloatNative(f);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImFloor_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImFloorVec2Native(Vector2* pOut, Vector2 v);

		/// <summary>/// To be documented./// </summary>		public static void ImFloorVec2( Vector2* pOut,  Vector2 v)
		{
			ImFloorVec2Native(pOut, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImModPositive")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImModPositiveNative(int a, int b);

		/// <summary>/// To be documented./// </summary>		public static int ImModPositive( int a,  int b)
		{
			int ret = ImModPositiveNative(a, b);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImDot")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImDotNative(Vector2 a, Vector2 b);

		/// <summary>/// To be documented./// </summary>		public static float ImDot( Vector2 a,  Vector2 b)
		{
			float ret = ImDotNative(a, b);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImRotate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRotateNative(Vector2* pOut, Vector2 v, float cosA, float sinA);

		/// <summary>/// To be documented./// </summary>		public static void ImRotate( Vector2* pOut,  Vector2 v,  float cosA,  float sinA)
		{
			ImRotateNative(pOut, v, cosA, sinA);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImLinearSweep")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImLinearSweepNative(float current, float target, float speed);

		/// <summary>/// To be documented./// </summary>		public static float ImLinearSweep( float current,  float target,  float speed)
		{
			float ret = ImLinearSweepNative(current, target, speed);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImMul")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImMulNative(Vector2* pOut, Vector2 lhs, Vector2 rhs);

		/// <summary>/// To be documented./// </summary>		public static void ImMul( Vector2* pOut,  Vector2 lhs,  Vector2 rhs)
		{
			ImMulNative(pOut, lhs, rhs);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImIsFloatAboveGuaranteedIntegerPrecision")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImIsFloatAboveGuaranteedIntegerPrecisionNative(float f);

		/// <summary>/// To be documented./// </summary>		public static bool ImIsFloatAboveGuaranteedIntegerPrecision( float f)
		{
			byte ret = ImIsFloatAboveGuaranteedIntegerPrecisionNative(f);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImExponentialMovingAverage")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImExponentialMovingAverageNative(float avg, float sample, int n);

		/// <summary>/// To be documented./// </summary>		public static float ImExponentialMovingAverage( float avg,  float sample,  int n)
		{
			float ret = ImExponentialMovingAverageNative(avg, sample, n);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBezierCubicCalc")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBezierCubicCalcNative(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t);

		/// <summary>/// To be documented./// </summary>		public static void ImBezierCubicCalc( Vector2* pOut,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  float t)
		{
			ImBezierCubicCalcNative(pOut, p1, p2, p3, p4, t);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBezierCubicClosestPoint")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBezierCubicClosestPointNative(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, int numSegments);

		/// <summary>/// To be documented./// </summary>		public static void ImBezierCubicClosestPoint( Vector2* pOut,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 p,  int numSegments)
		{
			ImBezierCubicClosestPointNative(pOut, p1, p2, p3, p4, p, numSegments);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBezierCubicClosestPointCasteljau")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBezierCubicClosestPointCasteljauNative(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2 p, float tessTol);

		/// <summary>/// To be documented./// </summary>		public static void ImBezierCubicClosestPointCasteljau( Vector2* pOut,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 p,  float tessTol)
		{
			ImBezierCubicClosestPointCasteljauNative(pOut, p1, p2, p3, p4, p, tessTol);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBezierQuadraticCalc")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBezierQuadraticCalcNative(Vector2* pOut, Vector2 p1, Vector2 p2, Vector2 p3, float t);

		/// <summary>/// To be documented./// </summary>		public static void ImBezierQuadraticCalc( Vector2* pOut,  Vector2 p1,  Vector2 p2,  Vector2 p3,  float t)
		{
			ImBezierQuadraticCalcNative(pOut, p1, p2, p3, t);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImLineClosestPoint")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImLineClosestPointNative(Vector2* pOut, Vector2 a, Vector2 b, Vector2 p);

		/// <summary>/// To be documented./// </summary>		public static void ImLineClosestPoint( Vector2* pOut,  Vector2 a,  Vector2 b,  Vector2 p)
		{
			ImLineClosestPointNative(pOut, a, b, p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTriangleContainsPoint")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImTriangleContainsPointNative(Vector2 a, Vector2 b, Vector2 c, Vector2 p);

		/// <summary>/// To be documented./// </summary>		public static bool ImTriangleContainsPoint( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p)
		{
			byte ret = ImTriangleContainsPointNative(a, b, c, p);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTriangleClosestPoint")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImTriangleClosestPointNative(Vector2* pOut, Vector2 a, Vector2 b, Vector2 c, Vector2 p);

		/// <summary>/// To be documented./// </summary>		public static void ImTriangleClosestPoint( Vector2* pOut,  Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p)
		{
			ImTriangleClosestPointNative(pOut, a, b, c, p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTriangleBarycentricCoords")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImTriangleBarycentricCoordsNative(Vector2 a, Vector2 b, Vector2 c, Vector2 p, float* outU, float* outV, float* outW);

		/// <summary>/// To be documented./// </summary>		public static void ImTriangleBarycentricCoords( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p,  float* outU,  float* outV,  float* outW)
		{
			ImTriangleBarycentricCoordsNative(a, b, c, p, outU, outV, outW);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImTriangleBarycentricCoords( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p,  ref float outU,  float* outV,  float* outW)
		{
			fixed (float* poutU = &outU)
			{
				ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, outV, outW);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImTriangleBarycentricCoords( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p,  float* outU,  ref float outV,  float* outW)
		{
			fixed (float* poutV = &outV)
			{
				ImTriangleBarycentricCoordsNative(a, b, c, p, outU, (float*)poutV, outW);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImTriangleBarycentricCoords( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p,  ref float outU,  ref float outV,  float* outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, (float*)poutV, outW);
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImTriangleBarycentricCoords( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p,  float* outU,  float* outV,  ref float outW)
		{
			fixed (float* poutW = &outW)
			{
				ImTriangleBarycentricCoordsNative(a, b, c, p, outU, outV, (float*)poutW);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImTriangleBarycentricCoords( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p,  ref float outU,  float* outV,  ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutW = &outW)
				{
					ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, outV, (float*)poutW);
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImTriangleBarycentricCoords( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p,  float* outU,  ref float outV,  ref float outW)
		{
			fixed (float* poutV = &outV)
			{
				fixed (float* poutW = &outW)
				{
					ImTriangleBarycentricCoordsNative(a, b, c, p, outU, (float*)poutV, (float*)poutW);
				}
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImTriangleBarycentricCoords( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 p,  ref float outU,  ref float outV,  ref float outW)
		{
			fixed (float* poutU = &outU)
			{
				fixed (float* poutV = &outV)
				{
					fixed (float* poutW = &outW)
					{
						ImTriangleBarycentricCoordsNative(a, b, c, p, (float*)poutU, (float*)poutV, (float*)poutW);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImTriangleArea")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImTriangleAreaNative(Vector2 a, Vector2 b, Vector2 c);

		/// <summary>/// To be documented./// </summary>		public static float ImTriangleArea( Vector2 a,  Vector2 b,  Vector2 c)
		{
			float ret = ImTriangleAreaNative(a, b, c);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec1_ImVec1_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImVec1* ImVec1ImVec1NilNative();

		/// <summary>/// To be documented./// </summary>		public static ImVec1* ImVec1ImVec1Nil()
		{
			ImVec1* ret = ImVec1ImVec1NilNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec1_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImVec1DestroyNative(ImVec1* self);

		/// <summary>/// To be documented./// </summary>		public static void ImVec1Destroy( ImVec1* self)
		{
			ImVec1DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec1_ImVec1_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImVec1* ImVec1ImVec1FloatNative(float X);

		/// <summary>/// To be documented./// </summary>		public static ImVec1* ImVec1ImVec1Float( float X)
		{
			ImVec1* ret = ImVec1ImVec1FloatNative(X);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec2ih_ImVec2ih_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImVec2Ih* ImVec2IhImVec2IhNilNative();

		/// <summary>/// To be documented./// </summary>		public static ImVec2Ih* ImVec2IhImVec2IhNil()
		{
			ImVec2Ih* ret = ImVec2IhImVec2IhNilNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec2ih_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImVec2IhDestroyNative(ImVec2Ih* self);

		/// <summary>/// To be documented./// </summary>		public static void ImVec2IhDestroy( ImVec2Ih* self)
		{
			ImVec2IhDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec2ih_ImVec2ih_short")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImVec2Ih* ImVec2IhImVec2IhShortNative(short X, short Y);

		/// <summary>/// To be documented./// </summary>		public static ImVec2Ih* ImVec2IhImVec2IhShort( short X,  short Y)
		{
			ImVec2Ih* ret = ImVec2IhImVec2IhShortNative(X, Y);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec2ih_ImVec2ih_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImVec2Ih* ImVec2IhImVec2IhVec2Native(Vector2 rhs);

		/// <summary>/// To be documented./// </summary>		public static ImVec2Ih* ImVec2IhImVec2IhVec2( Vector2 rhs)
		{
			ImVec2Ih* ret = ImVec2IhImVec2IhVec2Native(rhs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_ImRect_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImRect* ImRectImRectNilNative();

		/// <summary>/// To be documented./// </summary>		public static ImRect* ImRectImRectNil()
		{
			ImRect* ret = ImRectImRectNilNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectDestroyNative(ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static void ImRectDestroy( ImRect* self)
		{
			ImRectDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_ImRect_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImRect* ImRectImRectVec2Native(Vector2 min, Vector2 max);

		/// <summary>/// To be documented./// </summary>		public static ImRect* ImRectImRectVec2( Vector2 min,  Vector2 max)
		{
			ImRect* ret = ImRectImRectVec2Native(min, max);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_ImRect_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImRect* ImRectImRectVec4Native(Vector4 v);

		/// <summary>/// To be documented./// </summary>		public static ImRect* ImRectImRectVec4( Vector4 v)
		{
			ImRect* ret = ImRectImRectVec4Native(v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_ImRect_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImRect* ImRectImRectFloatNative(float x1, float y1, float x2, float y2);

		/// <summary>/// To be documented./// </summary>		public static ImRect* ImRectImRectFloat( float x1,  float y1,  float x2,  float y2)
		{
			ImRect* ret = ImRectImRectFloatNative(x1, y1, x2, y2);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_GetCenter")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectGetCenterNative(Vector2* pOut, ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetCenter( Vector2* pOut,  ImRect* self)
		{
			ImRectGetCenterNative(pOut, self);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetCenter( Vector2* pOut,  ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetCenterNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_GetSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectGetSizeNative(Vector2* pOut, ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetSize( Vector2* pOut,  ImRect* self)
		{
			ImRectGetSizeNative(pOut, self);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetSize( Vector2* pOut,  ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetSizeNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_GetWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImRectGetWidthNative(ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static float ImRectGetWidth( ImRect* self)
		{
			float ret = ImRectGetWidthNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_GetHeight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImRectGetHeightNative(ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static float ImRectGetHeight( ImRect* self)
		{
			float ret = ImRectGetHeightNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_GetArea")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImRectGetAreaNative(ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static float ImRectGetArea( ImRect* self)
		{
			float ret = ImRectGetAreaNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_GetTL")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectGetTLNative(Vector2* pOut, ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetTL( Vector2* pOut,  ImRect* self)
		{
			ImRectGetTLNative(pOut, self);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetTL( Vector2* pOut,  ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetTLNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_GetTR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectGetTRNative(Vector2* pOut, ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetTR( Vector2* pOut,  ImRect* self)
		{
			ImRectGetTRNative(pOut, self);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetTR( Vector2* pOut,  ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetTRNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_GetBL")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectGetBLNative(Vector2* pOut, ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetBL( Vector2* pOut,  ImRect* self)
		{
			ImRectGetBLNative(pOut, self);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetBL( Vector2* pOut,  ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetBLNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_GetBR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectGetBRNative(Vector2* pOut, ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetBR( Vector2* pOut,  ImRect* self)
		{
			ImRectGetBRNative(pOut, self);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImRectGetBR( Vector2* pOut,  ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectGetBRNative(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_Contains_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImRectContainsVec2Native(ImRect* self, Vector2 p);

		/// <summary>/// To be documented./// </summary>		public static bool ImRectContainsVec2( ImRect* self,  Vector2 p)
		{
			byte ret = ImRectContainsVec2Native(self, p);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_Contains_Rect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImRectContainsRectNative(ImRect* self, ImRect r);

		/// <summary>/// To be documented./// </summary>		public static bool ImRectContainsRect( ImRect* self,  ImRect r)
		{
			byte ret = ImRectContainsRectNative(self, r);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_ContainsWithPad")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImRectContainsWithPadNative(ImRect* self, Vector2 p, Vector2 pad);

		/// <summary>/// To be documented./// </summary>		public static bool ImRectContainsWithPad( ImRect* self,  Vector2 p,  Vector2 pad)
		{
			byte ret = ImRectContainsWithPadNative(self, p, pad);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_Overlaps")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImRectOverlapsNative(ImRect* self, ImRect r);

		/// <summary>/// To be documented./// </summary>		public static bool ImRectOverlaps( ImRect* self,  ImRect r)
		{
			byte ret = ImRectOverlapsNative(self, r);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_Add_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectAddVec2Native(ImRect* self, Vector2 p);

		/// <summary>/// To be documented./// </summary>		public static void ImRectAddVec2( ImRect* self,  Vector2 p)
		{
			ImRectAddVec2Native(self, p);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_Add_Rect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectAddRectNative(ImRect* self, ImRect r);

		/// <summary>/// To be documented./// </summary>		public static void ImRectAddRect( ImRect* self,  ImRect r)
		{
			ImRectAddRectNative(self, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_Expand_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectExpandFloatNative(ImRect* self, float amount);

		/// <summary>/// To be documented./// </summary>		public static void ImRectExpandFloat( ImRect* self,  float amount)
		{
			ImRectExpandFloatNative(self, amount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_Expand_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectExpandVec2Native(ImRect* self, Vector2 amount);

		/// <summary>/// To be documented./// </summary>		public static void ImRectExpandVec2( ImRect* self,  Vector2 amount)
		{
			ImRectExpandVec2Native(self, amount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_Translate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectTranslateNative(ImRect* self, Vector2 d);

		/// <summary>/// To be documented./// </summary>		public static void ImRectTranslate( ImRect* self,  Vector2 d)
		{
			ImRectTranslateNative(self, d);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_TranslateX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectTranslateXNative(ImRect* self, float dx);

		/// <summary>/// To be documented./// </summary>		public static void ImRectTranslateX( ImRect* self,  float dx)
		{
			ImRectTranslateXNative(self, dx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_TranslateY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectTranslateYNative(ImRect* self, float dy);

		/// <summary>/// To be documented./// </summary>		public static void ImRectTranslateY( ImRect* self,  float dy)
		{
			ImRectTranslateYNative(self, dy);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_ClipWith")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectClipWithNative(ImRect* self, ImRect r);

		/// <summary>/// To be documented./// </summary>		public static void ImRectClipWith( ImRect* self,  ImRect r)
		{
			ImRectClipWithNative(self, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_ClipWithFull")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectClipWithFullNative(ImRect* self, ImRect r);

		/// <summary>/// To be documented./// </summary>		public static void ImRectClipWithFull( ImRect* self,  ImRect r)
		{
			ImRectClipWithFullNative(self, r);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_Floor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectFloorNative(ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static void ImRectFloor( ImRect* self)
		{
			ImRectFloorNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_IsInverted")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImRectIsInvertedNative(ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static bool ImRectIsInverted( ImRect* self)
		{
			byte ret = ImRectIsInvertedNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImRect_ToVec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImRectToVec4Native(Vector4* pOut, ImRect* self);

		/// <summary>/// To be documented./// </summary>		public static void ImRectToVec4( Vector4* pOut,  ImRect* self)
		{
			ImRectToVec4Native(pOut, self);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImRectToVec4( Vector4* pOut,  ref ImRect self)
		{
			fixed (ImRect* pself = &self)
			{
				ImRectToVec4Native(pOut, (ImRect*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBitArrayGetStorageSizeInBytes")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong ImBitArrayGetStorageSizeInBytesNative(int bitcount);

		/// <summary>/// To be documented./// </summary>		public static ulong ImBitArrayGetStorageSizeInBytes( int bitcount)
		{
			ulong ret = ImBitArrayGetStorageSizeInBytesNative(bitcount);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBitArrayClearAllBits")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBitArrayClearAllBitsNative(uint* arr, int bitcount);

		/// <summary>/// To be documented./// </summary>		public static void ImBitArrayClearAllBits( uint* arr,  int bitcount)
		{
			ImBitArrayClearAllBitsNative(arr, bitcount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBitArrayTestBit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImBitArrayTestBitNative(uint* arr, int n);

		/// <summary>/// To be documented./// </summary>		public static bool ImBitArrayTestBit( uint* arr,  int n)
		{
			byte ret = ImBitArrayTestBitNative(arr, n);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBitArrayClearBit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBitArrayClearBitNative(uint* arr, int n);

		/// <summary>/// To be documented./// </summary>		public static void ImBitArrayClearBit( uint* arr,  int n)
		{
			ImBitArrayClearBitNative(arr, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBitArraySetBit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBitArraySetBitNative(uint* arr, int n);

		/// <summary>/// To be documented./// </summary>		public static void ImBitArraySetBit( uint* arr,  int n)
		{
			ImBitArraySetBitNative(arr, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImBitArraySetBitRange")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBitArraySetBitRangeNative(uint* arr, int n, int n2);

		/// <summary>/// To be documented./// </summary>		public static void ImBitArraySetBitRange( uint* arr,  int n,  int n2)
		{
			ImBitArraySetBitRangeNative(arr, n, n2);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImBitVector_Create")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBitVectorCreateNative(ImBitVector* self, int sz);

		/// <summary>/// To be documented./// </summary>		public static void ImBitVectorCreate( ImBitVector* self,  int sz)
		{
			ImBitVectorCreateNative(self, sz);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImBitVector_Clear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBitVectorClearNative(ImBitVector* self);

		/// <summary>/// To be documented./// </summary>		public static void ImBitVectorClear( ImBitVector* self)
		{
			ImBitVectorClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImBitVector_TestBit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImBitVectorTestBitNative(ImBitVector* self, int n);

		/// <summary>/// To be documented./// </summary>		public static bool ImBitVectorTestBit( ImBitVector* self,  int n)
		{
			byte ret = ImBitVectorTestBitNative(self, n);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImBitVector_SetBit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBitVectorSetBitNative(ImBitVector* self, int n);

		/// <summary>/// To be documented./// </summary>		public static void ImBitVectorSetBit( ImBitVector* self,  int n)
		{
			ImBitVectorSetBitNative(self, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImBitVector_ClearBit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImBitVectorClearBitNative(ImBitVector* self, int n);

		/// <summary>/// To be documented./// </summary>		public static void ImBitVectorClearBit( ImBitVector* self,  int n)
		{
			ImBitVectorClearBitNative(self, n);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextIndex_clear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiTextIndexClearNative(ImGuiTextIndex* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiTextIndexClear( ImGuiTextIndex* self)
		{
			ImGuiTextIndexClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextIndex_size")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImGuiTextIndexSizeNative(ImGuiTextIndex* self);

		/// <summary>/// To be documented./// </summary>		public static int ImGuiTextIndexSize( ImGuiTextIndex* self)
		{
			int ret = ImGuiTextIndexSizeNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextIndex_get_line_begin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImGuiTextIndexGetLineBeginNative(ImGuiTextIndex* self, byte* baseValue, int n);

		/// <summary>/// To be documented./// </summary>		public static byte* ImGuiTextIndexGetLineBegin( ImGuiTextIndex* self,  byte* baseValue,  int n)
		{
			byte* ret = ImGuiTextIndexGetLineBeginNative(self, baseValue, n);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImGuiTextIndexGetLineBeginS( ImGuiTextIndex* self,  byte* baseValue,  int n)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineBeginNative(self, baseValue, n));
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImGuiTextIndexGetLineBegin( ImGuiTextIndex* self,  ref byte baseValue,  int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = ImGuiTextIndexGetLineBeginNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImGuiTextIndexGetLineBeginS( ImGuiTextIndex* self,  ref byte baseValue,  int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineBeginNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImGuiTextIndexGetLineBegin( ImGuiTextIndex* self,  string baseValue,  int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiTextIndexGetLineBeginNative(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImGuiTextIndexGetLineBeginS( ImGuiTextIndex* self,  string baseValue,  int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineBeginNative(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextIndex_get_line_end")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* ImGuiTextIndexGetLineEndNative(ImGuiTextIndex* self, byte* baseValue, int n);

		/// <summary>/// To be documented./// </summary>		public static byte* ImGuiTextIndexGetLineEnd( ImGuiTextIndex* self,  byte* baseValue,  int n)
		{
			byte* ret = ImGuiTextIndexGetLineEndNative(self, baseValue, n);
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImGuiTextIndexGetLineEndS( ImGuiTextIndex* self,  byte* baseValue,  int n)
		{
			string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineEndNative(self, baseValue, n));
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImGuiTextIndexGetLineEnd( ImGuiTextIndex* self,  ref byte baseValue,  int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				byte* ret = ImGuiTextIndexGetLineEndNative(self, (byte*)pbaseValue, n);
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static string ImGuiTextIndexGetLineEndS( ImGuiTextIndex* self,  ref byte baseValue,  int n)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineEndNative(self, (byte*)pbaseValue, n));
				return ret;
			}
		}

		/// <summary>/// To be documented./// </summary>		public static byte* ImGuiTextIndexGetLineEnd( ImGuiTextIndex* self,  string baseValue,  int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImGuiTextIndexGetLineEndNative(self, pStr0, n);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>/// To be documented./// </summary>		public static string ImGuiTextIndexGetLineEndS( ImGuiTextIndex* self,  string baseValue,  int n)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImGuiTextIndexGetLineEndNative(self, pStr0, n));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextIndex_append")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiTextIndexAppendNative(ImGuiTextIndex* self, byte* baseValue, int oldSize, int newSize);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiTextIndexAppend( ImGuiTextIndex* self,  byte* baseValue,  int oldSize,  int newSize)
		{
			ImGuiTextIndexAppendNative(self, baseValue, oldSize, newSize);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImGuiTextIndexAppend( ImGuiTextIndex* self,  ref byte baseValue,  int oldSize,  int newSize)
		{
			fixed (byte* pbaseValue = &baseValue)
			{
				ImGuiTextIndexAppendNative(self, (byte*)pbaseValue, oldSize, newSize);
			}
		}

		/// <summary>/// To be documented./// </summary>		public static void ImGuiTextIndexAppend( ImGuiTextIndex* self,  string baseValue,  int oldSize,  int newSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (baseValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(baseValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextIndexAppendNative(self, pStr0, oldSize, newSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSharedData_ImDrawListSharedData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawListSharedData* ImDrawListSharedDataImDrawListSharedDataNative();

		/// <summary>/// To be documented./// </summary>		public static ImDrawListSharedData* ImDrawListSharedDataImDrawListSharedData()
		{
			ImDrawListSharedData* ret = ImDrawListSharedDataImDrawListSharedDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSharedData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImDrawListSharedDataDestroyNative(ImDrawListSharedData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImDrawListSharedDataDestroy( ImDrawListSharedData* self)
		{
			ImDrawListSharedDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSharedData_SetCircleTessellationMaxError")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImDrawListSharedDataSetCircleTessellationMaxErrorNative(ImDrawListSharedData* self, float maxError);

		/// <summary>/// To be documented./// </summary>		public static void ImDrawListSharedDataSetCircleTessellationMaxError( ImDrawListSharedData* self,  float maxError)
		{
			ImDrawListSharedDataSetCircleTessellationMaxErrorNative(self, maxError);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawDataBuilder_ImDrawDataBuilder")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawDataBuilder* ImDrawDataBuilderImDrawDataBuilderNative();

		/// <summary>/// To be documented./// </summary>		public static ImDrawDataBuilder* ImDrawDataBuilderImDrawDataBuilder()
		{
			ImDrawDataBuilder* ret = ImDrawDataBuilderImDrawDataBuilderNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawDataBuilder_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImDrawDataBuilderDestroyNative(ImDrawDataBuilder* self);

		/// <summary>/// To be documented./// </summary>		public static void ImDrawDataBuilderDestroy( ImDrawDataBuilder* self)
		{
			ImDrawDataBuilderDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiDataVarInfo_GetVarPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* ImGuiDataVarInfoGetVarPtrNative(ImGuiDataVarInfo* self, void* parent);

		/// <summary>/// To be documented./// </summary>		public static void* ImGuiDataVarInfoGetVarPtr( ImGuiDataVarInfo* self,  void* parent)
		{
			void* ret = ImGuiDataVarInfoGetVarPtrNative(self, parent);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStyleMod* ImGuiStyleModImGuiStyleModIntNative(int idx, int v);

		/// <summary>/// To be documented./// </summary>		public static ImGuiStyleMod* ImGuiStyleModImGuiStyleModInt( int idx,  int v)
		{
			ImGuiStyleMod* ret = ImGuiStyleModImGuiStyleModIntNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStyleMod_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiStyleModDestroyNative(ImGuiStyleMod* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiStyleModDestroy( ImGuiStyleMod* self)
		{
			ImGuiStyleModDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStyleMod* ImGuiStyleModImGuiStyleModFloatNative(int idx, float v);

		/// <summary>/// To be documented./// </summary>		public static ImGuiStyleMod* ImGuiStyleModImGuiStyleModFloat( int idx,  float v)
		{
			ImGuiStyleMod* ret = ImGuiStyleModImGuiStyleModFloatNative(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStyleMod* ImGuiStyleModImGuiStyleModVec2Native(int idx, Vector2 v);

		/// <summary>/// To be documented./// </summary>		public static ImGuiStyleMod* ImGuiStyleModImGuiStyleModVec2( int idx,  Vector2 v)
		{
			ImGuiStyleMod* ret = ImGuiStyleModImGuiStyleModVec2Native(idx, v);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiComboPreviewData_ImGuiComboPreviewData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiComboPreviewData* ImGuiComboPreviewDataImGuiComboPreviewDataNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiComboPreviewData* ImGuiComboPreviewDataImGuiComboPreviewData()
		{
			ImGuiComboPreviewData* ret = ImGuiComboPreviewDataImGuiComboPreviewDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiComboPreviewData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiComboPreviewDataDestroyNative(ImGuiComboPreviewData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiComboPreviewDataDestroy( ImGuiComboPreviewData* self)
		{
			ImGuiComboPreviewDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiMenuColumns_ImGuiMenuColumns")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiMenuColumns* ImGuiMenuColumnsImGuiMenuColumnsNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiMenuColumns* ImGuiMenuColumnsImGuiMenuColumns()
		{
			ImGuiMenuColumns* ret = ImGuiMenuColumnsImGuiMenuColumnsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiMenuColumns_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiMenuColumnsDestroyNative(ImGuiMenuColumns* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiMenuColumnsDestroy( ImGuiMenuColumns* self)
		{
			ImGuiMenuColumnsDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiMenuColumns_Update")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiMenuColumnsUpdateNative(ImGuiMenuColumns* self, float spacing, byte windowReappearing);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiMenuColumnsUpdate( ImGuiMenuColumns* self,  float spacing,  bool windowReappearing)
		{
			ImGuiMenuColumnsUpdateNative(self, spacing, windowReappearing ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiMenuColumns_DeclColumns")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float ImGuiMenuColumnsDeclColumnsNative(ImGuiMenuColumns* self, float wIcon, float wLabel, float wShortcut, float wMark);

		/// <summary>/// To be documented./// </summary>		public static float ImGuiMenuColumnsDeclColumns( ImGuiMenuColumns* self,  float wIcon,  float wLabel,  float wShortcut,  float wMark)
		{
			float ret = ImGuiMenuColumnsDeclColumnsNative(self, wIcon, wLabel, wShortcut, wMark);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiMenuColumns_CalcNextTotalWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiMenuColumnsCalcNextTotalWidthNative(ImGuiMenuColumns* self, byte updateOffsets);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiMenuColumnsCalcNextTotalWidth( ImGuiMenuColumns* self,  bool updateOffsets)
		{
			ImGuiMenuColumnsCalcNextTotalWidthNative(self, updateOffsets ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiInputTextDeactivatedState* ImGuiInputTextDeactivatedStateImGuiInputTextDeactivatedStateNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiInputTextDeactivatedState* ImGuiInputTextDeactivatedStateImGuiInputTextDeactivatedState()
		{
			ImGuiInputTextDeactivatedState* ret = ImGuiInputTextDeactivatedStateImGuiInputTextDeactivatedStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextDeactivatedState_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextDeactivatedStateDestroyNative(ImGuiInputTextDeactivatedState* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextDeactivatedStateDestroy( ImGuiInputTextDeactivatedState* self)
		{
			ImGuiInputTextDeactivatedStateDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextDeactivatedState_ClearFreeMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextDeactivatedStateClearFreeMemoryNative(ImGuiInputTextDeactivatedState* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextDeactivatedStateClearFreeMemory( ImGuiInputTextDeactivatedState* self)
		{
			ImGuiInputTextDeactivatedStateClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_ImGuiInputTextState")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiInputTextState* ImGuiInputTextStateImGuiInputTextStateNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiInputTextState* ImGuiInputTextStateImGuiInputTextState()
		{
			ImGuiInputTextState* ret = ImGuiInputTextStateImGuiInputTextStateNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextStateDestroyNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextStateDestroy( ImGuiInputTextState* self)
		{
			ImGuiInputTextStateDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_ClearText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextStateClearTextNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextStateClearText( ImGuiInputTextState* self)
		{
			ImGuiInputTextStateClearTextNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_ClearFreeMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextStateClearFreeMemoryNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextStateClearFreeMemory( ImGuiInputTextState* self)
		{
			ImGuiInputTextStateClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_GetUndoAvailCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImGuiInputTextStateGetUndoAvailCountNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static int ImGuiInputTextStateGetUndoAvailCount( ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetUndoAvailCountNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_GetRedoAvailCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImGuiInputTextStateGetRedoAvailCountNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static int ImGuiInputTextStateGetRedoAvailCount( ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetRedoAvailCountNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_OnKeyPressed")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextStateOnKeyPressedNative(ImGuiInputTextState* self, int key);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextStateOnKeyPressed( ImGuiInputTextState* self,  int key)
		{
			ImGuiInputTextStateOnKeyPressedNative(self, key);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_CursorAnimReset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextStateCursorAnimResetNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextStateCursorAnimReset( ImGuiInputTextState* self)
		{
			ImGuiInputTextStateCursorAnimResetNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_CursorClamp")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextStateCursorClampNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextStateCursorClamp( ImGuiInputTextState* self)
		{
			ImGuiInputTextStateCursorClampNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_HasSelection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImGuiInputTextStateHasSelectionNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static bool ImGuiInputTextStateHasSelection( ImGuiInputTextState* self)
		{
			byte ret = ImGuiInputTextStateHasSelectionNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_ClearSelection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextStateClearSelectionNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextStateClearSelection( ImGuiInputTextState* self)
		{
			ImGuiInputTextStateClearSelectionNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_GetCursorPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImGuiInputTextStateGetCursorPosNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static int ImGuiInputTextStateGetCursorPos( ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetCursorPosNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_GetSelectionStart")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImGuiInputTextStateGetSelectionStartNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static int ImGuiInputTextStateGetSelectionStart( ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetSelectionStartNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_GetSelectionEnd")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int ImGuiInputTextStateGetSelectionEndNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static int ImGuiInputTextStateGetSelectionEnd( ImGuiInputTextState* self)
		{
			int ret = ImGuiInputTextStateGetSelectionEndNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextState_SelectAll")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputTextStateSelectAllNative(ImGuiInputTextState* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputTextStateSelectAll( ImGuiInputTextState* self)
		{
			ImGuiInputTextStateSelectAllNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPopupData_ImGuiPopupData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPopupData* ImGuiPopupDataImGuiPopupDataNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiPopupData* ImGuiPopupDataImGuiPopupData()
		{
			ImGuiPopupData* ret = ImGuiPopupDataImGuiPopupDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPopupData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiPopupDataDestroyNative(ImGuiPopupData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiPopupDataDestroy( ImGuiPopupData* self)
		{
			ImGuiPopupDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiNextWindowData_ImGuiNextWindowData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiNextWindowData* ImGuiNextWindowDataImGuiNextWindowDataNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiNextWindowData* ImGuiNextWindowDataImGuiNextWindowData()
		{
			ImGuiNextWindowData* ret = ImGuiNextWindowDataImGuiNextWindowDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiNextWindowData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiNextWindowDataDestroyNative(ImGuiNextWindowData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiNextWindowDataDestroy( ImGuiNextWindowData* self)
		{
			ImGuiNextWindowDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiNextWindowData_ClearFlags")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiNextWindowDataClearFlagsNative(ImGuiNextWindowData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiNextWindowDataClearFlags( ImGuiNextWindowData* self)
		{
			ImGuiNextWindowDataClearFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiNextItemData_ImGuiNextItemData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiNextItemData* ImGuiNextItemDataImGuiNextItemDataNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiNextItemData* ImGuiNextItemDataImGuiNextItemData()
		{
			ImGuiNextItemData* ret = ImGuiNextItemDataImGuiNextItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiNextItemData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiNextItemDataDestroyNative(ImGuiNextItemData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiNextItemDataDestroy( ImGuiNextItemData* self)
		{
			ImGuiNextItemDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiNextItemData_ClearFlags")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiNextItemDataClearFlagsNative(ImGuiNextItemData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiNextItemDataClearFlags( ImGuiNextItemData* self)
		{
			ImGuiNextItemDataClearFlagsNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiLastItemData_ImGuiLastItemData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiLastItemData* ImGuiLastItemDataImGuiLastItemDataNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiLastItemData* ImGuiLastItemDataImGuiLastItemData()
		{
			ImGuiLastItemData* ret = ImGuiLastItemDataImGuiLastItemDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiLastItemData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiLastItemDataDestroyNative(ImGuiLastItemData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiLastItemDataDestroy( ImGuiLastItemData* self)
		{
			ImGuiLastItemDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStackSizes_ImGuiStackSizes")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStackSizes* ImGuiStackSizesImGuiStackSizesNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiStackSizes* ImGuiStackSizesImGuiStackSizes()
		{
			ImGuiStackSizes* ret = ImGuiStackSizesImGuiStackSizesNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStackSizes_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiStackSizesDestroyNative(ImGuiStackSizes* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiStackSizesDestroy( ImGuiStackSizes* self)
		{
			ImGuiStackSizesDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStackSizes_SetToContextState")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiStackSizesSetToContextStateNative(ImGuiStackSizes* self, ImGuiContext* ctx);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiStackSizesSetToContextState( ImGuiStackSizes* self,  ImGuiContext* ctx)
		{
			ImGuiStackSizesSetToContextStateNative(self, ctx);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImGuiStackSizesSetToContextState( ImGuiStackSizes* self,  ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiStackSizesSetToContextStateNative(self, (ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStackSizes_CompareWithContextState")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiStackSizesCompareWithContextStateNative(ImGuiStackSizes* self, ImGuiContext* ctx);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiStackSizesCompareWithContextState( ImGuiStackSizes* self,  ImGuiContext* ctx)
		{
			ImGuiStackSizesCompareWithContextStateNative(self, ctx);
		}

		/// <summary>/// To be documented./// </summary>		public static void ImGuiStackSizesCompareWithContextState( ImGuiStackSizes* self,  ref ImGuiContext ctx)
		{
			fixed (ImGuiContext* pctx = &ctx)
			{
				ImGuiStackSizesCompareWithContextStateNative(self, (ImGuiContext*)pctx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPtrOrIndex* ImGuiPtrOrIndexImGuiPtrOrIndexPtrNative(void* ptr);

		/// <summary>/// To be documented./// </summary>		public static ImGuiPtrOrIndex* ImGuiPtrOrIndexImGuiPtrOrIndexPtr( void* ptr)
		{
			ImGuiPtrOrIndex* ret = ImGuiPtrOrIndexImGuiPtrOrIndexPtrNative(ptr);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPtrOrIndex_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiPtrOrIndexDestroyNative(ImGuiPtrOrIndex* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiPtrOrIndexDestroy( ImGuiPtrOrIndex* self)
		{
			ImGuiPtrOrIndexDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPtrOrIndex* ImGuiPtrOrIndexImGuiPtrOrIndexIntNative(int index);

		/// <summary>/// To be documented./// </summary>		public static ImGuiPtrOrIndex* ImGuiPtrOrIndexImGuiPtrOrIndexInt( int index)
		{
			ImGuiPtrOrIndex* ret = ImGuiPtrOrIndexImGuiPtrOrIndexIntNative(index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputEvent_ImGuiInputEvent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiInputEvent* ImGuiInputEventImGuiInputEventNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiInputEvent* ImGuiInputEventImGuiInputEvent()
		{
			ImGuiInputEvent* ret = ImGuiInputEventImGuiInputEventNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputEvent_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiInputEventDestroyNative(ImGuiInputEvent* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiInputEventDestroy( ImGuiInputEvent* self)
		{
			ImGuiInputEventDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiKeyRoutingData_ImGuiKeyRoutingData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKeyRoutingData* ImGuiKeyRoutingDataImGuiKeyRoutingDataNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiKeyRoutingData* ImGuiKeyRoutingDataImGuiKeyRoutingData()
		{
			ImGuiKeyRoutingData* ret = ImGuiKeyRoutingDataImGuiKeyRoutingDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiKeyRoutingData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiKeyRoutingDataDestroyNative(ImGuiKeyRoutingData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiKeyRoutingDataDestroy( ImGuiKeyRoutingData* self)
		{
			ImGuiKeyRoutingDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiKeyRoutingTable_ImGuiKeyRoutingTable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKeyRoutingTable* ImGuiKeyRoutingTableImGuiKeyRoutingTableNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiKeyRoutingTable* ImGuiKeyRoutingTableImGuiKeyRoutingTable()
		{
			ImGuiKeyRoutingTable* ret = ImGuiKeyRoutingTableImGuiKeyRoutingTableNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiKeyRoutingTable_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiKeyRoutingTableDestroyNative(ImGuiKeyRoutingTable* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiKeyRoutingTableDestroy( ImGuiKeyRoutingTable* self)
		{
			ImGuiKeyRoutingTableDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiKeyRoutingTable_Clear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiKeyRoutingTableClearNative(ImGuiKeyRoutingTable* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiKeyRoutingTableClear( ImGuiKeyRoutingTable* self)
		{
			ImGuiKeyRoutingTableClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiKeyOwnerData_ImGuiKeyOwnerData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiKeyOwnerData* ImGuiKeyOwnerDataImGuiKeyOwnerDataNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiKeyOwnerData* ImGuiKeyOwnerDataImGuiKeyOwnerData()
		{
			ImGuiKeyOwnerData* ret = ImGuiKeyOwnerDataImGuiKeyOwnerDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiKeyOwnerData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiKeyOwnerDataDestroyNative(ImGuiKeyOwnerData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiKeyOwnerDataDestroy( ImGuiKeyOwnerData* self)
		{
			ImGuiKeyOwnerDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipperRange_FromIndices")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiListClipperRange ImGuiListClipperRangeFromIndicesNative(int min, int max);

		/// <summary>/// To be documented./// </summary>		public static ImGuiListClipperRange ImGuiListClipperRangeFromIndices( int min,  int max)
		{
			ImGuiListClipperRange ret = ImGuiListClipperRangeFromIndicesNative(min, max);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipperRange_FromPositions")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiListClipperRange ImGuiListClipperRangeFromPositionsNative(float y1, float y2, int offMin, int offMax);

		/// <summary>/// To be documented./// </summary>		public static ImGuiListClipperRange ImGuiListClipperRangeFromPositions( float y1,  float y2,  int offMin,  int offMax)
		{
			ImGuiListClipperRange ret = ImGuiListClipperRangeFromPositionsNative(y1, y2, offMin, offMax);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipperData_ImGuiListClipperData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiListClipperData* ImGuiListClipperDataImGuiListClipperDataNative();

		/// <summary>/// To be documented./// </summary>		public static ImGuiListClipperData* ImGuiListClipperDataImGuiListClipperData()
		{
			ImGuiListClipperData* ret = ImGuiListClipperDataImGuiListClipperDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipperData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiListClipperDataDestroyNative(ImGuiListClipperData* self);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiListClipperDataDestroy( ImGuiListClipperData* self)
		{
			ImGuiListClipperDataDestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipperData_Reset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImGuiListClipperDataResetNative(ImGuiListClipperData* self, ImGuiListClipper* clipper);

		/// <summary>/// To be documented./// </summary>		public static void ImGuiListClipperDataReset( ImGuiListClipperData* self,  ImGuiListClipper* clipper)
		{
			ImGuiListClipperDataResetNative(self, clipper);
		}
	}
}
