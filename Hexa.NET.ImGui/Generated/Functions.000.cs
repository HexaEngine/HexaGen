// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{
		internal const string LibName = "cimgui";

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec2_ImVec2_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector2* ImVec2Native();

		public static Vector2* ImVec2()
		{
			Vector2* ret = ImVec2Native();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec2_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(Vector2* self);

		public static void Destroy( Vector2* self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec2_ImVec2_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector2* ImVec2Native(float X, float Y);

		public static Vector2* ImVec2( float X,  float Y)
		{
			Vector2* ret = ImVec2Native(X, Y);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec4_ImVec4_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector4* ImVec4Native();

		public static Vector4* ImVec4()
		{
			Vector4* ret = ImVec4Native();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec4_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(Vector4* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImVec4_ImVec4_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector4* ImVec4Native(float X, float Y, float Z, float W);

		public static Vector4* ImVec4( float X,  float Y,  float Z,  float W)
		{
			Vector4* ret = ImVec4Native(X, Y, Z, W);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCreateContext")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiContext* CreateContextNative(ImFontAtlas* sharedFontAtlas);

		public static ImGuiContext* CreateContext( ImFontAtlas* sharedFontAtlas)
		{
			ImGuiContext* ret = CreateContextNative(sharedFontAtlas);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDestroyContext")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyContextNative(ImGuiContext* ctx);

		public static void DestroyContext( ImGuiContext* ctx)
		{
			DestroyContextNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetCurrentContext")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiContext* GetCurrentContextNative();

		public static ImGuiContext* GetCurrentContext()
		{
			ImGuiContext* ret = GetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetCurrentContext")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCurrentContextNative(ImGuiContext* ctx);

		public static void SetCurrentContext( ImGuiContext* ctx)
		{
			SetCurrentContextNative(ctx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetIO")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiIO* GetIONative();

		public static ImGuiIO* GetIO()
		{
			ImGuiIO* ret = GetIONative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetStyle")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStyle* GetStyleNative();

		public static ImGuiStyle* GetStyle()
		{
			ImGuiStyle* ret = GetStyleNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igNewFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NewFrameNative();

		public static void NewFrame()
		{
			NewFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndFrameNative();

		public static void EndFrame()
		{
			EndFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igRender")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderNative();

		public static void Render()
		{
			RenderNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetDrawData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawData* GetDrawDataNative();

		public static ImDrawData* GetDrawData()
		{
			ImDrawData* ret = GetDrawDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igShowDemoWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowDemoWindowNative(byte* pOpen);

		public static void ShowDemoWindow( byte* pOpen)
		{
			ShowDemoWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igShowMetricsWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowMetricsWindowNative(byte* pOpen);

		public static void ShowMetricsWindow( byte* pOpen)
		{
			ShowMetricsWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igShowDebugLogWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowDebugLogWindowNative(byte* pOpen);

		public static void ShowDebugLogWindow( byte* pOpen)
		{
			ShowDebugLogWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igShowIDStackToolWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowIDStackToolWindowNative(byte* pOpen);

		public static void ShowIDStackToolWindow( byte* pOpen)
		{
			ShowIDStackToolWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igShowAboutWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowAboutWindowNative(byte* pOpen);

		public static void ShowAboutWindow( byte* pOpen)
		{
			ShowAboutWindowNative(pOpen);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igShowStyleEditor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowStyleEditorNative(ImGuiStyle* reference);

		public static void ShowStyleEditor( ImGuiStyle* reference)
		{
			ShowStyleEditorNative(reference);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igShowStyleSelector")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ShowStyleSelectorNative(byte* label);

		public static bool ShowStyleSelector( byte* label)
		{
			byte ret = ShowStyleSelectorNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igShowFontSelector")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowFontSelectorNative(byte* label);

		public static void ShowFontSelector( byte* label)
		{
			ShowFontSelectorNative(label);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igShowUserGuide")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ShowUserGuideNative();

		public static void ShowUserGuide()
		{
			ShowUserGuideNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetVersion")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* GetVersionNative();

		public static byte* GetVersion()
		{
			byte* ret = GetVersionNative();
			return ret;
		}

		public static string GetVersionS()
		{
			string ret = Utils.DecodeStringUTF8(GetVersionNative());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igStyleColorsDark")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void StyleColorsDarkNative(ImGuiStyle* dst);

		public static void StyleColorsDark( ImGuiStyle* dst)
		{
			StyleColorsDarkNative(dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igStyleColorsLight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void StyleColorsLightNative(ImGuiStyle* dst);

		public static void StyleColorsLight( ImGuiStyle* dst)
		{
			StyleColorsLightNative(dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igStyleColorsClassic")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void StyleColorsClassicNative(ImGuiStyle* dst);

		public static void StyleColorsClassic( ImGuiStyle* dst)
		{
			StyleColorsClassicNative(dst);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBegin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginNative(byte* name, byte* pOpen, int flags);

		public static bool Begin( byte* name,  byte* pOpen,  int flags)
		{
			byte ret = BeginNative(name, pOpen, flags);
			return ret != 0;
		}

		public static bool Begin( byte* name,  byte* pOpen)
		{
			byte ret = BeginNative(name, pOpen, (int)(0));
			return ret != 0;
		}

		public static bool Begin( byte* name)
		{
			byte ret = BeginNative(name, (byte*)(default), (int)(0));
			return ret != 0;
		}

		public static bool Begin( byte* name,  int flags)
		{
			byte ret = BeginNative(name, (byte*)(default), flags);
			return ret != 0;
		}

		public static bool Begin( byte* name,  ref byte pOpen,  int flags)
		{
			fixed (byte* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (byte*)ppOpen, flags);
				return ret != 0;
			}
		}

		public static bool Begin( byte* name,  ref byte pOpen)
		{
			fixed (byte* ppOpen = &pOpen)
			{
				byte ret = BeginNative(name, (byte*)ppOpen, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEnd")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndNative();

		public static void End()
		{
			EndNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginChild_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginChildNative(byte* strId, Vector2 size, byte border, int windowFlags);

		public static bool BeginChild( byte* strId,  Vector2 size,  bool border,  int windowFlags)
		{
			byte ret = BeginChildNative(strId, size, border ? (byte)1 : (byte)0, windowFlags);
			return ret != 0;
		}

		public static bool BeginChild( byte* strId,  Vector2 size,  bool border)
		{
			byte ret = BeginChildNative(strId, size, border ? (byte)1 : (byte)0, (int)(0));
			return ret != 0;
		}

		public static bool BeginChild( byte* strId,  Vector2 size)
		{
			byte ret = BeginChildNative(strId, size, (byte)(0), (int)(0));
			return ret != 0;
		}

		public static bool BeginChild( byte* strId)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (byte)(0), (int)(0));
			return ret != 0;
		}

		public static bool BeginChild( byte* strId,  bool border)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, (int)(0));
			return ret != 0;
		}

		public static bool BeginChild( byte* strId,  Vector2 size,  int windowFlags)
		{
			byte ret = BeginChildNative(strId, size, (byte)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild( byte* strId,  int windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), (byte)(0), windowFlags);
			return ret != 0;
		}

		public static bool BeginChild( byte* strId,  bool border,  int windowFlags)
		{
			byte ret = BeginChildNative(strId, (Vector2)(new Vector2(0,0)), border ? (byte)1 : (byte)0, windowFlags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginChild_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginChildNative(uint id, Vector2 size, byte border, int windowFlags);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndChild")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndChildNative();

		public static void EndChild()
		{
			EndChildNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsWindowAppearing")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowAppearingNative();

		public static bool IsWindowAppearing()
		{
			byte ret = IsWindowAppearingNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsWindowCollapsed")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowCollapsedNative();

		public static bool IsWindowCollapsed()
		{
			byte ret = IsWindowCollapsedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsWindowFocused")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowFocusedNative(int flags);

		public static bool IsWindowFocused( int flags)
		{
			byte ret = IsWindowFocusedNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsWindowHovered")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowHoveredNative(int flags);

		public static bool IsWindowHovered( int flags)
		{
			byte ret = IsWindowHoveredNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowDrawList")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawList* GetWindowDrawListNative();

		public static ImDrawList* GetWindowDrawList()
		{
			ImDrawList* ret = GetWindowDrawListNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowDpiScale")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetWindowDpiScaleNative();

		public static float GetWindowDpiScale()
		{
			float ret = GetWindowDpiScaleNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetWindowPosNative(Vector2* pOut);

		public static void GetWindowPos( Vector2* pOut)
		{
			GetWindowPosNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetWindowSizeNative(Vector2* pOut);

		public static void GetWindowSize( Vector2* pOut)
		{
			GetWindowSizeNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetWindowWidthNative();

		public static float GetWindowWidth()
		{
			float ret = GetWindowWidthNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowHeight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetWindowHeightNative();

		public static float GetWindowHeight()
		{
			float ret = GetWindowHeightNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiViewport* GetWindowViewportNative();

		public static ImGuiViewport* GetWindowViewport()
		{
			ImGuiViewport* ret = GetWindowViewportNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowPosNative(Vector2 pos, int cond, Vector2 pivot);

		public static void SetNextWindowPos( Vector2 pos,  int cond,  Vector2 pivot)
		{
			SetNextWindowPosNative(pos, cond, pivot);
		}

		public static void SetNextWindowPos( Vector2 pos,  int cond)
		{
			SetNextWindowPosNative(pos, cond, (Vector2)(new Vector2(0,0)));
		}

		public static void SetNextWindowPos( Vector2 pos)
		{
			SetNextWindowPosNative(pos, (int)(0), (Vector2)(new Vector2(0,0)));
		}

		public static void SetNextWindowPos( Vector2 pos,  Vector2 pivot)
		{
			SetNextWindowPosNative(pos, (int)(0), pivot);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowSizeNative(Vector2 size, int cond);

		public static void SetNextWindowSize( Vector2 size,  int cond)
		{
			SetNextWindowSizeNative(size, cond);
		}

		public static void SetNextWindowSize( Vector2 size)
		{
			SetNextWindowSizeNative(size, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowSizeConstraints")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowSizeConstraintsNative(Vector2 sizeMin, Vector2 sizeMax, ImGuiSizeCallback customCallback, void* customCallbackData);

		public static void SetNextWindowSizeConstraints( Vector2 sizeMin,  Vector2 sizeMax,  ImGuiSizeCallback customCallback,  void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, customCallbackData);
		}

		public static void SetNextWindowSizeConstraints( Vector2 sizeMin,  Vector2 sizeMax,  ImGuiSizeCallback customCallback)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, customCallback, (void*)(default));
		}

		public static void SetNextWindowSizeConstraints( Vector2 sizeMin,  Vector2 sizeMax)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), (void*)(default));
		}

		public static void SetNextWindowSizeConstraints( Vector2 sizeMin,  Vector2 sizeMax,  void* customCallbackData)
		{
			SetNextWindowSizeConstraintsNative(sizeMin, sizeMax, (ImGuiSizeCallback)(default), customCallbackData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowContentSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowContentSizeNative(Vector2 size);

		public static void SetNextWindowContentSize( Vector2 size)
		{
			SetNextWindowContentSizeNative(size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowCollapsed")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowCollapsedNative(byte collapsed, int cond);

		public static void SetNextWindowCollapsed( bool collapsed,  int cond)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetNextWindowCollapsed( bool collapsed)
		{
			SetNextWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowFocus")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowFocusNative();

		public static void SetNextWindowFocus()
		{
			SetNextWindowFocusNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowScroll")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowScrollNative(Vector2 scroll);

		public static void SetNextWindowScroll( Vector2 scroll)
		{
			SetNextWindowScrollNative(scroll);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowBgAlpha")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowBgAlphaNative(float alpha);

		public static void SetNextWindowBgAlpha( float alpha)
		{
			SetNextWindowBgAlphaNative(alpha);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowViewportNative(uint viewportId);

		public static void SetNextWindowViewport( uint viewportId)
		{
			SetNextWindowViewportNative(viewportId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetWindowPos_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowPosNative(Vector2 pos, int cond);

		public static void SetWindowPos( Vector2 pos,  int cond)
		{
			SetWindowPosNative(pos, cond);
		}

		public static void SetWindowPos( Vector2 pos)
		{
			SetWindowPosNative(pos, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetWindowSize_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowSizeNative(Vector2 size, int cond);

		public static void SetWindowSize( Vector2 size,  int cond)
		{
			SetWindowSizeNative(size, cond);
		}

		public static void SetWindowSize( Vector2 size)
		{
			SetWindowSizeNative(size, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetWindowCollapsed_Bool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowCollapsedNative(byte collapsed, int cond);

		public static void SetWindowCollapsed( bool collapsed,  int cond)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsed( bool collapsed)
		{
			SetWindowCollapsedNative(collapsed ? (byte)1 : (byte)0, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetWindowFocus_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowFocusNative();

		public static void SetWindowFocus()
		{
			SetWindowFocusNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetWindowFontScale")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowFontScaleNative(float scale);

		public static void SetWindowFontScale( float scale)
		{
			SetWindowFontScaleNative(scale);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetWindowPos_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowPosNative(byte* name, Vector2 pos, int cond);

		public static void SetWindowPos( byte* name,  Vector2 pos,  int cond)
		{
			SetWindowPosNative(name, pos, cond);
		}

		public static void SetWindowPos( byte* name,  Vector2 pos)
		{
			SetWindowPosNative(name, pos, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetWindowSize_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowSizeNative(byte* name, Vector2 size, int cond);

		public static void SetWindowSize( byte* name,  Vector2 size,  int cond)
		{
			SetWindowSizeNative(name, size, cond);
		}

		public static void SetWindowSize( byte* name,  Vector2 size)
		{
			SetWindowSizeNative(name, size, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetWindowCollapsed_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowCollapsedNative(byte* name, byte collapsed, int cond);

		public static void SetWindowCollapsed( byte* name,  bool collapsed,  int cond)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, cond);
		}

		public static void SetWindowCollapsed( byte* name,  bool collapsed)
		{
			SetWindowCollapsedNative(name, collapsed ? (byte)1 : (byte)0, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetWindowFocus_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetWindowFocusNative(byte* name);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetContentRegionAvail")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetContentRegionAvailNative(Vector2* pOut);

		public static void GetContentRegionAvail( Vector2* pOut)
		{
			GetContentRegionAvailNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetContentRegionMax")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetContentRegionMaxNative(Vector2* pOut);

		public static void GetContentRegionMax( Vector2* pOut)
		{
			GetContentRegionMaxNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowContentRegionMin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetWindowContentRegionMinNative(Vector2* pOut);

		public static void GetWindowContentRegionMin( Vector2* pOut)
		{
			GetWindowContentRegionMinNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowContentRegionMax")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetWindowContentRegionMaxNative(Vector2* pOut);

		public static void GetWindowContentRegionMax( Vector2* pOut)
		{
			GetWindowContentRegionMaxNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetScrollX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetScrollXNative();

		public static float GetScrollX()
		{
			float ret = GetScrollXNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetScrollY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetScrollYNative();

		public static float GetScrollY()
		{
			float ret = GetScrollYNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetScrollX_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollXNative(float scrollX);

		public static void SetScrollX( float scrollX)
		{
			SetScrollXNative(scrollX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetScrollY_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollYNative(float scrollY);

		public static void SetScrollY( float scrollY)
		{
			SetScrollYNative(scrollY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetScrollMaxX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetScrollMaxXNative();

		public static float GetScrollMaxX()
		{
			float ret = GetScrollMaxXNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetScrollMaxY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetScrollMaxYNative();

		public static float GetScrollMaxY()
		{
			float ret = GetScrollMaxYNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetScrollHereX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollHereXNative(float centerXRatio);

		public static void SetScrollHereX( float centerXRatio)
		{
			SetScrollHereXNative(centerXRatio);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetScrollHereY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollHereYNative(float centerYRatio);

		public static void SetScrollHereY( float centerYRatio)
		{
			SetScrollHereYNative(centerYRatio);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetScrollFromPosX_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollFromPosXNative(float localX, float centerXRatio);

		public static void SetScrollFromPosX( float localX,  float centerXRatio)
		{
			SetScrollFromPosXNative(localX, centerXRatio);
		}

		public static void SetScrollFromPosX( float localX)
		{
			SetScrollFromPosXNative(localX, (float)(0.5f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetScrollFromPosY_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetScrollFromPosYNative(float localY, float centerYRatio);

		public static void SetScrollFromPosY( float localY,  float centerYRatio)
		{
			SetScrollFromPosYNative(localY, centerYRatio);
		}

		public static void SetScrollFromPosY( float localY)
		{
			SetScrollFromPosYNative(localY, (float)(0.5f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushFont")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushFontNative(ImFont* font);

		public static void PushFont( ImFont* font)
		{
			PushFontNative(font);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPopFont")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopFontNative();

		public static void PopFont()
		{
			PopFontNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushStyleColor_U32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushStyleColorNative(int idx, uint col);

		public static void PushStyleColor( int idx,  uint col)
		{
			PushStyleColorNative(idx, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushStyleColor_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushStyleColorNative(int idx, Vector4 col);

		public static void PushStyleColor( int idx,  Vector4 col)
		{
			PushStyleColorNative(idx, col);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPopStyleColor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopStyleColorNative(int count);

		public static void PopStyleColor( int count)
		{
			PopStyleColorNative(count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushStyleVar_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushStyleVarNative(int idx, float val);

		public static void PushStyleVar( int idx,  float val)
		{
			PushStyleVarNative(idx, val);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushStyleVar_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushStyleVarNative(int idx, Vector2 val);

		public static void PushStyleVar( int idx,  Vector2 val)
		{
			PushStyleVarNative(idx, val);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPopStyleVar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopStyleVarNative(int count);

		public static void PopStyleVar( int count)
		{
			PopStyleVarNative(count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushTabStop")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushTabStopNative(byte tabStop);

		public static void PushTabStop( bool tabStop)
		{
			PushTabStopNative(tabStop ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPopTabStop")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopTabStopNative();

		public static void PopTabStop()
		{
			PopTabStopNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushButtonRepeat")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushButtonRepeatNative(byte repeat);

		public static void PushButtonRepeat( bool repeat)
		{
			PushButtonRepeatNative(repeat ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPopButtonRepeat")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopButtonRepeatNative();

		public static void PopButtonRepeat()
		{
			PopButtonRepeatNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushItemWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushItemWidthNative(float itemWidth);

		public static void PushItemWidth( float itemWidth)
		{
			PushItemWidthNative(itemWidth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPopItemWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopItemWidthNative();

		public static void PopItemWidth()
		{
			PopItemWidthNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextItemWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextItemWidthNative(float itemWidth);

		public static void SetNextItemWidth( float itemWidth)
		{
			SetNextItemWidthNative(itemWidth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCalcItemWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float CalcItemWidthNative();

		public static float CalcItemWidth()
		{
			float ret = CalcItemWidthNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushTextWrapPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushTextWrapPosNative(float wrapLocalPosX);

		public static void PushTextWrapPos( float wrapLocalPosX)
		{
			PushTextWrapPosNative(wrapLocalPosX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPopTextWrapPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopTextWrapPosNative();

		public static void PopTextWrapPos()
		{
			PopTextWrapPosNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetFont")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImFont* GetFontNative();

		public static ImFont* GetFont()
		{
			ImFont* ret = GetFontNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetFontSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetFontSizeNative();

		public static float GetFontSize()
		{
			float ret = GetFontSizeNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetFontTexUvWhitePixel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetFontTexUvWhitePixelNative(Vector2* pOut);

		public static void GetFontTexUvWhitePixel( Vector2* pOut)
		{
			GetFontTexUvWhitePixelNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetColorU32_Col")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetColorU32Native(int idx, float alphaMul);

		public static uint GetColorU32( int idx,  float alphaMul)
		{
			uint ret = GetColorU32Native(idx, alphaMul);
			return ret;
		}

		public static uint GetColorU32( int idx)
		{
			uint ret = GetColorU32Native(idx, (float)(1.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetColorU32_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetColorU32Native(Vector4 col);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetColorU32_U32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetColorU32Native(uint col);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetStyleColorVec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial Vector4* GetStyleColorVec4Native(int idx);

		public static Vector4* GetStyleColorVec4( int idx)
		{
			Vector4* ret = GetStyleColorVec4Native(idx);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetCursorScreenPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetCursorScreenPosNative(Vector2* pOut);

		public static void GetCursorScreenPos( Vector2* pOut)
		{
			GetCursorScreenPosNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetCursorScreenPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCursorScreenPosNative(Vector2 pos);

		public static void SetCursorScreenPos( Vector2 pos)
		{
			SetCursorScreenPosNative(pos);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetCursorPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetCursorPosNative(Vector2* pOut);

		public static void GetCursorPos( Vector2* pOut)
		{
			GetCursorPosNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetCursorPosX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetCursorPosXNative();

		public static float GetCursorPosX()
		{
			float ret = GetCursorPosXNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetCursorPosY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetCursorPosYNative();

		public static float GetCursorPosY()
		{
			float ret = GetCursorPosYNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetCursorPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCursorPosNative(Vector2 localPos);

		public static void SetCursorPos( Vector2 localPos)
		{
			SetCursorPosNative(localPos);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetCursorPosX")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCursorPosXNative(float localX);

		public static void SetCursorPosX( float localX)
		{
			SetCursorPosXNative(localX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetCursorPosY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCursorPosYNative(float localY);

		public static void SetCursorPosY( float localY)
		{
			SetCursorPosYNative(localY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetCursorStartPos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetCursorStartPosNative(Vector2* pOut);

		public static void GetCursorStartPos( Vector2* pOut)
		{
			GetCursorStartPosNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSeparator")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SeparatorNative();

		public static void Separator()
		{
			SeparatorNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSameLine")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SameLineNative(float offsetFromStartX, float spacing);

		public static void SameLine( float offsetFromStartX,  float spacing)
		{
			SameLineNative(offsetFromStartX, spacing);
		}

		public static void SameLine( float offsetFromStartX)
		{
			SameLineNative(offsetFromStartX, (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igNewLine")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NewLineNative();

		public static void NewLine()
		{
			NewLineNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSpacing")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SpacingNative();

		public static void Spacing()
		{
			SpacingNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDummy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DummyNative(Vector2 size);

		public static void Dummy( Vector2 size)
		{
			DummyNative(size);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIndent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void IndentNative(float indentW);

		public static void Indent( float indentW)
		{
			IndentNative(indentW);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igUnindent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void UnindentNative(float indentW);

		public static void Unindent( float indentW)
		{
			UnindentNative(indentW);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginGroup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BeginGroupNative();

		public static void BeginGroup()
		{
			BeginGroupNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndGroup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndGroupNative();

		public static void EndGroup()
		{
			EndGroupNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igAlignTextToFramePadding")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AlignTextToFramePaddingNative();

		public static void AlignTextToFramePadding()
		{
			AlignTextToFramePaddingNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetTextLineHeight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetTextLineHeightNative();

		public static float GetTextLineHeight()
		{
			float ret = GetTextLineHeightNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetTextLineHeightWithSpacing")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetTextLineHeightWithSpacingNative();

		public static float GetTextLineHeightWithSpacing()
		{
			float ret = GetTextLineHeightWithSpacingNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetFrameHeight")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetFrameHeightNative();

		public static float GetFrameHeight()
		{
			float ret = GetFrameHeightNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetFrameHeightWithSpacing")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetFrameHeightWithSpacingNative();

		public static float GetFrameHeightWithSpacing()
		{
			float ret = GetFrameHeightWithSpacingNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushID_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushIDNative(byte* strId);

		public static void PushID( byte* strId)
		{
			PushIDNative(strId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushID_StrStr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushIDNative(byte* strIdBegin, byte* strIdEnd);

		public static void PushID( byte* strIdBegin,  byte* strIdEnd)
		{
			PushIDNative(strIdBegin, strIdEnd);
		}

		public static void PushID( byte* strIdBegin,  ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				PushIDNative(strIdBegin, (byte*)pstrIdEnd);
			}
		}

		public static void PushID( byte* strIdBegin,  string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushID_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushIDNative(void* ptrId);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushID_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushIDNative(int intId);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPopID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopIDNative();

		public static void PopID()
		{
			PopIDNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetID_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetIDNative(byte* strId);

		public static uint GetID( byte* strId)
		{
			uint ret = GetIDNative(strId);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetID_StrStr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetIDNative(byte* strIdBegin, byte* strIdEnd);

		public static uint GetID( byte* strIdBegin,  byte* strIdEnd)
		{
			uint ret = GetIDNative(strIdBegin, strIdEnd);
			return ret;
		}

		public static uint GetID( byte* strIdBegin,  ref byte strIdEnd)
		{
			fixed (byte* pstrIdEnd = &strIdEnd)
			{
				uint ret = GetIDNative(strIdBegin, (byte*)pstrIdEnd);
				return ret;
			}
		}

		public static uint GetID( byte* strIdBegin,  string strIdEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strIdEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strIdEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strIdEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetIDNative(strIdBegin, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetID_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetIDNative(void* ptrId);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTextUnformatted")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextUnformattedNative(byte* text, byte* textEnd);

		public static void TextUnformatted( byte* text,  byte* textEnd)
		{
			TextUnformattedNative(text, textEnd);
		}

		public static void TextUnformatted( byte* text)
		{
			TextUnformattedNative(text, (byte*)(default));
		}

		public static void TextUnformatted( byte* text,  ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				TextUnformattedNative(text, (byte*)ptextEnd);
			}
		}

		public static void TextUnformatted( byte* text,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextUnformattedNative(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextNative(byte* fmt);

		public static void Text( byte* fmt)
		{
			TextNative(fmt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTextV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextVNative(byte* fmt, nuint args);

		public static void TextV( byte* fmt,  nuint args)
		{
			TextVNative(fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTextColored")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextColoredNative(Vector4 col, byte* fmt);

		public static void TextColored( Vector4 col,  byte* fmt)
		{
			TextColoredNative(col, fmt);
		}

		public static void TextColored( Vector4 col,  ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColoredNative(col, (byte*)pfmt);
			}
		}

		public static void TextColored( Vector4 col,  string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColoredNative(col, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTextColoredV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextColoredVNative(Vector4 col, byte* fmt, nuint args);

		public static void TextColoredV( Vector4 col,  byte* fmt,  nuint args)
		{
			TextColoredVNative(col, fmt, args);
		}

		public static void TextColoredV( Vector4 col,  ref byte fmt,  nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				TextColoredVNative(col, (byte*)pfmt, args);
			}
		}

		public static void TextColoredV( Vector4 col,  string fmt,  nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TextColoredVNative(col, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTextDisabled")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextDisabledNative(byte* fmt);

		public static void TextDisabled( byte* fmt)
		{
			TextDisabledNative(fmt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTextDisabledV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextDisabledVNative(byte* fmt, nuint args);

		public static void TextDisabledV( byte* fmt,  nuint args)
		{
			TextDisabledVNative(fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTextWrapped")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextWrappedNative(byte* fmt);

		public static void TextWrapped( byte* fmt)
		{
			TextWrappedNative(fmt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTextWrappedV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TextWrappedVNative(byte* fmt, nuint args);

		public static void TextWrappedV( byte* fmt,  nuint args)
		{
			TextWrappedVNative(fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLabelText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LabelTextNative(byte* label, byte* fmt);

		public static void LabelText( byte* label,  byte* fmt)
		{
			LabelTextNative(label, fmt);
		}

		public static void LabelText( byte* label,  ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelTextNative(label, (byte*)pfmt);
			}
		}

		public static void LabelText( byte* label,  string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextNative(label, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLabelTextV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LabelTextVNative(byte* label, byte* fmt, nuint args);

		public static void LabelTextV( byte* label,  byte* fmt,  nuint args)
		{
			LabelTextVNative(label, fmt, args);
		}

		public static void LabelTextV( byte* label,  ref byte fmt,  nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				LabelTextVNative(label, (byte*)pfmt, args);
			}
		}

		public static void LabelTextV( byte* label,  string fmt,  nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelTextVNative(label, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBulletText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BulletTextNative(byte* fmt);

		public static void BulletText( byte* fmt)
		{
			BulletTextNative(fmt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBulletTextV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BulletTextVNative(byte* fmt, nuint args);

		public static void BulletTextV( byte* fmt,  nuint args)
		{
			BulletTextVNative(fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSeparatorText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SeparatorTextNative(byte* label);

		public static void SeparatorText( byte* label)
		{
			SeparatorTextNative(label);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ButtonNative(byte* label, Vector2 size);

		public static bool Button( byte* label,  Vector2 size)
		{
			byte ret = ButtonNative(label, size);
			return ret != 0;
		}

		public static bool Button( byte* label)
		{
			byte ret = ButtonNative(label, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSmallButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte SmallButtonNative(byte* label);

		public static bool SmallButton( byte* label)
		{
			byte ret = SmallButtonNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igInvisibleButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte InvisibleButtonNative(byte* strId, Vector2 size, int flags);

		public static bool InvisibleButton( byte* strId,  Vector2 size,  int flags)
		{
			byte ret = InvisibleButtonNative(strId, size, flags);
			return ret != 0;
		}

		public static bool InvisibleButton( byte* strId,  Vector2 size)
		{
			byte ret = InvisibleButtonNative(strId, size, (int)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igArrowButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ArrowButtonNative(byte* strId, int dir);

		public static bool ArrowButton( byte* strId,  int dir)
		{
			byte ret = ArrowButtonNative(strId, dir);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCheckbox")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte CheckboxNative(byte* label, byte* v);

		public static bool Checkbox( byte* label,  byte* v)
		{
			byte ret = CheckboxNative(label, v);
			return ret != 0;
		}

		public static bool Checkbox( byte* label,  ref byte v)
		{
			fixed (byte* pv = &v)
			{
				byte ret = CheckboxNative(label, (byte*)pv);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCheckboxFlags_IntPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte CheckboxFlagsNative(byte* label, int* flags, int flagsValue);

		public static bool CheckboxFlags( byte* label,  int* flags,  int flagsValue)
		{
			byte ret = CheckboxFlagsNative(label, flags, flagsValue);
			return ret != 0;
		}

		public static bool CheckboxFlags( byte* label,  ref int flags,  int flagsValue)
		{
			fixed (int* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(label, (int*)pflags, flagsValue);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCheckboxFlags_UintPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte CheckboxFlagsNative(byte* label, uint* flags, uint flagsValue);

		public static bool CheckboxFlags( byte* label,  uint* flags,  uint flagsValue)
		{
			byte ret = CheckboxFlagsNative(label, flags, flagsValue);
			return ret != 0;
		}

		public static bool CheckboxFlags( byte* label,  ref uint flags,  uint flagsValue)
		{
			fixed (uint* pflags = &flags)
			{
				byte ret = CheckboxFlagsNative(label, (uint*)pflags, flagsValue);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igRadioButton_Bool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte RadioButtonNative(byte* label, byte active);

		public static bool RadioButton( byte* label,  bool active)
		{
			byte ret = RadioButtonNative(label, active ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igRadioButton_IntPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte RadioButtonNative(byte* label, int* v, int vButton);

		public static bool RadioButton( byte* label,  int* v,  int vButton)
		{
			byte ret = RadioButtonNative(label, v, vButton);
			return ret != 0;
		}

		public static bool RadioButton( byte* label,  ref int v,  int vButton)
		{
			fixed (int* pv = &v)
			{
				byte ret = RadioButtonNative(label, (int*)pv, vButton);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igProgressBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ProgressBarNative(float fraction, Vector2 sizeArg, byte* overlay);

		public static void ProgressBar( float fraction,  Vector2 sizeArg,  byte* overlay)
		{
			ProgressBarNative(fraction, sizeArg, overlay);
		}

		public static void ProgressBar( float fraction,  Vector2 sizeArg)
		{
			ProgressBarNative(fraction, sizeArg, (byte*)(default));
		}

		public static void ProgressBar( float fraction)
		{
			ProgressBarNative(fraction, (Vector2)(new Vector2(-float.MinValue,0)), (byte*)(default));
		}

		public static void ProgressBar( float fraction,  byte* overlay)
		{
			ProgressBarNative(fraction, (Vector2)(new Vector2(-float.MinValue,0)), overlay);
		}

		public static void ProgressBar( float fraction,  Vector2 sizeArg,  ref byte overlay)
		{
			fixed (byte* poverlay = &overlay)
			{
				ProgressBarNative(fraction, sizeArg, (byte*)poverlay);
			}
		}

		public static void ProgressBar( float fraction,  ref byte overlay)
		{
			fixed (byte* poverlay = &overlay)
			{
				ProgressBarNative(fraction, (Vector2)(new Vector2(-float.MinValue,0)), (byte*)poverlay);
			}
		}

		public static void ProgressBar( float fraction,  Vector2 sizeArg,  string overlay)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlay != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlay);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlay, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgressBarNative(fraction, sizeArg, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ProgressBar( float fraction,  string overlay)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlay != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlay);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlay, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgressBarNative(fraction, (Vector2)(new Vector2(-float.MinValue,0)), pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBullet")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BulletNative();

		public static void Bullet()
		{
			BulletNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImage")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ImageNative(ImTextureID userTextureId, Vector2 size, Vector2 uv0, Vector2 uv1, Vector4 tintCol, Vector4 borderCol);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igImageButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ImageButtonNative(byte* strId, ImTextureID userTextureId, Vector2 imageSize, Vector2 uv0, Vector2 uv1, Vector4 bgCol, Vector4 tintCol);

		public static bool ImageButton( byte* strId,  ImTextureID userTextureId,  Vector2 imageSize,  Vector2 uv0,  Vector2 uv1,  Vector4 bgCol,  Vector4 tintCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, uv1, bgCol, tintCol);
			return ret != 0;
		}

		public static bool ImageButton( byte* strId,  ImTextureID userTextureId,  Vector2 imageSize,  Vector2 uv0,  Vector2 uv1,  Vector4 bgCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, uv1, bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton( byte* strId,  ImTextureID userTextureId,  Vector2 imageSize,  Vector2 uv0,  Vector2 uv1)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, uv1, (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton( byte* strId,  ImTextureID userTextureId,  Vector2 imageSize,  Vector2 uv0)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton( byte* strId,  ImTextureID userTextureId,  Vector2 imageSize)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (Vector4)(new Vector4(0,0,0,0)), (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton( byte* strId,  ImTextureID userTextureId,  Vector2 imageSize,  Vector2 uv0,  Vector4 bgCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton( byte* strId,  ImTextureID userTextureId,  Vector2 imageSize,  Vector4 bgCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), bgCol, (Vector4)(new Vector4(1,1,1,1)));
			return ret != 0;
		}

		public static bool ImageButton( byte* strId,  ImTextureID userTextureId,  Vector2 imageSize,  Vector2 uv0,  Vector4 bgCol,  Vector4 tintCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, uv0, (Vector2)(new Vector2(1,1)), bgCol, tintCol);
			return ret != 0;
		}

		public static bool ImageButton( byte* strId,  ImTextureID userTextureId,  Vector2 imageSize,  Vector4 bgCol,  Vector4 tintCol)
		{
			byte ret = ImageButtonNative(strId, userTextureId, imageSize, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), bgCol, tintCol);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginCombo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginComboNative(byte* label, byte* previewValue, int flags);

		public static bool BeginCombo( byte* label,  byte* previewValue,  int flags)
		{
			byte ret = BeginComboNative(label, previewValue, flags);
			return ret != 0;
		}

		public static bool BeginCombo( byte* label,  byte* previewValue)
		{
			byte ret = BeginComboNative(label, previewValue, (int)(0));
			return ret != 0;
		}

		public static bool BeginCombo( byte* label,  ref byte previewValue,  int flags)
		{
			fixed (byte* ppreviewValue = &previewValue)
			{
				byte ret = BeginComboNative(label, (byte*)ppreviewValue, flags);
				return ret != 0;
			}
		}

		public static bool BeginCombo( byte* label,  ref byte previewValue)
		{
			fixed (byte* ppreviewValue = &previewValue)
			{
				byte ret = BeginComboNative(label, (byte*)ppreviewValue, (int)(0));
				return ret != 0;
			}
		}

		public static bool BeginCombo( byte* label,  string previewValue,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (previewValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginComboNative(label, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool BeginCombo( byte* label,  string previewValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (previewValue != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(previewValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(previewValue, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = BeginComboNative(label, pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndCombo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndComboNative();

		public static void EndCombo()
		{
			EndComboNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCombo_Str_arr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ComboNative(byte* label, int* currentItem, byte** items, int itemsCount, int popupMaxHeightInItems);

		public static bool Combo( byte* label,  int* currentItem,  byte** items,  int itemsCount,  int popupMaxHeightInItems)
		{
			byte ret = ComboNative(label, currentItem, items, itemsCount, popupMaxHeightInItems);
			return ret != 0;
		}

		public static bool Combo( byte* label,  int* currentItem,  byte** items,  int itemsCount)
		{
			byte ret = ComboNative(label, currentItem, items, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool Combo( byte* label,  ref int currentItem,  byte** items,  int itemsCount,  int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, items, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  ref int currentItem,  byte** items,  int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  int* currentItem,  string[] items,  int itemsCount,  int popupMaxHeightInItems)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ComboNative(label, currentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}

		public static bool Combo( byte* label,  int* currentItem,  string[] items,  int itemsCount)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ComboNative(label, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}

		public static bool Combo( byte* label,  ref int currentItem,  string[] items,  int itemsCount,  int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ComboNative(label, (int*)pcurrentItem, pStrArray0, itemsCount, popupMaxHeightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  ref int currentItem,  string[] items,  int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ComboNative(label, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCombo_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ComboNative(byte* label, int* currentItem, byte* itemsSeparatedByZeros, int popupMaxHeightInItems);

		public static bool Combo( byte* label,  int* currentItem,  byte* itemsSeparatedByZeros,  int popupMaxHeightInItems)
		{
			byte ret = ComboNative(label, currentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
			return ret != 0;
		}

		public static bool Combo( byte* label,  int* currentItem,  byte* itemsSeparatedByZeros)
		{
			byte ret = ComboNative(label, currentItem, itemsSeparatedByZeros, (int)(-1));
			return ret != 0;
		}

		public static bool Combo( byte* label,  ref int currentItem,  byte* itemsSeparatedByZeros,  int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, itemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  ref int currentItem,  byte* itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, itemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  int* currentItem,  ref byte itemsSeparatedByZeros,  int popupMaxHeightInItems)
		{
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				byte ret = ComboNative(label, currentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  int* currentItem,  ref byte itemsSeparatedByZeros)
		{
			fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
			{
				byte ret = ComboNative(label, currentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  int* currentItem,  string itemsSeparatedByZeros,  int popupMaxHeightInItems)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(label, currentItem, pStr0, popupMaxHeightInItems);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo( byte* label,  int* currentItem,  string itemsSeparatedByZeros)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (itemsSeparatedByZeros != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ComboNative(label, currentItem, pStr0, (int)(-1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Combo( byte* label,  ref int currentItem,  ref byte itemsSeparatedByZeros,  int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ComboNative(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, popupMaxHeightInItems);
					return ret != 0;
				}
			}
		}

		public static bool Combo( byte* label,  ref int currentItem,  ref byte itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				fixed (byte* pitemsSeparatedByZeros = &itemsSeparatedByZeros)
				{
					byte ret = ComboNative(label, (int*)pcurrentItem, (byte*)pitemsSeparatedByZeros, (int)(-1));
					return ret != 0;
				}
			}
		}

		public static bool Combo( byte* label,  ref int currentItem,  string itemsSeparatedByZeros,  int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ComboNative(label, (int*)pcurrentItem, pStr0, popupMaxHeightInItems);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  ref int currentItem,  string itemsSeparatedByZeros)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (itemsSeparatedByZeros != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(itemsSeparatedByZeros);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(itemsSeparatedByZeros, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ComboNative(label, (int*)pcurrentItem, pStr0, (int)(-1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCombo_FnStrPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ComboNative(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter, void* userData, int itemsCount, int popupMaxHeightInItems);

		public static bool Combo( byte* label,  int* currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter,  void* userData,  int itemsCount,  int popupMaxHeightInItems)
		{
			byte ret = ComboNative(label, currentItem, getter, userData, itemsCount, popupMaxHeightInItems);
			return ret != 0;
		}

		public static bool Combo( byte* label,  int* currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter,  void* userData,  int itemsCount)
		{
			byte ret = ComboNative(label, currentItem, getter, userData, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool Combo( byte* label,  ref int currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter,  void* userData,  int itemsCount,  int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, getter, userData, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  ref int currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter,  void* userData,  int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, getter, userData, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  int* currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, ref byte> getter,  void* userData,  int itemsCount,  int popupMaxHeightInItems)
		{
			byte ret = ComboNative(label, currentItem, getter, userData, itemsCount, popupMaxHeightInItems);
			return ret != 0;
		}

		public static bool Combo( byte* label,  int* currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, ref byte> getter,  void* userData,  int itemsCount)
		{
			byte ret = ComboNative(label, currentItem, getter, userData, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool Combo( byte* label,  ref int currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, ref byte> getter,  void* userData,  int itemsCount,  int popupMaxHeightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, getter, userData, itemsCount, popupMaxHeightInItems);
				return ret != 0;
			}
		}

		public static bool Combo( byte* label,  ref int currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, ref byte> getter,  void* userData,  int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ComboNative(label, (int*)pcurrentItem, getter, userData, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDragFloat")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte DragFloatNative(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, int flags);

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  byte* format,  int flags)
		{
			byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  byte* format)
		{
			byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax)
		{
			bool ret = DragFloat(label, v, vSpeed, vMin, vMax, (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin)
		{
			bool ret = DragFloat(label, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed)
		{
			bool ret = DragFloat(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat( byte* label,  float* v)
		{
			bool ret = DragFloat(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  byte* format)
		{
			byte ret = DragFloatNative(label, v, vSpeed, vMin, (float)(0.0f), format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  byte* format)
		{
			byte ret = DragFloatNative(label, v, vSpeed, (float)(0.0f), (float)(0.0f), format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  byte* format)
		{
			byte ret = DragFloatNative(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  int flags)
		{
			bool ret = DragFloat(label, v, vSpeed, vMin, vMax, (string)"%.3f", flags);
			return ret;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  int flags)
		{
			bool ret = DragFloat(label, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", flags);
			return ret;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  int flags)
		{
			bool ret = DragFloat(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
			return ret;
		}

		public static bool DragFloat( byte* label,  float* v,  int flags)
		{
			bool ret = DragFloat(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
			return ret;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  byte* format,  int flags)
		{
			byte ret = DragFloatNative(label, v, vSpeed, vMin, (float)(0.0f), format, flags);
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  byte* format,  int flags)
		{
			byte ret = DragFloatNative(label, v, vSpeed, (float)(0.0f), (float)(0.0f), format, flags);
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  byte* format,  int flags)
		{
			byte ret = DragFloatNative(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, flags);
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  byte* format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat( byte* label,  ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, (float)(0.0f), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  int flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  int flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  int flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  int flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  byte* format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, (float)(0.0f), format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  byte* format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  byte* format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloatNative(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, vSpeed, vMin, (float)(0.0f), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  float* v,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, vSpeed, vMin, (float)(0.0f), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  float* v,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloatNative(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, vSpeed, vMin, vMax, pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, vSpeed, vMin, (float)(0.0f), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, vSpeed, (float)(0.0f), (float)(0.0f), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  float vMin,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, vSpeed, vMin, (float)(0.0f), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  float vSpeed,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, vSpeed, (float)(0.0f), (float)(0.0f), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  float* v,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloatNative(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  ref byte format,  int flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  ref byte format,  int flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  ref byte format,  int flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  ref byte format,  int flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloatNative(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  string format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, (float)(0.0f), pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  string format)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  float vMin,  string format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, vMin, (float)(0.0f), pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  float vSpeed,  string format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat( byte* label,  ref float v,  string format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloatNative(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDragFloat2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte DragFloat2Native(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, int flags);

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  byte* format,  int flags)
		{
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  byte* format)
		{
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax)
		{
			bool ret = DragFloat2(label, v, vSpeed, vMin, vMax, (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin)
		{
			bool ret = DragFloat2(label, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed)
		{
			bool ret = DragFloat2(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat2( byte* label,  float* v)
		{
			bool ret = DragFloat2(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  byte* format)
		{
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, (float)(0.0f), format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  byte* format)
		{
			byte ret = DragFloat2Native(label, v, vSpeed, (float)(0.0f), (float)(0.0f), format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  byte* format)
		{
			byte ret = DragFloat2Native(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  int flags)
		{
			bool ret = DragFloat2(label, v, vSpeed, vMin, vMax, (string)"%.3f", flags);
			return ret;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  int flags)
		{
			bool ret = DragFloat2(label, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", flags);
			return ret;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  int flags)
		{
			bool ret = DragFloat2(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
			return ret;
		}

		public static bool DragFloat2( byte* label,  float* v,  int flags)
		{
			bool ret = DragFloat2(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
			return ret;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  byte* format,  int flags)
		{
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, (float)(0.0f), format, flags);
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  byte* format,  int flags)
		{
			byte ret = DragFloat2Native(label, v, vSpeed, (float)(0.0f), (float)(0.0f), format, flags);
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  byte* format,  int flags)
		{
			byte ret = DragFloat2Native(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, flags);
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  byte* format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, (float)(0.0f), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  byte* format)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  int flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  int flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  int flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  int flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  byte* format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, (float)(0.0f), format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  byte* format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  byte* format,  int flags)
		{
			fixed (float* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  float vMax,  byte* format,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  float vMax,  byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  float vMax)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, (float)(0.0f), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  byte* format)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  float vMax,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, vMax, (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				bool ret = DragFloat2(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  byte* format,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, (float)(0.0f), format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  byte* format,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  byte* format,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte ret = DragFloat2Native(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), format, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, vSpeed, vMin, (float)(0.0f), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  float* v,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, vSpeed, vMin, (float)(0.0f), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  float* v,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = DragFloat2Native(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, vMax, pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, (float)(0.0f), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, vSpeed, (float)(0.0f), (float)(0.0f), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  float vMin,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, vSpeed, vMin, (float)(0.0f), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  float vSpeed,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, vSpeed, (float)(0.0f), (float)(0.0f), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  float* v,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DragFloat2Native(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  ref byte format,  int flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  float vMax,  ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  float vMin,  ref byte format,  int flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, (float)(0.0f), (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  float vSpeed,  ref byte format,  int flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2( byte* label,  ref float v,  ref byte format,  int flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = DragFloat2Native(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  float vMax,  string format,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  float vMax,  string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, vMax, pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, (float)(0.0f), pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  string format)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  float vMin,  string format,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, vMin, (float)(0.0f), pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  float vSpeed,  string format,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, vSpeed, (float)(0.0f), (float)(0.0f), pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool DragFloat2( byte* label,  ref Vector2 v,  string format,  int flags)
		{
			fixed (Vector2* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = DragFloat2Native(label, (float*)pv, (float)(1.0f), (float)(0.0f), (float)(0.0f), pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDragFloat3")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte DragFloat3Native(byte* label, float* v, float vSpeed, float vMin, float vMax, byte* format, int flags);

		public static bool DragFloat3( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  byte* format,  int flags)
		{
			byte ret = DragFloat3Native(label, v, vSpeed, vMin, vMax, format, flags);
			return ret != 0;
		}

		public static bool DragFloat3( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax,  byte* format)
		{
			byte ret = DragFloat3Native(label, v, vSpeed, vMin, vMax, format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat3( byte* label,  float* v,  float vSpeed,  float vMin,  float vMax)
		{
			bool ret = DragFloat3(label, v, vSpeed, vMin, vMax, (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat3( byte* label,  float* v,  float vSpeed,  float vMin)
		{
			bool ret = DragFloat3(label, v, vSpeed, vMin, (float)(0.0f), (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat3( byte* label,  float* v,  float vSpeed)
		{
			bool ret = DragFloat3(label, v, vSpeed, (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat3( byte* label,  float* v)
		{
			bool ret = DragFloat3(label, v, (float)(1.0f), (float)(0.0f), (float)(0.0f), (string)"%.3f", (int)(0));
			return ret;
		}

		public static bool DragFloat3( byte* label,  float* v,  float vSpeed,  float vMin,  byte* format)
		{
			byte ret = DragFloat3Native(label, v, vSpeed, vMin, (float)(0.0f), format, (int)(0));
			return ret != 0;
		}

		public static bool DragFloat3( byte* label,  float* v,  float vSpeed,  byte* format)
		{
			byte ret = DragFloat3Native(label, v, vSpeed, (float)(0.0f), (float)(0.0f), format, (int)(0));
			return ret != 0;
		}
	}
}
