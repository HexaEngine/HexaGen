// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawChannel
	{

		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiViewportP(ImGuiViewport Imguiviewport = default, ImGuiWindow* window = default, int idx = default, int lastFrameActive = default, int lastFocusedStampCount = default, uint lastNameHash = default, Vector2 lastPos = default, float alpha = default, float lastAlpha = default, bool lastFocusedHadNavWindow = default, short platformMonitor = default, Span<int> bgFgDrawListsLastFrame = default, Span<Pointer<ImDrawList>> bgFgDrawLists = default, ImDrawData drawDataP = default, ImDrawDataBuilder drawDataBuilder = default, Vector2 lastPlatformPos = default, Vector2 lastPlatformSize = default, Vector2 lastRendererSize = default, Vector2 workOffsetMin = default, Vector2 workOffsetMax = default, Vector2 buildWorkOffsetMin = default, Vector2 buildWorkOffsetMax = default)
		{
			ImGuiViewport = Imguiviewport;
			Window = window;
			Idx = idx;
			LastFrameActive = lastFrameActive;
			LastFocusedStampCount = lastFocusedStampCount;
			LastNameHash = lastNameHash;
			LastPos = lastPos;
			Alpha = alpha;
			LastAlpha = lastAlpha;
			LastFocusedHadNavWindow = lastFocusedHadNavWindow ? (byte)1 : (byte)0;
			PlatformMonitor = platformMonitor;
			if (bgFgDrawListsLastFrame != default)
			{
				BgFgDrawListsLastFrame_0 = bgFgDrawListsLastFrame[0];
				BgFgDrawListsLastFrame_1 = bgFgDrawListsLastFrame[1];
			}
			if (bgFgDrawLists != default)
			{
				BgFgDrawLists_0 = bgFgDrawLists[0];
				BgFgDrawLists_1 = bgFgDrawLists[1];
			}
			DrawDataP = drawDataP;
			DrawDataBuilder = drawDataBuilder;
			LastPlatformPos = lastPlatformPos;
			LastPlatformSize = lastPlatformSize;
			LastRendererSize = lastRendererSize;
			WorkOffsetMin = workOffsetMin;
			WorkOffsetMax = workOffsetMax;
			BuildWorkOffsetMin = buildWorkOffsetMin;
			BuildWorkOffsetMax = buildWorkOffsetMax;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawDataBuilder
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImVectorImDrawListPtr* Layers_0;
		public unsafe ImVectorImDrawListPtr* Layers_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawListPtr LayerData1;


		/// <summary>/// To be documented./// </summary>		public unsafe ImDrawDataBuilder(ImVectorImDrawListPtr** layers = default, ImVectorImDrawListPtr layerData1 = default)
		{
			if (layers != default)
			{
				Layers_0 = layers[0];
				Layers_1 = layers[1];
			}
			LayerData1 = layerData1;
		}

		/// <summary>/// To be documented./// </summary>		public unsafe ImDrawDataBuilder(Span<Pointer<ImVectorImDrawListPtr>> layers = default, ImVectorImDrawListPtr layerData1 = default)
		{
			if (layers != default)
			{
				Layers_0 = layers[0];
				Layers_1 = layers[1];
			}
			LayerData1 = layerData1;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiID
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe uint* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiID(int size = default, int capacity = default, uint* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowTempData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorPosPrevLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorStartPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorMaxPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 IdealMaxPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CurrLineSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 PrevLineSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CurrLineTextBaseOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PrevLineTextBaseOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSameLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSetPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 Indent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 ColumnsOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 GroupOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorStartPosLossyness;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNavLayer NavLayerCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short NavLayersActiveMask;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short NavLayersActiveMaskNext;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavIsScrollPushableX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavHideHighlightOneFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavWindowHasScrollY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte MenuBarAppending;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MenuBarOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiMenuColumns MenuColumns;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TreeDepth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint TreeJumpToParentOnPopMask;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiWindowPtr ChildWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiStorage* StateStorage;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiOldColumns* CurrentColumns;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurrentTableIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LayoutType;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ParentLayoutType;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ItemWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float TextWrapPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorFloat ItemWidthStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorFloat TextWrapPosStack;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiWindowTempData(Vector2 cursorPos = default, Vector2 cursorPosPrevLine = default, Vector2 cursorStartPos = default, Vector2 cursorMaxPos = default, Vector2 idealMaxPos = default, Vector2 currLineSize = default, Vector2 prevLineSize = default, float currLineTextBaseOffset = default, float prevLineTextBaseOffset = default, bool isSameLine = default, bool isSetPos = default, ImVec1 indent = default, ImVec1 columnsOffset = default, ImVec1 groupOffset = default, Vector2 cursorStartPosLossyness = default, ImGuiNavLayer navLayerCurrent = default, short navLayersActiveMask = default, short navLayersActiveMaskNext = default, bool navIsScrollPushableX = default, bool navHideHighlightOneFrame = default, bool navWindowHasScrollY = default, bool menuBarAppending = default, Vector2 menuBarOffset = default, ImGuiMenuColumns menuColumns = default, int treeDepth = default, uint treeJumpToParentOnPopMask = default, ImVectorImGuiWindowPtr childWindows = default, ImGuiStorage* stateStorage = default, ImGuiOldColumns* currentColumns = default, int currentTableIdx = default, int layoutType = default, int parentLayoutType = default, float itemWidth = default, float textWrapPos = default, ImVectorFloat itemWidthStack = default, ImVectorFloat textWrapPosStack = default)
		{
			CursorPos = cursorPos;
			CursorPosPrevLine = cursorPosPrevLine;
			CursorStartPos = cursorStartPos;
			CursorMaxPos = cursorMaxPos;
			IdealMaxPos = idealMaxPos;
			CurrLineSize = currLineSize;
			PrevLineSize = prevLineSize;
			CurrLineTextBaseOffset = currLineTextBaseOffset;
			PrevLineTextBaseOffset = prevLineTextBaseOffset;
			IsSameLine = isSameLine ? (byte)1 : (byte)0;
			IsSetPos = isSetPos ? (byte)1 : (byte)0;
			Indent = indent;
			ColumnsOffset = columnsOffset;
			GroupOffset = groupOffset;
			CursorStartPosLossyness = cursorStartPosLossyness;
			NavLayerCurrent = navLayerCurrent;
			NavLayersActiveMask = navLayersActiveMask;
			NavLayersActiveMaskNext = navLayersActiveMaskNext;
			NavIsScrollPushableX = navIsScrollPushableX ? (byte)1 : (byte)0;
			NavHideHighlightOneFrame = navHideHighlightOneFrame ? (byte)1 : (byte)0;
			NavWindowHasScrollY = navWindowHasScrollY ? (byte)1 : (byte)0;
			MenuBarAppending = menuBarAppending ? (byte)1 : (byte)0;
			MenuBarOffset = menuBarOffset;
			MenuColumns = menuColumns;
			TreeDepth = treeDepth;
			TreeJumpToParentOnPopMask = treeJumpToParentOnPopMask;
			ChildWindows = childWindows;
			StateStorage = stateStorage;
			CurrentColumns = currentColumns;
			CurrentTableIdx = currentTableIdx;
			LayoutType = layoutType;
			ParentLayoutType = parentLayoutType;
			ItemWidth = itemWidth;
			TextWrapPos = textWrapPos;
			ItemWidthStack = itemWidthStack;
			TextWrapPosStack = textWrapPosStack;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec1
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float X;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVec1(float x = default)
		{
			X = x;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiMenuColumns
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint TotalWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NextTotalWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Spacing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort OffsetIcon;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort OffsetLabel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort OffsetShortcut;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort OffsetMark;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Widths_0;
		public ushort Widths_1;
		public ushort Widths_2;
		public ushort Widths_3;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiMenuColumns(uint totalWidth = default, uint nextTotalWidth = default, ushort spacing = default, ushort offsetIcon = default, ushort offsetLabel = default, ushort offsetShortcut = default, ushort offsetMark = default, ushort* widths = default)
		{
			TotalWidth = totalWidth;
			NextTotalWidth = nextTotalWidth;
			Spacing = spacing;
			OffsetIcon = offsetIcon;
			OffsetLabel = offsetLabel;
			OffsetShortcut = offsetShortcut;
			OffsetMark = offsetMark;
			if (widths != default)
			{
				Widths_0 = widths[0];
				Widths_1 = widths[1];
				Widths_2 = widths[2];
				Widths_3 = widths[3];
			}
		}

		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiMenuColumns(uint totalWidth = default, uint nextTotalWidth = default, ushort spacing = default, ushort offsetIcon = default, ushort offsetLabel = default, ushort offsetShortcut = default, ushort offsetMark = default, Span<ushort> widths = default)
		{
			TotalWidth = totalWidth;
			NextTotalWidth = nextTotalWidth;
			Spacing = spacing;
			OffsetIcon = offsetIcon;
			OffsetLabel = offsetLabel;
			OffsetShortcut = offsetShortcut;
			OffsetMark = offsetMark;
			if (widths != default)
			{
				Widths_0 = widths[0];
				Widths_1 = widths[1];
				Widths_2 = widths[2];
				Widths_3 = widths[3];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStorage
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiStoragePair Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiStorage(ImVectorImGuiStoragePair data = default)
		{
			Data = data;
		}


		public unsafe void BuildSortByKey()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.BuildSortByKeyNative(@this);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe bool GetBool( uint key,  bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte ret = ImGui.GetBoolNative(@this, key, defaultVal ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public unsafe bool GetBool( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte ret = ImGui.GetBoolNative(@this, key, (byte)(0));
				return ret != 0;
			}
		}

		public unsafe byte* GetBoolRef( uint key,  bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte* ret = ImGui.GetBoolRefNative(@this, key, defaultVal ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public unsafe byte* GetBoolRef( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte* ret = ImGui.GetBoolRefNative(@this, key, (byte)(0));
				return ret;
			}
		}

		public unsafe float GetFloat( uint key,  float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float ret = ImGui.GetFloatNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float GetFloat( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float ret = ImGui.GetFloatNative(@this, key, (float)(0.0f));
				return ret;
			}
		}

		public unsafe float* GetFloatRef( uint key,  float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float* ret = ImGui.GetFloatRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float* GetFloatRef( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float* ret = ImGui.GetFloatRefNative(@this, key, (float)(0.0f));
				return ret;
			}
		}

		public unsafe int GetInt( uint key,  int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int ret = ImGui.GetIntNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int GetInt( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int ret = ImGui.GetIntNative(@this, key, (int)(0));
				return ret;
			}
		}

		public unsafe int* GetIntRef( uint key,  int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int* ret = ImGui.GetIntRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int* GetIntRef( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int* ret = ImGui.GetIntRefNative(@this, key, (int)(0));
				return ret;
			}
		}

		public unsafe void* GetVoidPtr( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void* ret = ImGui.GetVoidPtrNative(@this, key);
				return ret;
			}
		}

		public unsafe void** GetVoidPtrRef( uint key,  void* defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void** ret = ImGui.GetVoidPtrRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe void** GetVoidPtrRef( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void** ret = ImGui.GetVoidPtrRefNative(@this, key, (void*)(default));
				return ret;
			}
		}

		public unsafe void SetAllInt( int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetAllIntNative(@this, val);
			}
		}

		public unsafe void SetBool( uint key,  bool val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetBoolNative(@this, key, val ? (byte)1 : (byte)0);
			}
		}

		public unsafe void SetFloat( uint key,  float val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetFloatNative(@this, key, val);
			}
		}

		public unsafe void SetInt( uint key,  int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetIntNative(@this, key, val);
			}
		}

		public unsafe void SetVoidPtr( uint key,  void* val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetVoidPtrNative(@this, key, val);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStoragePair
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiStoragePair* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiStoragePair(int size = default, int capacity = default, ImGuiStoragePair* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStoragePair
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		[StructLayout(LayoutKind.Explicit)]
		public partial struct ImGuiStoragePairUnion
		{
			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public int ValI;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public float ValF;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public unsafe void* ValP;


			/// <summary>/// To be documented./// </summary>			public unsafe ImGuiStoragePairUnion(int valI = default, float valF = default, void* valP = default)
			{
				ValI = valI;
				ValF = valF;
				ValP = valP;
			}


		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Key;

		/// <summary>
		/// To be documented.
		/// </summary>
		public  ;



		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiStoragePair(uint key = default,   = default)
		{
			Key = key;
			this. = ;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiStoragePair* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumns
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsFirstFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsBeingResized;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Current;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Count;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float OffMinX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float OffMaxX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LineMinY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LineMaxY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HostCursorPosY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HostCursorMaxPosX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostInitialClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostBackupClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostBackupParentWorkRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiOldColumnData Columns;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawListSplitter Splitter;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiOldColumns(uint id = default, int flags = default, bool isFirstFrame = default, bool isBeingResized = default, int current = default, int count = default, float offMinX = default, float offMaxX = default, float lineMinY = default, float lineMaxY = default, float hostCursorPosY = default, float hostCursorMaxPosX = default, ImRect hostInitialClipRect = default, ImRect hostBackupClipRect = default, ImRect hostBackupParentWorkRect = default, ImVectorImGuiOldColumnData columns = default, ImDrawListSplitter splitter = default)
		{
			ID = id;
			Flags = flags;
			IsFirstFrame = isFirstFrame ? (byte)1 : (byte)0;
			IsBeingResized = isBeingResized ? (byte)1 : (byte)0;
			Current = current;
			Count = count;
			OffMinX = offMinX;
			OffMaxX = offMaxX;
			LineMinY = lineMinY;
			LineMaxY = lineMaxY;
			HostCursorPosY = hostCursorPosY;
			HostCursorMaxPosX = hostCursorMaxPosX;
			HostInitialClipRect = hostInitialClipRect;
			HostBackupClipRect = hostBackupClipRect;
			HostBackupParentWorkRect = hostBackupParentWorkRect;
			Columns = columns;
			Splitter = splitter;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImRect
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Min;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Max;


		/// <summary>/// To be documented./// </summary>		public unsafe ImRect(Vector2 min = default, Vector2 max = default)
		{
			Min = min;
			Max = max;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumnData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiOldColumnData* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiOldColumnData(int size = default, int capacity = default, ImGuiOldColumnData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumnData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float OffsetNorm;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float OffsetNormBeforeResize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect ClipRect;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiOldColumnData(float offsetNorm = default, float offsetNormBeforeResize = default, int flags = default, ImRect clipRect = default)
		{
			OffsetNorm = offsetNorm;
			OffsetNormBeforeResize = offsetNormBeforeResize;
			Flags = flags;
			ClipRect = clipRect;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec2Ih
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public short X;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short Y;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVec2Ih(short x = default, short y = default)
		{
			X = x;
			Y = y;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumns
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiOldColumns* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiOldColumns(int size = default, int capacity = default, ImGuiOldColumns* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowDockStyle
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Colors_0;
		public uint Colors_1;
		public uint Colors_2;
		public uint Colors_3;
		public uint Colors_4;
		public uint Colors_5;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiWindowDockStyle(uint* colors = default)
		{
			if (colors != default)
			{
				Colors_0 = colors[0];
				Colors_1 = colors[1];
				Colors_2 = colors[2];
				Colors_3 = colors[3];
				Colors_4 = colors[4];
				Colors_5 = colors[5];
			}
		}

		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiWindowDockStyle(Span<uint> colors = default)
		{
			if (colors != default)
			{
				Colors_0 = colors[0];
				Colors_1 = colors[1];
				Colors_2 = colors[2];
				Colors_3 = colors[3];
				Colors_4 = colors[4];
				Colors_5 = colors[5];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockNode
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SharedFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LocalFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LocalFlagsInWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MergedFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiDockNodeState State;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* ParentNode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* ChildNodes_0;
		public unsafe ImGuiDockNode* ChildNodes_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiWindowPtr Windows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTabBar* TabBar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SizeRef;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiAxis SplitAxis;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiWindowClass WindowClass;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint LastBgColor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* HostWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* VisibleWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* CentralNode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* OnlyNodeWithWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CountNodeWithWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameFocused;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint LastFocusedNodeId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint SelectedTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint WantCloseTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint RefViewportId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int AuthorityForPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int AuthorityForSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int AuthorityForViewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsFocused;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsBgDrawnThisFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasCloseButton;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasWindowMenuButton;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasCentralNodeChild;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantCloseAll;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantLockSizeOnce;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantMouseMove;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantHiddenTabBarUpdate;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantHiddenTabBarToggle;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiDockNode(uint id = default, int sharedFlags = default, int localFlags = default, int localFlagsInWindows = default, int mergedFlags = default, ImGuiDockNodeState state = default, ImGuiDockNode* parentNode = default, ImGuiDockNode** childNodes = default, ImVectorImGuiWindowPtr windows = default, ImGuiTabBar* tabBar = default, Vector2 pos = default, Vector2 size = default, Vector2 sizeRef = default, ImGuiAxis splitAxis = default, ImGuiWindowClass windowClass = default, uint lastBgColor = default, ImGuiWindow* hostWindow = default, ImGuiWindow* visibleWindow = default, ImGuiDockNode* centralNode = default, ImGuiDockNode* onlyNodeWithWindows = default, int countNodeWithWindows = default, int lastFrameAlive = default, int lastFrameActive = default, int lastFrameFocused = default, uint lastFocusedNodeId = default, uint selectedTabId = default, uint wantCloseTabId = default, uint refViewportId = default, int authorityForPos = default, int authorityForSize = default, int authorityForViewport = default, bool isVisible = default, bool isFocused = default, bool isBgDrawnThisFrame = default, bool hasCloseButton = default, bool hasWindowMenuButton = default, bool hasCentralNodeChild = default, bool wantCloseAll = default, bool wantLockSizeOnce = default, bool wantMouseMove = default, bool wantHiddenTabBarUpdate = default, bool wantHiddenTabBarToggle = default)
		{
			ID = id;
			SharedFlags = sharedFlags;
			LocalFlags = localFlags;
			LocalFlagsInWindows = localFlagsInWindows;
			MergedFlags = mergedFlags;
			State = state;
			ParentNode = parentNode;
			if (childNodes != default)
			{
				ChildNodes_0 = childNodes[0];
				ChildNodes_1 = childNodes[1];
			}
			Windows = windows;
			TabBar = tabBar;
			Pos = pos;
			Size = size;
			SizeRef = sizeRef;
			SplitAxis = splitAxis;
			WindowClass = windowClass;
			LastBgColor = lastBgColor;
			HostWindow = hostWindow;
			VisibleWindow = visibleWindow;
			CentralNode = centralNode;
			OnlyNodeWithWindows = onlyNodeWithWindows;
			CountNodeWithWindows = countNodeWithWindows;
			LastFrameAlive = lastFrameAlive;
			LastFrameActive = lastFrameActive;
			LastFrameFocused = lastFrameFocused;
			LastFocusedNodeId = lastFocusedNodeId;
			SelectedTabId = selectedTabId;
			WantCloseTabId = wantCloseTabId;
			RefViewportId = refViewportId;
			AuthorityForPos = authorityForPos;
			AuthorityForSize = authorityForSize;
			AuthorityForViewport = authorityForViewport;
			IsVisible = isVisible ? (byte)1 : (byte)0;
			IsFocused = isFocused ? (byte)1 : (byte)0;
			IsBgDrawnThisFrame = isBgDrawnThisFrame ? (byte)1 : (byte)0;
			HasCloseButton = hasCloseButton ? (byte)1 : (byte)0;
			HasWindowMenuButton = hasWindowMenuButton ? (byte)1 : (byte)0;
			HasCentralNodeChild = hasCentralNodeChild ? (byte)1 : (byte)0;
			WantCloseAll = wantCloseAll ? (byte)1 : (byte)0;
			WantLockSizeOnce = wantLockSizeOnce ? (byte)1 : (byte)0;
			WantMouseMove = wantMouseMove ? (byte)1 : (byte)0;
			WantHiddenTabBarUpdate = wantHiddenTabBarUpdate ? (byte)1 : (byte)0;
			WantHiddenTabBarToggle = wantHiddenTabBarToggle ? (byte)1 : (byte)0;
		}

		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiDockNode(uint id = default, int sharedFlags = default, int localFlags = default, int localFlagsInWindows = default, int mergedFlags = default, ImGuiDockNodeState state = default, ImGuiDockNode* parentNode = default, Span<Pointer<ImGuiDockNode>> childNodes = default, ImVectorImGuiWindowPtr windows = default, ImGuiTabBar* tabBar = default, Vector2 pos = default, Vector2 size = default, Vector2 sizeRef = default, ImGuiAxis splitAxis = default, ImGuiWindowClass windowClass = default, uint lastBgColor = default, ImGuiWindow* hostWindow = default, ImGuiWindow* visibleWindow = default, ImGuiDockNode* centralNode = default, ImGuiDockNode* onlyNodeWithWindows = default, int countNodeWithWindows = default, int lastFrameAlive = default, int lastFrameActive = default, int lastFrameFocused = default, uint lastFocusedNodeId = default, uint selectedTabId = default, uint wantCloseTabId = default, uint refViewportId = default, int authorityForPos = default, int authorityForSize = default, int authorityForViewport = default, bool isVisible = default, bool isFocused = default, bool isBgDrawnThisFrame = default, bool hasCloseButton = default, bool hasWindowMenuButton = default, bool hasCentralNodeChild = default, bool wantCloseAll = default, bool wantLockSizeOnce = default, bool wantMouseMove = default, bool wantHiddenTabBarUpdate = default, bool wantHiddenTabBarToggle = default)
		{
			ID = id;
			SharedFlags = sharedFlags;
			LocalFlags = localFlags;
			LocalFlagsInWindows = localFlagsInWindows;
			MergedFlags = mergedFlags;
			State = state;
			ParentNode = parentNode;
			if (childNodes != default)
			{
				ChildNodes_0 = childNodes[0];
				ChildNodes_1 = childNodes[1];
			}
			Windows = windows;
			TabBar = tabBar;
			Pos = pos;
			Size = size;
			SizeRef = sizeRef;
			SplitAxis = splitAxis;
			WindowClass = windowClass;
			LastBgColor = lastBgColor;
			HostWindow = hostWindow;
			VisibleWindow = visibleWindow;
			CentralNode = centralNode;
			OnlyNodeWithWindows = onlyNodeWithWindows;
			CountNodeWithWindows = countNodeWithWindows;
			LastFrameAlive = lastFrameAlive;
			LastFrameActive = lastFrameActive;
			LastFrameFocused = lastFrameFocused;
			LastFocusedNodeId = lastFocusedNodeId;
			SelectedTabId = selectedTabId;
			WantCloseTabId = wantCloseTabId;
			RefViewportId = refViewportId;
			AuthorityForPos = authorityForPos;
			AuthorityForSize = authorityForSize;
			AuthorityForViewport = authorityForViewport;
			IsVisible = isVisible ? (byte)1 : (byte)0;
			IsFocused = isFocused ? (byte)1 : (byte)0;
			IsBgDrawnThisFrame = isBgDrawnThisFrame ? (byte)1 : (byte)0;
			HasCloseButton = hasCloseButton ? (byte)1 : (byte)0;
			HasWindowMenuButton = hasWindowMenuButton ? (byte)1 : (byte)0;
			HasCentralNodeChild = hasCentralNodeChild ? (byte)1 : (byte)0;
			WantCloseAll = wantCloseAll ? (byte)1 : (byte)0;
			WantLockSizeOnce = wantLockSizeOnce ? (byte)1 : (byte)0;
			WantMouseMove = wantMouseMove ? (byte)1 : (byte)0;
			WantHiddenTabBarUpdate = wantHiddenTabBarUpdate ? (byte)1 : (byte)0;
			WantHiddenTabBarToggle = wantHiddenTabBarToggle ? (byte)1 : (byte)0;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabBar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTabItem Tabs;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint SelectedTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NextSelectedTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint VisibleTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurrFrameVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int PrevFrameVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect BarRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CurrTabsContentsHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PrevTabsContentsHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WidthAllTabs;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WidthAllTabsIdeal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingAnim;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingTarget;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingTargetDistToVisibility;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingSpeed;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingRectMinX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingRectMaxX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float SeparatorMinX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float SeparatorMaxX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ReorderRequestTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ReorderRequestOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BeginCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantLayout;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte VisibleTabWasSubmitted;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte TabsAddedNew;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short TabsActiveCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short LastTabItemIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ItemSpacingY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 FramePadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTextBuffer TabsNames;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiTabBar(ImVectorImGuiTabItem tabs = default, int flags = default, uint id = default, uint selectedTabId = default, uint nextSelectedTabId = default, uint visibleTabId = default, int currFrameVisible = default, int prevFrameVisible = default, ImRect barRect = default, float currTabsContentsHeight = default, float prevTabsContentsHeight = default, float widthAllTabs = default, float widthAllTabsIdeal = default, float scrollingAnim = default, float scrollingTarget = default, float scrollingTargetDistToVisibility = default, float scrollingSpeed = default, float scrollingRectMinX = default, float scrollingRectMaxX = default, float separatorMinX = default, float separatorMaxX = default, uint reorderRequestTabId = default, short reorderRequestOffset = default, byte beginCount = default, bool wantLayout = default, bool visibleTabWasSubmitted = default, bool tabsAddedNew = default, short tabsActiveCount = default, short lastTabItemIdx = default, float itemSpacingY = default, Vector2 framePadding = default, Vector2 backupCursorPos = default, ImGuiTextBuffer tabsNames = default)
		{
			Tabs = tabs;
			Flags = flags;
			ID = id;
			SelectedTabId = selectedTabId;
			NextSelectedTabId = nextSelectedTabId;
			VisibleTabId = visibleTabId;
			CurrFrameVisible = currFrameVisible;
			PrevFrameVisible = prevFrameVisible;
			BarRect = barRect;
			CurrTabsContentsHeight = currTabsContentsHeight;
			PrevTabsContentsHeight = prevTabsContentsHeight;
			WidthAllTabs = widthAllTabs;
			WidthAllTabsIdeal = widthAllTabsIdeal;
			ScrollingAnim = scrollingAnim;
			ScrollingTarget = scrollingTarget;
			ScrollingTargetDistToVisibility = scrollingTargetDistToVisibility;
			ScrollingSpeed = scrollingSpeed;
			ScrollingRectMinX = scrollingRectMinX;
			ScrollingRectMaxX = scrollingRectMaxX;
			SeparatorMinX = separatorMinX;
			SeparatorMaxX = separatorMaxX;
			ReorderRequestTabId = reorderRequestTabId;
			ReorderRequestOffset = reorderRequestOffset;
			BeginCount = beginCount;
			WantLayout = wantLayout ? (byte)1 : (byte)0;
			VisibleTabWasSubmitted = visibleTabWasSubmitted ? (byte)1 : (byte)0;
			TabsAddedNew = tabsAddedNew ? (byte)1 : (byte)0;
			TabsActiveCount = tabsActiveCount;
			LastTabItemIdx = lastTabItemIdx;
			ItemSpacingY = itemSpacingY;
			FramePadding = framePadding;
			BackupCursorPos = backupCursorPos;
			TabsNames = tabsNames;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTabItem
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTabItem* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiTabItem(int size = default, int capacity = default, ImGuiTabItem* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabItem
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameSelected;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Offset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Width;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ContentWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RequestedWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NameOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short BeginOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short IndexDuringLayout;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantClose;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiTabItem(uint id = default, int flags = default, ImGuiWindow* window = default, int lastFrameVisible = default, int lastFrameSelected = default, float offset = default, float width = default, float contentWidth = default, float requestedWidth = default, int nameOffset = default, short beginOrder = default, short indexDuringLayout = default, bool wantClose = default)
		{
			ID = id;
			Flags = flags;
			Window = window;
			LastFrameVisible = lastFrameVisible;
			LastFrameSelected = lastFrameSelected;
			Offset = offset;
			Width = width;
			ContentWidth = contentWidth;
			RequestedWidth = requestedWidth;
			NameOffset = nameOffset;
			BeginOrder = beginOrder;
			IndexDuringLayout = indexDuringLayout;
			WantClose = wantClose ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextBuffer
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorChar Buf;



		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiTextBuffer(ImVectorChar buf = default)
		{
			Buf = buf;
		}


		public unsafe void append( byte* str,  byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendNative(@this, str, strEnd);
			}
		}

		public unsafe void append( byte* str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendNative(@this, str, (byte*)(default));
			}
		}

		public unsafe void append( ref byte str,  byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.appendNative(@this, (byte*)pstr, strEnd);
				}
			}
		}

		public unsafe void append( ref byte str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.appendNative(@this, (byte*)pstr, (byte*)(default));
				}
			}
		}

		public unsafe void append( string str,  byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append( string str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append( byte* str,  ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					ImGui.appendNative(@this, str, (byte*)pstrEnd);
				}
			}
		}

		public unsafe void append( byte* str,  string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append( ref byte str,  ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						ImGui.appendNative(@this, (byte*)pstr, (byte*)pstrEnd);
					}
				}
			}
		}

		public unsafe void append( string str,  string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.appendNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void appendf( byte* fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendfNative(@this, fmt);
			}
		}

		public unsafe void appendf( ref byte fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendfNative(@this, (byte*)pfmt);
				}
			}
		}

		public unsafe void appendf( string fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendfNative(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void appendfv( byte* fmt,  nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendfvNative(@this, fmt, args);
			}
		}

		public unsafe void appendfv( ref byte fmt,  nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendfvNative(@this, (byte*)pfmt, args);
				}
			}
		}

		public unsafe void appendfv( string fmt,  nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendfvNative(@this, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe byte* begin()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.beginNative(@this);
				return ret;
			}
		}

		public unsafe string beginS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.beginNative(@this));
				return ret;
			}
		}

		public unsafe byte* c_str()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.c_strNative(@this);
				return ret;
			}
		}

		public unsafe string c_strS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.c_strNative(@this));
				return ret;
			}
		}

		public unsafe void clear()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.clearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool empty()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte ret = ImGui.emptyNative(@this);
				return ret != 0;
			}
		}

		public unsafe byte* end()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.endNative(@this);
				return ret;
			}
		}

		public unsafe string endS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.endNative(@this));
				return ret;
			}
		}

		public unsafe void reserve( int capacity)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.reserveNative(@this, capacity);
			}
		}

		public unsafe int size()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				int ret = ImGui.sizeNative(@this);
				return ret;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorChar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorChar(int size = default, int capacity = default, byte* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiWindowStackData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindowStackData* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiWindowStackData(int size = default, int capacity = default, ImGuiWindowStackData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowStackData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiLastItemData ParentLastItemDataBackup;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStackSizes StackSizesOnBegin;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiWindowStackData(ImGuiWindow* window = default, ImGuiLastItemData parentLastItemDataBackup = default, ImGuiStackSizes stackSizesOnBegin = default)
		{
			Window = window;
			ParentLastItemDataBackup = parentLastItemDataBackup;
			StackSizesOnBegin = stackSizesOnBegin;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiLastItemData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int InFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int StatusFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect Rect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect NavRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect DisplayRect;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiLastItemData(uint id = default, int inFlags = default, int statusFlags = default, ImRect rect = default, ImRect navRect = default, ImRect displayRect = default)
		{
			ID = id;
			InFlags = inFlags;
			StatusFlags = statusFlags;
			Rect = rect;
			NavRect = navRect;
			DisplayRect = displayRect;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackSizes
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfIDStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfColorStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfStyleVarStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfFontStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfFocusScopeStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfGroupStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfItemFlagsStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfBeginPopupStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfDisabledStack;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiStackSizes(short sizeOfIdStack = default, short sizeOfColorStack = default, short sizeOfStyleVarStack = default, short sizeOfFontStack = default, short sizeOfFocusScopeStack = default, short sizeOfGroupStack = default, short sizeOfItemFlagsStack = default, short sizeOfBeginPopupStack = default, short sizeOfDisabledStack = default)
		{
			SizeOfIDStack = sizeOfIdStack;
			SizeOfColorStack = sizeOfColorStack;
			SizeOfStyleVarStack = sizeOfStyleVarStack;
			SizeOfFontStack = sizeOfFontStack;
			SizeOfFocusScopeStack = sizeOfFocusScopeStack;
			SizeOfGroupStack = sizeOfGroupStack;
			SizeOfItemFlagsStack = sizeOfItemFlagsStack;
			SizeOfBeginPopupStack = sizeOfBeginPopupStack;
			SizeOfDisabledStack = sizeOfDisabledStack;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyOwnerData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint OwnerCurr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint OwnerNext;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte LockThisFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte LockUntilRelease;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiKeyOwnerData(uint ownerCurr = default, uint ownerNext = default, bool lockThisFrame = default, bool lockUntilRelease = default)
		{
			OwnerCurr = ownerCurr;
			OwnerNext = ownerNext;
			LockThisFrame = lockThisFrame ? (byte)1 : (byte)0;
			LockUntilRelease = lockUntilRelease ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingTable
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public short Index_0;
		public short Index_1;
		public short Index_2;
		public short Index_3;
		public short Index_4;
		public short Index_5;
		public short Index_6;
		public short Index_7;
		public short Index_8;
		public short Index_9;
		public short Index_10;
		public short Index_11;
		public short Index_12;
		public short Index_13;
		public short Index_14;
		public short Index_15;
		public short Index_16;
		public short Index_17;
		public short Index_18;
		public short Index_19;
		public short Index_20;
		public short Index_21;
		public short Index_22;
		public short Index_23;
		public short Index_24;
		public short Index_25;
		public short Index_26;
		public short Index_27;
		public short Index_28;
		public short Index_29;
		public short Index_30;
		public short Index_31;
		public short Index_32;
		public short Index_33;
		public short Index_34;
		public short Index_35;
		public short Index_36;
		public short Index_37;
		public short Index_38;
		public short Index_39;
		public short Index_40;
		public short Index_41;
		public short Index_42;
		public short Index_43;
		public short Index_44;
		public short Index_45;
		public short Index_46;
		public short Index_47;
		public short Index_48;
		public short Index_49;
		public short Index_50;
		public short Index_51;
		public short Index_52;
		public short Index_53;
		public short Index_54;
		public short Index_55;
		public short Index_56;
		public short Index_57;
		public short Index_58;
		public short Index_59;
		public short Index_60;
		public short Index_61;
		public short Index_62;
		public short Index_63;
		public short Index_64;
		public short Index_65;
		public short Index_66;
		public short Index_67;
		public short Index_68;
		public short Index_69;
		public short Index_70;
		public short Index_71;
		public short Index_72;
		public short Index_73;
		public short Index_74;
		public short Index_75;
		public short Index_76;
		public short Index_77;
		public short Index_78;
		public short Index_79;
		public short Index_80;
		public short Index_81;
		public short Index_82;
		public short Index_83;
		public short Index_84;
		public short Index_85;
		public short Index_86;
		public short Index_87;
		public short Index_88;
		public short Index_89;
		public short Index_90;
		public short Index_91;
		public short Index_92;
		public short Index_93;
		public short Index_94;
		public short Index_95;
		public short Index_96;
		public short Index_97;
		public short Index_98;
		public short Index_99;
		public short Index_100;
		public short Index_101;
		public short Index_102;
		public short Index_103;
		public short Index_104;
		public short Index_105;
		public short Index_106;
		public short Index_107;
		public short Index_108;
		public short Index_109;
		public short Index_110;
		public short Index_111;
		public short Index_112;
		public short Index_113;
		public short Index_114;
		public short Index_115;
		public short Index_116;
		public short Index_117;
		public short Index_118;
		public short Index_119;
		public short Index_120;
		public short Index_121;
		public short Index_122;
		public short Index_123;
		public short Index_124;
		public short Index_125;
		public short Index_126;
		public short Index_127;
		public short Index_128;
		public short Index_129;
		public short Index_130;
		public short Index_131;
		public short Index_132;
		public short Index_133;
		public short Index_134;
		public short Index_135;
		public short Index_136;
		public short Index_137;
		public short Index_138;
		public short Index_139;
		public short Index_140;
		public short Index_141;
		public short Index_142;
		public short Index_143;
		public short Index_144;
		public short Index_145;
		public short Index_146;
		public short Index_147;
		public short Index_148;
		public short Index_149;
		public short Index_150;
		public short Index_151;
		public short Index_152;
		public short Index_153;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiKeyRoutingData Entries;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiKeyRoutingData EntriesNext;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiKeyRoutingTable(short* index = default, ImVectorImGuiKeyRoutingData entries = default, ImVectorImGuiKeyRoutingData entriesNext = default)
		{
			if (index != default)
			{
				Index_0 = index[0];
				Index_1 = index[1];
				Index_2 = index[2];
				Index_3 = index[3];
				Index_4 = index[4];
				Index_5 = index[5];
				Index_6 = index[6];
				Index_7 = index[7];
				Index_8 = index[8];
				Index_9 = index[9];
				Index_10 = index[10];
				Index_11 = index[11];
				Index_12 = index[12];
				Index_13 = index[13];
				Index_14 = index[14];
				Index_15 = index[15];
				Index_16 = index[16];
				Index_17 = index[17];
				Index_18 = index[18];
				Index_19 = index[19];
				Index_20 = index[20];
				Index_21 = index[21];
				Index_22 = index[22];
				Index_23 = index[23];
				Index_24 = index[24];
				Index_25 = index[25];
				Index_26 = index[26];
				Index_27 = index[27];
				Index_28 = index[28];
				Index_29 = index[29];
				Index_30 = index[30];
				Index_31 = index[31];
				Index_32 = index[32];
				Index_33 = index[33];
				Index_34 = index[34];
				Index_35 = index[35];
				Index_36 = index[36];
				Index_37 = index[37];
				Index_38 = index[38];
				Index_39 = index[39];
				Index_40 = index[40];
				Index_41 = index[41];
				Index_42 = index[42];
				Index_43 = index[43];
				Index_44 = index[44];
				Index_45 = index[45];
				Index_46 = index[46];
				Index_47 = index[47];
				Index_48 = index[48];
				Index_49 = index[49];
				Index_50 = index[50];
				Index_51 = index[51];
				Index_52 = index[52];
				Index_53 = index[53];
				Index_54 = index[54];
				Index_55 = index[55];
				Index_56 = index[56];
				Index_57 = index[57];
				Index_58 = index[58];
				Index_59 = index[59];
				Index_60 = index[60];
				Index_61 = index[61];
				Index_62 = index[62];
				Index_63 = index[63];
				Index_64 = index[64];
				Index_65 = index[65];
				Index_66 = index[66];
				Index_67 = index[67];
				Index_68 = index[68];
				Index_69 = index[69];
				Index_70 = index[70];
				Index_71 = index[71];
				Index_72 = index[72];
				Index_73 = index[73];
				Index_74 = index[74];
				Index_75 = index[75];
				Index_76 = index[76];
				Index_77 = index[77];
				Index_78 = index[78];
				Index_79 = index[79];
				Index_80 = index[80];
				Index_81 = index[81];
				Index_82 = index[82];
				Index_83 = index[83];
				Index_84 = index[84];
				Index_85 = index[85];
				Index_86 = index[86];
				Index_87 = index[87];
				Index_88 = index[88];
				Index_89 = index[89];
				Index_90 = index[90];
				Index_91 = index[91];
				Index_92 = index[92];
				Index_93 = index[93];
				Index_94 = index[94];
				Index_95 = index[95];
				Index_96 = index[96];
				Index_97 = index[97];
				Index_98 = index[98];
				Index_99 = index[99];
				Index_100 = index[100];
				Index_101 = index[101];
				Index_102 = index[102];
				Index_103 = index[103];
				Index_104 = index[104];
				Index_105 = index[105];
				Index_106 = index[106];
				Index_107 = index[107];
				Index_108 = index[108];
				Index_109 = index[109];
				Index_110 = index[110];
				Index_111 = index[111];
				Index_112 = index[112];
				Index_113 = index[113];
				Index_114 = index[114];
				Index_115 = index[115];
				Index_116 = index[116];
				Index_117 = index[117];
				Index_118 = index[118];
				Index_119 = index[119];
				Index_120 = index[120];
				Index_121 = index[121];
				Index_122 = index[122];
				Index_123 = index[123];
				Index_124 = index[124];
				Index_125 = index[125];
				Index_126 = index[126];
				Index_127 = index[127];
				Index_128 = index[128];
				Index_129 = index[129];
				Index_130 = index[130];
				Index_131 = index[131];
				Index_132 = index[132];
				Index_133 = index[133];
				Index_134 = index[134];
				Index_135 = index[135];
				Index_136 = index[136];
				Index_137 = index[137];
				Index_138 = index[138];
				Index_139 = index[139];
				Index_140 = index[140];
				Index_141 = index[141];
				Index_142 = index[142];
				Index_143 = index[143];
				Index_144 = index[144];
				Index_145 = index[145];
				Index_146 = index[146];
				Index_147 = index[147];
				Index_148 = index[148];
				Index_149 = index[149];
				Index_150 = index[150];
				Index_151 = index[151];
				Index_152 = index[152];
				Index_153 = index[153];
			}
			Entries = entries;
			EntriesNext = entriesNext;
		}

		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiKeyRoutingTable(Span<short> index = default, ImVectorImGuiKeyRoutingData entries = default, ImVectorImGuiKeyRoutingData entriesNext = default)
		{
			if (index != default)
			{
				Index_0 = index[0];
				Index_1 = index[1];
				Index_2 = index[2];
				Index_3 = index[3];
				Index_4 = index[4];
				Index_5 = index[5];
				Index_6 = index[6];
				Index_7 = index[7];
				Index_8 = index[8];
				Index_9 = index[9];
				Index_10 = index[10];
				Index_11 = index[11];
				Index_12 = index[12];
				Index_13 = index[13];
				Index_14 = index[14];
				Index_15 = index[15];
				Index_16 = index[16];
				Index_17 = index[17];
				Index_18 = index[18];
				Index_19 = index[19];
				Index_20 = index[20];
				Index_21 = index[21];
				Index_22 = index[22];
				Index_23 = index[23];
				Index_24 = index[24];
				Index_25 = index[25];
				Index_26 = index[26];
				Index_27 = index[27];
				Index_28 = index[28];
				Index_29 = index[29];
				Index_30 = index[30];
				Index_31 = index[31];
				Index_32 = index[32];
				Index_33 = index[33];
				Index_34 = index[34];
				Index_35 = index[35];
				Index_36 = index[36];
				Index_37 = index[37];
				Index_38 = index[38];
				Index_39 = index[39];
				Index_40 = index[40];
				Index_41 = index[41];
				Index_42 = index[42];
				Index_43 = index[43];
				Index_44 = index[44];
				Index_45 = index[45];
				Index_46 = index[46];
				Index_47 = index[47];
				Index_48 = index[48];
				Index_49 = index[49];
				Index_50 = index[50];
				Index_51 = index[51];
				Index_52 = index[52];
				Index_53 = index[53];
				Index_54 = index[54];
				Index_55 = index[55];
				Index_56 = index[56];
				Index_57 = index[57];
				Index_58 = index[58];
				Index_59 = index[59];
				Index_60 = index[60];
				Index_61 = index[61];
				Index_62 = index[62];
				Index_63 = index[63];
				Index_64 = index[64];
				Index_65 = index[65];
				Index_66 = index[66];
				Index_67 = index[67];
				Index_68 = index[68];
				Index_69 = index[69];
				Index_70 = index[70];
				Index_71 = index[71];
				Index_72 = index[72];
				Index_73 = index[73];
				Index_74 = index[74];
				Index_75 = index[75];
				Index_76 = index[76];
				Index_77 = index[77];
				Index_78 = index[78];
				Index_79 = index[79];
				Index_80 = index[80];
				Index_81 = index[81];
				Index_82 = index[82];
				Index_83 = index[83];
				Index_84 = index[84];
				Index_85 = index[85];
				Index_86 = index[86];
				Index_87 = index[87];
				Index_88 = index[88];
				Index_89 = index[89];
				Index_90 = index[90];
				Index_91 = index[91];
				Index_92 = index[92];
				Index_93 = index[93];
				Index_94 = index[94];
				Index_95 = index[95];
				Index_96 = index[96];
				Index_97 = index[97];
				Index_98 = index[98];
				Index_99 = index[99];
				Index_100 = index[100];
				Index_101 = index[101];
				Index_102 = index[102];
				Index_103 = index[103];
				Index_104 = index[104];
				Index_105 = index[105];
				Index_106 = index[106];
				Index_107 = index[107];
				Index_108 = index[108];
				Index_109 = index[109];
				Index_110 = index[110];
				Index_111 = index[111];
				Index_112 = index[112];
				Index_113 = index[113];
				Index_114 = index[114];
				Index_115 = index[115];
				Index_116 = index[116];
				Index_117 = index[117];
				Index_118 = index[118];
				Index_119 = index[119];
				Index_120 = index[120];
				Index_121 = index[121];
				Index_122 = index[122];
				Index_123 = index[123];
				Index_124 = index[124];
				Index_125 = index[125];
				Index_126 = index[126];
				Index_127 = index[127];
				Index_128 = index[128];
				Index_129 = index[129];
				Index_130 = index[130];
				Index_131 = index[131];
				Index_132 = index[132];
				Index_133 = index[133];
				Index_134 = index[134];
				Index_135 = index[135];
				Index_136 = index[136];
				Index_137 = index[137];
				Index_138 = index[138];
				Index_139 = index[139];
				Index_140 = index[140];
				Index_141 = index[141];
				Index_142 = index[142];
				Index_143 = index[143];
				Index_144 = index[144];
				Index_145 = index[145];
				Index_146 = index[146];
				Index_147 = index[147];
				Index_148 = index[148];
				Index_149 = index[149];
				Index_150 = index[150];
				Index_151 = index[151];
				Index_152 = index[152];
				Index_153 = index[153];
			}
			Entries = entries;
			EntriesNext = entriesNext;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiKeyRoutingData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiKeyRoutingData* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiKeyRoutingData(int size = default, int capacity = default, ImGuiKeyRoutingData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public short NextEntryIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Mods;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte RoutingNextScore;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint RoutingCurr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint RoutingNext;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiKeyRoutingData(short nextEntryIndex = default, ushort mods = default, byte routingNextScore = default, uint routingCurr = default, uint routingNext = default)
		{
			NextEntryIndex = nextEntryIndex;
			Mods = mods;
			RoutingNextScore = routingNextScore;
			RoutingCurr = routingCurr;
			RoutingNext = routingNext;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextItemData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ItemFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Width;

		/// <summary>
		/// To be documented.
		/// </summary>
		public long SelectionUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int OpenCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte OpenVal;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiNextItemData(int flags = default, int itemFlags = default, float width = default, long selectionUserData = default, int openCond = default, bool openVal = default)
		{
			Flags = flags;
			ItemFlags = itemFlags;
			Width = width;
			SelectionUserData = selectionUserData;
			OpenCond = openCond;
			OpenVal = openVal ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextWindowData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int PosCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SizeCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CollapsedCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DockCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 PosVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 PosPivotVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SizeVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ContentSizeVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ScrollVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PosUndock;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CollapsedVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect SizeConstraintRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* SizeCallback;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* SizeCallbackUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BgAlphaVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ViewportId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DockId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiWindowClass WindowClass;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MenuBarOffsetMinVal;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiNextWindowData(int flags = default, int posCond = default, int sizeCond = default, int collapsedCond = default, int dockCond = default, Vector2 posVal = default, Vector2 posPivotVal = default, Vector2 sizeVal = default, Vector2 contentSizeVal = default, Vector2 scrollVal = default, bool posUndock = default, bool collapsedVal = default, ImRect sizeConstraintRect = default, delegate*<void> sizeCallback = default, void* sizeCallbackUserData = default, float bgAlphaVal = default, uint viewportId = default, uint dockId = default, ImGuiWindowClass windowClass = default, Vector2 menuBarOffsetMinVal = default)
		{
			Flags = flags;
			PosCond = posCond;
			SizeCond = sizeCond;
			CollapsedCond = collapsedCond;
			DockCond = dockCond;
			PosVal = posVal;
			PosPivotVal = posPivotVal;
			SizeVal = sizeVal;
			ContentSizeVal = contentSizeVal;
			ScrollVal = scrollVal;
			PosUndock = posUndock ? (byte)1 : (byte)0;
			CollapsedVal = collapsedVal ? (byte)1 : (byte)0;
			SizeConstraintRect = sizeConstraintRect;
			SizeCallback = (void*)sizeCallback;
			SizeCallbackUserData = sizeCallbackUserData;
			BgAlphaVal = bgAlphaVal;
			ViewportId = viewportId;
			DockId = dockId;
			WindowClass = windowClass;
			MenuBarOffsetMinVal = menuBarOffsetMinVal;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiColorMod
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiColorMod* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiColorMod(int size = default, int capacity = default, ImGuiColorMod* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiColorMod
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Col;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 BackupValue;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiColorMod(int col = default, Vector4 backupValue = default)
		{
			Col = col;
			BackupValue = backupValue;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStyleMod
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiStyleMod* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiStyleMod(int size = default, int capacity = default, ImGuiStyleMod* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStyleMod
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		[StructLayout(LayoutKind.Explicit)]
		public partial struct ImGuiStyleModUnion
		{
			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public int BackupInt_0;
			[FieldOffset(8)]
			public int BackupInt_1;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public float BackupFloat_0;
			[FieldOffset(8)]
			public float BackupFloat_1;


			/// <summary>/// To be documented./// </summary>			public unsafe ImGuiStyleModUnion(int* backupInt = default, float* backupFloat = default)
			{
				if (backupInt != default)
				{
					BackupInt_0 = backupInt[0];
					BackupInt_1 = backupInt[1];
				}
				if (backupFloat != default)
				{
					BackupFloat_0 = backupFloat[0];
					BackupFloat_1 = backupFloat[1];
				}
			}

			/// <summary>/// To be documented./// </summary>			public unsafe ImGuiStyleModUnion(Span<int> backupInt = default, Span<float> backupFloat = default)
			{
				if (backupInt != default)
				{
					BackupInt_0 = backupInt[0];
					BackupInt_1 = backupInt[1];
				}
				if (backupFloat != default)
				{
					BackupFloat_0 = backupFloat[0];
					BackupFloat_1 = backupFloat[1];
				}
			}


			/// <summary>
			/// To be documented.
			/// </summary>
			/// <summary>
			/// To be documented.
			/// </summary>
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public int VarIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public  ;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiStyleMod(int varIdx = default,   = default)
		{
			VarIdx = varIdx;
			this. = ;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiItemFlags
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe int* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiItemFlags(int size = default, int capacity = default, int* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiGroupData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiGroupData* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiGroupData(int size = default, int capacity = default, ImGuiGroupData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiGroupData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint WindowID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorMaxPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorPosPrevLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 BackupIndent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 BackupGroupOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCurrLineSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BackupCurrLineTextBaseOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint BackupActiveIdIsAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BackupActiveIdPreviousFrameIsAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BackupHoveredIdIsAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BackupIsSameLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte EmitItem;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiGroupData(uint windowId = default, Vector2 backupCursorPos = default, Vector2 backupCursorMaxPos = default, Vector2 backupCursorPosPrevLine = default, ImVec1 backupIndent = default, ImVec1 backupGroupOffset = default, Vector2 backupCurrLineSize = default, float backupCurrLineTextBaseOffset = default, uint backupActiveIdIsAlive = default, bool backupActiveIdPreviousFrameIsAlive = default, bool backupHoveredIdIsAlive = default, bool backupIsSameLine = default, bool emitItem = default)
		{
			WindowID = windowId;
			BackupCursorPos = backupCursorPos;
			BackupCursorMaxPos = backupCursorMaxPos;
			BackupCursorPosPrevLine = backupCursorPosPrevLine;
			BackupIndent = backupIndent;
			BackupGroupOffset = backupGroupOffset;
			BackupCurrLineSize = backupCurrLineSize;
			BackupCurrLineTextBaseOffset = backupCurrLineTextBaseOffset;
			BackupActiveIdIsAlive = backupActiveIdIsAlive;
			BackupActiveIdPreviousFrameIsAlive = backupActiveIdPreviousFrameIsAlive ? (byte)1 : (byte)0;
			BackupHoveredIdIsAlive = backupHoveredIdIsAlive ? (byte)1 : (byte)0;
			BackupIsSameLine = backupIsSameLine ? (byte)1 : (byte)0;
			EmitItem = emitItem ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPopupData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiPopupData* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiPopupData(int size = default, int capacity = default, ImGuiPopupData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPopupData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint PopupId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* BackupNavWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ParentNavLayer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int OpenFrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint OpenParentId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 OpenPopupPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 OpenMousePos;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiPopupData(uint popupId = default, ImGuiWindow* window = default, ImGuiWindow* backupNavWindow = default, int parentNavLayer = default, int openFrameCount = default, uint openParentId = default, Vector2 openPopupPos = default, Vector2 openMousePos = default)
		{
			PopupId = popupId;
			Window = window;
			BackupNavWindow = backupNavWindow;
			ParentNavLayer = parentNavLayer;
			OpenFrameCount = openFrameCount;
			OpenParentId = openParentId;
			OpenPopupPos = openPopupPos;
			OpenMousePos = openMousePos;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiNavTreeNodeData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiNavTreeNodeData* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiNavTreeNodeData(int size = default, int capacity = default, ImGuiNavTreeNodeData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNavTreeNodeData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int InFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect NavRect;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiNavTreeNodeData(uint id = default, int inFlags = default, ImRect navRect = default)
		{
			ID = id;
			InFlags = inFlags;
			NavRect = navRect;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiViewportPPtr
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiViewportP** Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiViewportPPtr(int size = default, int capacity = default, ImGuiViewportP** data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNavItemData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint FocusScopeId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect RectRel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int InFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public long SelectionUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DistBox;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DistCenter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DistAxial;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiNavItemData(ImGuiWindow* window = default, uint id = default, uint focusScopeId = default, ImRect rectRel = default, int inFlags = default, long selectionUserData = default, float distBox = default, float distCenter = default, float distAxial = default)
		{
			Window = window;
			ID = id;
			FocusScopeId = focusScopeId;
			RectRel = rectRel;
			InFlags = inFlags;
			SelectionUserData = selectionUserData;
			DistBox = distBox;
			DistCenter = distCenter;
			DistAxial = distAxial;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPayload
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* Data;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DataSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint SourceId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint SourceParentId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DataFrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DataType_0;
		public byte DataType_1;
		public byte DataType_2;
		public byte DataType_3;
		public byte DataType_4;
		public byte DataType_5;
		public byte DataType_6;
		public byte DataType_7;
		public byte DataType_8;
		public byte DataType_9;
		public byte DataType_10;
		public byte DataType_11;
		public byte DataType_12;
		public byte DataType_13;
		public byte DataType_14;
		public byte DataType_15;
		public byte DataType_16;
		public byte DataType_17;
		public byte DataType_18;
		public byte DataType_19;
		public byte DataType_20;
		public byte DataType_21;
		public byte DataType_22;
		public byte DataType_23;
		public byte DataType_24;
		public byte DataType_25;
		public byte DataType_26;
		public byte DataType_27;
		public byte DataType_28;
		public byte DataType_29;
		public byte DataType_30;
		public byte DataType_31;
		public byte DataType_32;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Preview;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Delivery;



		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiPayload(void* data = default, int dataSize = default, uint sourceId = default, uint sourceParentId = default, int dataFrameCount = default, byte* dataType = default, bool preview = default, bool delivery = default)
		{
			Data = data;
			DataSize = dataSize;
			SourceId = sourceId;
			SourceParentId = sourceParentId;
			DataFrameCount = dataFrameCount;
			if (dataType != default)
			{
				DataType_0 = dataType[0];
				DataType_1 = dataType[1];
				DataType_2 = dataType[2];
				DataType_3 = dataType[3];
				DataType_4 = dataType[4];
				DataType_5 = dataType[5];
				DataType_6 = dataType[6];
				DataType_7 = dataType[7];
				DataType_8 = dataType[8];
				DataType_9 = dataType[9];
				DataType_10 = dataType[10];
				DataType_11 = dataType[11];
				DataType_12 = dataType[12];
				DataType_13 = dataType[13];
				DataType_14 = dataType[14];
				DataType_15 = dataType[15];
				DataType_16 = dataType[16];
				DataType_17 = dataType[17];
				DataType_18 = dataType[18];
				DataType_19 = dataType[19];
				DataType_20 = dataType[20];
				DataType_21 = dataType[21];
				DataType_22 = dataType[22];
				DataType_23 = dataType[23];
				DataType_24 = dataType[24];
				DataType_25 = dataType[25];
				DataType_26 = dataType[26];
				DataType_27 = dataType[27];
				DataType_28 = dataType[28];
				DataType_29 = dataType[29];
				DataType_30 = dataType[30];
				DataType_31 = dataType[31];
				DataType_32 = dataType[32];
			}
			Preview = preview ? (byte)1 : (byte)0;
			Delivery = delivery ? (byte)1 : (byte)0;
		}

		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiPayload(void* data = default, int dataSize = default, uint sourceId = default, uint sourceParentId = default, int dataFrameCount = default, Span<byte> dataType = default, bool preview = default, bool delivery = default)
		{
			Data = data;
			DataSize = dataSize;
			SourceId = sourceId;
			SourceParentId = sourceParentId;
			DataFrameCount = dataFrameCount;
			if (dataType != default)
			{
				DataType_0 = dataType[0];
				DataType_1 = dataType[1];
				DataType_2 = dataType[2];
				DataType_3 = dataType[3];
				DataType_4 = dataType[4];
				DataType_5 = dataType[5];
				DataType_6 = dataType[6];
				DataType_7 = dataType[7];
				DataType_8 = dataType[8];
				DataType_9 = dataType[9];
				DataType_10 = dataType[10];
				DataType_11 = dataType[11];
				DataType_12 = dataType[12];
				DataType_13 = dataType[13];
				DataType_14 = dataType[14];
				DataType_15 = dataType[15];
				DataType_16 = dataType[16];
				DataType_17 = dataType[17];
				DataType_18 = dataType[18];
				DataType_19 = dataType[19];
				DataType_20 = dataType[20];
				DataType_21 = dataType[21];
				DataType_22 = dataType[22];
				DataType_23 = dataType[23];
				DataType_24 = dataType[24];
				DataType_25 = dataType[25];
				DataType_26 = dataType[26];
				DataType_27 = dataType[27];
				DataType_28 = dataType[28];
				DataType_29 = dataType[29];
				DataType_30 = dataType[30];
				DataType_31 = dataType[31];
				DataType_32 = dataType[32];
			}
			Preview = preview ? (byte)1 : (byte)0;
			Delivery = delivery ? (byte)1 : (byte)0;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Clear()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool IsDataType( byte* type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsDataTypeNative(@this, type);
				return ret != 0;
			}
		}

		public unsafe bool IsDataType( ref byte type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				fixed (byte* ptype = &type)
				{
					byte ret = ImGui.IsDataTypeNative(@this, (byte*)ptype);
					return ret != 0;
				}
			}
		}

		public unsafe bool IsDataType( string type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.IsDataTypeNative(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool IsDelivery()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsDeliveryNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsPreview()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsPreviewNative(@this);
				return ret != 0;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorUnsignedChar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorUnsignedChar(int size = default, int capacity = default, byte* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiListClipperData* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiListClipperData(int size = default, int capacity = default, ImGuiListClipperData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiListClipper* ListClipper;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LossynessOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int StepNo;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ItemsFrozen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiListClipperRange Ranges;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiListClipperData(ImGuiListClipper* listClipper = default, float lossynessOffset = default, int stepNo = default, int itemsFrozen = default, ImVectorImGuiListClipperRange ranges = default)
		{
			ListClipper = listClipper;
			LossynessOffset = lossynessOffset;
			StepNo = stepNo;
			ItemsFrozen = itemsFrozen;
			Ranges = ranges;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipper
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DisplayStart;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DisplayEnd;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ItemsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ItemsHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float StartPosY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* TempData;



		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiListClipper(ImGuiContext* ctx = default, int displayStart = default, int displayEnd = default, int itemsCount = default, float itemsHeight = default, float startPosY = default, void* tempData = default)
		{
			Ctx = ctx;
			DisplayStart = displayStart;
			DisplayEnd = displayEnd;
			ItemsCount = itemsCount;
			ItemsHeight = itemsHeight;
			StartPosY = startPosY;
			TempData = tempData;
		}


		public unsafe void Begin( int itemsCount,  float itemsHeight)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.BeginNative(@this, itemsCount, itemsHeight);
			}
		}

		public unsafe void Begin( int itemsCount)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.BeginNative(@this, itemsCount, (float)(-1.0f));
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void End()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.EndNative(@this);
			}
		}

		public unsafe void IncludeItemByIndex( int itemIndex)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.IncludeItemByIndexNative(@this, itemIndex);
			}
		}

		public unsafe void IncludeItemsByIndex( int itemBegin,  int itemEnd)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.IncludeItemsByIndexNative(@this, itemBegin, itemEnd);
			}
		}

		public unsafe bool Step()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				byte ret = ImGui.StepNative(@this);
				return ret != 0;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperRange
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiListClipperRange* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImGuiListClipperRange(int size = default, int capacity = default, ImGuiListClipperRange* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperRange
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Min;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Max;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PosToIndexConvert;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PosToIndexOffsetMin;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PosToIndexOffsetMax;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiListClipperRange(int min = default, int max = default, bool posToIndexConvert = default, byte posToIndexOffsetMin = default, byte posToIndexOffsetMax = default)
		{
			Min = min;
			Max = max;
			PosToIndexConvert = posToIndexConvert ? (byte)1 : (byte)0;
			PosToIndexOffsetMin = posToIndexOffsetMin;
			PosToIndexOffsetMax = posToIndexOffsetMax;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTable
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* RawData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableTempData* TempData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImSpanImGuiTableColumn Columns;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImSpanImGuiTableColumnIdx DisplayOrderToIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImSpanImGuiTableCellData RowCellData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe uint* EnabledMaskByDisplayOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe uint* EnabledMaskByIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe uint* VisibleMaskByIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SettingsLoadedFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SettingsOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ColumnsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurrentRow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurrentColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short InstanceCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short InstanceInteracted;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowPosY1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowPosY2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowMinHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowCellPaddingY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowTextBaseline;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowIndentOffsetX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int RowFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastRowFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int RowBgColorCounter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint RowBgColor_0;
		public uint RowBgColor_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint BorderColorStrong;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint BorderColorLight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BorderX1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BorderX2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HostIndentX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MinColumnWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float OuterPaddingX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CellPaddingX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CellSpacingX1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CellSpacingX2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float InnerWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ColumnsGivenWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ColumnsAutoFitWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ColumnsStretchSumWeights;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ResizedColumnNextWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ResizeLockMinContentsX2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RefScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float AngledHeadersHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float AngledHeadersSlope;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect OuterRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect InnerRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect WorkRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect InnerClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect BgClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect Bg0ClipRectForDrawCmd;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect Bg2ClipRectForDrawCmd;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostBackupInnerClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* OuterWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* InnerWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTextBuffer ColumnsNames;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawListSplitter* DrawSplitter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTableInstanceData InstanceDataFirst;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTableInstanceData InstanceDataExtra;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTableColumnSortSpecs SortSpecsSingle;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTableColumnSortSpecs SortSpecsMulti;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTableSortSpecs SortSpecs;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SortSpecsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ColumnsEnabledCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ColumnsEnabledFixedCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short DeclColumnsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short AngledHeadersCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short HoveredColumnBody;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short HoveredColumnBorder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short HighlightColumnHeader;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short AutoFitSingleColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ResizedColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short LastResizedColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short HeldHeaderColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ReorderColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ReorderColumnDir;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short LeftMostEnabledColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short RightMostEnabledColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short LeftMostStretchedColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short RightMostStretchedColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ContextPopupColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short FreezeRowsRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short FreezeRowsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short FreezeColumnsRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short FreezeColumnsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short RowCellDataCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort DummyDrawChannel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Bg2DrawChannelCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Bg2DrawChannelUnfrozen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsLayoutLocked;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsInsideRow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsInitializing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSortSpecsDirty;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsUsingHeaders;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsContextPopupOpen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSettingsRequestLoad;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSettingsDirty;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsDefaultDisplayOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsResetAllRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsResetDisplayOrderRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsUnfrozenRows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsDefaultSizingPolicy;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsActiveIdAliveBeforeTable;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsActiveIdInTable;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasScrollbarYCurr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasScrollbarYPrev;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte MemoryCompacted;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HostSkipItems;


		/// <summary>/// To be documented./// </summary>		public unsafe ImGuiTable(uint id = default, int flags = default, void* rawData = default, ImGuiTableTempData* tempData = default, ImSpanImGuiTableColumn columns = default, ImSpanImGuiTableColumnIdx displayOrderToIndex = default, ImSpanImGuiTableCellData rowCellData = default, uint* enabledMaskByDisplayOrder = default, uint* enabledMaskByIndex = default, uint* visibleMaskByIndex = default, int settingsLoadedFlags = default, int settingsOffset = default, int lastFrameActive = default, int columnsCount = default, int currentRow = default, int currentColumn = default, short instanceCurrent = default, short instanceInteracted = default, float rowPosY1 = default, float rowPosY2 = default, float rowMinHeight = default, float rowCellPaddingY = default, float rowTextBaseline = default, float rowIndentOffsetX = default, int rowFlags = default, int lastRowFlags = default, int rowBgColorCounter = default, uint* rowBgColor = default, uint borderColorStrong = default, uint borderColorLight = default, float borderX1 = default, float borderX2 = default, float hostIndentX = default, float minColumnWidth = default, float outerPaddingX = default, float cellPaddingX = default, float cellSpacingX1 = default, float cellSpacingX2 = default, float innerWidth = default, float columnsGivenWidth = default, float columnsAutoFitWidth = default, float columnsStretchSumWeights = default, float resizedColumnNextWidth = default, float resizeLockMinContentsX2 = default, float refScale = default, float angledHeadersHeight = default, float angledHeadersSlope = default, ImRect outerRect = default, ImRect innerRect = default, ImRect workRect = default, ImRect innerClipRect = default, ImRect bgClipRect = default, ImRect bg0ClipRectForDrawCmd = default, ImRect bg2ClipRectForDrawCmd = default, ImRect hostClipRect = default, ImRect hostBackupInnerClipRect = default, ImGuiWindow* outerWindow = default, ImGuiWindow* innerWindow = default, ImGuiTextBuffer columnsNames = default, ImDrawListSplitter* drawSplitter = default, ImGuiTableInstanceData instanceDataFirst = default, ImVectorImGuiTableInstanceData instanceDataExtra = default, ImGuiTableColumnSortSpecs sortSpecsSingle = default, ImVectorImGuiTableColumnSortSpecs sortSpecsMulti = default, ImGuiTableSortSpecs sortSpecs = default, short sortSpecsCount = default, short columnsEnabledCount = default, short columnsEnabledFixedCount = default, short declColumnsCount = default, short angledHeadersCount = default, short hoveredColumnBody = default, short hoveredColumnBorder = default, short highlightColumnHeader = default, short autoFitSingleColumn = default, short resizedColumn = default, short lastResizedColumn = default, short heldHeaderColumn = default, short reorderColumn = default, short reorderColumnDir = default, short leftMostEnabledColumn = default, short rightMostEnabledColumn = default, short leftMostStretchedColumn = default, short rightMostStretchedColumn = default, short contextPopupColumn = default, short freezeRowsRequest = default, short freezeRowsCount = default, short freezeColumnsRequest = default, short freezeColumnsCount = default, short rowCellDataCurrent = default, ushort dummyDrawChannel = default, ushort bg2DrawChannelCurrent = default, ushort bg2DrawChannelUnfrozen = default, bool isLayoutLocked = default, bool isInsideRow = default, bool isInitializing = default, bool isSortSpecsDirty = default, bool isUsingHeaders = default, bool isContextPopupOpen = default, bool isSettingsRequestLoad = default, bool isSettingsDirty = default, bool isDefaultDisplayOrder = default, bool isResetAllRequest = default, bool isResetDisplayOrderRequest = default, bool isUnfrozenRows = default, bool isDefaultSizingPolicy = default, bool isActiveIdAliveBeforeTable = default, bool isActiveIdInTable = default, bool hasScrollbarYCurr = default, bool hasScrollbarYPrev = default, bool memoryCompacted = default, bool hostSkipItems = default)
		{
			ID = id;
			Flags = flags;
			RawData = rawData;
			TempData = tempData;
			Columns = columns;
			DisplayOrderToIndex = displayOrderToIndex;
			RowCellData = rowCellData;
			EnabledMaskByDisplayOrder = enabledMaskByDisplayOrder;
			EnabledMaskByIndex = enabledMaskByIndex;
			VisibleMaskByIndex = visibleMaskByIndex;
			SettingsLoadedFlags = settingsLoadedFlags;
			SettingsOffset = settingsOffset;
			LastFrameActive = lastFrameActive;
			ColumnsCount = columnsCount;
			CurrentRow = currentRow;
			CurrentColumn = currentColumn;
			InstanceCurrent = instanceCurrent;
			InstanceInteracted = instanceInteracted;
			RowPosY1 = rowPosY1;
			RowPosY2 = rowPosY2;
			RowMinHeight = rowMinHeight;
			RowCellPaddingY = rowCellPaddingY;
			RowTextBaseline = rowTextBaseline;
			RowIndentOffsetX = rowIndentOffsetX;
			RowFlags = rowFlags;
			LastRowFlags = lastRowFlags;
			RowBgColorCounter = rowBgColorCounter;
			if (rowBgColor != default)
			{
				RowBgColor_0 = rowBgColor[0];
				RowBgColor_1 = rowBgColor[1];
			}
			BorderColorStrong = borderColorStrong;
			BorderColorLight = borderColorLight;
			BorderX1 = borderX1;
			BorderX2 = borderX2;
			HostIndentX = hostIndentX;
			MinColumnWidth = minColumnWidth;
			OuterPaddingX = outerPaddingX;
			CellPaddingX = cellPaddingX;
			CellSpacingX1 = cellSpacingX1;
			CellSpacingX2 = cellSpacingX2;
			InnerWidth = innerWidth;
			ColumnsGivenWidth = columnsGivenWidth;
			ColumnsAutoFitWidth = columnsAutoFitWidth;
			ColumnsStretchSumWeights = columnsStretchSumWeights;
			ResizedColumnNextWidth = resizedColumnNextWidth;
			ResizeLockMinContentsX2 = resizeLockMinContentsX2;
			RefScale = refScale;
			AngledHeadersHeight = angledHeadersHeight;
			AngledHeadersSlope = angledHeadersSlope;
			OuterRect = outerRect;
			InnerRect = innerRect;
			WorkRect = workRect;
			InnerClipRect = innerClipRect;
			BgClipRect = bgClipRect;
			Bg0ClipRectForDrawCmd = bg0ClipRectForDrawCmd;
			Bg2ClipRectForDrawCmd = bg2ClipRectForDrawCmd;
			HostClipRect = hostClipRect;
			HostBackupInnerClipRect = hostBackupInnerClipRect;
			OuterWindow = outerWindow;
			InnerWindow = innerWindow;
			ColumnsNames = columnsNames;
			DrawSplitter = drawSplitter;
			InstanceDataFirst = instanceDataFirst;
			InstanceDataExtra = instanceDataExtra;
			SortSpecsSingle = sortSpecsSingle;
			SortSpecsMulti = sortSpecsMulti;
			SortSpecs = sortSpecs;
			SortSpecsCount = sortSpecsCount;
			ColumnsEnabledCount = columnsEnabledCount;
			ColumnsEnabledFixedCount = columnsEnabledFixedCount;
			DeclColumnsCount = declColumnsCount;
			AngledHeadersCount = angledHeadersCount;
			HoveredColumnBody = hoveredColumnBody;
			HoveredColumnBorder = hoveredColumnBorder;
			HighlightColumnHeader = highlightColumnHeader;
			AutoFitSingleColumn = autoFitSingleColumn;
			ResizedColumn = resizedColumn;
			LastResizedColumn = lastResizedColumn;
			HeldHeaderColumn = heldHeaderColumn;
			ReorderColumn = reorderColumn;
			ReorderColumnDir = reorderColumnDir;
			LeftMostEnabledColumn = leftMostEnabledColumn;
			RightMostEnabledColumn = rightMostEnabledColumn;
			LeftMostStretchedColumn = leftMostStretchedColumn;
			RightMostStretchedColumn = rightMostStretchedColumn;
			ContextPopupColumn = contextPopupColumn;
			FreezeRowsRequest = freezeRowsRequest;
			FreezeRowsCount = freezeRowsCount;
			FreezeColumnsRequest = freezeColumnsRequest;
			FreezeColumnsCount = freezeColumnsCount;
			RowCellDataCurrent = rowCellDataCurrent;
			DummyDrawChannel = dummyDrawChannel;
			Bg2DrawChannelCurrent = bg2DrawChannelCurrent;
			Bg2DrawChannelUnfrozen = bg2DrawChannelUnfrozen;
			IsLayoutLocked = isLayoutLocked ? (byte)1 : (byte)0;
			IsInsideRow = isInsideRow ? (byte)1 : (byte)0;
			IsInitializing = isInitializing ? (byte)1 : (byte)0;
			IsSortSpecsDirty = isSortSpecsDirty ? (byte)1 : (byte)0;
			IsUsingHeaders = isUsingHeaders ? (byte)1 : (byte)0;
			IsContextPopupOpen = isContextPopupOpen ? (byte)1 : (byte)0;
			IsSettingsRequestLoad = isSettingsRequestLoad ? (byte)1 : (byte)0;
			IsSettingsDirty = isSettingsDirty ? (byte)1 : (byte)0;
			IsDefaultDisplayOrder = isDefaultDisplayOrder ? (byte)1 : (byte)0;
			IsResetAllRequest = isResetAllRequest ? (byte)1 : (byte)0;
			IsResetDisplayOrderRequest = isResetDisplayOrderRequest ? (byte)1 : (byte)0;
			IsUnfrozenRows = isUnfrozenRows ? (byte)1 : (byte)0;
			IsDefaultSizingPolicy = isDefaultSizingPolicy ? (byte)1 : (byte)0;
			IsActiveIdAliveBeforeTable = isActiveIdAliveBeforeTable ? (byte)1 : (byte)0;
			IsActiveIdInTable = isActiveIdInTable ? (byte)1 : (byte)0;
			HasScrollbarYCurr = hasScrollbarYCurr ? (byte)1 : (byte)0;
			HasScrollbarYPrev = hasScrollbarYPrev ? (byte)1 : (byte)0;
			MemoryCompacted = memoryCompacted ? (byte)1 : (byte)0;
			HostSkipItems = hostSkipItems ? (byte)1 : (byte)0;
		}
	}
}
