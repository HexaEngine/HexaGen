// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawChannel
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawCmd CmdBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawIdx IdxBuffer;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawChannel(ImVectorImDrawCmd Cmdbuffer = default, ImVectorImDrawIdx Idxbuffer = default)
		{
			CmdBuffer = Cmdbuffer;
			IdxBuffer = Idxbuffer;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawCmd
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawCmd* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImDrawCmd(int size = default, int capacity = default, ImDrawCmd* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawCmd
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 ClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImTextureID TextureId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint VtxOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint IdxOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ElemCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserCallback;
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserCallbackData;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawCmd(Vector4 clipRect = default, ImTextureID textureId = default, uint vtxOffset = default, uint idxOffset = default, uint elemCount = default, ImDrawCallback userCallback = default, void* userCallbackData = default)
		{
			ClipRect = clipRect;
			TextureId = textureId;
			VtxOffset = vtxOffset;
			IdxOffset = idxOffset;
			ElemCount = elemCount;
			UserCallback = (void*)Marshal.GetFunctionPointerForDelegate(userCallback);
			UserCallbackData = userCallbackData;
		}


		public unsafe void Destroy()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImTextureID GetTexID()
		{
			fixed (ImDrawCmd* @this = &this)
			{
				ImTextureID ret = ImGui.GetTexIDNative(@this);
				return ret;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawList
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawCmd CmdBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawIdx IdxBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawVert VtxBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint VtxCurrentIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawListSharedData* Data;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* OwnerName;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawVert* VtxWritePtr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ushort* IdxWritePtr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImVec4 ClipRectStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImTextureID TextureIdStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImVec2 Path;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawCmdHeader CmdHeader;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawListSplitter Splitter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FringeScale;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawList(ImVectorImDrawCmd cmdBuffer = default, ImVectorImDrawIdx idxBuffer = default, ImVectorImDrawVert vtxBuffer = default, int flags = default, uint Vtxcurrentidx = default, ImDrawListSharedData* Data = default, byte* Ownername = default, ImDrawVert* Vtxwriteptr = default, ushort* Idxwriteptr = default, ImVectorImVec4 Cliprectstack = default, ImVectorImTextureID Textureidstack = default, ImVectorImVec2 Path = default, ImDrawCmdHeader Cmdheader = default, ImDrawListSplitter Splitter = default, float Fringescale = default)
		{
			CmdBuffer = cmdBuffer;
			IdxBuffer = idxBuffer;
			VtxBuffer = vtxBuffer;
			Flags = flags;
			VtxCurrentIdx = Vtxcurrentidx;
			this.Data = Data;
			OwnerName = Ownername;
			VtxWritePtr = Vtxwriteptr;
			IdxWritePtr = Idxwriteptr;
			ClipRectStack = Cliprectstack;
			TextureIdStack = Textureidstack;
			this.Path = Path;
			CmdHeader = Cmdheader;
			this.Splitter = Splitter;
			FringeScale = Fringescale;
		}


		public unsafe int _CalcCircleAutoSegmentCount( float radius)
		{
			fixed (ImDrawList* @this = &this)
			{
				int ret = ImGui._CalcCircleAutoSegmentCountNative(@this, radius);
				return ret;
			}
		}

		public unsafe void _ClearFreeMemory()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void _OnChangedClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedClipRectNative(@this);
			}
		}

		public unsafe void _OnChangedTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedTextureIDNative(@this);
			}
		}

		public unsafe void _OnChangedVtxOffset()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._OnChangedVtxOffsetNative(@this);
			}
		}

		public unsafe void _PathArcToFastEx( Vector2 center,  float radius,  int aMinSample,  int aMaxSample,  int aStep)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToFastExNative(@this, center, radius, aMinSample, aMaxSample, aStep);
			}
		}

		public unsafe void _PathArcToN( Vector2 center,  float radius,  float aMin,  float aMax,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PathArcToNNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void _PopUnusedDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._PopUnusedDrawCmdNative(@this);
			}
		}

		public unsafe void _ResetForNewFrame()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._ResetForNewFrameNative(@this);
			}
		}

		public unsafe void _TryMergeDrawCmds()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui._TryMergeDrawCmdsNative(@this);
			}
		}

		public unsafe void AddBezierCubic( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col,  float thickness,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, numSegments);
			}
		}

		public unsafe void AddBezierCubic( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierCubicNative(@this, p1, p2, p3, p4, col, thickness, (int)(0));
			}
		}

		public unsafe void AddBezierQuadratic( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col,  float thickness,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, numSegments);
			}
		}

		public unsafe void AddBezierQuadratic( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddBezierQuadraticNative(@this, p1, p2, p3, col, thickness, (int)(0));
			}
		}

		public unsafe void AddCallback( ImDrawCallback callback,  void* callbackData)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCallbackNative(@this, callback, callbackData);
			}
		}

		public unsafe void AddCircle( Vector2 center,  float radius,  uint col,  int numSegments,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddCircle( Vector2 center,  float radius,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddCircle( Vector2 center,  float radius,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddCircle( Vector2 center,  float radius,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleNative(@this, center, radius, col, (int)(0), thickness);
			}
		}

		public unsafe void AddCircleFilled( Vector2 center,  float radius,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddCircleFilled( Vector2 center,  float radius,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddCircleFilledNative(@this, center, radius, col, (int)(0));
			}
		}

		public unsafe void AddConvexPolyFilled( Vector2* points,  int numPoints,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddConvexPolyFilledNative(@this, points, numPoints, col);
			}
		}

		public unsafe void AddConvexPolyFilled( ref Vector2 points,  int numPoints,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddConvexPolyFilledNative(@this, (Vector2*)ppoints, numPoints, col);
				}
			}
		}

		public unsafe void AddDrawCmd()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddDrawCmdNative(@this);
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot,  int numSegments,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, rot, numSegments, thickness);
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, rot, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, rot, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, (float)(0.0f), (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, (float)(0.0f), numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, rot, (int)(0), thickness);
			}
		}

		public unsafe void AddEllipse( Vector2 center,  float radiusX,  float radiusY,  uint col,  int numSegments,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseNative(@this, center, radiusX, radiusY, col, (float)(0.0f), numSegments, thickness);
			}
		}

		public unsafe void AddEllipseFilled( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseFilledNative(@this, center, radiusX, radiusY, col, rot, numSegments);
			}
		}

		public unsafe void AddEllipseFilled( Vector2 center,  float radiusX,  float radiusY,  uint col,  float rot)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseFilledNative(@this, center, radiusX, radiusY, col, rot, (int)(0));
			}
		}

		public unsafe void AddEllipseFilled( Vector2 center,  float radiusX,  float radiusY,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseFilledNative(@this, center, radiusX, radiusY, col, (float)(0.0f), (int)(0));
			}
		}

		public unsafe void AddEllipseFilled( Vector2 center,  float radiusX,  float radiusY,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddEllipseFilledNative(@this, center, radiusX, radiusY, col, (float)(0.0f), numSegments);
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  Vector2 uvMax,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col);
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  Vector2 uvMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, (uint)(4294967295));
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, uvMin, (Vector2)(new Vector2(1,1)), col);
			}
		}

		public unsafe void AddImage( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageNative(@this, userTextureId, pMin, pMax, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,1)), col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  Vector2 uv3,  Vector2 uv4,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  Vector2 uv3,  Vector2 uv4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, uv4, (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  Vector2 uv3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), (uint)(4294967295));
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  Vector2 uv3,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, uv3, (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  Vector2 uv2,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, uv2, (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  Vector2 uv1,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, uv1, (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageQuad( ImTextureID userTextureId,  Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageQuadNative(@this, userTextureId, p1, p2, p3, p4, (Vector2)(new Vector2(0,0)), (Vector2)(new Vector2(1,0)), (Vector2)(new Vector2(1,1)), (Vector2)(new Vector2(0,1)), col);
			}
		}

		public unsafe void AddImageRounded( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  Vector2 uvMax,  uint col,  float rounding,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, flags);
			}
		}

		public unsafe void AddImageRounded( ImTextureID userTextureId,  Vector2 pMin,  Vector2 pMax,  Vector2 uvMin,  Vector2 uvMax,  uint col,  float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddImageRoundedNative(@this, userTextureId, pMin, pMax, uvMin, uvMax, col, rounding, (int)(0));
			}
		}

		public unsafe void AddLine( Vector2 p1,  Vector2 p2,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, thickness);
			}
		}

		public unsafe void AddLine( Vector2 p1,  Vector2 p2,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddLineNative(@this, p1, p2, col, (float)(1.0f));
			}
		}

		public unsafe void AddNgon( Vector2 center,  float radius,  uint col,  int numSegments,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, thickness);
			}
		}

		public unsafe void AddNgon( Vector2 center,  float radius,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonNative(@this, center, radius, col, numSegments, (float)(1.0f));
			}
		}

		public unsafe void AddNgonFilled( Vector2 center,  float radius,  uint col,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddNgonFilledNative(@this, center, radius, col, numSegments);
			}
		}

		public unsafe void AddPolyline( Vector2* points,  int numPoints,  uint col,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddPolylineNative(@this, points, numPoints, col, flags, thickness);
			}
		}

		public unsafe void AddPolyline( ref Vector2 points,  int numPoints,  uint col,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector2* ppoints = &points)
				{
					ImGui.AddPolylineNative(@this, (Vector2*)ppoints, numPoints, col, flags, thickness);
				}
			}
		}

		public unsafe void AddQuad( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, thickness);
			}
		}

		public unsafe void AddQuad( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadNative(@this, p1, p2, p3, p4, col, (float)(1.0f));
			}
		}

		public unsafe void AddQuadFilled( Vector2 p1,  Vector2 p2,  Vector2 p3,  Vector2 p4,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddQuadFilledNative(@this, p1, p2, p3, p4, col);
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, thickness);
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, flags, (float)(1.0f));
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), (int)(0), (float)(1.0f));
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, (float)(1.0f));
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, rounding, (int)(0), thickness);
			}
		}

		public unsafe void AddRect( Vector2 pMin,  Vector2 pMax,  uint col,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectNative(@this, pMin, pMax, col, (float)(0.0f), flags, thickness);
			}
		}

		public unsafe void AddRectFilled( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, flags);
			}
		}

		public unsafe void AddRectFilled( Vector2 pMin,  Vector2 pMax,  uint col,  float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, rounding, (int)(0));
			}
		}

		public unsafe void AddRectFilled( Vector2 pMin,  Vector2 pMax,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), (int)(0));
			}
		}

		public unsafe void AddRectFilled( Vector2 pMin,  Vector2 pMax,  uint col,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledNative(@this, pMin, pMax, col, (float)(0.0f), flags);
			}
		}

		public unsafe void AddRectFilledMultiColor( Vector2 pMin,  Vector2 pMax,  uint colUprLeft,  uint colUprRight,  uint colBotRight,  uint colBotLeft)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddRectFilledMultiColorNative(@this, pMin, pMax, colUprLeft, colUprRight, colBotRight, colBotLeft);
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, textEnd);
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)(default));
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, textEnd);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)(default));
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  string textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, pos, col, textBegin, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  byte* textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, textBegin, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, pos, col, (byte*)ptextBegin, (byte*)ptextEnd);
					}
				}
			}
		}

		public unsafe void AddText( Vector2 pos,  uint col,  string textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, pos, col, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), cpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)(default));
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)(default));
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)(default));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  Vector4* cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), cpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  byte* textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, textEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, (byte*)(default), wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  ref byte textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  byte* textBegin,  string textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, textBegin, pStr0, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
						{
							ImGui.AddTextNative(@this, font, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						}
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ImFont* font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
				{
					ImGui.AddTextNative(@this, font, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  ref byte textBegin,  ref byte textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
							{
								ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (Vector4*)pcpuFineClipRect);
							}
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  float wrapWidth,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, wrapWidth, (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddText( ref ImFont font,  float fontSize,  Vector2 pos,  uint col,  string textBegin,  string textEnd,  ref Vector4 cpuFineClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					fixed (Vector4* pcpuFineClipRect = &cpuFineClipRect)
					{
						ImGui.AddTextNative(@this, (ImFont*)pfont, fontSize, pos, col, pStr0, pStr1, (float)(0.0f), (Vector4*)pcpuFineClipRect);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr1);
						}
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
					}
				}
			}
		}

		public unsafe void AddTriangle( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, thickness);
			}
		}

		public unsafe void AddTriangle( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleNative(@this, p1, p2, p3, col, (float)(1.0f));
			}
		}

		public unsafe void AddTriangleFilled( Vector2 p1,  Vector2 p2,  Vector2 p3,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.AddTriangleFilledNative(@this, p1, p2, p3, col);
			}
		}

		public unsafe void ChannelsMerge()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsMergeNative(@this);
			}
		}

		public unsafe void ChannelsSetCurrent( int n)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSetCurrentNative(@this, n);
			}
		}

		public unsafe void ChannelsSplit( int count)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.ChannelsSplitNative(@this, count);
			}
		}

		public unsafe ImDrawList* CloneOutput()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImDrawList* ret = ImGui.CloneOutputNative(@this);
				return ret;
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void PathArcTo( Vector2 center,  float radius,  float aMin,  float aMax,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, numSegments);
			}
		}

		public unsafe void PathArcTo( Vector2 center,  float radius,  float aMin,  float aMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToNative(@this, center, radius, aMin, aMax, (int)(0));
			}
		}

		public unsafe void PathArcToFast( Vector2 center,  float radius,  int aMinOf12,  int aMaxOf12)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathArcToFastNative(@this, center, radius, aMinOf12, aMaxOf12);
			}
		}

		public unsafe void PathBezierCubicCurveTo( Vector2 p2,  Vector2 p3,  Vector2 p4,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, numSegments);
			}
		}

		public unsafe void PathBezierCubicCurveTo( Vector2 p2,  Vector2 p3,  Vector2 p4)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierCubicCurveToNative(@this, p2, p3, p4, (int)(0));
			}
		}

		public unsafe void PathBezierQuadraticCurveTo( Vector2 p2,  Vector2 p3,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, numSegments);
			}
		}

		public unsafe void PathBezierQuadraticCurveTo( Vector2 p2,  Vector2 p3)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathBezierQuadraticCurveToNative(@this, p2, p3, (int)(0));
			}
		}

		public unsafe void PathClear()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathClearNative(@this);
			}
		}

		public unsafe void PathEllipticalArcTo( Vector2 center,  float radiusX,  float radiusY,  float rot,  float aMin,  float aMax,  int numSegments)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathEllipticalArcToNative(@this, center, radiusX, radiusY, rot, aMin, aMax, numSegments);
			}
		}

		public unsafe void PathEllipticalArcTo( Vector2 center,  float radiusX,  float radiusY,  float rot,  float aMin,  float aMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathEllipticalArcToNative(@this, center, radiusX, radiusY, rot, aMin, aMax, (int)(0));
			}
		}

		public unsafe void PathFillConvex( uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathFillConvexNative(@this, col);
			}
		}

		public unsafe void PathLineTo( Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToNative(@this, pos);
			}
		}

		public unsafe void PathLineToMergeDuplicate( Vector2 pos)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathLineToMergeDuplicateNative(@this, pos);
			}
		}

		public unsafe void PathRect( Vector2 rectMin,  Vector2 rectMax,  float rounding,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, flags);
			}
		}

		public unsafe void PathRect( Vector2 rectMin,  Vector2 rectMax,  float rounding)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, rounding, (int)(0));
			}
		}

		public unsafe void PathRect( Vector2 rectMin,  Vector2 rectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), (int)(0));
			}
		}

		public unsafe void PathRect( Vector2 rectMin,  Vector2 rectMax,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathRectNative(@this, rectMin, rectMax, (float)(0.0f), flags);
			}
		}

		public unsafe void PathStroke( uint col,  int flags,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, thickness);
			}
		}

		public unsafe void PathStroke( uint col,  int flags)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, flags, (float)(1.0f));
			}
		}

		public unsafe void PathStroke( uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (int)(0), (float)(1.0f));
			}
		}

		public unsafe void PathStroke( uint col,  float thickness)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PathStrokeNative(@this, col, (int)(0), thickness);
			}
		}

		public unsafe void PopClipRect()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopClipRectNative(@this);
			}
		}

		public unsafe void PopTextureID()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PopTextureIDNative(@this);
			}
		}

		public unsafe void PrimQuadUV( Vector2 a,  Vector2 b,  Vector2 c,  Vector2 d,  Vector2 uvA,  Vector2 uvB,  Vector2 uvC,  Vector2 uvD,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimQuadUVNative(@this, a, b, c, d, uvA, uvB, uvC, uvD, col);
			}
		}

		public unsafe void PrimRect( Vector2 a,  Vector2 b,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectNative(@this, a, b, col);
			}
		}

		public unsafe void PrimRectUV( Vector2 a,  Vector2 b,  Vector2 uvA,  Vector2 uvB,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimRectUVNative(@this, a, b, uvA, uvB, col);
			}
		}

		public unsafe void PrimReserve( int idxCount,  int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimReserveNative(@this, idxCount, vtxCount);
			}
		}

		public unsafe void PrimUnreserve( int idxCount,  int vtxCount)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimUnreserveNative(@this, idxCount, vtxCount);
			}
		}

		public unsafe void PrimVtx( Vector2 pos,  Vector2 uv,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimVtxNative(@this, pos, uv, col);
			}
		}

		public unsafe void PrimWriteIdx( ushort idx)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteIdxNative(@this, idx);
			}
		}

		public unsafe void PrimWriteVtx( Vector2 pos,  Vector2 uv,  uint col)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PrimWriteVtxNative(@this, pos, uv, col);
			}
		}

		public unsafe void PushClipRect( Vector2 clipRectMin,  Vector2 clipRectMax,  bool intersectWithCurrentClipRect)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
			}
		}

		public unsafe void PushClipRect( Vector2 clipRectMin,  Vector2 clipRectMax)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectNative(@this, clipRectMin, clipRectMax, (byte)(0));
			}
		}

		public unsafe void PushClipRectFullScreen()
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushClipRectFullScreenNative(@this);
			}
		}

		public unsafe void PushTextureID( ImTextureID textureId)
		{
			fixed (ImDrawList* @this = &this)
			{
				ImGui.PushTextureIDNative(@this, textureId);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawIdx
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ushort* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImDrawIdx(int size = default, int capacity = default, ushort* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawVert
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawVert* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImDrawVert(int size = default, int capacity = default, ImDrawVert* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawVert
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Uv;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Col;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawVert(Vector2 pos = default, Vector2 uv = default, uint col = default)
		{
			Pos = pos;
			Uv = uv;
			Col = col;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawListSharedData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 TexUvWhitePixel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFont* Font;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FontSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CurveTessellationTol;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CircleSegmentMaxError;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 ClipRectFullscreen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int InitialFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImVec2 TempBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ArcFastVtx_0;
		public Vector2 ArcFastVtx_1;
		public Vector2 ArcFastVtx_2;
		public Vector2 ArcFastVtx_3;
		public Vector2 ArcFastVtx_4;
		public Vector2 ArcFastVtx_5;
		public Vector2 ArcFastVtx_6;
		public Vector2 ArcFastVtx_7;
		public Vector2 ArcFastVtx_8;
		public Vector2 ArcFastVtx_9;
		public Vector2 ArcFastVtx_10;
		public Vector2 ArcFastVtx_11;
		public Vector2 ArcFastVtx_12;
		public Vector2 ArcFastVtx_13;
		public Vector2 ArcFastVtx_14;
		public Vector2 ArcFastVtx_15;
		public Vector2 ArcFastVtx_16;
		public Vector2 ArcFastVtx_17;
		public Vector2 ArcFastVtx_18;
		public Vector2 ArcFastVtx_19;
		public Vector2 ArcFastVtx_20;
		public Vector2 ArcFastVtx_21;
		public Vector2 ArcFastVtx_22;
		public Vector2 ArcFastVtx_23;
		public Vector2 ArcFastVtx_24;
		public Vector2 ArcFastVtx_25;
		public Vector2 ArcFastVtx_26;
		public Vector2 ArcFastVtx_27;
		public Vector2 ArcFastVtx_28;
		public Vector2 ArcFastVtx_29;
		public Vector2 ArcFastVtx_30;
		public Vector2 ArcFastVtx_31;
		public Vector2 ArcFastVtx_32;
		public Vector2 ArcFastVtx_33;
		public Vector2 ArcFastVtx_34;
		public Vector2 ArcFastVtx_35;
		public Vector2 ArcFastVtx_36;
		public Vector2 ArcFastVtx_37;
		public Vector2 ArcFastVtx_38;
		public Vector2 ArcFastVtx_39;
		public Vector2 ArcFastVtx_40;
		public Vector2 ArcFastVtx_41;
		public Vector2 ArcFastVtx_42;
		public Vector2 ArcFastVtx_43;
		public Vector2 ArcFastVtx_44;
		public Vector2 ArcFastVtx_45;
		public Vector2 ArcFastVtx_46;
		public Vector2 ArcFastVtx_47;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ArcFastRadiusCutoff;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CircleSegmentCounts_0;
		public byte CircleSegmentCounts_1;
		public byte CircleSegmentCounts_2;
		public byte CircleSegmentCounts_3;
		public byte CircleSegmentCounts_4;
		public byte CircleSegmentCounts_5;
		public byte CircleSegmentCounts_6;
		public byte CircleSegmentCounts_7;
		public byte CircleSegmentCounts_8;
		public byte CircleSegmentCounts_9;
		public byte CircleSegmentCounts_10;
		public byte CircleSegmentCounts_11;
		public byte CircleSegmentCounts_12;
		public byte CircleSegmentCounts_13;
		public byte CircleSegmentCounts_14;
		public byte CircleSegmentCounts_15;
		public byte CircleSegmentCounts_16;
		public byte CircleSegmentCounts_17;
		public byte CircleSegmentCounts_18;
		public byte CircleSegmentCounts_19;
		public byte CircleSegmentCounts_20;
		public byte CircleSegmentCounts_21;
		public byte CircleSegmentCounts_22;
		public byte CircleSegmentCounts_23;
		public byte CircleSegmentCounts_24;
		public byte CircleSegmentCounts_25;
		public byte CircleSegmentCounts_26;
		public byte CircleSegmentCounts_27;
		public byte CircleSegmentCounts_28;
		public byte CircleSegmentCounts_29;
		public byte CircleSegmentCounts_30;
		public byte CircleSegmentCounts_31;
		public byte CircleSegmentCounts_32;
		public byte CircleSegmentCounts_33;
		public byte CircleSegmentCounts_34;
		public byte CircleSegmentCounts_35;
		public byte CircleSegmentCounts_36;
		public byte CircleSegmentCounts_37;
		public byte CircleSegmentCounts_38;
		public byte CircleSegmentCounts_39;
		public byte CircleSegmentCounts_40;
		public byte CircleSegmentCounts_41;
		public byte CircleSegmentCounts_42;
		public byte CircleSegmentCounts_43;
		public byte CircleSegmentCounts_44;
		public byte CircleSegmentCounts_45;
		public byte CircleSegmentCounts_46;
		public byte CircleSegmentCounts_47;
		public byte CircleSegmentCounts_48;
		public byte CircleSegmentCounts_49;
		public byte CircleSegmentCounts_50;
		public byte CircleSegmentCounts_51;
		public byte CircleSegmentCounts_52;
		public byte CircleSegmentCounts_53;
		public byte CircleSegmentCounts_54;
		public byte CircleSegmentCounts_55;
		public byte CircleSegmentCounts_56;
		public byte CircleSegmentCounts_57;
		public byte CircleSegmentCounts_58;
		public byte CircleSegmentCounts_59;
		public byte CircleSegmentCounts_60;
		public byte CircleSegmentCounts_61;
		public byte CircleSegmentCounts_62;
		public byte CircleSegmentCounts_63;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Vector4* TexUvLines;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawListSharedData(Vector2 texUvWhitePixel = default, ImFont* font = default, float fontSize = default, float curveTessellationTol = default, float circleSegmentMaxError = default, Vector4 clipRectFullscreen = default, int initialFlags = default, ImVectorImVec2 tempBuffer = default, Vector2* arcFastVtx = default, float arcFastRadiusCutoff = default, byte* circleSegmentCounts = default, Vector4* texUvLines = default)
		{
			TexUvWhitePixel = texUvWhitePixel;
			Font = font;
			FontSize = fontSize;
			CurveTessellationTol = curveTessellationTol;
			CircleSegmentMaxError = circleSegmentMaxError;
			ClipRectFullscreen = clipRectFullscreen;
			InitialFlags = initialFlags;
			TempBuffer = tempBuffer;
			if (arcFastVtx != default)
			{
				ArcFastVtx_0 = arcFastVtx[0];
				ArcFastVtx_1 = arcFastVtx[1];
				ArcFastVtx_2 = arcFastVtx[2];
				ArcFastVtx_3 = arcFastVtx[3];
				ArcFastVtx_4 = arcFastVtx[4];
				ArcFastVtx_5 = arcFastVtx[5];
				ArcFastVtx_6 = arcFastVtx[6];
				ArcFastVtx_7 = arcFastVtx[7];
				ArcFastVtx_8 = arcFastVtx[8];
				ArcFastVtx_9 = arcFastVtx[9];
				ArcFastVtx_10 = arcFastVtx[10];
				ArcFastVtx_11 = arcFastVtx[11];
				ArcFastVtx_12 = arcFastVtx[12];
				ArcFastVtx_13 = arcFastVtx[13];
				ArcFastVtx_14 = arcFastVtx[14];
				ArcFastVtx_15 = arcFastVtx[15];
				ArcFastVtx_16 = arcFastVtx[16];
				ArcFastVtx_17 = arcFastVtx[17];
				ArcFastVtx_18 = arcFastVtx[18];
				ArcFastVtx_19 = arcFastVtx[19];
				ArcFastVtx_20 = arcFastVtx[20];
				ArcFastVtx_21 = arcFastVtx[21];
				ArcFastVtx_22 = arcFastVtx[22];
				ArcFastVtx_23 = arcFastVtx[23];
				ArcFastVtx_24 = arcFastVtx[24];
				ArcFastVtx_25 = arcFastVtx[25];
				ArcFastVtx_26 = arcFastVtx[26];
				ArcFastVtx_27 = arcFastVtx[27];
				ArcFastVtx_28 = arcFastVtx[28];
				ArcFastVtx_29 = arcFastVtx[29];
				ArcFastVtx_30 = arcFastVtx[30];
				ArcFastVtx_31 = arcFastVtx[31];
				ArcFastVtx_32 = arcFastVtx[32];
				ArcFastVtx_33 = arcFastVtx[33];
				ArcFastVtx_34 = arcFastVtx[34];
				ArcFastVtx_35 = arcFastVtx[35];
				ArcFastVtx_36 = arcFastVtx[36];
				ArcFastVtx_37 = arcFastVtx[37];
				ArcFastVtx_38 = arcFastVtx[38];
				ArcFastVtx_39 = arcFastVtx[39];
				ArcFastVtx_40 = arcFastVtx[40];
				ArcFastVtx_41 = arcFastVtx[41];
				ArcFastVtx_42 = arcFastVtx[42];
				ArcFastVtx_43 = arcFastVtx[43];
				ArcFastVtx_44 = arcFastVtx[44];
				ArcFastVtx_45 = arcFastVtx[45];
				ArcFastVtx_46 = arcFastVtx[46];
				ArcFastVtx_47 = arcFastVtx[47];
			}
			ArcFastRadiusCutoff = arcFastRadiusCutoff;
			if (circleSegmentCounts != default)
			{
				CircleSegmentCounts_0 = circleSegmentCounts[0];
				CircleSegmentCounts_1 = circleSegmentCounts[1];
				CircleSegmentCounts_2 = circleSegmentCounts[2];
				CircleSegmentCounts_3 = circleSegmentCounts[3];
				CircleSegmentCounts_4 = circleSegmentCounts[4];
				CircleSegmentCounts_5 = circleSegmentCounts[5];
				CircleSegmentCounts_6 = circleSegmentCounts[6];
				CircleSegmentCounts_7 = circleSegmentCounts[7];
				CircleSegmentCounts_8 = circleSegmentCounts[8];
				CircleSegmentCounts_9 = circleSegmentCounts[9];
				CircleSegmentCounts_10 = circleSegmentCounts[10];
				CircleSegmentCounts_11 = circleSegmentCounts[11];
				CircleSegmentCounts_12 = circleSegmentCounts[12];
				CircleSegmentCounts_13 = circleSegmentCounts[13];
				CircleSegmentCounts_14 = circleSegmentCounts[14];
				CircleSegmentCounts_15 = circleSegmentCounts[15];
				CircleSegmentCounts_16 = circleSegmentCounts[16];
				CircleSegmentCounts_17 = circleSegmentCounts[17];
				CircleSegmentCounts_18 = circleSegmentCounts[18];
				CircleSegmentCounts_19 = circleSegmentCounts[19];
				CircleSegmentCounts_20 = circleSegmentCounts[20];
				CircleSegmentCounts_21 = circleSegmentCounts[21];
				CircleSegmentCounts_22 = circleSegmentCounts[22];
				CircleSegmentCounts_23 = circleSegmentCounts[23];
				CircleSegmentCounts_24 = circleSegmentCounts[24];
				CircleSegmentCounts_25 = circleSegmentCounts[25];
				CircleSegmentCounts_26 = circleSegmentCounts[26];
				CircleSegmentCounts_27 = circleSegmentCounts[27];
				CircleSegmentCounts_28 = circleSegmentCounts[28];
				CircleSegmentCounts_29 = circleSegmentCounts[29];
				CircleSegmentCounts_30 = circleSegmentCounts[30];
				CircleSegmentCounts_31 = circleSegmentCounts[31];
				CircleSegmentCounts_32 = circleSegmentCounts[32];
				CircleSegmentCounts_33 = circleSegmentCounts[33];
				CircleSegmentCounts_34 = circleSegmentCounts[34];
				CircleSegmentCounts_35 = circleSegmentCounts[35];
				CircleSegmentCounts_36 = circleSegmentCounts[36];
				CircleSegmentCounts_37 = circleSegmentCounts[37];
				CircleSegmentCounts_38 = circleSegmentCounts[38];
				CircleSegmentCounts_39 = circleSegmentCounts[39];
				CircleSegmentCounts_40 = circleSegmentCounts[40];
				CircleSegmentCounts_41 = circleSegmentCounts[41];
				CircleSegmentCounts_42 = circleSegmentCounts[42];
				CircleSegmentCounts_43 = circleSegmentCounts[43];
				CircleSegmentCounts_44 = circleSegmentCounts[44];
				CircleSegmentCounts_45 = circleSegmentCounts[45];
				CircleSegmentCounts_46 = circleSegmentCounts[46];
				CircleSegmentCounts_47 = circleSegmentCounts[47];
				CircleSegmentCounts_48 = circleSegmentCounts[48];
				CircleSegmentCounts_49 = circleSegmentCounts[49];
				CircleSegmentCounts_50 = circleSegmentCounts[50];
				CircleSegmentCounts_51 = circleSegmentCounts[51];
				CircleSegmentCounts_52 = circleSegmentCounts[52];
				CircleSegmentCounts_53 = circleSegmentCounts[53];
				CircleSegmentCounts_54 = circleSegmentCounts[54];
				CircleSegmentCounts_55 = circleSegmentCounts[55];
				CircleSegmentCounts_56 = circleSegmentCounts[56];
				CircleSegmentCounts_57 = circleSegmentCounts[57];
				CircleSegmentCounts_58 = circleSegmentCounts[58];
				CircleSegmentCounts_59 = circleSegmentCounts[59];
				CircleSegmentCounts_60 = circleSegmentCounts[60];
				CircleSegmentCounts_61 = circleSegmentCounts[61];
				CircleSegmentCounts_62 = circleSegmentCounts[62];
				CircleSegmentCounts_63 = circleSegmentCounts[63];
			}
			TexUvLines = texUvLines;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawListSharedData(Vector2 texUvWhitePixel = default, ImFont* font = default, float fontSize = default, float curveTessellationTol = default, float circleSegmentMaxError = default, Vector4 clipRectFullscreen = default, int initialFlags = default, ImVectorImVec2 tempBuffer = default, Span<Vector2> arcFastVtx = default, float arcFastRadiusCutoff = default, Span<byte> circleSegmentCounts = default, Vector4* texUvLines = default)
		{
			TexUvWhitePixel = texUvWhitePixel;
			Font = font;
			FontSize = fontSize;
			CurveTessellationTol = curveTessellationTol;
			CircleSegmentMaxError = circleSegmentMaxError;
			ClipRectFullscreen = clipRectFullscreen;
			InitialFlags = initialFlags;
			TempBuffer = tempBuffer;
			if (arcFastVtx != default)
			{
				ArcFastVtx_0 = arcFastVtx[0];
				ArcFastVtx_1 = arcFastVtx[1];
				ArcFastVtx_2 = arcFastVtx[2];
				ArcFastVtx_3 = arcFastVtx[3];
				ArcFastVtx_4 = arcFastVtx[4];
				ArcFastVtx_5 = arcFastVtx[5];
				ArcFastVtx_6 = arcFastVtx[6];
				ArcFastVtx_7 = arcFastVtx[7];
				ArcFastVtx_8 = arcFastVtx[8];
				ArcFastVtx_9 = arcFastVtx[9];
				ArcFastVtx_10 = arcFastVtx[10];
				ArcFastVtx_11 = arcFastVtx[11];
				ArcFastVtx_12 = arcFastVtx[12];
				ArcFastVtx_13 = arcFastVtx[13];
				ArcFastVtx_14 = arcFastVtx[14];
				ArcFastVtx_15 = arcFastVtx[15];
				ArcFastVtx_16 = arcFastVtx[16];
				ArcFastVtx_17 = arcFastVtx[17];
				ArcFastVtx_18 = arcFastVtx[18];
				ArcFastVtx_19 = arcFastVtx[19];
				ArcFastVtx_20 = arcFastVtx[20];
				ArcFastVtx_21 = arcFastVtx[21];
				ArcFastVtx_22 = arcFastVtx[22];
				ArcFastVtx_23 = arcFastVtx[23];
				ArcFastVtx_24 = arcFastVtx[24];
				ArcFastVtx_25 = arcFastVtx[25];
				ArcFastVtx_26 = arcFastVtx[26];
				ArcFastVtx_27 = arcFastVtx[27];
				ArcFastVtx_28 = arcFastVtx[28];
				ArcFastVtx_29 = arcFastVtx[29];
				ArcFastVtx_30 = arcFastVtx[30];
				ArcFastVtx_31 = arcFastVtx[31];
				ArcFastVtx_32 = arcFastVtx[32];
				ArcFastVtx_33 = arcFastVtx[33];
				ArcFastVtx_34 = arcFastVtx[34];
				ArcFastVtx_35 = arcFastVtx[35];
				ArcFastVtx_36 = arcFastVtx[36];
				ArcFastVtx_37 = arcFastVtx[37];
				ArcFastVtx_38 = arcFastVtx[38];
				ArcFastVtx_39 = arcFastVtx[39];
				ArcFastVtx_40 = arcFastVtx[40];
				ArcFastVtx_41 = arcFastVtx[41];
				ArcFastVtx_42 = arcFastVtx[42];
				ArcFastVtx_43 = arcFastVtx[43];
				ArcFastVtx_44 = arcFastVtx[44];
				ArcFastVtx_45 = arcFastVtx[45];
				ArcFastVtx_46 = arcFastVtx[46];
				ArcFastVtx_47 = arcFastVtx[47];
			}
			ArcFastRadiusCutoff = arcFastRadiusCutoff;
			if (circleSegmentCounts != default)
			{
				CircleSegmentCounts_0 = circleSegmentCounts[0];
				CircleSegmentCounts_1 = circleSegmentCounts[1];
				CircleSegmentCounts_2 = circleSegmentCounts[2];
				CircleSegmentCounts_3 = circleSegmentCounts[3];
				CircleSegmentCounts_4 = circleSegmentCounts[4];
				CircleSegmentCounts_5 = circleSegmentCounts[5];
				CircleSegmentCounts_6 = circleSegmentCounts[6];
				CircleSegmentCounts_7 = circleSegmentCounts[7];
				CircleSegmentCounts_8 = circleSegmentCounts[8];
				CircleSegmentCounts_9 = circleSegmentCounts[9];
				CircleSegmentCounts_10 = circleSegmentCounts[10];
				CircleSegmentCounts_11 = circleSegmentCounts[11];
				CircleSegmentCounts_12 = circleSegmentCounts[12];
				CircleSegmentCounts_13 = circleSegmentCounts[13];
				CircleSegmentCounts_14 = circleSegmentCounts[14];
				CircleSegmentCounts_15 = circleSegmentCounts[15];
				CircleSegmentCounts_16 = circleSegmentCounts[16];
				CircleSegmentCounts_17 = circleSegmentCounts[17];
				CircleSegmentCounts_18 = circleSegmentCounts[18];
				CircleSegmentCounts_19 = circleSegmentCounts[19];
				CircleSegmentCounts_20 = circleSegmentCounts[20];
				CircleSegmentCounts_21 = circleSegmentCounts[21];
				CircleSegmentCounts_22 = circleSegmentCounts[22];
				CircleSegmentCounts_23 = circleSegmentCounts[23];
				CircleSegmentCounts_24 = circleSegmentCounts[24];
				CircleSegmentCounts_25 = circleSegmentCounts[25];
				CircleSegmentCounts_26 = circleSegmentCounts[26];
				CircleSegmentCounts_27 = circleSegmentCounts[27];
				CircleSegmentCounts_28 = circleSegmentCounts[28];
				CircleSegmentCounts_29 = circleSegmentCounts[29];
				CircleSegmentCounts_30 = circleSegmentCounts[30];
				CircleSegmentCounts_31 = circleSegmentCounts[31];
				CircleSegmentCounts_32 = circleSegmentCounts[32];
				CircleSegmentCounts_33 = circleSegmentCounts[33];
				CircleSegmentCounts_34 = circleSegmentCounts[34];
				CircleSegmentCounts_35 = circleSegmentCounts[35];
				CircleSegmentCounts_36 = circleSegmentCounts[36];
				CircleSegmentCounts_37 = circleSegmentCounts[37];
				CircleSegmentCounts_38 = circleSegmentCounts[38];
				CircleSegmentCounts_39 = circleSegmentCounts[39];
				CircleSegmentCounts_40 = circleSegmentCounts[40];
				CircleSegmentCounts_41 = circleSegmentCounts[41];
				CircleSegmentCounts_42 = circleSegmentCounts[42];
				CircleSegmentCounts_43 = circleSegmentCounts[43];
				CircleSegmentCounts_44 = circleSegmentCounts[44];
				CircleSegmentCounts_45 = circleSegmentCounts[45];
				CircleSegmentCounts_46 = circleSegmentCounts[46];
				CircleSegmentCounts_47 = circleSegmentCounts[47];
				CircleSegmentCounts_48 = circleSegmentCounts[48];
				CircleSegmentCounts_49 = circleSegmentCounts[49];
				CircleSegmentCounts_50 = circleSegmentCounts[50];
				CircleSegmentCounts_51 = circleSegmentCounts[51];
				CircleSegmentCounts_52 = circleSegmentCounts[52];
				CircleSegmentCounts_53 = circleSegmentCounts[53];
				CircleSegmentCounts_54 = circleSegmentCounts[54];
				CircleSegmentCounts_55 = circleSegmentCounts[55];
				CircleSegmentCounts_56 = circleSegmentCounts[56];
				CircleSegmentCounts_57 = circleSegmentCounts[57];
				CircleSegmentCounts_58 = circleSegmentCounts[58];
				CircleSegmentCounts_59 = circleSegmentCounts[59];
				CircleSegmentCounts_60 = circleSegmentCounts[60];
				CircleSegmentCounts_61 = circleSegmentCounts[61];
				CircleSegmentCounts_62 = circleSegmentCounts[62];
				CircleSegmentCounts_63 = circleSegmentCounts[63];
			}
			TexUvLines = texUvLines;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Vector2> ArcFastVtx
		
		{
			get
			{
				fixed (Vector2* p = &this.ArcFastVtx_0)
				{
					return new Span<Vector2>(p, 48);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFont
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorFloat IndexAdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FallbackAdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FontSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImWchar IndexLookup;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImFontGlyph Glyphs;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontGlyph* FallbackGlyph;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontAtlas* ContainerAtlas;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontConfig* ConfigData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ConfigDataCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public char FallbackChar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public char EllipsisChar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short EllipsisCharCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float EllipsisWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float EllipsisCharStep;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DirtyLookupTables;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Scale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Ascent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Descent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MetricsTotalSurface;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Used4kPagesMap_0;
		public byte Used4kPagesMap_1;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFont(ImVectorFloat indexAdvanceX = default, float fallbackAdvanceX = default, float fontSize = default, ImVectorImWchar indexLookup = default, ImVectorImFontGlyph glyphs = default, ImFontGlyph* fallbackGlyph = default, ImFontAtlas* containerAtlas = default, ImFontConfig* configData = default, short configDataCount = default, char fallbackChar = default, char ellipsisChar = default, short ellipsisCharCount = default, float ellipsisWidth = default, float ellipsisCharStep = default, bool dirtyLookupTables = default, float scale = default, float ascent = default, float descent = default, int metricsTotalSurface = default, byte* used4KPagesMap = default)
		{
			IndexAdvanceX = indexAdvanceX;
			FallbackAdvanceX = fallbackAdvanceX;
			FontSize = fontSize;
			IndexLookup = indexLookup;
			Glyphs = glyphs;
			FallbackGlyph = fallbackGlyph;
			ContainerAtlas = containerAtlas;
			ConfigData = configData;
			ConfigDataCount = configDataCount;
			FallbackChar = fallbackChar;
			EllipsisChar = ellipsisChar;
			EllipsisCharCount = ellipsisCharCount;
			EllipsisWidth = ellipsisWidth;
			EllipsisCharStep = ellipsisCharStep;
			DirtyLookupTables = dirtyLookupTables ? (byte)1 : (byte)0;
			Scale = scale;
			Ascent = ascent;
			Descent = descent;
			MetricsTotalSurface = metricsTotalSurface;
			if (used4KPagesMap != default)
			{
				Used4kPagesMap_0 = used4KPagesMap[0];
				Used4kPagesMap_1 = used4KPagesMap[1];
			}
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFont(ImVectorFloat indexAdvanceX = default, float fallbackAdvanceX = default, float fontSize = default, ImVectorImWchar indexLookup = default, ImVectorImFontGlyph glyphs = default, ImFontGlyph* fallbackGlyph = default, ImFontAtlas* containerAtlas = default, ImFontConfig* configData = default, short configDataCount = default, char fallbackChar = default, char ellipsisChar = default, short ellipsisCharCount = default, float ellipsisWidth = default, float ellipsisCharStep = default, bool dirtyLookupTables = default, float scale = default, float ascent = default, float descent = default, int metricsTotalSurface = default, Span<byte> used4KPagesMap = default)
		{
			IndexAdvanceX = indexAdvanceX;
			FallbackAdvanceX = fallbackAdvanceX;
			FontSize = fontSize;
			IndexLookup = indexLookup;
			Glyphs = glyphs;
			FallbackGlyph = fallbackGlyph;
			ContainerAtlas = containerAtlas;
			ConfigData = configData;
			ConfigDataCount = configDataCount;
			FallbackChar = fallbackChar;
			EllipsisChar = ellipsisChar;
			EllipsisCharCount = ellipsisCharCount;
			EllipsisWidth = ellipsisWidth;
			EllipsisCharStep = ellipsisCharStep;
			DirtyLookupTables = dirtyLookupTables ? (byte)1 : (byte)0;
			Scale = scale;
			Ascent = ascent;
			Descent = descent;
			MetricsTotalSurface = metricsTotalSurface;
			if (used4KPagesMap != default)
			{
				Used4kPagesMap_0 = used4KPagesMap[0];
				Used4kPagesMap_1 = used4KPagesMap[1];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddGlyph( ImFontConfig* srcCfg,  char c,  float x0,  float y0,  float x1,  float y1,  float u0,  float v0,  float u1,  float v1,  float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddGlyphNative(@this, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public unsafe void AddGlyph( ref ImFontConfig srcCfg,  char c,  float x0,  float y0,  float x1,  float y1,  float u0,  float v0,  float u1,  float v1,  float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImFontConfig* psrcCfg = &srcCfg)
				{
					ImGui.AddGlyphNative(@this, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
				}
			}
		}

		public unsafe void AddRemapChar( char dst,  char src,  bool overwriteDst)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddRemapCharNative(@this, dst, src, overwriteDst ? (byte)1 : (byte)0);
			}
		}

		public unsafe void AddRemapChar( char dst,  char src)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddRemapCharNative(@this, dst, src, (byte)(1));
			}
		}

		public unsafe void BuildLookupTable()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.BuildLookupTableNative(@this);
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  byte* text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, textEnd, wrapWidth);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  byte* text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, textEnd, wrapWidth));
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  ref byte text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, textEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  ref byte text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, textEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  string text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, textEnd, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  string text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, textEnd, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  byte* text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  byte* text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  byte* text,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, pStr0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  byte* text,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, pStr0, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  ref byte text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
						return ret;
					}
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  ref byte text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
						return ret;
					}
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  string text,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, pStr1, wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  string text,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, pStr1, wrapWidth));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe void ClearOutputData()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.ClearOutputDataNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImFontGlyph* FindGlyph( char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyphNative(@this, c);
				return ret;
			}
		}

		public unsafe ImFontGlyph* FindGlyphNoFallback( char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyphNoFallbackNative(@this, c);
				return ret;
			}
		}

		public unsafe float GetCharAdvance( char c)
		{
			fixed (ImFont* @this = &this)
			{
				float ret = ImGui.GetCharAdvanceNative(@this, c);
				return ret;
			}
		}

		public unsafe byte* GetDebugName()
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.GetDebugNameNative(@this);
				return ret;
			}
		}

		public unsafe string GetDebugNameS()
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.GetDebugNameNative(@this));
				return ret;
			}
		}

		public unsafe void GrowIndex( int newSize)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.GrowIndexNative(@this, newSize);
			}
		}

		public unsafe bool IsGlyphRangeUnused( uint cBegin,  uint cLast)
		{
			fixed (ImFont* @this = &this)
			{
				byte ret = ImGui.IsGlyphRangeUnusedNative(@this, cBegin, cLast);
				return ret != 0;
			}
		}

		public unsafe bool IsLoaded()
		{
			fixed (ImFont* @this = &this)
			{
				byte ret = ImGui.IsLoadedNative(@this);
				return ret != 0;
			}
		}

		public unsafe void RenderChar( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderCharNative(@this, drawList, size, pos, col, c);
			}
		}

		public unsafe void RenderChar( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  char c)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderCharNative(@this, (ImDrawList*)pdrawList, size, pos, col, c);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
						}
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
						}
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void SetGlyphVisible( char c,  bool visible)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.SetGlyphVisibleNative(@this, c, visible ? (byte)1 : (byte)0);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorFloat
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe float* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorFloat(int size = default, int capacity = default, float* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImWchar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe char* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImWchar(int size = default, int capacity = default, char* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontGlyph
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontGlyph* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImFontGlyph(int size = default, int capacity = default, ImFontGlyph* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontGlyph
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Colored;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Visible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Codepoint;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float AdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float X0;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Y0;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float X1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Y1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float U0;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float V0;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float U1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float V1;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFontGlyph(uint colored = default, uint visible = default, uint codepoint = default, float advanceX = default, float x0 = default, float y0 = default, float x1 = default, float y1 = default, float u0 = default, float v0 = default, float u1 = default, float v1 = default)
		{
			Colored = colored;
			Visible = visible;
			Codepoint = codepoint;
			AdvanceX = advanceX;
			X0 = x0;
			Y0 = y0;
			X1 = x1;
			Y1 = y1;
			U0 = u0;
			V0 = v0;
			U1 = u1;
			V1 = v1;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlas
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImTextureID TexID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TexDesiredWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TexGlyphPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Locked;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte TexReady;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte TexPixelsUseColors;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* TexPixelsAlpha8;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe uint* TexPixelsRGBA32;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TexWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TexHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 TexUvScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 TexUvWhitePixel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImFontPtr Fonts;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImFontAtlasCustomRect CustomRects;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImFontConfig ConfigData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 TexUvLines_0;
		public Vector4 TexUvLines_1;
		public Vector4 TexUvLines_2;
		public Vector4 TexUvLines_3;
		public Vector4 TexUvLines_4;
		public Vector4 TexUvLines_5;
		public Vector4 TexUvLines_6;
		public Vector4 TexUvLines_7;
		public Vector4 TexUvLines_8;
		public Vector4 TexUvLines_9;
		public Vector4 TexUvLines_10;
		public Vector4 TexUvLines_11;
		public Vector4 TexUvLines_12;
		public Vector4 TexUvLines_13;
		public Vector4 TexUvLines_14;
		public Vector4 TexUvLines_15;
		public Vector4 TexUvLines_16;
		public Vector4 TexUvLines_17;
		public Vector4 TexUvLines_18;
		public Vector4 TexUvLines_19;
		public Vector4 TexUvLines_20;
		public Vector4 TexUvLines_21;
		public Vector4 TexUvLines_22;
		public Vector4 TexUvLines_23;
		public Vector4 TexUvLines_24;
		public Vector4 TexUvLines_25;
		public Vector4 TexUvLines_26;
		public Vector4 TexUvLines_27;
		public Vector4 TexUvLines_28;
		public Vector4 TexUvLines_29;
		public Vector4 TexUvLines_30;
		public Vector4 TexUvLines_31;
		public Vector4 TexUvLines_32;
		public Vector4 TexUvLines_33;
		public Vector4 TexUvLines_34;
		public Vector4 TexUvLines_35;
		public Vector4 TexUvLines_36;
		public Vector4 TexUvLines_37;
		public Vector4 TexUvLines_38;
		public Vector4 TexUvLines_39;
		public Vector4 TexUvLines_40;
		public Vector4 TexUvLines_41;
		public Vector4 TexUvLines_42;
		public Vector4 TexUvLines_43;
		public Vector4 TexUvLines_44;
		public Vector4 TexUvLines_45;
		public Vector4 TexUvLines_46;
		public Vector4 TexUvLines_47;
		public Vector4 TexUvLines_48;
		public Vector4 TexUvLines_49;
		public Vector4 TexUvLines_50;
		public Vector4 TexUvLines_51;
		public Vector4 TexUvLines_52;
		public Vector4 TexUvLines_53;
		public Vector4 TexUvLines_54;
		public Vector4 TexUvLines_55;
		public Vector4 TexUvLines_56;
		public Vector4 TexUvLines_57;
		public Vector4 TexUvLines_58;
		public Vector4 TexUvLines_59;
		public Vector4 TexUvLines_60;
		public Vector4 TexUvLines_61;
		public Vector4 TexUvLines_62;
		public Vector4 TexUvLines_63;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontBuilderIO* FontBuilderIO;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint FontBuilderFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int PackIdMouseCursors;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int PackIdLines;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFontAtlas(int flags = default, ImTextureID texId = default, int texDesiredWidth = default, int texGlyphPadding = default, bool locked = default, void* userData = default, bool texReady = default, bool texPixelsUseColors = default, byte* texPixelsAlpha8 = default, uint* texPixelsRgba32 = default, int texWidth = default, int texHeight = default, Vector2 texUvScale = default, Vector2 texUvWhitePixel = default, ImVectorImFontPtr fonts = default, ImVectorImFontAtlasCustomRect customRects = default, ImVectorImFontConfig configData = default, Vector4* texUvLines = default, ImFontBuilderIO* fontBuilderIo = default, uint fontBuilderFlags = default, int packIdMouseCursors = default, int packIdLines = default)
		{
			Flags = flags;
			TexID = texId;
			TexDesiredWidth = texDesiredWidth;
			TexGlyphPadding = texGlyphPadding;
			Locked = locked ? (byte)1 : (byte)0;
			UserData = userData;
			TexReady = texReady ? (byte)1 : (byte)0;
			TexPixelsUseColors = texPixelsUseColors ? (byte)1 : (byte)0;
			TexPixelsAlpha8 = texPixelsAlpha8;
			TexPixelsRGBA32 = texPixelsRgba32;
			TexWidth = texWidth;
			TexHeight = texHeight;
			TexUvScale = texUvScale;
			TexUvWhitePixel = texUvWhitePixel;
			Fonts = fonts;
			CustomRects = customRects;
			ConfigData = configData;
			if (texUvLines != default)
			{
				TexUvLines_0 = texUvLines[0];
				TexUvLines_1 = texUvLines[1];
				TexUvLines_2 = texUvLines[2];
				TexUvLines_3 = texUvLines[3];
				TexUvLines_4 = texUvLines[4];
				TexUvLines_5 = texUvLines[5];
				TexUvLines_6 = texUvLines[6];
				TexUvLines_7 = texUvLines[7];
				TexUvLines_8 = texUvLines[8];
				TexUvLines_9 = texUvLines[9];
				TexUvLines_10 = texUvLines[10];
				TexUvLines_11 = texUvLines[11];
				TexUvLines_12 = texUvLines[12];
				TexUvLines_13 = texUvLines[13];
				TexUvLines_14 = texUvLines[14];
				TexUvLines_15 = texUvLines[15];
				TexUvLines_16 = texUvLines[16];
				TexUvLines_17 = texUvLines[17];
				TexUvLines_18 = texUvLines[18];
				TexUvLines_19 = texUvLines[19];
				TexUvLines_20 = texUvLines[20];
				TexUvLines_21 = texUvLines[21];
				TexUvLines_22 = texUvLines[22];
				TexUvLines_23 = texUvLines[23];
				TexUvLines_24 = texUvLines[24];
				TexUvLines_25 = texUvLines[25];
				TexUvLines_26 = texUvLines[26];
				TexUvLines_27 = texUvLines[27];
				TexUvLines_28 = texUvLines[28];
				TexUvLines_29 = texUvLines[29];
				TexUvLines_30 = texUvLines[30];
				TexUvLines_31 = texUvLines[31];
				TexUvLines_32 = texUvLines[32];
				TexUvLines_33 = texUvLines[33];
				TexUvLines_34 = texUvLines[34];
				TexUvLines_35 = texUvLines[35];
				TexUvLines_36 = texUvLines[36];
				TexUvLines_37 = texUvLines[37];
				TexUvLines_38 = texUvLines[38];
				TexUvLines_39 = texUvLines[39];
				TexUvLines_40 = texUvLines[40];
				TexUvLines_41 = texUvLines[41];
				TexUvLines_42 = texUvLines[42];
				TexUvLines_43 = texUvLines[43];
				TexUvLines_44 = texUvLines[44];
				TexUvLines_45 = texUvLines[45];
				TexUvLines_46 = texUvLines[46];
				TexUvLines_47 = texUvLines[47];
				TexUvLines_48 = texUvLines[48];
				TexUvLines_49 = texUvLines[49];
				TexUvLines_50 = texUvLines[50];
				TexUvLines_51 = texUvLines[51];
				TexUvLines_52 = texUvLines[52];
				TexUvLines_53 = texUvLines[53];
				TexUvLines_54 = texUvLines[54];
				TexUvLines_55 = texUvLines[55];
				TexUvLines_56 = texUvLines[56];
				TexUvLines_57 = texUvLines[57];
				TexUvLines_58 = texUvLines[58];
				TexUvLines_59 = texUvLines[59];
				TexUvLines_60 = texUvLines[60];
				TexUvLines_61 = texUvLines[61];
				TexUvLines_62 = texUvLines[62];
				TexUvLines_63 = texUvLines[63];
			}
			FontBuilderIO = fontBuilderIo;
			FontBuilderFlags = fontBuilderFlags;
			PackIdMouseCursors = packIdMouseCursors;
			PackIdLines = packIdLines;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFontAtlas(int flags = default, ImTextureID texId = default, int texDesiredWidth = default, int texGlyphPadding = default, bool locked = default, void* userData = default, bool texReady = default, bool texPixelsUseColors = default, byte* texPixelsAlpha8 = default, uint* texPixelsRgba32 = default, int texWidth = default, int texHeight = default, Vector2 texUvScale = default, Vector2 texUvWhitePixel = default, ImVectorImFontPtr fonts = default, ImVectorImFontAtlasCustomRect customRects = default, ImVectorImFontConfig configData = default, Span<Vector4> texUvLines = default, ImFontBuilderIO* fontBuilderIo = default, uint fontBuilderFlags = default, int packIdMouseCursors = default, int packIdLines = default)
		{
			Flags = flags;
			TexID = texId;
			TexDesiredWidth = texDesiredWidth;
			TexGlyphPadding = texGlyphPadding;
			Locked = locked ? (byte)1 : (byte)0;
			UserData = userData;
			TexReady = texReady ? (byte)1 : (byte)0;
			TexPixelsUseColors = texPixelsUseColors ? (byte)1 : (byte)0;
			TexPixelsAlpha8 = texPixelsAlpha8;
			TexPixelsRGBA32 = texPixelsRgba32;
			TexWidth = texWidth;
			TexHeight = texHeight;
			TexUvScale = texUvScale;
			TexUvWhitePixel = texUvWhitePixel;
			Fonts = fonts;
			CustomRects = customRects;
			ConfigData = configData;
			if (texUvLines != default)
			{
				TexUvLines_0 = texUvLines[0];
				TexUvLines_1 = texUvLines[1];
				TexUvLines_2 = texUvLines[2];
				TexUvLines_3 = texUvLines[3];
				TexUvLines_4 = texUvLines[4];
				TexUvLines_5 = texUvLines[5];
				TexUvLines_6 = texUvLines[6];
				TexUvLines_7 = texUvLines[7];
				TexUvLines_8 = texUvLines[8];
				TexUvLines_9 = texUvLines[9];
				TexUvLines_10 = texUvLines[10];
				TexUvLines_11 = texUvLines[11];
				TexUvLines_12 = texUvLines[12];
				TexUvLines_13 = texUvLines[13];
				TexUvLines_14 = texUvLines[14];
				TexUvLines_15 = texUvLines[15];
				TexUvLines_16 = texUvLines[16];
				TexUvLines_17 = texUvLines[17];
				TexUvLines_18 = texUvLines[18];
				TexUvLines_19 = texUvLines[19];
				TexUvLines_20 = texUvLines[20];
				TexUvLines_21 = texUvLines[21];
				TexUvLines_22 = texUvLines[22];
				TexUvLines_23 = texUvLines[23];
				TexUvLines_24 = texUvLines[24];
				TexUvLines_25 = texUvLines[25];
				TexUvLines_26 = texUvLines[26];
				TexUvLines_27 = texUvLines[27];
				TexUvLines_28 = texUvLines[28];
				TexUvLines_29 = texUvLines[29];
				TexUvLines_30 = texUvLines[30];
				TexUvLines_31 = texUvLines[31];
				TexUvLines_32 = texUvLines[32];
				TexUvLines_33 = texUvLines[33];
				TexUvLines_34 = texUvLines[34];
				TexUvLines_35 = texUvLines[35];
				TexUvLines_36 = texUvLines[36];
				TexUvLines_37 = texUvLines[37];
				TexUvLines_38 = texUvLines[38];
				TexUvLines_39 = texUvLines[39];
				TexUvLines_40 = texUvLines[40];
				TexUvLines_41 = texUvLines[41];
				TexUvLines_42 = texUvLines[42];
				TexUvLines_43 = texUvLines[43];
				TexUvLines_44 = texUvLines[44];
				TexUvLines_45 = texUvLines[45];
				TexUvLines_46 = texUvLines[46];
				TexUvLines_47 = texUvLines[47];
				TexUvLines_48 = texUvLines[48];
				TexUvLines_49 = texUvLines[49];
				TexUvLines_50 = texUvLines[50];
				TexUvLines_51 = texUvLines[51];
				TexUvLines_52 = texUvLines[52];
				TexUvLines_53 = texUvLines[53];
				TexUvLines_54 = texUvLines[54];
				TexUvLines_55 = texUvLines[55];
				TexUvLines_56 = texUvLines[56];
				TexUvLines_57 = texUvLines[57];
				TexUvLines_58 = texUvLines[58];
				TexUvLines_59 = texUvLines[59];
				TexUvLines_60 = texUvLines[60];
				TexUvLines_61 = texUvLines[61];
				TexUvLines_62 = texUvLines[62];
				TexUvLines_63 = texUvLines[63];
			}
			FontBuilderIO = fontBuilderIo;
			FontBuilderFlags = fontBuilderFlags;
			PackIdMouseCursors = packIdMouseCursors;
			PackIdLines = packIdLines;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Vector4> TexUvLines
		
		{
			get
			{
				fixed (Vector4* p = &this.TexUvLines_0)
				{
					return new Span<Vector4>(p, 64);
				}
			}
		}
		public unsafe int AddCustomRectFontGlyph( ImFont* font,  char id,  int width,  int height,  float advanceX,  Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(@this, font, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph( ImFont* font,  char id,  int width,  int height,  float advanceX)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(@this, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph( ref ImFont font,  char id,  int width,  int height,  float advanceX,  Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGui.AddCustomRectFontGlyphNative(@this, (ImFont*)pfont, id, width, height, advanceX, offset);
					return ret;
				}
			}
		}

		public unsafe int AddCustomRectFontGlyph( ref ImFont font,  char id,  int width,  int height,  float advanceX)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGui.AddCustomRectFontGlyphNative(@this, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
					return ret;
				}
			}
		}

		public unsafe int AddCustomRectRegular( int width,  int height)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectRegularNative(@this, width, height);
				return ret;
			}
		}

		public unsafe ImFont* AddFont( ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontNative(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFont* AddFont( ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontNative(@this, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontDefault( ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontDefaultNative(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFont* AddFontDefault()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontDefaultNative(@this, (ImFontConfig*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontDefault( ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontDefaultNative(@this, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe bool Build()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.BuildNative(@this);
				return ret != 0;
			}
		}

		public unsafe void CalcCustomRectUV( ImFontAtlasCustomRect* rect,  Vector2* outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.CalcCustomRectUVNative(@this, rect, outUvMin, outUvMax);
			}
		}

		public unsafe void CalcCustomRectUV( ref ImFontAtlasCustomRect rect,  Vector2* outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV( ImFontAtlasCustomRect* rect,  ref Vector2 outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					ImGui.CalcCustomRectUVNative(@this, rect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV( ref ImFontAtlasCustomRect rect,  ref Vector2 outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV( ImFontAtlasCustomRect* rect,  Vector2* outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGui.CalcCustomRectUVNative(@this, rect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV( ref ImFontAtlasCustomRect rect,  Vector2* outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV( ImFontAtlasCustomRect* rect,  ref Vector2 outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(@this, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV( ref ImFontAtlasCustomRect rect,  ref Vector2 outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						fixed (Vector2* poutUvMax = &outUvMax)
						{
							ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
						}
					}
				}
			}
		}

		public unsafe void Clear()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void ClearFonts()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearFontsNative(@this);
			}
		}

		public unsafe void ClearInputData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearInputDataNative(@this);
			}
		}

		public unsafe void ClearTexData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearTexDataNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImFontAtlasCustomRect* GetCustomRectByIndex( int index)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontAtlasCustomRect* ret = ImGui.GetCustomRectByIndexNative(@this, index);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesChineseFull()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseFullNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesChineseSimplifiedCommon()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseSimplifiedCommonNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesCyrillic()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesCyrillicNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesDefault()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesDefaultNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesGreek()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesGreekNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesJapanese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesJapaneseNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesKorean()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesKoreanNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesThai()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesThaiNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesVietnamese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesVietnameseNative(@this);
				return ret;
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  Vector2* outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  Vector2* outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  Vector2* outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  Vector2* outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (Vector2* poutUvFill = &outUvFill)
							{
								byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		public unsafe bool IsBuilt()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.IsBuiltNative(@this);
				return ret != 0;
			}
		}

		public unsafe void SetTexID( ImTextureID id)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.SetTexIDNative(@this, id);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontPtr
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFont** Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImFontPtr(int size = default, int capacity = default, ImFont** data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontAtlasCustomRect
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontAtlasCustomRect* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImFontAtlasCustomRect(int size = default, int capacity = default, ImFontAtlasCustomRect* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlasCustomRect
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Width;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Height;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort X;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Y;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint GlyphID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float GlyphAdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 GlyphOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFont* Font;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFontAtlasCustomRect(ushort width = default, ushort height = default, ushort x = default, ushort y = default, uint glyphId = default, float glyphAdvanceX = default, Vector2 glyphOffset = default, ImFont* font = default)
		{
			Width = width;
			Height = height;
			X = x;
			Y = y;
			GlyphID = glyphId;
			GlyphAdvanceX = glyphAdvanceX;
			GlyphOffset = glyphOffset;
			Font = font;
		}


		public unsafe void Destroy()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool IsPacked()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				byte ret = ImGui.IsPackedNative(@this);
				return ret != 0;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontConfig
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontConfig* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImFontConfig(int size = default, int capacity = default, ImFontConfig* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontConfig
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* FontData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FontDataSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte FontDataOwnedByAtlas;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FontNo;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float SizePixels;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int OversampleH;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int OversampleV;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PixelSnapH;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 GlyphExtraSpacing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 GlyphOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe char* GlyphRanges;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float GlyphMinAdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float GlyphMaxAdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte MergeMode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint FontBuilderFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RasterizerMultiply;

		/// <summary>
		/// To be documented.
		/// </summary>
		public char EllipsisChar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Name_0;
		public byte Name_1;
		public byte Name_2;
		public byte Name_3;
		public byte Name_4;
		public byte Name_5;
		public byte Name_6;
		public byte Name_7;
		public byte Name_8;
		public byte Name_9;
		public byte Name_10;
		public byte Name_11;
		public byte Name_12;
		public byte Name_13;
		public byte Name_14;
		public byte Name_15;
		public byte Name_16;
		public byte Name_17;
		public byte Name_18;
		public byte Name_19;
		public byte Name_20;
		public byte Name_21;
		public byte Name_22;
		public byte Name_23;
		public byte Name_24;
		public byte Name_25;
		public byte Name_26;
		public byte Name_27;
		public byte Name_28;
		public byte Name_29;
		public byte Name_30;
		public byte Name_31;
		public byte Name_32;
		public byte Name_33;
		public byte Name_34;
		public byte Name_35;
		public byte Name_36;
		public byte Name_37;
		public byte Name_38;
		public byte Name_39;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFont* DstFont;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFontConfig(void* fontData = default, int fontDataSize = default, bool fontDataOwnedByAtlas = default, int fontNo = default, float sizePixels = default, int oversampleH = default, int oversampleV = default, bool pixelSnapH = default, Vector2 glyphExtraSpacing = default, Vector2 glyphOffset = default, char* glyphRanges = default, float glyphMinAdvanceX = default, float glyphMaxAdvanceX = default, bool mergeMode = default, uint fontBuilderFlags = default, float rasterizerMultiply = default, char ellipsisChar = default, byte* name = default, ImFont* dstFont = default)
		{
			FontData = fontData;
			FontDataSize = fontDataSize;
			FontDataOwnedByAtlas = fontDataOwnedByAtlas ? (byte)1 : (byte)0;
			FontNo = fontNo;
			SizePixels = sizePixels;
			OversampleH = oversampleH;
			OversampleV = oversampleV;
			PixelSnapH = pixelSnapH ? (byte)1 : (byte)0;
			GlyphExtraSpacing = glyphExtraSpacing;
			GlyphOffset = glyphOffset;
			GlyphRanges = glyphRanges;
			GlyphMinAdvanceX = glyphMinAdvanceX;
			GlyphMaxAdvanceX = glyphMaxAdvanceX;
			MergeMode = mergeMode ? (byte)1 : (byte)0;
			FontBuilderFlags = fontBuilderFlags;
			RasterizerMultiply = rasterizerMultiply;
			EllipsisChar = ellipsisChar;
			if (name != default)
			{
				Name_0 = name[0];
				Name_1 = name[1];
				Name_2 = name[2];
				Name_3 = name[3];
				Name_4 = name[4];
				Name_5 = name[5];
				Name_6 = name[6];
				Name_7 = name[7];
				Name_8 = name[8];
				Name_9 = name[9];
				Name_10 = name[10];
				Name_11 = name[11];
				Name_12 = name[12];
				Name_13 = name[13];
				Name_14 = name[14];
				Name_15 = name[15];
				Name_16 = name[16];
				Name_17 = name[17];
				Name_18 = name[18];
				Name_19 = name[19];
				Name_20 = name[20];
				Name_21 = name[21];
				Name_22 = name[22];
				Name_23 = name[23];
				Name_24 = name[24];
				Name_25 = name[25];
				Name_26 = name[26];
				Name_27 = name[27];
				Name_28 = name[28];
				Name_29 = name[29];
				Name_30 = name[30];
				Name_31 = name[31];
				Name_32 = name[32];
				Name_33 = name[33];
				Name_34 = name[34];
				Name_35 = name[35];
				Name_36 = name[36];
				Name_37 = name[37];
				Name_38 = name[38];
				Name_39 = name[39];
			}
			DstFont = dstFont;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFontConfig(void* fontData = default, int fontDataSize = default, bool fontDataOwnedByAtlas = default, int fontNo = default, float sizePixels = default, int oversampleH = default, int oversampleV = default, bool pixelSnapH = default, Vector2 glyphExtraSpacing = default, Vector2 glyphOffset = default, char* glyphRanges = default, float glyphMinAdvanceX = default, float glyphMaxAdvanceX = default, bool mergeMode = default, uint fontBuilderFlags = default, float rasterizerMultiply = default, char ellipsisChar = default, Span<byte> name = default, ImFont* dstFont = default)
		{
			FontData = fontData;
			FontDataSize = fontDataSize;
			FontDataOwnedByAtlas = fontDataOwnedByAtlas ? (byte)1 : (byte)0;
			FontNo = fontNo;
			SizePixels = sizePixels;
			OversampleH = oversampleH;
			OversampleV = oversampleV;
			PixelSnapH = pixelSnapH ? (byte)1 : (byte)0;
			GlyphExtraSpacing = glyphExtraSpacing;
			GlyphOffset = glyphOffset;
			GlyphRanges = glyphRanges;
			GlyphMinAdvanceX = glyphMinAdvanceX;
			GlyphMaxAdvanceX = glyphMaxAdvanceX;
			MergeMode = mergeMode ? (byte)1 : (byte)0;
			FontBuilderFlags = fontBuilderFlags;
			RasterizerMultiply = rasterizerMultiply;
			EllipsisChar = ellipsisChar;
			if (name != default)
			{
				Name_0 = name[0];
				Name_1 = name[1];
				Name_2 = name[2];
				Name_3 = name[3];
				Name_4 = name[4];
				Name_5 = name[5];
				Name_6 = name[6];
				Name_7 = name[7];
				Name_8 = name[8];
				Name_9 = name[9];
				Name_10 = name[10];
				Name_11 = name[11];
				Name_12 = name[12];
				Name_13 = name[13];
				Name_14 = name[14];
				Name_15 = name[15];
				Name_16 = name[16];
				Name_17 = name[17];
				Name_18 = name[18];
				Name_19 = name[19];
				Name_20 = name[20];
				Name_21 = name[21];
				Name_22 = name[22];
				Name_23 = name[23];
				Name_24 = name[24];
				Name_25 = name[25];
				Name_26 = name[26];
				Name_27 = name[27];
				Name_28 = name[28];
				Name_29 = name[29];
				Name_30 = name[30];
				Name_31 = name[31];
				Name_32 = name[32];
				Name_33 = name[33];
				Name_34 = name[34];
				Name_35 = name[35];
				Name_36 = name[36];
				Name_37 = name[37];
				Name_38 = name[38];
				Name_39 = name[39];
			}
			DstFont = dstFont;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Destroy()
		{
			fixed (ImFontConfig* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontBuilderIO
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* FontBuilderBuild;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFontBuilderIO(delegate*<ImFontAtlas*, bool> fontbuilderBuild = default)
		{
			FontBuilderBuild = (void*)fontbuilderBuild;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImVec2
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Vector2* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImVec2(int size = default, int capacity = default, Vector2* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImVec4
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Vector4* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImVec4(int size = default, int capacity = default, Vector4* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImTextureID
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImTextureID* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImTextureID(int size = default, int capacity = default, ImTextureID* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawCmdHeader
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 ClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImTextureID TextureId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint VtxOffset;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawCmdHeader(Vector4 clipRect = default, ImTextureID textureId = default, uint vtxOffset = default)
		{
			ClipRect = clipRect;
			TextureId = textureId;
			VtxOffset = vtxOffset;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawListSplitter
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Current;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Count;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawChannel Channels;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawListSplitter(int Current = default, int Count = default, ImVectorImDrawChannel Channels = default)
		{
			this.Current = Current;
			this.Count = Count;
			this.Channels = Channels;
		}


		public unsafe void Clear()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void ClearFreeMemory()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.ClearFreeMemoryNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void Merge( ImDrawList* drawList)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.MergeNative(@this, drawList);
			}
		}

		public unsafe void Merge( ref ImDrawList drawList)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.MergeNative(@this, (ImDrawList*)pdrawList);
				}
			}
		}

		public unsafe void SetCurrentChannel( ImDrawList* drawList,  int channelIdx)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.SetCurrentChannelNative(@this, drawList, channelIdx);
			}
		}

		public unsafe void SetCurrentChannel( ref ImDrawList drawList,  int channelIdx)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.SetCurrentChannelNative(@this, (ImDrawList*)pdrawList, channelIdx);
				}
			}
		}

		public unsafe void Split( ImDrawList* drawList,  int count)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				ImGui.SplitNative(@this, drawList, count);
			}
		}

		public unsafe void Split( ref ImDrawList drawList,  int count)
		{
			fixed (ImDrawListSplitter* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.SplitNative(@this, (ImDrawList*)pdrawList, count);
				}
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawChannel
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawChannel* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImDrawChannel(int size = default, int capacity = default, ImDrawChannel* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Valid;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CmdListsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TotalIdxCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TotalVtxCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawListPtr CmdLists;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 DisplayPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 DisplaySize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 FramebufferScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiViewport* OwnerViewport;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawData(bool valid = default, int cmdListsCount = default, int totalIdxCount = default, int totalVtxCount = default, ImVectorImDrawListPtr cmdLists = default, Vector2 displayPos = default, Vector2 displaySize = default, Vector2 framebufferScale = default, ImGuiViewport* ownerViewport = default)
		{
			Valid = valid ? (byte)1 : (byte)0;
			CmdListsCount = cmdListsCount;
			TotalIdxCount = totalIdxCount;
			TotalVtxCount = totalVtxCount;
			CmdLists = cmdLists;
			DisplayPos = displayPos;
			DisplaySize = displaySize;
			FramebufferScale = framebufferScale;
			OwnerViewport = ownerViewport;
		}


		public unsafe void AddDrawList( ImDrawList* drawList)
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.AddDrawListNative(@this, drawList);
			}
		}

		public unsafe void AddDrawList( ref ImDrawList drawList)
		{
			fixed (ImDrawData* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.AddDrawListNative(@this, (ImDrawList*)pdrawList);
				}
			}
		}

		public unsafe void Clear()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void DeIndexAllBuffers()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.DeIndexAllBuffersNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void ScaleClipRects( Vector2 fbScale)
		{
			fixed (ImDrawData* @this = &this)
			{
				ImGui.ScaleClipRectsNative(@this, fbScale);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImDrawListPtr
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawList** Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImDrawListPtr(int size = default, int capacity = default, ImDrawList** data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiViewport
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WorkPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WorkSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DpiScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ParentViewportId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawData* DrawData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* RendererUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformHandle;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformHandleRaw;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PlatformWindowCreated;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PlatformRequestMove;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PlatformRequestResize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PlatformRequestClose;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiViewport(uint id = default, int flags = default, Vector2 pos = default, Vector2 size = default, Vector2 workPos = default, Vector2 workSize = default, float dpiScale = default, uint parentViewportId = default, ImDrawData* drawData = default, void* rendererUserData = default, void* platformUserData = default, void* platformHandle = default, void* platformHandleRaw = default, bool platformWindowCreated = default, bool platformRequestMove = default, bool platformRequestResize = default, bool platformRequestClose = default)
		{
			ID = id;
			Flags = flags;
			Pos = pos;
			Size = size;
			WorkPos = workPos;
			WorkSize = workSize;
			DpiScale = dpiScale;
			ParentViewportId = parentViewportId;
			DrawData = drawData;
			RendererUserData = rendererUserData;
			PlatformUserData = platformUserData;
			PlatformHandle = platformHandle;
			PlatformHandleRaw = platformHandleRaw;
			PlatformWindowCreated = platformWindowCreated ? (byte)1 : (byte)0;
			PlatformRequestMove = platformRequestMove ? (byte)1 : (byte)0;
			PlatformRequestResize = platformRequestResize ? (byte)1 : (byte)0;
			PlatformRequestClose = platformRequestClose ? (byte)1 : (byte)0;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiViewport* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontGlyphRangesBuilder
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImU32 UsedChars;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImFontGlyphRangesBuilder(ImVectorImU32 usedChars = default)
		{
			UsedChars = usedChars;
		}


		public unsafe void AddChar( char c)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddCharNative(@this, c);
			}
		}

		public unsafe void AddRanges( char* ranges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddRangesNative(@this, ranges);
			}
		}

		public unsafe void AddRanges( ref char ranges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (char* pranges = &ranges)
				{
					ImGui.AddRangesNative(@this, (char*)pranges);
				}
			}
		}

		public unsafe void AddText( byte* text,  byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddTextNative(@this, text, textEnd);
			}
		}

		public unsafe void AddText( byte* text)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.AddTextNative(@this, text, (byte*)(default));
			}
		}

		public unsafe void AddText( ref byte text,  byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.AddTextNative(@this, (byte*)ptext, textEnd);
				}
			}
		}

		public unsafe void AddText( ref byte text)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.AddTextNative(@this, (byte*)ptext, (byte*)(default));
				}
			}
		}

		public unsafe void AddText( string text,  byte* textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( string text)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( byte* text,  ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.AddTextNative(@this, text, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void AddText( byte* text,  string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddTextNative(@this, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddText( ref byte text,  ref byte textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.AddTextNative(@this, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public unsafe void AddText( string text,  string textEnd)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.AddTextNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void BuildRanges( ImVectorImWchar* outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.BuildRangesNative(@this, outRanges);
			}
		}

		public unsafe void BuildRanges( ref ImVectorImWchar outRanges)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				fixed (ImVectorImWchar* poutRanges = &outRanges)
				{
					ImGui.BuildRangesNative(@this, (ImVectorImWchar*)poutRanges);
				}
			}
		}

		public unsafe void Clear()
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool GetBit( ulong n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte ret = ImGui.GetBitNative(@this, n);
				return ret != 0;
			}
		}

		public unsafe bool GetBit( nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				byte ret = ImGui.GetBitNative(@this, n);
				return ret != 0;
			}
		}

		public unsafe void SetBit( ulong n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.SetBitNative(@this, n);
			}
		}

		public unsafe void SetBit( nuint n)
		{
			fixed (ImFontGlyphRangesBuilder* @this = &this)
			{
				ImGui.SetBitNative(@this, n);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImU32
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe uint* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImU32(int size = default, int capacity = default, uint* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImColor
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 Value;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImColor(Vector4 value = default)
		{
			Value = value;
		}


		public unsafe void Destroy()
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void HSV( float h,  float s,  float v,  float a)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.HSVNative(@this, h, s, v, a);
			}
		}

		public unsafe void HSV( float h,  float s,  float v)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.HSVNative(@this, h, s, v, (float)(1.0f));
			}
		}

		public unsafe void SetHSV( float h,  float s,  float v,  float a)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.SetHSVNative(@this, h, s, v, a);
			}
		}

		public unsafe void SetHSV( float h,  float s,  float v)
		{
			fixed (ImColor* @this = &this)
			{
				ImGui.SetHSVNative(@this, h, s, v, (float)(1.0f));
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiContext
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Initialized;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte FontAtlasOwnedByContext;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiIO IO;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiPlatformIO PlatformIO;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStyle Style;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ConfigFlagsCurrFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ConfigFlagsLastFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFont* Font;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FontSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FontBaseSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawListSharedData DrawListSharedData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public double Time;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FrameCountEnded;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FrameCountPlatformEnded;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FrameCountRendered;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WithinFrameScope;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WithinFrameScopeWithImplicitWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WithinEndChild;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte GcCompactAll;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte TestEngineHookItems;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* TestEngine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiInputEvent InputEventsQueue;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiInputEvent InputEventsTrail;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiMouseSource InputEventsNextMouseSource;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint InputEventsNextEventId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiWindowPtr Windows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiWindowPtr WindowsFocusOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiWindowPtr WindowsTempSortBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiWindowStackData CurrentWindowStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStorage WindowsById;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int WindowsActiveCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WindowsHoverPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* CurrentWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* HoveredWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* HoveredWindowUnderMovingWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* MovingWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* WheelingWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WheelingWindowRefMousePos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int WheelingWindowStartFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WheelingWindowReleaseTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WheelingWindowWheelRemainder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WheelingAxisAvg;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DebugHookIdInfo;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint HoveredId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint HoveredIdPreviousFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HoveredIdAllowOverlap;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HoveredIdDisabled;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HoveredIdTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HoveredIdNotActiveTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ActiveId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ActiveIdIsAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ActiveIdTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ActiveIdIsJustActivated;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ActiveIdAllowOverlap;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ActiveIdNoClearOnFocusLoss;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ActiveIdHasBeenPressedBefore;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ActiveIdHasBeenEditedBefore;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ActiveIdHasBeenEditedThisFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ActiveIdClickOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* ActiveIdWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiInputSource ActiveIdSource;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ActiveIdMouseButton;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ActiveIdPreviousFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ActiveIdPreviousFrameIsAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ActiveIdPreviousFrameHasBeenEditedBefore;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* ActiveIdPreviousFrameWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint LastActiveId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LastActiveIdTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiKeyOwnerData KeysOwnerData_0;
		public ImGuiKeyOwnerData KeysOwnerData_1;
		public ImGuiKeyOwnerData KeysOwnerData_2;
		public ImGuiKeyOwnerData KeysOwnerData_3;
		public ImGuiKeyOwnerData KeysOwnerData_4;
		public ImGuiKeyOwnerData KeysOwnerData_5;
		public ImGuiKeyOwnerData KeysOwnerData_6;
		public ImGuiKeyOwnerData KeysOwnerData_7;
		public ImGuiKeyOwnerData KeysOwnerData_8;
		public ImGuiKeyOwnerData KeysOwnerData_9;
		public ImGuiKeyOwnerData KeysOwnerData_10;
		public ImGuiKeyOwnerData KeysOwnerData_11;
		public ImGuiKeyOwnerData KeysOwnerData_12;
		public ImGuiKeyOwnerData KeysOwnerData_13;
		public ImGuiKeyOwnerData KeysOwnerData_14;
		public ImGuiKeyOwnerData KeysOwnerData_15;
		public ImGuiKeyOwnerData KeysOwnerData_16;
		public ImGuiKeyOwnerData KeysOwnerData_17;
		public ImGuiKeyOwnerData KeysOwnerData_18;
		public ImGuiKeyOwnerData KeysOwnerData_19;
		public ImGuiKeyOwnerData KeysOwnerData_20;
		public ImGuiKeyOwnerData KeysOwnerData_21;
		public ImGuiKeyOwnerData KeysOwnerData_22;
		public ImGuiKeyOwnerData KeysOwnerData_23;
		public ImGuiKeyOwnerData KeysOwnerData_24;
		public ImGuiKeyOwnerData KeysOwnerData_25;
		public ImGuiKeyOwnerData KeysOwnerData_26;
		public ImGuiKeyOwnerData KeysOwnerData_27;
		public ImGuiKeyOwnerData KeysOwnerData_28;
		public ImGuiKeyOwnerData KeysOwnerData_29;
		public ImGuiKeyOwnerData KeysOwnerData_30;
		public ImGuiKeyOwnerData KeysOwnerData_31;
		public ImGuiKeyOwnerData KeysOwnerData_32;
		public ImGuiKeyOwnerData KeysOwnerData_33;
		public ImGuiKeyOwnerData KeysOwnerData_34;
		public ImGuiKeyOwnerData KeysOwnerData_35;
		public ImGuiKeyOwnerData KeysOwnerData_36;
		public ImGuiKeyOwnerData KeysOwnerData_37;
		public ImGuiKeyOwnerData KeysOwnerData_38;
		public ImGuiKeyOwnerData KeysOwnerData_39;
		public ImGuiKeyOwnerData KeysOwnerData_40;
		public ImGuiKeyOwnerData KeysOwnerData_41;
		public ImGuiKeyOwnerData KeysOwnerData_42;
		public ImGuiKeyOwnerData KeysOwnerData_43;
		public ImGuiKeyOwnerData KeysOwnerData_44;
		public ImGuiKeyOwnerData KeysOwnerData_45;
		public ImGuiKeyOwnerData KeysOwnerData_46;
		public ImGuiKeyOwnerData KeysOwnerData_47;
		public ImGuiKeyOwnerData KeysOwnerData_48;
		public ImGuiKeyOwnerData KeysOwnerData_49;
		public ImGuiKeyOwnerData KeysOwnerData_50;
		public ImGuiKeyOwnerData KeysOwnerData_51;
		public ImGuiKeyOwnerData KeysOwnerData_52;
		public ImGuiKeyOwnerData KeysOwnerData_53;
		public ImGuiKeyOwnerData KeysOwnerData_54;
		public ImGuiKeyOwnerData KeysOwnerData_55;
		public ImGuiKeyOwnerData KeysOwnerData_56;
		public ImGuiKeyOwnerData KeysOwnerData_57;
		public ImGuiKeyOwnerData KeysOwnerData_58;
		public ImGuiKeyOwnerData KeysOwnerData_59;
		public ImGuiKeyOwnerData KeysOwnerData_60;
		public ImGuiKeyOwnerData KeysOwnerData_61;
		public ImGuiKeyOwnerData KeysOwnerData_62;
		public ImGuiKeyOwnerData KeysOwnerData_63;
		public ImGuiKeyOwnerData KeysOwnerData_64;
		public ImGuiKeyOwnerData KeysOwnerData_65;
		public ImGuiKeyOwnerData KeysOwnerData_66;
		public ImGuiKeyOwnerData KeysOwnerData_67;
		public ImGuiKeyOwnerData KeysOwnerData_68;
		public ImGuiKeyOwnerData KeysOwnerData_69;
		public ImGuiKeyOwnerData KeysOwnerData_70;
		public ImGuiKeyOwnerData KeysOwnerData_71;
		public ImGuiKeyOwnerData KeysOwnerData_72;
		public ImGuiKeyOwnerData KeysOwnerData_73;
		public ImGuiKeyOwnerData KeysOwnerData_74;
		public ImGuiKeyOwnerData KeysOwnerData_75;
		public ImGuiKeyOwnerData KeysOwnerData_76;
		public ImGuiKeyOwnerData KeysOwnerData_77;
		public ImGuiKeyOwnerData KeysOwnerData_78;
		public ImGuiKeyOwnerData KeysOwnerData_79;
		public ImGuiKeyOwnerData KeysOwnerData_80;
		public ImGuiKeyOwnerData KeysOwnerData_81;
		public ImGuiKeyOwnerData KeysOwnerData_82;
		public ImGuiKeyOwnerData KeysOwnerData_83;
		public ImGuiKeyOwnerData KeysOwnerData_84;
		public ImGuiKeyOwnerData KeysOwnerData_85;
		public ImGuiKeyOwnerData KeysOwnerData_86;
		public ImGuiKeyOwnerData KeysOwnerData_87;
		public ImGuiKeyOwnerData KeysOwnerData_88;
		public ImGuiKeyOwnerData KeysOwnerData_89;
		public ImGuiKeyOwnerData KeysOwnerData_90;
		public ImGuiKeyOwnerData KeysOwnerData_91;
		public ImGuiKeyOwnerData KeysOwnerData_92;
		public ImGuiKeyOwnerData KeysOwnerData_93;
		public ImGuiKeyOwnerData KeysOwnerData_94;
		public ImGuiKeyOwnerData KeysOwnerData_95;
		public ImGuiKeyOwnerData KeysOwnerData_96;
		public ImGuiKeyOwnerData KeysOwnerData_97;
		public ImGuiKeyOwnerData KeysOwnerData_98;
		public ImGuiKeyOwnerData KeysOwnerData_99;
		public ImGuiKeyOwnerData KeysOwnerData_100;
		public ImGuiKeyOwnerData KeysOwnerData_101;
		public ImGuiKeyOwnerData KeysOwnerData_102;
		public ImGuiKeyOwnerData KeysOwnerData_103;
		public ImGuiKeyOwnerData KeysOwnerData_104;
		public ImGuiKeyOwnerData KeysOwnerData_105;
		public ImGuiKeyOwnerData KeysOwnerData_106;
		public ImGuiKeyOwnerData KeysOwnerData_107;
		public ImGuiKeyOwnerData KeysOwnerData_108;
		public ImGuiKeyOwnerData KeysOwnerData_109;
		public ImGuiKeyOwnerData KeysOwnerData_110;
		public ImGuiKeyOwnerData KeysOwnerData_111;
		public ImGuiKeyOwnerData KeysOwnerData_112;
		public ImGuiKeyOwnerData KeysOwnerData_113;
		public ImGuiKeyOwnerData KeysOwnerData_114;
		public ImGuiKeyOwnerData KeysOwnerData_115;
		public ImGuiKeyOwnerData KeysOwnerData_116;
		public ImGuiKeyOwnerData KeysOwnerData_117;
		public ImGuiKeyOwnerData KeysOwnerData_118;
		public ImGuiKeyOwnerData KeysOwnerData_119;
		public ImGuiKeyOwnerData KeysOwnerData_120;
		public ImGuiKeyOwnerData KeysOwnerData_121;
		public ImGuiKeyOwnerData KeysOwnerData_122;
		public ImGuiKeyOwnerData KeysOwnerData_123;
		public ImGuiKeyOwnerData KeysOwnerData_124;
		public ImGuiKeyOwnerData KeysOwnerData_125;
		public ImGuiKeyOwnerData KeysOwnerData_126;
		public ImGuiKeyOwnerData KeysOwnerData_127;
		public ImGuiKeyOwnerData KeysOwnerData_128;
		public ImGuiKeyOwnerData KeysOwnerData_129;
		public ImGuiKeyOwnerData KeysOwnerData_130;
		public ImGuiKeyOwnerData KeysOwnerData_131;
		public ImGuiKeyOwnerData KeysOwnerData_132;
		public ImGuiKeyOwnerData KeysOwnerData_133;
		public ImGuiKeyOwnerData KeysOwnerData_134;
		public ImGuiKeyOwnerData KeysOwnerData_135;
		public ImGuiKeyOwnerData KeysOwnerData_136;
		public ImGuiKeyOwnerData KeysOwnerData_137;
		public ImGuiKeyOwnerData KeysOwnerData_138;
		public ImGuiKeyOwnerData KeysOwnerData_139;
		public ImGuiKeyOwnerData KeysOwnerData_140;
		public ImGuiKeyOwnerData KeysOwnerData_141;
		public ImGuiKeyOwnerData KeysOwnerData_142;
		public ImGuiKeyOwnerData KeysOwnerData_143;
		public ImGuiKeyOwnerData KeysOwnerData_144;
		public ImGuiKeyOwnerData KeysOwnerData_145;
		public ImGuiKeyOwnerData KeysOwnerData_146;
		public ImGuiKeyOwnerData KeysOwnerData_147;
		public ImGuiKeyOwnerData KeysOwnerData_148;
		public ImGuiKeyOwnerData KeysOwnerData_149;
		public ImGuiKeyOwnerData KeysOwnerData_150;
		public ImGuiKeyOwnerData KeysOwnerData_151;
		public ImGuiKeyOwnerData KeysOwnerData_152;
		public ImGuiKeyOwnerData KeysOwnerData_153;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiKeyRoutingTable KeysRoutingTable;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ActiveIdUsingNavDirMask;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ActiveIdUsingAllKeyboardKeys;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ActiveIdUsingNavInputMask;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint CurrentFocusScopeId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurrentItemFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DebugLocateId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNextItemData NextItemData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiLastItemData LastItemData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNextWindowData NextWindowData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DebugShowGroupRects;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiColorMod ColorStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiStyleMod StyleVarStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImFontPtr FontStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiID FocusScopeStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiItemFlags ItemFlagsStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiGroupData GroupStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiPopupData OpenPopupStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiPopupData BeginPopupStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiNavTreeNodeData NavTreeNodeStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BeginMenuCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiViewportPPtr Viewports;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CurrentDpiScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiViewportP* CurrentViewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiViewportP* MouseViewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiViewportP* MouseLastHoveredViewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint PlatformLastFocusedViewportId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiPlatformMonitor FallbackMonitor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ViewportCreatedCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int PlatformWindowsCreatedCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ViewportFocusedStampCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* NavWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavFocusScopeId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavActivateId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavActivateDownId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavActivatePressedId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavActivateFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavJustMovedToId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavJustMovedToFocusScopeId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavJustMovedToKeyMods;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavNextActivateId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavNextActivateFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiInputSource NavInputSource;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNavLayer NavLayer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiSelectionUserData NavLastValidSelectionUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavIdIsAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavMousePosDirty;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavDisableHighlight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavDisableMouseHover;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavAnyRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavInitRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavInitRequestFromMove;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNavItemData NavInitResult;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavMoveSubmitted;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavMoveScoringItems;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavMoveForwardToNextFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavMoveFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavMoveScrollFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavMoveKeyMods;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavMoveDir;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavMoveDirForDebug;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavMoveClipDir;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect NavScoringRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect NavScoringNoClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavScoringDebugCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavTabbingDir;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NavTabbingCounter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNavItemData NavMoveResultLocal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNavItemData NavMoveResultLocalVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNavItemData NavMoveResultOther;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNavItemData NavTabbingResultFirst;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ConfigNavWindowingKeyNext;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ConfigNavWindowingKeyPrev;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* NavWindowingTarget;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* NavWindowingTargetAnim;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* NavWindowingListWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float NavWindowingTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float NavWindowingHighlightAlpha;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavWindowingToggleLayer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 NavWindowingAccumDeltaPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 NavWindowingAccumDeltaSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DimBgRatio;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DragDropActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DragDropWithinSource;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DragDropWithinTarget;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DragDropSourceFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DragDropSourceFrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DragDropMouseButton;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiPayload DragDropPayload;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect DragDropTargetRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DragDropTargetId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DragDropAcceptFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DragDropAcceptIdCurrRectSurface;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DragDropAcceptIdCurr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DragDropAcceptIdPrev;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DragDropAcceptFrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DragDropHoldJustPressedId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorUnsignedChar DragDropPayloadBufHeap;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DragDropPayloadBufLocal_0;
		public byte DragDropPayloadBufLocal_1;
		public byte DragDropPayloadBufLocal_2;
		public byte DragDropPayloadBufLocal_3;
		public byte DragDropPayloadBufLocal_4;
		public byte DragDropPayloadBufLocal_5;
		public byte DragDropPayloadBufLocal_6;
		public byte DragDropPayloadBufLocal_7;
		public byte DragDropPayloadBufLocal_8;
		public byte DragDropPayloadBufLocal_9;
		public byte DragDropPayloadBufLocal_10;
		public byte DragDropPayloadBufLocal_11;
		public byte DragDropPayloadBufLocal_12;
		public byte DragDropPayloadBufLocal_13;
		public byte DragDropPayloadBufLocal_14;
		public byte DragDropPayloadBufLocal_15;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ClipperTempDataStacked;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiListClipperData ClipperTempData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTable* CurrentTable;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TablesTempDataStacked;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTableTempData TablesTempData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImPoolImGuiTable Tables;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorFloat TablesLastTimeActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawChannel DrawChannelsTempMergeBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTabBar* CurrentTabBar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImPoolImGuiTabBar TabBars;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiPtrOrIndex CurrentTabBarStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiShrinkWidthItem ShrinkWidthBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint HoverItemDelayId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint HoverItemDelayIdPreviousFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HoverItemDelayTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HoverItemDelayClearTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint HoverItemUnlockedStationaryId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint HoverWindowUnlockedStationaryId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MouseCursor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseStationaryTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MouseLastValidPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiInputTextState InputTextState;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiInputTextDeactivatedState InputTextDeactivatedState;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImFont InputTextPasswordFont;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint TempInputId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ColorEditOptions;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ColorEditCurrentID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ColorEditSavedID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ColorEditSavedHue;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ColorEditSavedSat;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ColorEditSavedColor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 ColorPickerRef;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiComboPreviewData ComboPreviewData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float SliderGrabClickOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float SliderCurrentAccum;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SliderCurrentAccumDirty;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DragCurrentAccumDirty;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DragCurrentAccum;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DragSpeedDefaultRatio;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollbarClickDeltaToGrabCenter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DisabledAlphaBackup;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short DisabledStackSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short LockMarkEdited;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short TooltipOverrideCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorChar ClipboardHandlerData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiID MenusIdSubmittedThisFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTypingSelectState TypingSelectState;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiPlatformImeData PlatformImeData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiPlatformImeData PlatformImeDataPrev;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint PlatformImeViewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiDockContext DockContext;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* DockNodeWindowMenuHandler;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SettingsLoaded;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float SettingsDirtyTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTextBuffer SettingsIniData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiSettingsHandler SettingsHandlers;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImChunkStreamImGuiWindowSettings SettingsWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImChunkStreamImGuiTableSettings SettingsTables;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiContextHook Hooks;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint HookIdNext;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* LocalizationTable_0;
		public unsafe byte* LocalizationTable_1;
		public unsafe byte* LocalizationTable_2;
		public unsafe byte* LocalizationTable_3;
		public unsafe byte* LocalizationTable_4;
		public unsafe byte* LocalizationTable_5;
		public unsafe byte* LocalizationTable_6;
		public unsafe byte* LocalizationTable_7;
		public unsafe byte* LocalizationTable_8;
		public unsafe byte* LocalizationTable_9;
		public unsafe byte* LocalizationTable_10;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte LogEnabled;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiLogType LogType;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImFileHandle LogFile;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTextBuffer LogBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* LogNextPrefix;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* LogNextSuffix;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LogLinePosY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte LogLineFirstItem;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LogDepthRef;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LogDepthToExpand;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LogDepthToExpandDefault;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DebugLogFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTextBuffer DebugLogBuf;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTextIndex DebugLogIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DebugLogClipperAutoDisableFrames;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DebugLocateFrames;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DebugBeginReturnValueCullDepth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DebugItemPickerActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DebugItemPickerMouseButton;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DebugItemPickerBreakId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiMetricsConfig DebugMetricsConfig;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiIDStackTool DebugIDStackTool;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiDebugAllocInfo DebugAllocInfo;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* DebugHoveredDockNode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FramerateSecPerFrame_0;
		public float FramerateSecPerFrame_1;
		public float FramerateSecPerFrame_2;
		public float FramerateSecPerFrame_3;
		public float FramerateSecPerFrame_4;
		public float FramerateSecPerFrame_5;
		public float FramerateSecPerFrame_6;
		public float FramerateSecPerFrame_7;
		public float FramerateSecPerFrame_8;
		public float FramerateSecPerFrame_9;
		public float FramerateSecPerFrame_10;
		public float FramerateSecPerFrame_11;
		public float FramerateSecPerFrame_12;
		public float FramerateSecPerFrame_13;
		public float FramerateSecPerFrame_14;
		public float FramerateSecPerFrame_15;
		public float FramerateSecPerFrame_16;
		public float FramerateSecPerFrame_17;
		public float FramerateSecPerFrame_18;
		public float FramerateSecPerFrame_19;
		public float FramerateSecPerFrame_20;
		public float FramerateSecPerFrame_21;
		public float FramerateSecPerFrame_22;
		public float FramerateSecPerFrame_23;
		public float FramerateSecPerFrame_24;
		public float FramerateSecPerFrame_25;
		public float FramerateSecPerFrame_26;
		public float FramerateSecPerFrame_27;
		public float FramerateSecPerFrame_28;
		public float FramerateSecPerFrame_29;
		public float FramerateSecPerFrame_30;
		public float FramerateSecPerFrame_31;
		public float FramerateSecPerFrame_32;
		public float FramerateSecPerFrame_33;
		public float FramerateSecPerFrame_34;
		public float FramerateSecPerFrame_35;
		public float FramerateSecPerFrame_36;
		public float FramerateSecPerFrame_37;
		public float FramerateSecPerFrame_38;
		public float FramerateSecPerFrame_39;
		public float FramerateSecPerFrame_40;
		public float FramerateSecPerFrame_41;
		public float FramerateSecPerFrame_42;
		public float FramerateSecPerFrame_43;
		public float FramerateSecPerFrame_44;
		public float FramerateSecPerFrame_45;
		public float FramerateSecPerFrame_46;
		public float FramerateSecPerFrame_47;
		public float FramerateSecPerFrame_48;
		public float FramerateSecPerFrame_49;
		public float FramerateSecPerFrame_50;
		public float FramerateSecPerFrame_51;
		public float FramerateSecPerFrame_52;
		public float FramerateSecPerFrame_53;
		public float FramerateSecPerFrame_54;
		public float FramerateSecPerFrame_55;
		public float FramerateSecPerFrame_56;
		public float FramerateSecPerFrame_57;
		public float FramerateSecPerFrame_58;
		public float FramerateSecPerFrame_59;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FramerateSecPerFrameIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FramerateSecPerFrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FramerateSecPerFrameAccum;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int WantCaptureMouseNextFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int WantCaptureKeyboardNextFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int WantTextInputNextFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorChar TempBuffer;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiContext(bool initialized = default, bool fontAtlasOwnedByContext = default, ImGuiIO io = default, ImGuiPlatformIO platformIo = default, ImGuiStyle style = default, int configFlagsCurrFrame = default, int configFlagsLastFrame = default, ImFont* font = default, float fontSize = default, float fontBaseSize = default, ImDrawListSharedData drawListSharedData = default, double time = default, int frameCount = default, int frameCountEnded = default, int frameCountPlatformEnded = default, int frameCountRendered = default, bool withinFrameScope = default, bool withinFrameScopeWithImplicitWindow = default, bool withinEndChild = default, bool gcCompactAll = default, bool testEngineHookItems = default, void* testEngine = default, ImVectorImGuiInputEvent inputEventsQueue = default, ImVectorImGuiInputEvent inputEventsTrail = default, ImGuiMouseSource inputEventsNextMouseSource = default, uint inputEventsNextEventId = default, ImVectorImGuiWindowPtr windows = default, ImVectorImGuiWindowPtr windowsFocusOrder = default, ImVectorImGuiWindowPtr windowsTempSortBuffer = default, ImVectorImGuiWindowStackData currentWindowStack = default, ImGuiStorage windowsById = default, int windowsActiveCount = default, Vector2 windowsHoverPadding = default, ImGuiWindow* currentWindow = default, ImGuiWindow* hoveredWindow = default, ImGuiWindow* hoveredWindowUnderMovingWindow = default, ImGuiWindow* movingWindow = default, ImGuiWindow* wheelingWindow = default, Vector2 wheelingWindowRefMousePos = default, int wheelingWindowStartFrame = default, float wheelingWindowReleaseTimer = default, Vector2 wheelingWindowWheelRemainder = default, Vector2 wheelingAxisAvg = default, uint debugHookIdInfo = default, uint hoveredId = default, uint hoveredIdPreviousFrame = default, bool hoveredIdAllowOverlap = default, bool hoveredIdDisabled = default, float hoveredIdTimer = default, float hoveredIdNotActiveTimer = default, uint activeId = default, uint activeIdIsAlive = default, float activeIdTimer = default, bool activeIdIsJustActivated = default, bool activeIdAllowOverlap = default, bool activeIdNoClearOnFocusLoss = default, bool activeIdHasBeenPressedBefore = default, bool activeIdHasBeenEditedBefore = default, bool activeIdHasBeenEditedThisFrame = default, Vector2 activeIdClickOffset = default, ImGuiWindow* activeIdWindow = default, ImGuiInputSource activeIdSource = default, int activeIdMouseButton = default, uint activeIdPreviousFrame = default, bool activeIdPreviousFrameIsAlive = default, bool activeIdPreviousFrameHasBeenEditedBefore = default, ImGuiWindow* activeIdPreviousFrameWindow = default, uint lastActiveId = default, float lastActiveIdTimer = default, ImGuiKeyOwnerData* keysOwnerData = default, ImGuiKeyRoutingTable keysRoutingTable = default, uint activeIdUsingNavDirMask = default, bool activeIdUsingAllKeyboardKeys = default, uint activeIdUsingNavInputMask = default, uint currentFocusScopeId = default, int currentItemFlags = default, uint debugLocateId = default, ImGuiNextItemData nextItemData = default, ImGuiLastItemData lastItemData = default, ImGuiNextWindowData nextWindowData = default, bool debugShowGroupRects = default, ImVectorImGuiColorMod colorStack = default, ImVectorImGuiStyleMod styleVarStack = default, ImVectorImFontPtr fontStack = default, ImVectorImGuiID focusScopeStack = default, ImVectorImGuiItemFlags itemFlagsStack = default, ImVectorImGuiGroupData groupStack = default, ImVectorImGuiPopupData openPopupStack = default, ImVectorImGuiPopupData beginPopupStack = default, ImVectorImGuiNavTreeNodeData navTreeNodeStack = default, int beginMenuCount = default, ImVectorImGuiViewportPPtr viewports = default, float currentDpiScale = default, ImGuiViewportP* currentViewport = default, ImGuiViewportP* mouseViewport = default, ImGuiViewportP* mouseLastHoveredViewport = default, uint platformLastFocusedViewportId = default, ImGuiPlatformMonitor fallbackMonitor = default, int viewportCreatedCount = default, int platformWindowsCreatedCount = default, int viewportFocusedStampCount = default, ImGuiWindow* navWindow = default, uint navId = default, uint navFocusScopeId = default, uint navActivateId = default, uint navActivateDownId = default, uint navActivatePressedId = default, int navActivateFlags = default, uint navJustMovedToId = default, uint navJustMovedToFocusScopeId = default, int navJustMovedToKeyMods = default, uint navNextActivateId = default, int navNextActivateFlags = default, ImGuiInputSource navInputSource = default, ImGuiNavLayer navLayer = default, ImGuiSelectionUserData navLastValidSelectionUserData = default, bool navIdIsAlive = default, bool navMousePosDirty = default, bool navDisableHighlight = default, bool navDisableMouseHover = default, bool navAnyRequest = default, bool navInitRequest = default, bool navInitRequestFromMove = default, ImGuiNavItemData navInitResult = default, bool navMoveSubmitted = default, bool navMoveScoringItems = default, bool navMoveForwardToNextFrame = default, int navMoveFlags = default, int navMoveScrollFlags = default, int navMoveKeyMods = default, int navMoveDir = default, int navMoveDirForDebug = default, int navMoveClipDir = default, ImRect navScoringRect = default, ImRect navScoringNoClipRect = default, int navScoringDebugCount = default, int navTabbingDir = default, int navTabbingCounter = default, ImGuiNavItemData navMoveResultLocal = default, ImGuiNavItemData navMoveResultLocalVisible = default, ImGuiNavItemData navMoveResultOther = default, ImGuiNavItemData navTabbingResultFirst = default, int configNavWindowingKeyNext = default, int configNavWindowingKeyPrev = default, ImGuiWindow* navWindowingTarget = default, ImGuiWindow* navWindowingTargetAnim = default, ImGuiWindow* navWindowingListWindow = default, float navWindowingTimer = default, float navWindowingHighlightAlpha = default, bool navWindowingToggleLayer = default, Vector2 navWindowingAccumDeltaPos = default, Vector2 navWindowingAccumDeltaSize = default, float dimBgRatio = default, bool dragDropActive = default, bool dragDropWithinSource = default, bool dragDropWithinTarget = default, int dragDropSourceFlags = default, int dragDropSourceFrameCount = default, int dragDropMouseButton = default, ImGuiPayload dragDropPayload = default, ImRect dragDropTargetRect = default, uint dragDropTargetId = default, int dragDropAcceptFlags = default, float dragDropAcceptIdCurrRectSurface = default, uint dragDropAcceptIdCurr = default, uint dragDropAcceptIdPrev = default, int dragDropAcceptFrameCount = default, uint dragDropHoldJustPressedId = default, ImVectorUnsignedChar dragDropPayloadBufHeap = default, byte* dragDropPayloadBufLocal = default, int clipperTempDataStacked = default, ImVectorImGuiListClipperData clipperTempData = default, ImGuiTable* currentTable = default, int tablesTempDataStacked = default, ImVectorImGuiTableTempData tablesTempData = default, ImPoolImGuiTable tables = default, ImVectorFloat tablesLastTimeActive = default, ImVectorImDrawChannel drawChannelsTempMergeBuffer = default, ImGuiTabBar* currentTabBar = default, ImPoolImGuiTabBar tabBars = default, ImVectorImGuiPtrOrIndex currentTabBarStack = default, ImVectorImGuiShrinkWidthItem shrinkWidthBuffer = default, uint hoverItemDelayId = default, uint hoverItemDelayIdPreviousFrame = default, float hoverItemDelayTimer = default, float hoverItemDelayClearTimer = default, uint hoverItemUnlockedStationaryId = default, uint hoverWindowUnlockedStationaryId = default, int mouseCursor = default, float mouseStationaryTimer = default, Vector2 mouseLastValidPos = default, ImGuiInputTextState inputTextState = default, ImGuiInputTextDeactivatedState inputTextDeactivatedState = default, ImFont inputTextPasswordFont = default, uint tempInputId = default, int colorEditOptions = default, uint colorEditCurrentId = default, uint colorEditSavedId = default, float colorEditSavedHue = default, float colorEditSavedSat = default, uint colorEditSavedColor = default, Vector4 colorPickerRef = default, ImGuiComboPreviewData comboPreviewData = default, float sliderGrabClickOffset = default, float sliderCurrentAccum = default, bool sliderCurrentAccumDirty = default, bool dragCurrentAccumDirty = default, float dragCurrentAccum = default, float dragSpeedDefaultRatio = default, float scrollbarClickDeltaToGrabCenter = default, float disabledAlphaBackup = default, short disabledStackSize = default, short lockMarkEdited = default, short tooltipOverrideCount = default, ImVectorChar clipboardHandlerData = default, ImVectorImGuiID menusIdSubmittedThisFrame = default, ImGuiTypingSelectState typingSelectState = default, ImGuiPlatformImeData platformImeData = default, ImGuiPlatformImeData platformImeDataPrev = default, uint platformImeViewport = default, ImGuiDockContext dockContext = default, delegate*<ImGuiContext*, ImGuiDockNode*, ImGuiTabBar*, void> dockNodeWindowMenuHandler = default, bool settingsLoaded = default, float settingsDirtyTimer = default, ImGuiTextBuffer settingsIniData = default, ImVectorImGuiSettingsHandler settingsHandlers = default, ImChunkStreamImGuiWindowSettings settingsWindows = default, ImChunkStreamImGuiTableSettings settingsTables = default, ImVectorImGuiContextHook hooks = default, uint hookIdNext = default, byte** localizationTable = default, bool logEnabled = default, ImGuiLogType logType = default, ImFileHandle logFile = default, ImGuiTextBuffer logBuffer = default, byte* logNextPrefix = default, byte* logNextSuffix = default, float logLinePosY = default, bool logLineFirstItem = default, int logDepthRef = default, int logDepthToExpand = default, int logDepthToExpandDefault = default, int debugLogFlags = default, ImGuiTextBuffer debugLogBuf = default, ImGuiTextIndex debugLogIndex = default, byte debugLogClipperAutoDisableFrames = default, byte debugLocateFrames = default, byte debugBeginReturnValueCullDepth = default, bool debugItemPickerActive = default, byte debugItemPickerMouseButton = default, uint debugItemPickerBreakId = default, ImGuiMetricsConfig debugMetricsConfig = default, ImGuiIDStackTool debugIdStackTool = default, ImGuiDebugAllocInfo debugAllocInfo = default, ImGuiDockNode* debugHoveredDockNode = default, float* framerateSecPerFrame = default, int framerateSecPerFrameIdx = default, int framerateSecPerFrameCount = default, float framerateSecPerFrameAccum = default, int wantCaptureMouseNextFrame = default, int wantCaptureKeyboardNextFrame = default, int wantTextInputNextFrame = default, ImVectorChar tempBuffer = default)
		{
			Initialized = initialized ? (byte)1 : (byte)0;
			FontAtlasOwnedByContext = fontAtlasOwnedByContext ? (byte)1 : (byte)0;
			IO = io;
			PlatformIO = platformIo;
			Style = style;
			ConfigFlagsCurrFrame = configFlagsCurrFrame;
			ConfigFlagsLastFrame = configFlagsLastFrame;
			Font = font;
			FontSize = fontSize;
			FontBaseSize = fontBaseSize;
			DrawListSharedData = drawListSharedData;
			Time = time;
			FrameCount = frameCount;
			FrameCountEnded = frameCountEnded;
			FrameCountPlatformEnded = frameCountPlatformEnded;
			FrameCountRendered = frameCountRendered;
			WithinFrameScope = withinFrameScope ? (byte)1 : (byte)0;
			WithinFrameScopeWithImplicitWindow = withinFrameScopeWithImplicitWindow ? (byte)1 : (byte)0;
			WithinEndChild = withinEndChild ? (byte)1 : (byte)0;
			GcCompactAll = gcCompactAll ? (byte)1 : (byte)0;
			TestEngineHookItems = testEngineHookItems ? (byte)1 : (byte)0;
			TestEngine = testEngine;
			InputEventsQueue = inputEventsQueue;
			InputEventsTrail = inputEventsTrail;
			InputEventsNextMouseSource = inputEventsNextMouseSource;
			InputEventsNextEventId = inputEventsNextEventId;
			Windows = windows;
			WindowsFocusOrder = windowsFocusOrder;
			WindowsTempSortBuffer = windowsTempSortBuffer;
			CurrentWindowStack = currentWindowStack;
			WindowsById = windowsById;
			WindowsActiveCount = windowsActiveCount;
			WindowsHoverPadding = windowsHoverPadding;
			CurrentWindow = currentWindow;
			HoveredWindow = hoveredWindow;
			HoveredWindowUnderMovingWindow = hoveredWindowUnderMovingWindow;
			MovingWindow = movingWindow;
			WheelingWindow = wheelingWindow;
			WheelingWindowRefMousePos = wheelingWindowRefMousePos;
			WheelingWindowStartFrame = wheelingWindowStartFrame;
			WheelingWindowReleaseTimer = wheelingWindowReleaseTimer;
			WheelingWindowWheelRemainder = wheelingWindowWheelRemainder;
			WheelingAxisAvg = wheelingAxisAvg;
			DebugHookIdInfo = debugHookIdInfo;
			HoveredId = hoveredId;
			HoveredIdPreviousFrame = hoveredIdPreviousFrame;
			HoveredIdAllowOverlap = hoveredIdAllowOverlap ? (byte)1 : (byte)0;
			HoveredIdDisabled = hoveredIdDisabled ? (byte)1 : (byte)0;
			HoveredIdTimer = hoveredIdTimer;
			HoveredIdNotActiveTimer = hoveredIdNotActiveTimer;
			ActiveId = activeId;
			ActiveIdIsAlive = activeIdIsAlive;
			ActiveIdTimer = activeIdTimer;
			ActiveIdIsJustActivated = activeIdIsJustActivated ? (byte)1 : (byte)0;
			ActiveIdAllowOverlap = activeIdAllowOverlap ? (byte)1 : (byte)0;
			ActiveIdNoClearOnFocusLoss = activeIdNoClearOnFocusLoss ? (byte)1 : (byte)0;
			ActiveIdHasBeenPressedBefore = activeIdHasBeenPressedBefore ? (byte)1 : (byte)0;
			ActiveIdHasBeenEditedBefore = activeIdHasBeenEditedBefore ? (byte)1 : (byte)0;
			ActiveIdHasBeenEditedThisFrame = activeIdHasBeenEditedThisFrame ? (byte)1 : (byte)0;
			ActiveIdClickOffset = activeIdClickOffset;
			ActiveIdWindow = activeIdWindow;
			ActiveIdSource = activeIdSource;
			ActiveIdMouseButton = activeIdMouseButton;
			ActiveIdPreviousFrame = activeIdPreviousFrame;
			ActiveIdPreviousFrameIsAlive = activeIdPreviousFrameIsAlive ? (byte)1 : (byte)0;
			ActiveIdPreviousFrameHasBeenEditedBefore = activeIdPreviousFrameHasBeenEditedBefore ? (byte)1 : (byte)0;
			ActiveIdPreviousFrameWindow = activeIdPreviousFrameWindow;
			LastActiveId = lastActiveId;
			LastActiveIdTimer = lastActiveIdTimer;
			if (keysOwnerData != default)
			{
				KeysOwnerData_0 = keysOwnerData[0];
				KeysOwnerData_1 = keysOwnerData[1];
				KeysOwnerData_2 = keysOwnerData[2];
				KeysOwnerData_3 = keysOwnerData[3];
				KeysOwnerData_4 = keysOwnerData[4];
				KeysOwnerData_5 = keysOwnerData[5];
				KeysOwnerData_6 = keysOwnerData[6];
				KeysOwnerData_7 = keysOwnerData[7];
				KeysOwnerData_8 = keysOwnerData[8];
				KeysOwnerData_9 = keysOwnerData[9];
				KeysOwnerData_10 = keysOwnerData[10];
				KeysOwnerData_11 = keysOwnerData[11];
				KeysOwnerData_12 = keysOwnerData[12];
				KeysOwnerData_13 = keysOwnerData[13];
				KeysOwnerData_14 = keysOwnerData[14];
				KeysOwnerData_15 = keysOwnerData[15];
				KeysOwnerData_16 = keysOwnerData[16];
				KeysOwnerData_17 = keysOwnerData[17];
				KeysOwnerData_18 = keysOwnerData[18];
				KeysOwnerData_19 = keysOwnerData[19];
				KeysOwnerData_20 = keysOwnerData[20];
				KeysOwnerData_21 = keysOwnerData[21];
				KeysOwnerData_22 = keysOwnerData[22];
				KeysOwnerData_23 = keysOwnerData[23];
				KeysOwnerData_24 = keysOwnerData[24];
				KeysOwnerData_25 = keysOwnerData[25];
				KeysOwnerData_26 = keysOwnerData[26];
				KeysOwnerData_27 = keysOwnerData[27];
				KeysOwnerData_28 = keysOwnerData[28];
				KeysOwnerData_29 = keysOwnerData[29];
				KeysOwnerData_30 = keysOwnerData[30];
				KeysOwnerData_31 = keysOwnerData[31];
				KeysOwnerData_32 = keysOwnerData[32];
				KeysOwnerData_33 = keysOwnerData[33];
				KeysOwnerData_34 = keysOwnerData[34];
				KeysOwnerData_35 = keysOwnerData[35];
				KeysOwnerData_36 = keysOwnerData[36];
				KeysOwnerData_37 = keysOwnerData[37];
				KeysOwnerData_38 = keysOwnerData[38];
				KeysOwnerData_39 = keysOwnerData[39];
				KeysOwnerData_40 = keysOwnerData[40];
				KeysOwnerData_41 = keysOwnerData[41];
				KeysOwnerData_42 = keysOwnerData[42];
				KeysOwnerData_43 = keysOwnerData[43];
				KeysOwnerData_44 = keysOwnerData[44];
				KeysOwnerData_45 = keysOwnerData[45];
				KeysOwnerData_46 = keysOwnerData[46];
				KeysOwnerData_47 = keysOwnerData[47];
				KeysOwnerData_48 = keysOwnerData[48];
				KeysOwnerData_49 = keysOwnerData[49];
				KeysOwnerData_50 = keysOwnerData[50];
				KeysOwnerData_51 = keysOwnerData[51];
				KeysOwnerData_52 = keysOwnerData[52];
				KeysOwnerData_53 = keysOwnerData[53];
				KeysOwnerData_54 = keysOwnerData[54];
				KeysOwnerData_55 = keysOwnerData[55];
				KeysOwnerData_56 = keysOwnerData[56];
				KeysOwnerData_57 = keysOwnerData[57];
				KeysOwnerData_58 = keysOwnerData[58];
				KeysOwnerData_59 = keysOwnerData[59];
				KeysOwnerData_60 = keysOwnerData[60];
				KeysOwnerData_61 = keysOwnerData[61];
				KeysOwnerData_62 = keysOwnerData[62];
				KeysOwnerData_63 = keysOwnerData[63];
				KeysOwnerData_64 = keysOwnerData[64];
				KeysOwnerData_65 = keysOwnerData[65];
				KeysOwnerData_66 = keysOwnerData[66];
				KeysOwnerData_67 = keysOwnerData[67];
				KeysOwnerData_68 = keysOwnerData[68];
				KeysOwnerData_69 = keysOwnerData[69];
				KeysOwnerData_70 = keysOwnerData[70];
				KeysOwnerData_71 = keysOwnerData[71];
				KeysOwnerData_72 = keysOwnerData[72];
				KeysOwnerData_73 = keysOwnerData[73];
				KeysOwnerData_74 = keysOwnerData[74];
				KeysOwnerData_75 = keysOwnerData[75];
				KeysOwnerData_76 = keysOwnerData[76];
				KeysOwnerData_77 = keysOwnerData[77];
				KeysOwnerData_78 = keysOwnerData[78];
				KeysOwnerData_79 = keysOwnerData[79];
				KeysOwnerData_80 = keysOwnerData[80];
				KeysOwnerData_81 = keysOwnerData[81];
				KeysOwnerData_82 = keysOwnerData[82];
				KeysOwnerData_83 = keysOwnerData[83];
				KeysOwnerData_84 = keysOwnerData[84];
				KeysOwnerData_85 = keysOwnerData[85];
				KeysOwnerData_86 = keysOwnerData[86];
				KeysOwnerData_87 = keysOwnerData[87];
				KeysOwnerData_88 = keysOwnerData[88];
				KeysOwnerData_89 = keysOwnerData[89];
				KeysOwnerData_90 = keysOwnerData[90];
				KeysOwnerData_91 = keysOwnerData[91];
				KeysOwnerData_92 = keysOwnerData[92];
				KeysOwnerData_93 = keysOwnerData[93];
				KeysOwnerData_94 = keysOwnerData[94];
				KeysOwnerData_95 = keysOwnerData[95];
				KeysOwnerData_96 = keysOwnerData[96];
				KeysOwnerData_97 = keysOwnerData[97];
				KeysOwnerData_98 = keysOwnerData[98];
				KeysOwnerData_99 = keysOwnerData[99];
				KeysOwnerData_100 = keysOwnerData[100];
				KeysOwnerData_101 = keysOwnerData[101];
				KeysOwnerData_102 = keysOwnerData[102];
				KeysOwnerData_103 = keysOwnerData[103];
				KeysOwnerData_104 = keysOwnerData[104];
				KeysOwnerData_105 = keysOwnerData[105];
				KeysOwnerData_106 = keysOwnerData[106];
				KeysOwnerData_107 = keysOwnerData[107];
				KeysOwnerData_108 = keysOwnerData[108];
				KeysOwnerData_109 = keysOwnerData[109];
				KeysOwnerData_110 = keysOwnerData[110];
				KeysOwnerData_111 = keysOwnerData[111];
				KeysOwnerData_112 = keysOwnerData[112];
				KeysOwnerData_113 = keysOwnerData[113];
				KeysOwnerData_114 = keysOwnerData[114];
				KeysOwnerData_115 = keysOwnerData[115];
				KeysOwnerData_116 = keysOwnerData[116];
				KeysOwnerData_117 = keysOwnerData[117];
				KeysOwnerData_118 = keysOwnerData[118];
				KeysOwnerData_119 = keysOwnerData[119];
				KeysOwnerData_120 = keysOwnerData[120];
				KeysOwnerData_121 = keysOwnerData[121];
				KeysOwnerData_122 = keysOwnerData[122];
				KeysOwnerData_123 = keysOwnerData[123];
				KeysOwnerData_124 = keysOwnerData[124];
				KeysOwnerData_125 = keysOwnerData[125];
				KeysOwnerData_126 = keysOwnerData[126];
				KeysOwnerData_127 = keysOwnerData[127];
				KeysOwnerData_128 = keysOwnerData[128];
				KeysOwnerData_129 = keysOwnerData[129];
				KeysOwnerData_130 = keysOwnerData[130];
				KeysOwnerData_131 = keysOwnerData[131];
				KeysOwnerData_132 = keysOwnerData[132];
				KeysOwnerData_133 = keysOwnerData[133];
				KeysOwnerData_134 = keysOwnerData[134];
				KeysOwnerData_135 = keysOwnerData[135];
				KeysOwnerData_136 = keysOwnerData[136];
				KeysOwnerData_137 = keysOwnerData[137];
				KeysOwnerData_138 = keysOwnerData[138];
				KeysOwnerData_139 = keysOwnerData[139];
				KeysOwnerData_140 = keysOwnerData[140];
				KeysOwnerData_141 = keysOwnerData[141];
				KeysOwnerData_142 = keysOwnerData[142];
				KeysOwnerData_143 = keysOwnerData[143];
				KeysOwnerData_144 = keysOwnerData[144];
				KeysOwnerData_145 = keysOwnerData[145];
				KeysOwnerData_146 = keysOwnerData[146];
				KeysOwnerData_147 = keysOwnerData[147];
				KeysOwnerData_148 = keysOwnerData[148];
				KeysOwnerData_149 = keysOwnerData[149];
				KeysOwnerData_150 = keysOwnerData[150];
				KeysOwnerData_151 = keysOwnerData[151];
				KeysOwnerData_152 = keysOwnerData[152];
				KeysOwnerData_153 = keysOwnerData[153];
			}
			KeysRoutingTable = keysRoutingTable;
			ActiveIdUsingNavDirMask = activeIdUsingNavDirMask;
			ActiveIdUsingAllKeyboardKeys = activeIdUsingAllKeyboardKeys ? (byte)1 : (byte)0;
			ActiveIdUsingNavInputMask = activeIdUsingNavInputMask;
			CurrentFocusScopeId = currentFocusScopeId;
			CurrentItemFlags = currentItemFlags;
			DebugLocateId = debugLocateId;
			NextItemData = nextItemData;
			LastItemData = lastItemData;
			NextWindowData = nextWindowData;
			DebugShowGroupRects = debugShowGroupRects ? (byte)1 : (byte)0;
			ColorStack = colorStack;
			StyleVarStack = styleVarStack;
			FontStack = fontStack;
			FocusScopeStack = focusScopeStack;
			ItemFlagsStack = itemFlagsStack;
			GroupStack = groupStack;
			OpenPopupStack = openPopupStack;
			BeginPopupStack = beginPopupStack;
			NavTreeNodeStack = navTreeNodeStack;
			BeginMenuCount = beginMenuCount;
			Viewports = viewports;
			CurrentDpiScale = currentDpiScale;
			CurrentViewport = currentViewport;
			MouseViewport = mouseViewport;
			MouseLastHoveredViewport = mouseLastHoveredViewport;
			PlatformLastFocusedViewportId = platformLastFocusedViewportId;
			FallbackMonitor = fallbackMonitor;
			ViewportCreatedCount = viewportCreatedCount;
			PlatformWindowsCreatedCount = platformWindowsCreatedCount;
			ViewportFocusedStampCount = viewportFocusedStampCount;
			NavWindow = navWindow;
			NavId = navId;
			NavFocusScopeId = navFocusScopeId;
			NavActivateId = navActivateId;
			NavActivateDownId = navActivateDownId;
			NavActivatePressedId = navActivatePressedId;
			NavActivateFlags = navActivateFlags;
			NavJustMovedToId = navJustMovedToId;
			NavJustMovedToFocusScopeId = navJustMovedToFocusScopeId;
			NavJustMovedToKeyMods = navJustMovedToKeyMods;
			NavNextActivateId = navNextActivateId;
			NavNextActivateFlags = navNextActivateFlags;
			NavInputSource = navInputSource;
			NavLayer = navLayer;
			NavLastValidSelectionUserData = navLastValidSelectionUserData;
			NavIdIsAlive = navIdIsAlive ? (byte)1 : (byte)0;
			NavMousePosDirty = navMousePosDirty ? (byte)1 : (byte)0;
			NavDisableHighlight = navDisableHighlight ? (byte)1 : (byte)0;
			NavDisableMouseHover = navDisableMouseHover ? (byte)1 : (byte)0;
			NavAnyRequest = navAnyRequest ? (byte)1 : (byte)0;
			NavInitRequest = navInitRequest ? (byte)1 : (byte)0;
			NavInitRequestFromMove = navInitRequestFromMove ? (byte)1 : (byte)0;
			NavInitResult = navInitResult;
			NavMoveSubmitted = navMoveSubmitted ? (byte)1 : (byte)0;
			NavMoveScoringItems = navMoveScoringItems ? (byte)1 : (byte)0;
			NavMoveForwardToNextFrame = navMoveForwardToNextFrame ? (byte)1 : (byte)0;
			NavMoveFlags = navMoveFlags;
			NavMoveScrollFlags = navMoveScrollFlags;
			NavMoveKeyMods = navMoveKeyMods;
			NavMoveDir = navMoveDir;
			NavMoveDirForDebug = navMoveDirForDebug;
			NavMoveClipDir = navMoveClipDir;
			NavScoringRect = navScoringRect;
			NavScoringNoClipRect = navScoringNoClipRect;
			NavScoringDebugCount = navScoringDebugCount;
			NavTabbingDir = navTabbingDir;
			NavTabbingCounter = navTabbingCounter;
			NavMoveResultLocal = navMoveResultLocal;
			NavMoveResultLocalVisible = navMoveResultLocalVisible;
			NavMoveResultOther = navMoveResultOther;
			NavTabbingResultFirst = navTabbingResultFirst;
			ConfigNavWindowingKeyNext = configNavWindowingKeyNext;
			ConfigNavWindowingKeyPrev = configNavWindowingKeyPrev;
			NavWindowingTarget = navWindowingTarget;
			NavWindowingTargetAnim = navWindowingTargetAnim;
			NavWindowingListWindow = navWindowingListWindow;
			NavWindowingTimer = navWindowingTimer;
			NavWindowingHighlightAlpha = navWindowingHighlightAlpha;
			NavWindowingToggleLayer = navWindowingToggleLayer ? (byte)1 : (byte)0;
			NavWindowingAccumDeltaPos = navWindowingAccumDeltaPos;
			NavWindowingAccumDeltaSize = navWindowingAccumDeltaSize;
			DimBgRatio = dimBgRatio;
			DragDropActive = dragDropActive ? (byte)1 : (byte)0;
			DragDropWithinSource = dragDropWithinSource ? (byte)1 : (byte)0;
			DragDropWithinTarget = dragDropWithinTarget ? (byte)1 : (byte)0;
			DragDropSourceFlags = dragDropSourceFlags;
			DragDropSourceFrameCount = dragDropSourceFrameCount;
			DragDropMouseButton = dragDropMouseButton;
			DragDropPayload = dragDropPayload;
			DragDropTargetRect = dragDropTargetRect;
			DragDropTargetId = dragDropTargetId;
			DragDropAcceptFlags = dragDropAcceptFlags;
			DragDropAcceptIdCurrRectSurface = dragDropAcceptIdCurrRectSurface;
			DragDropAcceptIdCurr = dragDropAcceptIdCurr;
			DragDropAcceptIdPrev = dragDropAcceptIdPrev;
			DragDropAcceptFrameCount = dragDropAcceptFrameCount;
			DragDropHoldJustPressedId = dragDropHoldJustPressedId;
			DragDropPayloadBufHeap = dragDropPayloadBufHeap;
			if (dragDropPayloadBufLocal != default)
			{
				DragDropPayloadBufLocal_0 = dragDropPayloadBufLocal[0];
				DragDropPayloadBufLocal_1 = dragDropPayloadBufLocal[1];
				DragDropPayloadBufLocal_2 = dragDropPayloadBufLocal[2];
				DragDropPayloadBufLocal_3 = dragDropPayloadBufLocal[3];
				DragDropPayloadBufLocal_4 = dragDropPayloadBufLocal[4];
				DragDropPayloadBufLocal_5 = dragDropPayloadBufLocal[5];
				DragDropPayloadBufLocal_6 = dragDropPayloadBufLocal[6];
				DragDropPayloadBufLocal_7 = dragDropPayloadBufLocal[7];
				DragDropPayloadBufLocal_8 = dragDropPayloadBufLocal[8];
				DragDropPayloadBufLocal_9 = dragDropPayloadBufLocal[9];
				DragDropPayloadBufLocal_10 = dragDropPayloadBufLocal[10];
				DragDropPayloadBufLocal_11 = dragDropPayloadBufLocal[11];
				DragDropPayloadBufLocal_12 = dragDropPayloadBufLocal[12];
				DragDropPayloadBufLocal_13 = dragDropPayloadBufLocal[13];
				DragDropPayloadBufLocal_14 = dragDropPayloadBufLocal[14];
				DragDropPayloadBufLocal_15 = dragDropPayloadBufLocal[15];
			}
			ClipperTempDataStacked = clipperTempDataStacked;
			ClipperTempData = clipperTempData;
			CurrentTable = currentTable;
			TablesTempDataStacked = tablesTempDataStacked;
			TablesTempData = tablesTempData;
			Tables = tables;
			TablesLastTimeActive = tablesLastTimeActive;
			DrawChannelsTempMergeBuffer = drawChannelsTempMergeBuffer;
			CurrentTabBar = currentTabBar;
			TabBars = tabBars;
			CurrentTabBarStack = currentTabBarStack;
			ShrinkWidthBuffer = shrinkWidthBuffer;
			HoverItemDelayId = hoverItemDelayId;
			HoverItemDelayIdPreviousFrame = hoverItemDelayIdPreviousFrame;
			HoverItemDelayTimer = hoverItemDelayTimer;
			HoverItemDelayClearTimer = hoverItemDelayClearTimer;
			HoverItemUnlockedStationaryId = hoverItemUnlockedStationaryId;
			HoverWindowUnlockedStationaryId = hoverWindowUnlockedStationaryId;
			MouseCursor = mouseCursor;
			MouseStationaryTimer = mouseStationaryTimer;
			MouseLastValidPos = mouseLastValidPos;
			InputTextState = inputTextState;
			InputTextDeactivatedState = inputTextDeactivatedState;
			InputTextPasswordFont = inputTextPasswordFont;
			TempInputId = tempInputId;
			ColorEditOptions = colorEditOptions;
			ColorEditCurrentID = colorEditCurrentId;
			ColorEditSavedID = colorEditSavedId;
			ColorEditSavedHue = colorEditSavedHue;
			ColorEditSavedSat = colorEditSavedSat;
			ColorEditSavedColor = colorEditSavedColor;
			ColorPickerRef = colorPickerRef;
			ComboPreviewData = comboPreviewData;
			SliderGrabClickOffset = sliderGrabClickOffset;
			SliderCurrentAccum = sliderCurrentAccum;
			SliderCurrentAccumDirty = sliderCurrentAccumDirty ? (byte)1 : (byte)0;
			DragCurrentAccumDirty = dragCurrentAccumDirty ? (byte)1 : (byte)0;
			DragCurrentAccum = dragCurrentAccum;
			DragSpeedDefaultRatio = dragSpeedDefaultRatio;
			ScrollbarClickDeltaToGrabCenter = scrollbarClickDeltaToGrabCenter;
			DisabledAlphaBackup = disabledAlphaBackup;
			DisabledStackSize = disabledStackSize;
			LockMarkEdited = lockMarkEdited;
			TooltipOverrideCount = tooltipOverrideCount;
			ClipboardHandlerData = clipboardHandlerData;
			MenusIdSubmittedThisFrame = menusIdSubmittedThisFrame;
			TypingSelectState = typingSelectState;
			PlatformImeData = platformImeData;
			PlatformImeDataPrev = platformImeDataPrev;
			PlatformImeViewport = platformImeViewport;
			DockContext = dockContext;
			DockNodeWindowMenuHandler = (void*)dockNodeWindowMenuHandler;
			SettingsLoaded = settingsLoaded ? (byte)1 : (byte)0;
			SettingsDirtyTimer = settingsDirtyTimer;
			SettingsIniData = settingsIniData;
			SettingsHandlers = settingsHandlers;
			SettingsWindows = settingsWindows;
			SettingsTables = settingsTables;
			Hooks = hooks;
			HookIdNext = hookIdNext;
			if (localizationTable != default)
			{
				LocalizationTable_0 = localizationTable[0];
				LocalizationTable_1 = localizationTable[1];
				LocalizationTable_2 = localizationTable[2];
				LocalizationTable_3 = localizationTable[3];
				LocalizationTable_4 = localizationTable[4];
				LocalizationTable_5 = localizationTable[5];
				LocalizationTable_6 = localizationTable[6];
				LocalizationTable_7 = localizationTable[7];
				LocalizationTable_8 = localizationTable[8];
				LocalizationTable_9 = localizationTable[9];
				LocalizationTable_10 = localizationTable[10];
			}
			LogEnabled = logEnabled ? (byte)1 : (byte)0;
			LogType = logType;
			LogFile = logFile;
			LogBuffer = logBuffer;
			LogNextPrefix = logNextPrefix;
			LogNextSuffix = logNextSuffix;
			LogLinePosY = logLinePosY;
			LogLineFirstItem = logLineFirstItem ? (byte)1 : (byte)0;
			LogDepthRef = logDepthRef;
			LogDepthToExpand = logDepthToExpand;
			LogDepthToExpandDefault = logDepthToExpandDefault;
			DebugLogFlags = debugLogFlags;
			DebugLogBuf = debugLogBuf;
			DebugLogIndex = debugLogIndex;
			DebugLogClipperAutoDisableFrames = debugLogClipperAutoDisableFrames;
			DebugLocateFrames = debugLocateFrames;
			DebugBeginReturnValueCullDepth = debugBeginReturnValueCullDepth;
			DebugItemPickerActive = debugItemPickerActive ? (byte)1 : (byte)0;
			DebugItemPickerMouseButton = debugItemPickerMouseButton;
			DebugItemPickerBreakId = debugItemPickerBreakId;
			DebugMetricsConfig = debugMetricsConfig;
			DebugIDStackTool = debugIdStackTool;
			DebugAllocInfo = debugAllocInfo;
			DebugHoveredDockNode = debugHoveredDockNode;
			if (framerateSecPerFrame != default)
			{
				FramerateSecPerFrame_0 = framerateSecPerFrame[0];
				FramerateSecPerFrame_1 = framerateSecPerFrame[1];
				FramerateSecPerFrame_2 = framerateSecPerFrame[2];
				FramerateSecPerFrame_3 = framerateSecPerFrame[3];
				FramerateSecPerFrame_4 = framerateSecPerFrame[4];
				FramerateSecPerFrame_5 = framerateSecPerFrame[5];
				FramerateSecPerFrame_6 = framerateSecPerFrame[6];
				FramerateSecPerFrame_7 = framerateSecPerFrame[7];
				FramerateSecPerFrame_8 = framerateSecPerFrame[8];
				FramerateSecPerFrame_9 = framerateSecPerFrame[9];
				FramerateSecPerFrame_10 = framerateSecPerFrame[10];
				FramerateSecPerFrame_11 = framerateSecPerFrame[11];
				FramerateSecPerFrame_12 = framerateSecPerFrame[12];
				FramerateSecPerFrame_13 = framerateSecPerFrame[13];
				FramerateSecPerFrame_14 = framerateSecPerFrame[14];
				FramerateSecPerFrame_15 = framerateSecPerFrame[15];
				FramerateSecPerFrame_16 = framerateSecPerFrame[16];
				FramerateSecPerFrame_17 = framerateSecPerFrame[17];
				FramerateSecPerFrame_18 = framerateSecPerFrame[18];
				FramerateSecPerFrame_19 = framerateSecPerFrame[19];
				FramerateSecPerFrame_20 = framerateSecPerFrame[20];
				FramerateSecPerFrame_21 = framerateSecPerFrame[21];
				FramerateSecPerFrame_22 = framerateSecPerFrame[22];
				FramerateSecPerFrame_23 = framerateSecPerFrame[23];
				FramerateSecPerFrame_24 = framerateSecPerFrame[24];
				FramerateSecPerFrame_25 = framerateSecPerFrame[25];
				FramerateSecPerFrame_26 = framerateSecPerFrame[26];
				FramerateSecPerFrame_27 = framerateSecPerFrame[27];
				FramerateSecPerFrame_28 = framerateSecPerFrame[28];
				FramerateSecPerFrame_29 = framerateSecPerFrame[29];
				FramerateSecPerFrame_30 = framerateSecPerFrame[30];
				FramerateSecPerFrame_31 = framerateSecPerFrame[31];
				FramerateSecPerFrame_32 = framerateSecPerFrame[32];
				FramerateSecPerFrame_33 = framerateSecPerFrame[33];
				FramerateSecPerFrame_34 = framerateSecPerFrame[34];
				FramerateSecPerFrame_35 = framerateSecPerFrame[35];
				FramerateSecPerFrame_36 = framerateSecPerFrame[36];
				FramerateSecPerFrame_37 = framerateSecPerFrame[37];
				FramerateSecPerFrame_38 = framerateSecPerFrame[38];
				FramerateSecPerFrame_39 = framerateSecPerFrame[39];
				FramerateSecPerFrame_40 = framerateSecPerFrame[40];
				FramerateSecPerFrame_41 = framerateSecPerFrame[41];
				FramerateSecPerFrame_42 = framerateSecPerFrame[42];
				FramerateSecPerFrame_43 = framerateSecPerFrame[43];
				FramerateSecPerFrame_44 = framerateSecPerFrame[44];
				FramerateSecPerFrame_45 = framerateSecPerFrame[45];
				FramerateSecPerFrame_46 = framerateSecPerFrame[46];
				FramerateSecPerFrame_47 = framerateSecPerFrame[47];
				FramerateSecPerFrame_48 = framerateSecPerFrame[48];
				FramerateSecPerFrame_49 = framerateSecPerFrame[49];
				FramerateSecPerFrame_50 = framerateSecPerFrame[50];
				FramerateSecPerFrame_51 = framerateSecPerFrame[51];
				FramerateSecPerFrame_52 = framerateSecPerFrame[52];
				FramerateSecPerFrame_53 = framerateSecPerFrame[53];
				FramerateSecPerFrame_54 = framerateSecPerFrame[54];
				FramerateSecPerFrame_55 = framerateSecPerFrame[55];
				FramerateSecPerFrame_56 = framerateSecPerFrame[56];
				FramerateSecPerFrame_57 = framerateSecPerFrame[57];
				FramerateSecPerFrame_58 = framerateSecPerFrame[58];
				FramerateSecPerFrame_59 = framerateSecPerFrame[59];
			}
			FramerateSecPerFrameIdx = framerateSecPerFrameIdx;
			FramerateSecPerFrameCount = framerateSecPerFrameCount;
			FramerateSecPerFrameAccum = framerateSecPerFrameAccum;
			WantCaptureMouseNextFrame = wantCaptureMouseNextFrame;
			WantCaptureKeyboardNextFrame = wantCaptureKeyboardNextFrame;
			WantTextInputNextFrame = wantTextInputNextFrame;
			TempBuffer = tempBuffer;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiContext(bool initialized = default, bool fontAtlasOwnedByContext = default, ImGuiIO io = default, ImGuiPlatformIO platformIo = default, ImGuiStyle style = default, int configFlagsCurrFrame = default, int configFlagsLastFrame = default, ImFont* font = default, float fontSize = default, float fontBaseSize = default, ImDrawListSharedData drawListSharedData = default, double time = default, int frameCount = default, int frameCountEnded = default, int frameCountPlatformEnded = default, int frameCountRendered = default, bool withinFrameScope = default, bool withinFrameScopeWithImplicitWindow = default, bool withinEndChild = default, bool gcCompactAll = default, bool testEngineHookItems = default, void* testEngine = default, ImVectorImGuiInputEvent inputEventsQueue = default, ImVectorImGuiInputEvent inputEventsTrail = default, ImGuiMouseSource inputEventsNextMouseSource = default, uint inputEventsNextEventId = default, ImVectorImGuiWindowPtr windows = default, ImVectorImGuiWindowPtr windowsFocusOrder = default, ImVectorImGuiWindowPtr windowsTempSortBuffer = default, ImVectorImGuiWindowStackData currentWindowStack = default, ImGuiStorage windowsById = default, int windowsActiveCount = default, Vector2 windowsHoverPadding = default, ImGuiWindow* currentWindow = default, ImGuiWindow* hoveredWindow = default, ImGuiWindow* hoveredWindowUnderMovingWindow = default, ImGuiWindow* movingWindow = default, ImGuiWindow* wheelingWindow = default, Vector2 wheelingWindowRefMousePos = default, int wheelingWindowStartFrame = default, float wheelingWindowReleaseTimer = default, Vector2 wheelingWindowWheelRemainder = default, Vector2 wheelingAxisAvg = default, uint debugHookIdInfo = default, uint hoveredId = default, uint hoveredIdPreviousFrame = default, bool hoveredIdAllowOverlap = default, bool hoveredIdDisabled = default, float hoveredIdTimer = default, float hoveredIdNotActiveTimer = default, uint activeId = default, uint activeIdIsAlive = default, float activeIdTimer = default, bool activeIdIsJustActivated = default, bool activeIdAllowOverlap = default, bool activeIdNoClearOnFocusLoss = default, bool activeIdHasBeenPressedBefore = default, bool activeIdHasBeenEditedBefore = default, bool activeIdHasBeenEditedThisFrame = default, Vector2 activeIdClickOffset = default, ImGuiWindow* activeIdWindow = default, ImGuiInputSource activeIdSource = default, int activeIdMouseButton = default, uint activeIdPreviousFrame = default, bool activeIdPreviousFrameIsAlive = default, bool activeIdPreviousFrameHasBeenEditedBefore = default, ImGuiWindow* activeIdPreviousFrameWindow = default, uint lastActiveId = default, float lastActiveIdTimer = default, Span<ImGuiKeyOwnerData> keysOwnerData = default, ImGuiKeyRoutingTable keysRoutingTable = default, uint activeIdUsingNavDirMask = default, bool activeIdUsingAllKeyboardKeys = default, uint activeIdUsingNavInputMask = default, uint currentFocusScopeId = default, int currentItemFlags = default, uint debugLocateId = default, ImGuiNextItemData nextItemData = default, ImGuiLastItemData lastItemData = default, ImGuiNextWindowData nextWindowData = default, bool debugShowGroupRects = default, ImVectorImGuiColorMod colorStack = default, ImVectorImGuiStyleMod styleVarStack = default, ImVectorImFontPtr fontStack = default, ImVectorImGuiID focusScopeStack = default, ImVectorImGuiItemFlags itemFlagsStack = default, ImVectorImGuiGroupData groupStack = default, ImVectorImGuiPopupData openPopupStack = default, ImVectorImGuiPopupData beginPopupStack = default, ImVectorImGuiNavTreeNodeData navTreeNodeStack = default, int beginMenuCount = default, ImVectorImGuiViewportPPtr viewports = default, float currentDpiScale = default, ImGuiViewportP* currentViewport = default, ImGuiViewportP* mouseViewport = default, ImGuiViewportP* mouseLastHoveredViewport = default, uint platformLastFocusedViewportId = default, ImGuiPlatformMonitor fallbackMonitor = default, int viewportCreatedCount = default, int platformWindowsCreatedCount = default, int viewportFocusedStampCount = default, ImGuiWindow* navWindow = default, uint navId = default, uint navFocusScopeId = default, uint navActivateId = default, uint navActivateDownId = default, uint navActivatePressedId = default, int navActivateFlags = default, uint navJustMovedToId = default, uint navJustMovedToFocusScopeId = default, int navJustMovedToKeyMods = default, uint navNextActivateId = default, int navNextActivateFlags = default, ImGuiInputSource navInputSource = default, ImGuiNavLayer navLayer = default, ImGuiSelectionUserData navLastValidSelectionUserData = default, bool navIdIsAlive = default, bool navMousePosDirty = default, bool navDisableHighlight = default, bool navDisableMouseHover = default, bool navAnyRequest = default, bool navInitRequest = default, bool navInitRequestFromMove = default, ImGuiNavItemData navInitResult = default, bool navMoveSubmitted = default, bool navMoveScoringItems = default, bool navMoveForwardToNextFrame = default, int navMoveFlags = default, int navMoveScrollFlags = default, int navMoveKeyMods = default, int navMoveDir = default, int navMoveDirForDebug = default, int navMoveClipDir = default, ImRect navScoringRect = default, ImRect navScoringNoClipRect = default, int navScoringDebugCount = default, int navTabbingDir = default, int navTabbingCounter = default, ImGuiNavItemData navMoveResultLocal = default, ImGuiNavItemData navMoveResultLocalVisible = default, ImGuiNavItemData navMoveResultOther = default, ImGuiNavItemData navTabbingResultFirst = default, int configNavWindowingKeyNext = default, int configNavWindowingKeyPrev = default, ImGuiWindow* navWindowingTarget = default, ImGuiWindow* navWindowingTargetAnim = default, ImGuiWindow* navWindowingListWindow = default, float navWindowingTimer = default, float navWindowingHighlightAlpha = default, bool navWindowingToggleLayer = default, Vector2 navWindowingAccumDeltaPos = default, Vector2 navWindowingAccumDeltaSize = default, float dimBgRatio = default, bool dragDropActive = default, bool dragDropWithinSource = default, bool dragDropWithinTarget = default, int dragDropSourceFlags = default, int dragDropSourceFrameCount = default, int dragDropMouseButton = default, ImGuiPayload dragDropPayload = default, ImRect dragDropTargetRect = default, uint dragDropTargetId = default, int dragDropAcceptFlags = default, float dragDropAcceptIdCurrRectSurface = default, uint dragDropAcceptIdCurr = default, uint dragDropAcceptIdPrev = default, int dragDropAcceptFrameCount = default, uint dragDropHoldJustPressedId = default, ImVectorUnsignedChar dragDropPayloadBufHeap = default, Span<byte> dragDropPayloadBufLocal = default, int clipperTempDataStacked = default, ImVectorImGuiListClipperData clipperTempData = default, ImGuiTable* currentTable = default, int tablesTempDataStacked = default, ImVectorImGuiTableTempData tablesTempData = default, ImPoolImGuiTable tables = default, ImVectorFloat tablesLastTimeActive = default, ImVectorImDrawChannel drawChannelsTempMergeBuffer = default, ImGuiTabBar* currentTabBar = default, ImPoolImGuiTabBar tabBars = default, ImVectorImGuiPtrOrIndex currentTabBarStack = default, ImVectorImGuiShrinkWidthItem shrinkWidthBuffer = default, uint hoverItemDelayId = default, uint hoverItemDelayIdPreviousFrame = default, float hoverItemDelayTimer = default, float hoverItemDelayClearTimer = default, uint hoverItemUnlockedStationaryId = default, uint hoverWindowUnlockedStationaryId = default, int mouseCursor = default, float mouseStationaryTimer = default, Vector2 mouseLastValidPos = default, ImGuiInputTextState inputTextState = default, ImGuiInputTextDeactivatedState inputTextDeactivatedState = default, ImFont inputTextPasswordFont = default, uint tempInputId = default, int colorEditOptions = default, uint colorEditCurrentId = default, uint colorEditSavedId = default, float colorEditSavedHue = default, float colorEditSavedSat = default, uint colorEditSavedColor = default, Vector4 colorPickerRef = default, ImGuiComboPreviewData comboPreviewData = default, float sliderGrabClickOffset = default, float sliderCurrentAccum = default, bool sliderCurrentAccumDirty = default, bool dragCurrentAccumDirty = default, float dragCurrentAccum = default, float dragSpeedDefaultRatio = default, float scrollbarClickDeltaToGrabCenter = default, float disabledAlphaBackup = default, short disabledStackSize = default, short lockMarkEdited = default, short tooltipOverrideCount = default, ImVectorChar clipboardHandlerData = default, ImVectorImGuiID menusIdSubmittedThisFrame = default, ImGuiTypingSelectState typingSelectState = default, ImGuiPlatformImeData platformImeData = default, ImGuiPlatformImeData platformImeDataPrev = default, uint platformImeViewport = default, ImGuiDockContext dockContext = default, delegate*<ImGuiContext*, ImGuiDockNode*, ImGuiTabBar*, void> dockNodeWindowMenuHandler = default, bool settingsLoaded = default, float settingsDirtyTimer = default, ImGuiTextBuffer settingsIniData = default, ImVectorImGuiSettingsHandler settingsHandlers = default, ImChunkStreamImGuiWindowSettings settingsWindows = default, ImChunkStreamImGuiTableSettings settingsTables = default, ImVectorImGuiContextHook hooks = default, uint hookIdNext = default, Span<Pointer<byte>> localizationTable = default, bool logEnabled = default, ImGuiLogType logType = default, ImFileHandle logFile = default, ImGuiTextBuffer logBuffer = default, byte* logNextPrefix = default, byte* logNextSuffix = default, float logLinePosY = default, bool logLineFirstItem = default, int logDepthRef = default, int logDepthToExpand = default, int logDepthToExpandDefault = default, int debugLogFlags = default, ImGuiTextBuffer debugLogBuf = default, ImGuiTextIndex debugLogIndex = default, byte debugLogClipperAutoDisableFrames = default, byte debugLocateFrames = default, byte debugBeginReturnValueCullDepth = default, bool debugItemPickerActive = default, byte debugItemPickerMouseButton = default, uint debugItemPickerBreakId = default, ImGuiMetricsConfig debugMetricsConfig = default, ImGuiIDStackTool debugIdStackTool = default, ImGuiDebugAllocInfo debugAllocInfo = default, ImGuiDockNode* debugHoveredDockNode = default, Span<float> framerateSecPerFrame = default, int framerateSecPerFrameIdx = default, int framerateSecPerFrameCount = default, float framerateSecPerFrameAccum = default, int wantCaptureMouseNextFrame = default, int wantCaptureKeyboardNextFrame = default, int wantTextInputNextFrame = default, ImVectorChar tempBuffer = default)
		{
			Initialized = initialized ? (byte)1 : (byte)0;
			FontAtlasOwnedByContext = fontAtlasOwnedByContext ? (byte)1 : (byte)0;
			IO = io;
			PlatformIO = platformIo;
			Style = style;
			ConfigFlagsCurrFrame = configFlagsCurrFrame;
			ConfigFlagsLastFrame = configFlagsLastFrame;
			Font = font;
			FontSize = fontSize;
			FontBaseSize = fontBaseSize;
			DrawListSharedData = drawListSharedData;
			Time = time;
			FrameCount = frameCount;
			FrameCountEnded = frameCountEnded;
			FrameCountPlatformEnded = frameCountPlatformEnded;
			FrameCountRendered = frameCountRendered;
			WithinFrameScope = withinFrameScope ? (byte)1 : (byte)0;
			WithinFrameScopeWithImplicitWindow = withinFrameScopeWithImplicitWindow ? (byte)1 : (byte)0;
			WithinEndChild = withinEndChild ? (byte)1 : (byte)0;
			GcCompactAll = gcCompactAll ? (byte)1 : (byte)0;
			TestEngineHookItems = testEngineHookItems ? (byte)1 : (byte)0;
			TestEngine = testEngine;
			InputEventsQueue = inputEventsQueue;
			InputEventsTrail = inputEventsTrail;
			InputEventsNextMouseSource = inputEventsNextMouseSource;
			InputEventsNextEventId = inputEventsNextEventId;
			Windows = windows;
			WindowsFocusOrder = windowsFocusOrder;
			WindowsTempSortBuffer = windowsTempSortBuffer;
			CurrentWindowStack = currentWindowStack;
			WindowsById = windowsById;
			WindowsActiveCount = windowsActiveCount;
			WindowsHoverPadding = windowsHoverPadding;
			CurrentWindow = currentWindow;
			HoveredWindow = hoveredWindow;
			HoveredWindowUnderMovingWindow = hoveredWindowUnderMovingWindow;
			MovingWindow = movingWindow;
			WheelingWindow = wheelingWindow;
			WheelingWindowRefMousePos = wheelingWindowRefMousePos;
			WheelingWindowStartFrame = wheelingWindowStartFrame;
			WheelingWindowReleaseTimer = wheelingWindowReleaseTimer;
			WheelingWindowWheelRemainder = wheelingWindowWheelRemainder;
			WheelingAxisAvg = wheelingAxisAvg;
			DebugHookIdInfo = debugHookIdInfo;
			HoveredId = hoveredId;
			HoveredIdPreviousFrame = hoveredIdPreviousFrame;
			HoveredIdAllowOverlap = hoveredIdAllowOverlap ? (byte)1 : (byte)0;
			HoveredIdDisabled = hoveredIdDisabled ? (byte)1 : (byte)0;
			HoveredIdTimer = hoveredIdTimer;
			HoveredIdNotActiveTimer = hoveredIdNotActiveTimer;
			ActiveId = activeId;
			ActiveIdIsAlive = activeIdIsAlive;
			ActiveIdTimer = activeIdTimer;
			ActiveIdIsJustActivated = activeIdIsJustActivated ? (byte)1 : (byte)0;
			ActiveIdAllowOverlap = activeIdAllowOverlap ? (byte)1 : (byte)0;
			ActiveIdNoClearOnFocusLoss = activeIdNoClearOnFocusLoss ? (byte)1 : (byte)0;
			ActiveIdHasBeenPressedBefore = activeIdHasBeenPressedBefore ? (byte)1 : (byte)0;
			ActiveIdHasBeenEditedBefore = activeIdHasBeenEditedBefore ? (byte)1 : (byte)0;
			ActiveIdHasBeenEditedThisFrame = activeIdHasBeenEditedThisFrame ? (byte)1 : (byte)0;
			ActiveIdClickOffset = activeIdClickOffset;
			ActiveIdWindow = activeIdWindow;
			ActiveIdSource = activeIdSource;
			ActiveIdMouseButton = activeIdMouseButton;
			ActiveIdPreviousFrame = activeIdPreviousFrame;
			ActiveIdPreviousFrameIsAlive = activeIdPreviousFrameIsAlive ? (byte)1 : (byte)0;
			ActiveIdPreviousFrameHasBeenEditedBefore = activeIdPreviousFrameHasBeenEditedBefore ? (byte)1 : (byte)0;
			ActiveIdPreviousFrameWindow = activeIdPreviousFrameWindow;
			LastActiveId = lastActiveId;
			LastActiveIdTimer = lastActiveIdTimer;
			if (keysOwnerData != default)
			{
				KeysOwnerData_0 = keysOwnerData[0];
				KeysOwnerData_1 = keysOwnerData[1];
				KeysOwnerData_2 = keysOwnerData[2];
				KeysOwnerData_3 = keysOwnerData[3];
				KeysOwnerData_4 = keysOwnerData[4];
				KeysOwnerData_5 = keysOwnerData[5];
				KeysOwnerData_6 = keysOwnerData[6];
				KeysOwnerData_7 = keysOwnerData[7];
				KeysOwnerData_8 = keysOwnerData[8];
				KeysOwnerData_9 = keysOwnerData[9];
				KeysOwnerData_10 = keysOwnerData[10];
				KeysOwnerData_11 = keysOwnerData[11];
				KeysOwnerData_12 = keysOwnerData[12];
				KeysOwnerData_13 = keysOwnerData[13];
				KeysOwnerData_14 = keysOwnerData[14];
				KeysOwnerData_15 = keysOwnerData[15];
				KeysOwnerData_16 = keysOwnerData[16];
				KeysOwnerData_17 = keysOwnerData[17];
				KeysOwnerData_18 = keysOwnerData[18];
				KeysOwnerData_19 = keysOwnerData[19];
				KeysOwnerData_20 = keysOwnerData[20];
				KeysOwnerData_21 = keysOwnerData[21];
				KeysOwnerData_22 = keysOwnerData[22];
				KeysOwnerData_23 = keysOwnerData[23];
				KeysOwnerData_24 = keysOwnerData[24];
				KeysOwnerData_25 = keysOwnerData[25];
				KeysOwnerData_26 = keysOwnerData[26];
				KeysOwnerData_27 = keysOwnerData[27];
				KeysOwnerData_28 = keysOwnerData[28];
				KeysOwnerData_29 = keysOwnerData[29];
				KeysOwnerData_30 = keysOwnerData[30];
				KeysOwnerData_31 = keysOwnerData[31];
				KeysOwnerData_32 = keysOwnerData[32];
				KeysOwnerData_33 = keysOwnerData[33];
				KeysOwnerData_34 = keysOwnerData[34];
				KeysOwnerData_35 = keysOwnerData[35];
				KeysOwnerData_36 = keysOwnerData[36];
				KeysOwnerData_37 = keysOwnerData[37];
				KeysOwnerData_38 = keysOwnerData[38];
				KeysOwnerData_39 = keysOwnerData[39];
				KeysOwnerData_40 = keysOwnerData[40];
				KeysOwnerData_41 = keysOwnerData[41];
				KeysOwnerData_42 = keysOwnerData[42];
				KeysOwnerData_43 = keysOwnerData[43];
				KeysOwnerData_44 = keysOwnerData[44];
				KeysOwnerData_45 = keysOwnerData[45];
				KeysOwnerData_46 = keysOwnerData[46];
				KeysOwnerData_47 = keysOwnerData[47];
				KeysOwnerData_48 = keysOwnerData[48];
				KeysOwnerData_49 = keysOwnerData[49];
				KeysOwnerData_50 = keysOwnerData[50];
				KeysOwnerData_51 = keysOwnerData[51];
				KeysOwnerData_52 = keysOwnerData[52];
				KeysOwnerData_53 = keysOwnerData[53];
				KeysOwnerData_54 = keysOwnerData[54];
				KeysOwnerData_55 = keysOwnerData[55];
				KeysOwnerData_56 = keysOwnerData[56];
				KeysOwnerData_57 = keysOwnerData[57];
				KeysOwnerData_58 = keysOwnerData[58];
				KeysOwnerData_59 = keysOwnerData[59];
				KeysOwnerData_60 = keysOwnerData[60];
				KeysOwnerData_61 = keysOwnerData[61];
				KeysOwnerData_62 = keysOwnerData[62];
				KeysOwnerData_63 = keysOwnerData[63];
				KeysOwnerData_64 = keysOwnerData[64];
				KeysOwnerData_65 = keysOwnerData[65];
				KeysOwnerData_66 = keysOwnerData[66];
				KeysOwnerData_67 = keysOwnerData[67];
				KeysOwnerData_68 = keysOwnerData[68];
				KeysOwnerData_69 = keysOwnerData[69];
				KeysOwnerData_70 = keysOwnerData[70];
				KeysOwnerData_71 = keysOwnerData[71];
				KeysOwnerData_72 = keysOwnerData[72];
				KeysOwnerData_73 = keysOwnerData[73];
				KeysOwnerData_74 = keysOwnerData[74];
				KeysOwnerData_75 = keysOwnerData[75];
				KeysOwnerData_76 = keysOwnerData[76];
				KeysOwnerData_77 = keysOwnerData[77];
				KeysOwnerData_78 = keysOwnerData[78];
				KeysOwnerData_79 = keysOwnerData[79];
				KeysOwnerData_80 = keysOwnerData[80];
				KeysOwnerData_81 = keysOwnerData[81];
				KeysOwnerData_82 = keysOwnerData[82];
				KeysOwnerData_83 = keysOwnerData[83];
				KeysOwnerData_84 = keysOwnerData[84];
				KeysOwnerData_85 = keysOwnerData[85];
				KeysOwnerData_86 = keysOwnerData[86];
				KeysOwnerData_87 = keysOwnerData[87];
				KeysOwnerData_88 = keysOwnerData[88];
				KeysOwnerData_89 = keysOwnerData[89];
				KeysOwnerData_90 = keysOwnerData[90];
				KeysOwnerData_91 = keysOwnerData[91];
				KeysOwnerData_92 = keysOwnerData[92];
				KeysOwnerData_93 = keysOwnerData[93];
				KeysOwnerData_94 = keysOwnerData[94];
				KeysOwnerData_95 = keysOwnerData[95];
				KeysOwnerData_96 = keysOwnerData[96];
				KeysOwnerData_97 = keysOwnerData[97];
				KeysOwnerData_98 = keysOwnerData[98];
				KeysOwnerData_99 = keysOwnerData[99];
				KeysOwnerData_100 = keysOwnerData[100];
				KeysOwnerData_101 = keysOwnerData[101];
				KeysOwnerData_102 = keysOwnerData[102];
				KeysOwnerData_103 = keysOwnerData[103];
				KeysOwnerData_104 = keysOwnerData[104];
				KeysOwnerData_105 = keysOwnerData[105];
				KeysOwnerData_106 = keysOwnerData[106];
				KeysOwnerData_107 = keysOwnerData[107];
				KeysOwnerData_108 = keysOwnerData[108];
				KeysOwnerData_109 = keysOwnerData[109];
				KeysOwnerData_110 = keysOwnerData[110];
				KeysOwnerData_111 = keysOwnerData[111];
				KeysOwnerData_112 = keysOwnerData[112];
				KeysOwnerData_113 = keysOwnerData[113];
				KeysOwnerData_114 = keysOwnerData[114];
				KeysOwnerData_115 = keysOwnerData[115];
				KeysOwnerData_116 = keysOwnerData[116];
				KeysOwnerData_117 = keysOwnerData[117];
				KeysOwnerData_118 = keysOwnerData[118];
				KeysOwnerData_119 = keysOwnerData[119];
				KeysOwnerData_120 = keysOwnerData[120];
				KeysOwnerData_121 = keysOwnerData[121];
				KeysOwnerData_122 = keysOwnerData[122];
				KeysOwnerData_123 = keysOwnerData[123];
				KeysOwnerData_124 = keysOwnerData[124];
				KeysOwnerData_125 = keysOwnerData[125];
				KeysOwnerData_126 = keysOwnerData[126];
				KeysOwnerData_127 = keysOwnerData[127];
				KeysOwnerData_128 = keysOwnerData[128];
				KeysOwnerData_129 = keysOwnerData[129];
				KeysOwnerData_130 = keysOwnerData[130];
				KeysOwnerData_131 = keysOwnerData[131];
				KeysOwnerData_132 = keysOwnerData[132];
				KeysOwnerData_133 = keysOwnerData[133];
				KeysOwnerData_134 = keysOwnerData[134];
				KeysOwnerData_135 = keysOwnerData[135];
				KeysOwnerData_136 = keysOwnerData[136];
				KeysOwnerData_137 = keysOwnerData[137];
				KeysOwnerData_138 = keysOwnerData[138];
				KeysOwnerData_139 = keysOwnerData[139];
				KeysOwnerData_140 = keysOwnerData[140];
				KeysOwnerData_141 = keysOwnerData[141];
				KeysOwnerData_142 = keysOwnerData[142];
				KeysOwnerData_143 = keysOwnerData[143];
				KeysOwnerData_144 = keysOwnerData[144];
				KeysOwnerData_145 = keysOwnerData[145];
				KeysOwnerData_146 = keysOwnerData[146];
				KeysOwnerData_147 = keysOwnerData[147];
				KeysOwnerData_148 = keysOwnerData[148];
				KeysOwnerData_149 = keysOwnerData[149];
				KeysOwnerData_150 = keysOwnerData[150];
				KeysOwnerData_151 = keysOwnerData[151];
				KeysOwnerData_152 = keysOwnerData[152];
				KeysOwnerData_153 = keysOwnerData[153];
			}
			KeysRoutingTable = keysRoutingTable;
			ActiveIdUsingNavDirMask = activeIdUsingNavDirMask;
			ActiveIdUsingAllKeyboardKeys = activeIdUsingAllKeyboardKeys ? (byte)1 : (byte)0;
			ActiveIdUsingNavInputMask = activeIdUsingNavInputMask;
			CurrentFocusScopeId = currentFocusScopeId;
			CurrentItemFlags = currentItemFlags;
			DebugLocateId = debugLocateId;
			NextItemData = nextItemData;
			LastItemData = lastItemData;
			NextWindowData = nextWindowData;
			DebugShowGroupRects = debugShowGroupRects ? (byte)1 : (byte)0;
			ColorStack = colorStack;
			StyleVarStack = styleVarStack;
			FontStack = fontStack;
			FocusScopeStack = focusScopeStack;
			ItemFlagsStack = itemFlagsStack;
			GroupStack = groupStack;
			OpenPopupStack = openPopupStack;
			BeginPopupStack = beginPopupStack;
			NavTreeNodeStack = navTreeNodeStack;
			BeginMenuCount = beginMenuCount;
			Viewports = viewports;
			CurrentDpiScale = currentDpiScale;
			CurrentViewport = currentViewport;
			MouseViewport = mouseViewport;
			MouseLastHoveredViewport = mouseLastHoveredViewport;
			PlatformLastFocusedViewportId = platformLastFocusedViewportId;
			FallbackMonitor = fallbackMonitor;
			ViewportCreatedCount = viewportCreatedCount;
			PlatformWindowsCreatedCount = platformWindowsCreatedCount;
			ViewportFocusedStampCount = viewportFocusedStampCount;
			NavWindow = navWindow;
			NavId = navId;
			NavFocusScopeId = navFocusScopeId;
			NavActivateId = navActivateId;
			NavActivateDownId = navActivateDownId;
			NavActivatePressedId = navActivatePressedId;
			NavActivateFlags = navActivateFlags;
			NavJustMovedToId = navJustMovedToId;
			NavJustMovedToFocusScopeId = navJustMovedToFocusScopeId;
			NavJustMovedToKeyMods = navJustMovedToKeyMods;
			NavNextActivateId = navNextActivateId;
			NavNextActivateFlags = navNextActivateFlags;
			NavInputSource = navInputSource;
			NavLayer = navLayer;
			NavLastValidSelectionUserData = navLastValidSelectionUserData;
			NavIdIsAlive = navIdIsAlive ? (byte)1 : (byte)0;
			NavMousePosDirty = navMousePosDirty ? (byte)1 : (byte)0;
			NavDisableHighlight = navDisableHighlight ? (byte)1 : (byte)0;
			NavDisableMouseHover = navDisableMouseHover ? (byte)1 : (byte)0;
			NavAnyRequest = navAnyRequest ? (byte)1 : (byte)0;
			NavInitRequest = navInitRequest ? (byte)1 : (byte)0;
			NavInitRequestFromMove = navInitRequestFromMove ? (byte)1 : (byte)0;
			NavInitResult = navInitResult;
			NavMoveSubmitted = navMoveSubmitted ? (byte)1 : (byte)0;
			NavMoveScoringItems = navMoveScoringItems ? (byte)1 : (byte)0;
			NavMoveForwardToNextFrame = navMoveForwardToNextFrame ? (byte)1 : (byte)0;
			NavMoveFlags = navMoveFlags;
			NavMoveScrollFlags = navMoveScrollFlags;
			NavMoveKeyMods = navMoveKeyMods;
			NavMoveDir = navMoveDir;
			NavMoveDirForDebug = navMoveDirForDebug;
			NavMoveClipDir = navMoveClipDir;
			NavScoringRect = navScoringRect;
			NavScoringNoClipRect = navScoringNoClipRect;
			NavScoringDebugCount = navScoringDebugCount;
			NavTabbingDir = navTabbingDir;
			NavTabbingCounter = navTabbingCounter;
			NavMoveResultLocal = navMoveResultLocal;
			NavMoveResultLocalVisible = navMoveResultLocalVisible;
			NavMoveResultOther = navMoveResultOther;
			NavTabbingResultFirst = navTabbingResultFirst;
			ConfigNavWindowingKeyNext = configNavWindowingKeyNext;
			ConfigNavWindowingKeyPrev = configNavWindowingKeyPrev;
			NavWindowingTarget = navWindowingTarget;
			NavWindowingTargetAnim = navWindowingTargetAnim;
			NavWindowingListWindow = navWindowingListWindow;
			NavWindowingTimer = navWindowingTimer;
			NavWindowingHighlightAlpha = navWindowingHighlightAlpha;
			NavWindowingToggleLayer = navWindowingToggleLayer ? (byte)1 : (byte)0;
			NavWindowingAccumDeltaPos = navWindowingAccumDeltaPos;
			NavWindowingAccumDeltaSize = navWindowingAccumDeltaSize;
			DimBgRatio = dimBgRatio;
			DragDropActive = dragDropActive ? (byte)1 : (byte)0;
			DragDropWithinSource = dragDropWithinSource ? (byte)1 : (byte)0;
			DragDropWithinTarget = dragDropWithinTarget ? (byte)1 : (byte)0;
			DragDropSourceFlags = dragDropSourceFlags;
			DragDropSourceFrameCount = dragDropSourceFrameCount;
			DragDropMouseButton = dragDropMouseButton;
			DragDropPayload = dragDropPayload;
			DragDropTargetRect = dragDropTargetRect;
			DragDropTargetId = dragDropTargetId;
			DragDropAcceptFlags = dragDropAcceptFlags;
			DragDropAcceptIdCurrRectSurface = dragDropAcceptIdCurrRectSurface;
			DragDropAcceptIdCurr = dragDropAcceptIdCurr;
			DragDropAcceptIdPrev = dragDropAcceptIdPrev;
			DragDropAcceptFrameCount = dragDropAcceptFrameCount;
			DragDropHoldJustPressedId = dragDropHoldJustPressedId;
			DragDropPayloadBufHeap = dragDropPayloadBufHeap;
			if (dragDropPayloadBufLocal != default)
			{
				DragDropPayloadBufLocal_0 = dragDropPayloadBufLocal[0];
				DragDropPayloadBufLocal_1 = dragDropPayloadBufLocal[1];
				DragDropPayloadBufLocal_2 = dragDropPayloadBufLocal[2];
				DragDropPayloadBufLocal_3 = dragDropPayloadBufLocal[3];
				DragDropPayloadBufLocal_4 = dragDropPayloadBufLocal[4];
				DragDropPayloadBufLocal_5 = dragDropPayloadBufLocal[5];
				DragDropPayloadBufLocal_6 = dragDropPayloadBufLocal[6];
				DragDropPayloadBufLocal_7 = dragDropPayloadBufLocal[7];
				DragDropPayloadBufLocal_8 = dragDropPayloadBufLocal[8];
				DragDropPayloadBufLocal_9 = dragDropPayloadBufLocal[9];
				DragDropPayloadBufLocal_10 = dragDropPayloadBufLocal[10];
				DragDropPayloadBufLocal_11 = dragDropPayloadBufLocal[11];
				DragDropPayloadBufLocal_12 = dragDropPayloadBufLocal[12];
				DragDropPayloadBufLocal_13 = dragDropPayloadBufLocal[13];
				DragDropPayloadBufLocal_14 = dragDropPayloadBufLocal[14];
				DragDropPayloadBufLocal_15 = dragDropPayloadBufLocal[15];
			}
			ClipperTempDataStacked = clipperTempDataStacked;
			ClipperTempData = clipperTempData;
			CurrentTable = currentTable;
			TablesTempDataStacked = tablesTempDataStacked;
			TablesTempData = tablesTempData;
			Tables = tables;
			TablesLastTimeActive = tablesLastTimeActive;
			DrawChannelsTempMergeBuffer = drawChannelsTempMergeBuffer;
			CurrentTabBar = currentTabBar;
			TabBars = tabBars;
			CurrentTabBarStack = currentTabBarStack;
			ShrinkWidthBuffer = shrinkWidthBuffer;
			HoverItemDelayId = hoverItemDelayId;
			HoverItemDelayIdPreviousFrame = hoverItemDelayIdPreviousFrame;
			HoverItemDelayTimer = hoverItemDelayTimer;
			HoverItemDelayClearTimer = hoverItemDelayClearTimer;
			HoverItemUnlockedStationaryId = hoverItemUnlockedStationaryId;
			HoverWindowUnlockedStationaryId = hoverWindowUnlockedStationaryId;
			MouseCursor = mouseCursor;
			MouseStationaryTimer = mouseStationaryTimer;
			MouseLastValidPos = mouseLastValidPos;
			InputTextState = inputTextState;
			InputTextDeactivatedState = inputTextDeactivatedState;
			InputTextPasswordFont = inputTextPasswordFont;
			TempInputId = tempInputId;
			ColorEditOptions = colorEditOptions;
			ColorEditCurrentID = colorEditCurrentId;
			ColorEditSavedID = colorEditSavedId;
			ColorEditSavedHue = colorEditSavedHue;
			ColorEditSavedSat = colorEditSavedSat;
			ColorEditSavedColor = colorEditSavedColor;
			ColorPickerRef = colorPickerRef;
			ComboPreviewData = comboPreviewData;
			SliderGrabClickOffset = sliderGrabClickOffset;
			SliderCurrentAccum = sliderCurrentAccum;
			SliderCurrentAccumDirty = sliderCurrentAccumDirty ? (byte)1 : (byte)0;
			DragCurrentAccumDirty = dragCurrentAccumDirty ? (byte)1 : (byte)0;
			DragCurrentAccum = dragCurrentAccum;
			DragSpeedDefaultRatio = dragSpeedDefaultRatio;
			ScrollbarClickDeltaToGrabCenter = scrollbarClickDeltaToGrabCenter;
			DisabledAlphaBackup = disabledAlphaBackup;
			DisabledStackSize = disabledStackSize;
			LockMarkEdited = lockMarkEdited;
			TooltipOverrideCount = tooltipOverrideCount;
			ClipboardHandlerData = clipboardHandlerData;
			MenusIdSubmittedThisFrame = menusIdSubmittedThisFrame;
			TypingSelectState = typingSelectState;
			PlatformImeData = platformImeData;
			PlatformImeDataPrev = platformImeDataPrev;
			PlatformImeViewport = platformImeViewport;
			DockContext = dockContext;
			DockNodeWindowMenuHandler = (void*)dockNodeWindowMenuHandler;
			SettingsLoaded = settingsLoaded ? (byte)1 : (byte)0;
			SettingsDirtyTimer = settingsDirtyTimer;
			SettingsIniData = settingsIniData;
			SettingsHandlers = settingsHandlers;
			SettingsWindows = settingsWindows;
			SettingsTables = settingsTables;
			Hooks = hooks;
			HookIdNext = hookIdNext;
			if (localizationTable != default)
			{
				LocalizationTable_0 = localizationTable[0];
				LocalizationTable_1 = localizationTable[1];
				LocalizationTable_2 = localizationTable[2];
				LocalizationTable_3 = localizationTable[3];
				LocalizationTable_4 = localizationTable[4];
				LocalizationTable_5 = localizationTable[5];
				LocalizationTable_6 = localizationTable[6];
				LocalizationTable_7 = localizationTable[7];
				LocalizationTable_8 = localizationTable[8];
				LocalizationTable_9 = localizationTable[9];
				LocalizationTable_10 = localizationTable[10];
			}
			LogEnabled = logEnabled ? (byte)1 : (byte)0;
			LogType = logType;
			LogFile = logFile;
			LogBuffer = logBuffer;
			LogNextPrefix = logNextPrefix;
			LogNextSuffix = logNextSuffix;
			LogLinePosY = logLinePosY;
			LogLineFirstItem = logLineFirstItem ? (byte)1 : (byte)0;
			LogDepthRef = logDepthRef;
			LogDepthToExpand = logDepthToExpand;
			LogDepthToExpandDefault = logDepthToExpandDefault;
			DebugLogFlags = debugLogFlags;
			DebugLogBuf = debugLogBuf;
			DebugLogIndex = debugLogIndex;
			DebugLogClipperAutoDisableFrames = debugLogClipperAutoDisableFrames;
			DebugLocateFrames = debugLocateFrames;
			DebugBeginReturnValueCullDepth = debugBeginReturnValueCullDepth;
			DebugItemPickerActive = debugItemPickerActive ? (byte)1 : (byte)0;
			DebugItemPickerMouseButton = debugItemPickerMouseButton;
			DebugItemPickerBreakId = debugItemPickerBreakId;
			DebugMetricsConfig = debugMetricsConfig;
			DebugIDStackTool = debugIdStackTool;
			DebugAllocInfo = debugAllocInfo;
			DebugHoveredDockNode = debugHoveredDockNode;
			if (framerateSecPerFrame != default)
			{
				FramerateSecPerFrame_0 = framerateSecPerFrame[0];
				FramerateSecPerFrame_1 = framerateSecPerFrame[1];
				FramerateSecPerFrame_2 = framerateSecPerFrame[2];
				FramerateSecPerFrame_3 = framerateSecPerFrame[3];
				FramerateSecPerFrame_4 = framerateSecPerFrame[4];
				FramerateSecPerFrame_5 = framerateSecPerFrame[5];
				FramerateSecPerFrame_6 = framerateSecPerFrame[6];
				FramerateSecPerFrame_7 = framerateSecPerFrame[7];
				FramerateSecPerFrame_8 = framerateSecPerFrame[8];
				FramerateSecPerFrame_9 = framerateSecPerFrame[9];
				FramerateSecPerFrame_10 = framerateSecPerFrame[10];
				FramerateSecPerFrame_11 = framerateSecPerFrame[11];
				FramerateSecPerFrame_12 = framerateSecPerFrame[12];
				FramerateSecPerFrame_13 = framerateSecPerFrame[13];
				FramerateSecPerFrame_14 = framerateSecPerFrame[14];
				FramerateSecPerFrame_15 = framerateSecPerFrame[15];
				FramerateSecPerFrame_16 = framerateSecPerFrame[16];
				FramerateSecPerFrame_17 = framerateSecPerFrame[17];
				FramerateSecPerFrame_18 = framerateSecPerFrame[18];
				FramerateSecPerFrame_19 = framerateSecPerFrame[19];
				FramerateSecPerFrame_20 = framerateSecPerFrame[20];
				FramerateSecPerFrame_21 = framerateSecPerFrame[21];
				FramerateSecPerFrame_22 = framerateSecPerFrame[22];
				FramerateSecPerFrame_23 = framerateSecPerFrame[23];
				FramerateSecPerFrame_24 = framerateSecPerFrame[24];
				FramerateSecPerFrame_25 = framerateSecPerFrame[25];
				FramerateSecPerFrame_26 = framerateSecPerFrame[26];
				FramerateSecPerFrame_27 = framerateSecPerFrame[27];
				FramerateSecPerFrame_28 = framerateSecPerFrame[28];
				FramerateSecPerFrame_29 = framerateSecPerFrame[29];
				FramerateSecPerFrame_30 = framerateSecPerFrame[30];
				FramerateSecPerFrame_31 = framerateSecPerFrame[31];
				FramerateSecPerFrame_32 = framerateSecPerFrame[32];
				FramerateSecPerFrame_33 = framerateSecPerFrame[33];
				FramerateSecPerFrame_34 = framerateSecPerFrame[34];
				FramerateSecPerFrame_35 = framerateSecPerFrame[35];
				FramerateSecPerFrame_36 = framerateSecPerFrame[36];
				FramerateSecPerFrame_37 = framerateSecPerFrame[37];
				FramerateSecPerFrame_38 = framerateSecPerFrame[38];
				FramerateSecPerFrame_39 = framerateSecPerFrame[39];
				FramerateSecPerFrame_40 = framerateSecPerFrame[40];
				FramerateSecPerFrame_41 = framerateSecPerFrame[41];
				FramerateSecPerFrame_42 = framerateSecPerFrame[42];
				FramerateSecPerFrame_43 = framerateSecPerFrame[43];
				FramerateSecPerFrame_44 = framerateSecPerFrame[44];
				FramerateSecPerFrame_45 = framerateSecPerFrame[45];
				FramerateSecPerFrame_46 = framerateSecPerFrame[46];
				FramerateSecPerFrame_47 = framerateSecPerFrame[47];
				FramerateSecPerFrame_48 = framerateSecPerFrame[48];
				FramerateSecPerFrame_49 = framerateSecPerFrame[49];
				FramerateSecPerFrame_50 = framerateSecPerFrame[50];
				FramerateSecPerFrame_51 = framerateSecPerFrame[51];
				FramerateSecPerFrame_52 = framerateSecPerFrame[52];
				FramerateSecPerFrame_53 = framerateSecPerFrame[53];
				FramerateSecPerFrame_54 = framerateSecPerFrame[54];
				FramerateSecPerFrame_55 = framerateSecPerFrame[55];
				FramerateSecPerFrame_56 = framerateSecPerFrame[56];
				FramerateSecPerFrame_57 = framerateSecPerFrame[57];
				FramerateSecPerFrame_58 = framerateSecPerFrame[58];
				FramerateSecPerFrame_59 = framerateSecPerFrame[59];
			}
			FramerateSecPerFrameIdx = framerateSecPerFrameIdx;
			FramerateSecPerFrameCount = framerateSecPerFrameCount;
			FramerateSecPerFrameAccum = framerateSecPerFrameAccum;
			WantCaptureMouseNextFrame = wantCaptureMouseNextFrame;
			WantCaptureKeyboardNextFrame = wantCaptureKeyboardNextFrame;
			WantTextInputNextFrame = wantTextInputNextFrame;
			TempBuffer = tempBuffer;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<ImGuiKeyOwnerData> KeysOwnerData
		
		{
			get
			{
				fixed (ImGuiKeyOwnerData* p = &this.KeysOwnerData_0)
				{
					return new Span<ImGuiKeyOwnerData>(p, 154);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiIO
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int ConfigFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BackendFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 DisplaySize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DeltaTime;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float IniSavingRate;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* IniFilename;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* LogFilename;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontAtlas* Fonts;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FontGlobalScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte FontAllowUserScaling;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFont* FontDefault;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 DisplayFramebufferScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigDockingNoSplit;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigDockingWithShift;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigDockingAlwaysTabBar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigDockingTransparentPayload;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigViewportsNoAutoMerge;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigViewportsNoTaskBarIcon;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigViewportsNoDecoration;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigViewportsNoDefaultParent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte MouseDrawCursor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigMacOSXBehaviors;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigInputTrickleEventQueue;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigInputTextCursorBlink;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigInputTextEnterKeepActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigDragClickToInputText;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigWindowsResizeFromEdges;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigWindowsMoveFromTitleBarOnly;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ConfigMemoryCompactTimer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseDoubleClickTime;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseDoubleClickMaxDist;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseDragThreshold;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float KeyRepeatDelay;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float KeyRepeatRate;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigDebugBeginReturnValueOnce;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigDebugBeginReturnValueLoop;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigDebugIgnoreFocusLoss;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ConfigDebugIniSettings;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* BackendPlatformName;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* BackendRendererName;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* BackendPlatformUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* BackendRendererUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* BackendLanguageUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* GetClipboardTextFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* SetClipboardTextFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* ClipboardUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* SetPlatformImeDataFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public char PlatformLocaleDecimalPoint;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantCaptureMouse;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantCaptureKeyboard;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantTextInput;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantSetMousePos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantSaveIniSettings;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Framerate;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MetricsRenderVertices;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MetricsRenderIndices;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MetricsRenderWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MetricsActiveWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MouseDelta;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int KeyMap_0;
		public int KeyMap_1;
		public int KeyMap_2;
		public int KeyMap_3;
		public int KeyMap_4;
		public int KeyMap_5;
		public int KeyMap_6;
		public int KeyMap_7;
		public int KeyMap_8;
		public int KeyMap_9;
		public int KeyMap_10;
		public int KeyMap_11;
		public int KeyMap_12;
		public int KeyMap_13;
		public int KeyMap_14;
		public int KeyMap_15;
		public int KeyMap_16;
		public int KeyMap_17;
		public int KeyMap_18;
		public int KeyMap_19;
		public int KeyMap_20;
		public int KeyMap_21;
		public int KeyMap_22;
		public int KeyMap_23;
		public int KeyMap_24;
		public int KeyMap_25;
		public int KeyMap_26;
		public int KeyMap_27;
		public int KeyMap_28;
		public int KeyMap_29;
		public int KeyMap_30;
		public int KeyMap_31;
		public int KeyMap_32;
		public int KeyMap_33;
		public int KeyMap_34;
		public int KeyMap_35;
		public int KeyMap_36;
		public int KeyMap_37;
		public int KeyMap_38;
		public int KeyMap_39;
		public int KeyMap_40;
		public int KeyMap_41;
		public int KeyMap_42;
		public int KeyMap_43;
		public int KeyMap_44;
		public int KeyMap_45;
		public int KeyMap_46;
		public int KeyMap_47;
		public int KeyMap_48;
		public int KeyMap_49;
		public int KeyMap_50;
		public int KeyMap_51;
		public int KeyMap_52;
		public int KeyMap_53;
		public int KeyMap_54;
		public int KeyMap_55;
		public int KeyMap_56;
		public int KeyMap_57;
		public int KeyMap_58;
		public int KeyMap_59;
		public int KeyMap_60;
		public int KeyMap_61;
		public int KeyMap_62;
		public int KeyMap_63;
		public int KeyMap_64;
		public int KeyMap_65;
		public int KeyMap_66;
		public int KeyMap_67;
		public int KeyMap_68;
		public int KeyMap_69;
		public int KeyMap_70;
		public int KeyMap_71;
		public int KeyMap_72;
		public int KeyMap_73;
		public int KeyMap_74;
		public int KeyMap_75;
		public int KeyMap_76;
		public int KeyMap_77;
		public int KeyMap_78;
		public int KeyMap_79;
		public int KeyMap_80;
		public int KeyMap_81;
		public int KeyMap_82;
		public int KeyMap_83;
		public int KeyMap_84;
		public int KeyMap_85;
		public int KeyMap_86;
		public int KeyMap_87;
		public int KeyMap_88;
		public int KeyMap_89;
		public int KeyMap_90;
		public int KeyMap_91;
		public int KeyMap_92;
		public int KeyMap_93;
		public int KeyMap_94;
		public int KeyMap_95;
		public int KeyMap_96;
		public int KeyMap_97;
		public int KeyMap_98;
		public int KeyMap_99;
		public int KeyMap_100;
		public int KeyMap_101;
		public int KeyMap_102;
		public int KeyMap_103;
		public int KeyMap_104;
		public int KeyMap_105;
		public int KeyMap_106;
		public int KeyMap_107;
		public int KeyMap_108;
		public int KeyMap_109;
		public int KeyMap_110;
		public int KeyMap_111;
		public int KeyMap_112;
		public int KeyMap_113;
		public int KeyMap_114;
		public int KeyMap_115;
		public int KeyMap_116;
		public int KeyMap_117;
		public int KeyMap_118;
		public int KeyMap_119;
		public int KeyMap_120;
		public int KeyMap_121;
		public int KeyMap_122;
		public int KeyMap_123;
		public int KeyMap_124;
		public int KeyMap_125;
		public int KeyMap_126;
		public int KeyMap_127;
		public int KeyMap_128;
		public int KeyMap_129;
		public int KeyMap_130;
		public int KeyMap_131;
		public int KeyMap_132;
		public int KeyMap_133;
		public int KeyMap_134;
		public int KeyMap_135;
		public int KeyMap_136;
		public int KeyMap_137;
		public int KeyMap_138;
		public int KeyMap_139;
		public int KeyMap_140;
		public int KeyMap_141;
		public int KeyMap_142;
		public int KeyMap_143;
		public int KeyMap_144;
		public int KeyMap_145;
		public int KeyMap_146;
		public int KeyMap_147;
		public int KeyMap_148;
		public int KeyMap_149;
		public int KeyMap_150;
		public int KeyMap_151;
		public int KeyMap_152;
		public int KeyMap_153;
		public int KeyMap_154;
		public int KeyMap_155;
		public int KeyMap_156;
		public int KeyMap_157;
		public int KeyMap_158;
		public int KeyMap_159;
		public int KeyMap_160;
		public int KeyMap_161;
		public int KeyMap_162;
		public int KeyMap_163;
		public int KeyMap_164;
		public int KeyMap_165;
		public int KeyMap_166;
		public int KeyMap_167;
		public int KeyMap_168;
		public int KeyMap_169;
		public int KeyMap_170;
		public int KeyMap_171;
		public int KeyMap_172;
		public int KeyMap_173;
		public int KeyMap_174;
		public int KeyMap_175;
		public int KeyMap_176;
		public int KeyMap_177;
		public int KeyMap_178;
		public int KeyMap_179;
		public int KeyMap_180;
		public int KeyMap_181;
		public int KeyMap_182;
		public int KeyMap_183;
		public int KeyMap_184;
		public int KeyMap_185;
		public int KeyMap_186;
		public int KeyMap_187;
		public int KeyMap_188;
		public int KeyMap_189;
		public int KeyMap_190;
		public int KeyMap_191;
		public int KeyMap_192;
		public int KeyMap_193;
		public int KeyMap_194;
		public int KeyMap_195;
		public int KeyMap_196;
		public int KeyMap_197;
		public int KeyMap_198;
		public int KeyMap_199;
		public int KeyMap_200;
		public int KeyMap_201;
		public int KeyMap_202;
		public int KeyMap_203;
		public int KeyMap_204;
		public int KeyMap_205;
		public int KeyMap_206;
		public int KeyMap_207;
		public int KeyMap_208;
		public int KeyMap_209;
		public int KeyMap_210;
		public int KeyMap_211;
		public int KeyMap_212;
		public int KeyMap_213;
		public int KeyMap_214;
		public int KeyMap_215;
		public int KeyMap_216;
		public int KeyMap_217;
		public int KeyMap_218;
		public int KeyMap_219;
		public int KeyMap_220;
		public int KeyMap_221;
		public int KeyMap_222;
		public int KeyMap_223;
		public int KeyMap_224;
		public int KeyMap_225;
		public int KeyMap_226;
		public int KeyMap_227;
		public int KeyMap_228;
		public int KeyMap_229;
		public int KeyMap_230;
		public int KeyMap_231;
		public int KeyMap_232;
		public int KeyMap_233;
		public int KeyMap_234;
		public int KeyMap_235;
		public int KeyMap_236;
		public int KeyMap_237;
		public int KeyMap_238;
		public int KeyMap_239;
		public int KeyMap_240;
		public int KeyMap_241;
		public int KeyMap_242;
		public int KeyMap_243;
		public int KeyMap_244;
		public int KeyMap_245;
		public int KeyMap_246;
		public int KeyMap_247;
		public int KeyMap_248;
		public int KeyMap_249;
		public int KeyMap_250;
		public int KeyMap_251;
		public int KeyMap_252;
		public int KeyMap_253;
		public int KeyMap_254;
		public int KeyMap_255;
		public int KeyMap_256;
		public int KeyMap_257;
		public int KeyMap_258;
		public int KeyMap_259;
		public int KeyMap_260;
		public int KeyMap_261;
		public int KeyMap_262;
		public int KeyMap_263;
		public int KeyMap_264;
		public int KeyMap_265;
		public int KeyMap_266;
		public int KeyMap_267;
		public int KeyMap_268;
		public int KeyMap_269;
		public int KeyMap_270;
		public int KeyMap_271;
		public int KeyMap_272;
		public int KeyMap_273;
		public int KeyMap_274;
		public int KeyMap_275;
		public int KeyMap_276;
		public int KeyMap_277;
		public int KeyMap_278;
		public int KeyMap_279;
		public int KeyMap_280;
		public int KeyMap_281;
		public int KeyMap_282;
		public int KeyMap_283;
		public int KeyMap_284;
		public int KeyMap_285;
		public int KeyMap_286;
		public int KeyMap_287;
		public int KeyMap_288;
		public int KeyMap_289;
		public int KeyMap_290;
		public int KeyMap_291;
		public int KeyMap_292;
		public int KeyMap_293;
		public int KeyMap_294;
		public int KeyMap_295;
		public int KeyMap_296;
		public int KeyMap_297;
		public int KeyMap_298;
		public int KeyMap_299;
		public int KeyMap_300;
		public int KeyMap_301;
		public int KeyMap_302;
		public int KeyMap_303;
		public int KeyMap_304;
		public int KeyMap_305;
		public int KeyMap_306;
		public int KeyMap_307;
		public int KeyMap_308;
		public int KeyMap_309;
		public int KeyMap_310;
		public int KeyMap_311;
		public int KeyMap_312;
		public int KeyMap_313;
		public int KeyMap_314;
		public int KeyMap_315;
		public int KeyMap_316;
		public int KeyMap_317;
		public int KeyMap_318;
		public int KeyMap_319;
		public int KeyMap_320;
		public int KeyMap_321;
		public int KeyMap_322;
		public int KeyMap_323;
		public int KeyMap_324;
		public int KeyMap_325;
		public int KeyMap_326;
		public int KeyMap_327;
		public int KeyMap_328;
		public int KeyMap_329;
		public int KeyMap_330;
		public int KeyMap_331;
		public int KeyMap_332;
		public int KeyMap_333;
		public int KeyMap_334;
		public int KeyMap_335;
		public int KeyMap_336;
		public int KeyMap_337;
		public int KeyMap_338;
		public int KeyMap_339;
		public int KeyMap_340;
		public int KeyMap_341;
		public int KeyMap_342;
		public int KeyMap_343;
		public int KeyMap_344;
		public int KeyMap_345;
		public int KeyMap_346;
		public int KeyMap_347;
		public int KeyMap_348;
		public int KeyMap_349;
		public int KeyMap_350;
		public int KeyMap_351;
		public int KeyMap_352;
		public int KeyMap_353;
		public int KeyMap_354;
		public int KeyMap_355;
		public int KeyMap_356;
		public int KeyMap_357;
		public int KeyMap_358;
		public int KeyMap_359;
		public int KeyMap_360;
		public int KeyMap_361;
		public int KeyMap_362;
		public int KeyMap_363;
		public int KeyMap_364;
		public int KeyMap_365;
		public int KeyMap_366;
		public int KeyMap_367;
		public int KeyMap_368;
		public int KeyMap_369;
		public int KeyMap_370;
		public int KeyMap_371;
		public int KeyMap_372;
		public int KeyMap_373;
		public int KeyMap_374;
		public int KeyMap_375;
		public int KeyMap_376;
		public int KeyMap_377;
		public int KeyMap_378;
		public int KeyMap_379;
		public int KeyMap_380;
		public int KeyMap_381;
		public int KeyMap_382;
		public int KeyMap_383;
		public int KeyMap_384;
		public int KeyMap_385;
		public int KeyMap_386;
		public int KeyMap_387;
		public int KeyMap_388;
		public int KeyMap_389;
		public int KeyMap_390;
		public int KeyMap_391;
		public int KeyMap_392;
		public int KeyMap_393;
		public int KeyMap_394;
		public int KeyMap_395;
		public int KeyMap_396;
		public int KeyMap_397;
		public int KeyMap_398;
		public int KeyMap_399;
		public int KeyMap_400;
		public int KeyMap_401;
		public int KeyMap_402;
		public int KeyMap_403;
		public int KeyMap_404;
		public int KeyMap_405;
		public int KeyMap_406;
		public int KeyMap_407;
		public int KeyMap_408;
		public int KeyMap_409;
		public int KeyMap_410;
		public int KeyMap_411;
		public int KeyMap_412;
		public int KeyMap_413;
		public int KeyMap_414;
		public int KeyMap_415;
		public int KeyMap_416;
		public int KeyMap_417;
		public int KeyMap_418;
		public int KeyMap_419;
		public int KeyMap_420;
		public int KeyMap_421;
		public int KeyMap_422;
		public int KeyMap_423;
		public int KeyMap_424;
		public int KeyMap_425;
		public int KeyMap_426;
		public int KeyMap_427;
		public int KeyMap_428;
		public int KeyMap_429;
		public int KeyMap_430;
		public int KeyMap_431;
		public int KeyMap_432;
		public int KeyMap_433;
		public int KeyMap_434;
		public int KeyMap_435;
		public int KeyMap_436;
		public int KeyMap_437;
		public int KeyMap_438;
		public int KeyMap_439;
		public int KeyMap_440;
		public int KeyMap_441;
		public int KeyMap_442;
		public int KeyMap_443;
		public int KeyMap_444;
		public int KeyMap_445;
		public int KeyMap_446;
		public int KeyMap_447;
		public int KeyMap_448;
		public int KeyMap_449;
		public int KeyMap_450;
		public int KeyMap_451;
		public int KeyMap_452;
		public int KeyMap_453;
		public int KeyMap_454;
		public int KeyMap_455;
		public int KeyMap_456;
		public int KeyMap_457;
		public int KeyMap_458;
		public int KeyMap_459;
		public int KeyMap_460;
		public int KeyMap_461;
		public int KeyMap_462;
		public int KeyMap_463;
		public int KeyMap_464;
		public int KeyMap_465;
		public int KeyMap_466;
		public int KeyMap_467;
		public int KeyMap_468;
		public int KeyMap_469;
		public int KeyMap_470;
		public int KeyMap_471;
		public int KeyMap_472;
		public int KeyMap_473;
		public int KeyMap_474;
		public int KeyMap_475;
		public int KeyMap_476;
		public int KeyMap_477;
		public int KeyMap_478;
		public int KeyMap_479;
		public int KeyMap_480;
		public int KeyMap_481;
		public int KeyMap_482;
		public int KeyMap_483;
		public int KeyMap_484;
		public int KeyMap_485;
		public int KeyMap_486;
		public int KeyMap_487;
		public int KeyMap_488;
		public int KeyMap_489;
		public int KeyMap_490;
		public int KeyMap_491;
		public int KeyMap_492;
		public int KeyMap_493;
		public int KeyMap_494;
		public int KeyMap_495;
		public int KeyMap_496;
		public int KeyMap_497;
		public int KeyMap_498;
		public int KeyMap_499;
		public int KeyMap_500;
		public int KeyMap_501;
		public int KeyMap_502;
		public int KeyMap_503;
		public int KeyMap_504;
		public int KeyMap_505;
		public int KeyMap_506;
		public int KeyMap_507;
		public int KeyMap_508;
		public int KeyMap_509;
		public int KeyMap_510;
		public int KeyMap_511;
		public int KeyMap_512;
		public int KeyMap_513;
		public int KeyMap_514;
		public int KeyMap_515;
		public int KeyMap_516;
		public int KeyMap_517;
		public int KeyMap_518;
		public int KeyMap_519;
		public int KeyMap_520;
		public int KeyMap_521;
		public int KeyMap_522;
		public int KeyMap_523;
		public int KeyMap_524;
		public int KeyMap_525;
		public int KeyMap_526;
		public int KeyMap_527;
		public int KeyMap_528;
		public int KeyMap_529;
		public int KeyMap_530;
		public int KeyMap_531;
		public int KeyMap_532;
		public int KeyMap_533;
		public int KeyMap_534;
		public int KeyMap_535;
		public int KeyMap_536;
		public int KeyMap_537;
		public int KeyMap_538;
		public int KeyMap_539;
		public int KeyMap_540;
		public int KeyMap_541;
		public int KeyMap_542;
		public int KeyMap_543;
		public int KeyMap_544;
		public int KeyMap_545;
		public int KeyMap_546;
		public int KeyMap_547;
		public int KeyMap_548;
		public int KeyMap_549;
		public int KeyMap_550;
		public int KeyMap_551;
		public int KeyMap_552;
		public int KeyMap_553;
		public int KeyMap_554;
		public int KeyMap_555;
		public int KeyMap_556;
		public int KeyMap_557;
		public int KeyMap_558;
		public int KeyMap_559;
		public int KeyMap_560;
		public int KeyMap_561;
		public int KeyMap_562;
		public int KeyMap_563;
		public int KeyMap_564;
		public int KeyMap_565;
		public int KeyMap_566;
		public int KeyMap_567;
		public int KeyMap_568;
		public int KeyMap_569;
		public int KeyMap_570;
		public int KeyMap_571;
		public int KeyMap_572;
		public int KeyMap_573;
		public int KeyMap_574;
		public int KeyMap_575;
		public int KeyMap_576;
		public int KeyMap_577;
		public int KeyMap_578;
		public int KeyMap_579;
		public int KeyMap_580;
		public int KeyMap_581;
		public int KeyMap_582;
		public int KeyMap_583;
		public int KeyMap_584;
		public int KeyMap_585;
		public int KeyMap_586;
		public int KeyMap_587;
		public int KeyMap_588;
		public int KeyMap_589;
		public int KeyMap_590;
		public int KeyMap_591;
		public int KeyMap_592;
		public int KeyMap_593;
		public int KeyMap_594;
		public int KeyMap_595;
		public int KeyMap_596;
		public int KeyMap_597;
		public int KeyMap_598;
		public int KeyMap_599;
		public int KeyMap_600;
		public int KeyMap_601;
		public int KeyMap_602;
		public int KeyMap_603;
		public int KeyMap_604;
		public int KeyMap_605;
		public int KeyMap_606;
		public int KeyMap_607;
		public int KeyMap_608;
		public int KeyMap_609;
		public int KeyMap_610;
		public int KeyMap_611;
		public int KeyMap_612;
		public int KeyMap_613;
		public int KeyMap_614;
		public int KeyMap_615;
		public int KeyMap_616;
		public int KeyMap_617;
		public int KeyMap_618;
		public int KeyMap_619;
		public int KeyMap_620;
		public int KeyMap_621;
		public int KeyMap_622;
		public int KeyMap_623;
		public int KeyMap_624;
		public int KeyMap_625;
		public int KeyMap_626;
		public int KeyMap_627;
		public int KeyMap_628;
		public int KeyMap_629;
		public int KeyMap_630;
		public int KeyMap_631;
		public int KeyMap_632;
		public int KeyMap_633;
		public int KeyMap_634;
		public int KeyMap_635;
		public int KeyMap_636;
		public int KeyMap_637;
		public int KeyMap_638;
		public int KeyMap_639;
		public int KeyMap_640;
		public int KeyMap_641;
		public int KeyMap_642;
		public int KeyMap_643;
		public int KeyMap_644;
		public int KeyMap_645;
		public int KeyMap_646;
		public int KeyMap_647;
		public int KeyMap_648;
		public int KeyMap_649;
		public int KeyMap_650;
		public int KeyMap_651;
		public int KeyMap_652;
		public int KeyMap_653;
		public int KeyMap_654;
		public int KeyMap_655;
		public int KeyMap_656;
		public int KeyMap_657;
		public int KeyMap_658;
		public int KeyMap_659;
		public int KeyMap_660;
		public int KeyMap_661;
		public int KeyMap_662;
		public int KeyMap_663;
		public int KeyMap_664;
		public int KeyMap_665;

		/// <summary>
		/// To be documented.
		/// </summary>
		public bool KeysDown_0;
		public bool KeysDown_1;
		public bool KeysDown_2;
		public bool KeysDown_3;
		public bool KeysDown_4;
		public bool KeysDown_5;
		public bool KeysDown_6;
		public bool KeysDown_7;
		public bool KeysDown_8;
		public bool KeysDown_9;
		public bool KeysDown_10;
		public bool KeysDown_11;
		public bool KeysDown_12;
		public bool KeysDown_13;
		public bool KeysDown_14;
		public bool KeysDown_15;
		public bool KeysDown_16;
		public bool KeysDown_17;
		public bool KeysDown_18;
		public bool KeysDown_19;
		public bool KeysDown_20;
		public bool KeysDown_21;
		public bool KeysDown_22;
		public bool KeysDown_23;
		public bool KeysDown_24;
		public bool KeysDown_25;
		public bool KeysDown_26;
		public bool KeysDown_27;
		public bool KeysDown_28;
		public bool KeysDown_29;
		public bool KeysDown_30;
		public bool KeysDown_31;
		public bool KeysDown_32;
		public bool KeysDown_33;
		public bool KeysDown_34;
		public bool KeysDown_35;
		public bool KeysDown_36;
		public bool KeysDown_37;
		public bool KeysDown_38;
		public bool KeysDown_39;
		public bool KeysDown_40;
		public bool KeysDown_41;
		public bool KeysDown_42;
		public bool KeysDown_43;
		public bool KeysDown_44;
		public bool KeysDown_45;
		public bool KeysDown_46;
		public bool KeysDown_47;
		public bool KeysDown_48;
		public bool KeysDown_49;
		public bool KeysDown_50;
		public bool KeysDown_51;
		public bool KeysDown_52;
		public bool KeysDown_53;
		public bool KeysDown_54;
		public bool KeysDown_55;
		public bool KeysDown_56;
		public bool KeysDown_57;
		public bool KeysDown_58;
		public bool KeysDown_59;
		public bool KeysDown_60;
		public bool KeysDown_61;
		public bool KeysDown_62;
		public bool KeysDown_63;
		public bool KeysDown_64;
		public bool KeysDown_65;
		public bool KeysDown_66;
		public bool KeysDown_67;
		public bool KeysDown_68;
		public bool KeysDown_69;
		public bool KeysDown_70;
		public bool KeysDown_71;
		public bool KeysDown_72;
		public bool KeysDown_73;
		public bool KeysDown_74;
		public bool KeysDown_75;
		public bool KeysDown_76;
		public bool KeysDown_77;
		public bool KeysDown_78;
		public bool KeysDown_79;
		public bool KeysDown_80;
		public bool KeysDown_81;
		public bool KeysDown_82;
		public bool KeysDown_83;
		public bool KeysDown_84;
		public bool KeysDown_85;
		public bool KeysDown_86;
		public bool KeysDown_87;
		public bool KeysDown_88;
		public bool KeysDown_89;
		public bool KeysDown_90;
		public bool KeysDown_91;
		public bool KeysDown_92;
		public bool KeysDown_93;
		public bool KeysDown_94;
		public bool KeysDown_95;
		public bool KeysDown_96;
		public bool KeysDown_97;
		public bool KeysDown_98;
		public bool KeysDown_99;
		public bool KeysDown_100;
		public bool KeysDown_101;
		public bool KeysDown_102;
		public bool KeysDown_103;
		public bool KeysDown_104;
		public bool KeysDown_105;
		public bool KeysDown_106;
		public bool KeysDown_107;
		public bool KeysDown_108;
		public bool KeysDown_109;
		public bool KeysDown_110;
		public bool KeysDown_111;
		public bool KeysDown_112;
		public bool KeysDown_113;
		public bool KeysDown_114;
		public bool KeysDown_115;
		public bool KeysDown_116;
		public bool KeysDown_117;
		public bool KeysDown_118;
		public bool KeysDown_119;
		public bool KeysDown_120;
		public bool KeysDown_121;
		public bool KeysDown_122;
		public bool KeysDown_123;
		public bool KeysDown_124;
		public bool KeysDown_125;
		public bool KeysDown_126;
		public bool KeysDown_127;
		public bool KeysDown_128;
		public bool KeysDown_129;
		public bool KeysDown_130;
		public bool KeysDown_131;
		public bool KeysDown_132;
		public bool KeysDown_133;
		public bool KeysDown_134;
		public bool KeysDown_135;
		public bool KeysDown_136;
		public bool KeysDown_137;
		public bool KeysDown_138;
		public bool KeysDown_139;
		public bool KeysDown_140;
		public bool KeysDown_141;
		public bool KeysDown_142;
		public bool KeysDown_143;
		public bool KeysDown_144;
		public bool KeysDown_145;
		public bool KeysDown_146;
		public bool KeysDown_147;
		public bool KeysDown_148;
		public bool KeysDown_149;
		public bool KeysDown_150;
		public bool KeysDown_151;
		public bool KeysDown_152;
		public bool KeysDown_153;
		public bool KeysDown_154;
		public bool KeysDown_155;
		public bool KeysDown_156;
		public bool KeysDown_157;
		public bool KeysDown_158;
		public bool KeysDown_159;
		public bool KeysDown_160;
		public bool KeysDown_161;
		public bool KeysDown_162;
		public bool KeysDown_163;
		public bool KeysDown_164;
		public bool KeysDown_165;
		public bool KeysDown_166;
		public bool KeysDown_167;
		public bool KeysDown_168;
		public bool KeysDown_169;
		public bool KeysDown_170;
		public bool KeysDown_171;
		public bool KeysDown_172;
		public bool KeysDown_173;
		public bool KeysDown_174;
		public bool KeysDown_175;
		public bool KeysDown_176;
		public bool KeysDown_177;
		public bool KeysDown_178;
		public bool KeysDown_179;
		public bool KeysDown_180;
		public bool KeysDown_181;
		public bool KeysDown_182;
		public bool KeysDown_183;
		public bool KeysDown_184;
		public bool KeysDown_185;
		public bool KeysDown_186;
		public bool KeysDown_187;
		public bool KeysDown_188;
		public bool KeysDown_189;
		public bool KeysDown_190;
		public bool KeysDown_191;
		public bool KeysDown_192;
		public bool KeysDown_193;
		public bool KeysDown_194;
		public bool KeysDown_195;
		public bool KeysDown_196;
		public bool KeysDown_197;
		public bool KeysDown_198;
		public bool KeysDown_199;
		public bool KeysDown_200;
		public bool KeysDown_201;
		public bool KeysDown_202;
		public bool KeysDown_203;
		public bool KeysDown_204;
		public bool KeysDown_205;
		public bool KeysDown_206;
		public bool KeysDown_207;
		public bool KeysDown_208;
		public bool KeysDown_209;
		public bool KeysDown_210;
		public bool KeysDown_211;
		public bool KeysDown_212;
		public bool KeysDown_213;
		public bool KeysDown_214;
		public bool KeysDown_215;
		public bool KeysDown_216;
		public bool KeysDown_217;
		public bool KeysDown_218;
		public bool KeysDown_219;
		public bool KeysDown_220;
		public bool KeysDown_221;
		public bool KeysDown_222;
		public bool KeysDown_223;
		public bool KeysDown_224;
		public bool KeysDown_225;
		public bool KeysDown_226;
		public bool KeysDown_227;
		public bool KeysDown_228;
		public bool KeysDown_229;
		public bool KeysDown_230;
		public bool KeysDown_231;
		public bool KeysDown_232;
		public bool KeysDown_233;
		public bool KeysDown_234;
		public bool KeysDown_235;
		public bool KeysDown_236;
		public bool KeysDown_237;
		public bool KeysDown_238;
		public bool KeysDown_239;
		public bool KeysDown_240;
		public bool KeysDown_241;
		public bool KeysDown_242;
		public bool KeysDown_243;
		public bool KeysDown_244;
		public bool KeysDown_245;
		public bool KeysDown_246;
		public bool KeysDown_247;
		public bool KeysDown_248;
		public bool KeysDown_249;
		public bool KeysDown_250;
		public bool KeysDown_251;
		public bool KeysDown_252;
		public bool KeysDown_253;
		public bool KeysDown_254;
		public bool KeysDown_255;
		public bool KeysDown_256;
		public bool KeysDown_257;
		public bool KeysDown_258;
		public bool KeysDown_259;
		public bool KeysDown_260;
		public bool KeysDown_261;
		public bool KeysDown_262;
		public bool KeysDown_263;
		public bool KeysDown_264;
		public bool KeysDown_265;
		public bool KeysDown_266;
		public bool KeysDown_267;
		public bool KeysDown_268;
		public bool KeysDown_269;
		public bool KeysDown_270;
		public bool KeysDown_271;
		public bool KeysDown_272;
		public bool KeysDown_273;
		public bool KeysDown_274;
		public bool KeysDown_275;
		public bool KeysDown_276;
		public bool KeysDown_277;
		public bool KeysDown_278;
		public bool KeysDown_279;
		public bool KeysDown_280;
		public bool KeysDown_281;
		public bool KeysDown_282;
		public bool KeysDown_283;
		public bool KeysDown_284;
		public bool KeysDown_285;
		public bool KeysDown_286;
		public bool KeysDown_287;
		public bool KeysDown_288;
		public bool KeysDown_289;
		public bool KeysDown_290;
		public bool KeysDown_291;
		public bool KeysDown_292;
		public bool KeysDown_293;
		public bool KeysDown_294;
		public bool KeysDown_295;
		public bool KeysDown_296;
		public bool KeysDown_297;
		public bool KeysDown_298;
		public bool KeysDown_299;
		public bool KeysDown_300;
		public bool KeysDown_301;
		public bool KeysDown_302;
		public bool KeysDown_303;
		public bool KeysDown_304;
		public bool KeysDown_305;
		public bool KeysDown_306;
		public bool KeysDown_307;
		public bool KeysDown_308;
		public bool KeysDown_309;
		public bool KeysDown_310;
		public bool KeysDown_311;
		public bool KeysDown_312;
		public bool KeysDown_313;
		public bool KeysDown_314;
		public bool KeysDown_315;
		public bool KeysDown_316;
		public bool KeysDown_317;
		public bool KeysDown_318;
		public bool KeysDown_319;
		public bool KeysDown_320;
		public bool KeysDown_321;
		public bool KeysDown_322;
		public bool KeysDown_323;
		public bool KeysDown_324;
		public bool KeysDown_325;
		public bool KeysDown_326;
		public bool KeysDown_327;
		public bool KeysDown_328;
		public bool KeysDown_329;
		public bool KeysDown_330;
		public bool KeysDown_331;
		public bool KeysDown_332;
		public bool KeysDown_333;
		public bool KeysDown_334;
		public bool KeysDown_335;
		public bool KeysDown_336;
		public bool KeysDown_337;
		public bool KeysDown_338;
		public bool KeysDown_339;
		public bool KeysDown_340;
		public bool KeysDown_341;
		public bool KeysDown_342;
		public bool KeysDown_343;
		public bool KeysDown_344;
		public bool KeysDown_345;
		public bool KeysDown_346;
		public bool KeysDown_347;
		public bool KeysDown_348;
		public bool KeysDown_349;
		public bool KeysDown_350;
		public bool KeysDown_351;
		public bool KeysDown_352;
		public bool KeysDown_353;
		public bool KeysDown_354;
		public bool KeysDown_355;
		public bool KeysDown_356;
		public bool KeysDown_357;
		public bool KeysDown_358;
		public bool KeysDown_359;
		public bool KeysDown_360;
		public bool KeysDown_361;
		public bool KeysDown_362;
		public bool KeysDown_363;
		public bool KeysDown_364;
		public bool KeysDown_365;
		public bool KeysDown_366;
		public bool KeysDown_367;
		public bool KeysDown_368;
		public bool KeysDown_369;
		public bool KeysDown_370;
		public bool KeysDown_371;
		public bool KeysDown_372;
		public bool KeysDown_373;
		public bool KeysDown_374;
		public bool KeysDown_375;
		public bool KeysDown_376;
		public bool KeysDown_377;
		public bool KeysDown_378;
		public bool KeysDown_379;
		public bool KeysDown_380;
		public bool KeysDown_381;
		public bool KeysDown_382;
		public bool KeysDown_383;
		public bool KeysDown_384;
		public bool KeysDown_385;
		public bool KeysDown_386;
		public bool KeysDown_387;
		public bool KeysDown_388;
		public bool KeysDown_389;
		public bool KeysDown_390;
		public bool KeysDown_391;
		public bool KeysDown_392;
		public bool KeysDown_393;
		public bool KeysDown_394;
		public bool KeysDown_395;
		public bool KeysDown_396;
		public bool KeysDown_397;
		public bool KeysDown_398;
		public bool KeysDown_399;
		public bool KeysDown_400;
		public bool KeysDown_401;
		public bool KeysDown_402;
		public bool KeysDown_403;
		public bool KeysDown_404;
		public bool KeysDown_405;
		public bool KeysDown_406;
		public bool KeysDown_407;
		public bool KeysDown_408;
		public bool KeysDown_409;
		public bool KeysDown_410;
		public bool KeysDown_411;
		public bool KeysDown_412;
		public bool KeysDown_413;
		public bool KeysDown_414;
		public bool KeysDown_415;
		public bool KeysDown_416;
		public bool KeysDown_417;
		public bool KeysDown_418;
		public bool KeysDown_419;
		public bool KeysDown_420;
		public bool KeysDown_421;
		public bool KeysDown_422;
		public bool KeysDown_423;
		public bool KeysDown_424;
		public bool KeysDown_425;
		public bool KeysDown_426;
		public bool KeysDown_427;
		public bool KeysDown_428;
		public bool KeysDown_429;
		public bool KeysDown_430;
		public bool KeysDown_431;
		public bool KeysDown_432;
		public bool KeysDown_433;
		public bool KeysDown_434;
		public bool KeysDown_435;
		public bool KeysDown_436;
		public bool KeysDown_437;
		public bool KeysDown_438;
		public bool KeysDown_439;
		public bool KeysDown_440;
		public bool KeysDown_441;
		public bool KeysDown_442;
		public bool KeysDown_443;
		public bool KeysDown_444;
		public bool KeysDown_445;
		public bool KeysDown_446;
		public bool KeysDown_447;
		public bool KeysDown_448;
		public bool KeysDown_449;
		public bool KeysDown_450;
		public bool KeysDown_451;
		public bool KeysDown_452;
		public bool KeysDown_453;
		public bool KeysDown_454;
		public bool KeysDown_455;
		public bool KeysDown_456;
		public bool KeysDown_457;
		public bool KeysDown_458;
		public bool KeysDown_459;
		public bool KeysDown_460;
		public bool KeysDown_461;
		public bool KeysDown_462;
		public bool KeysDown_463;
		public bool KeysDown_464;
		public bool KeysDown_465;
		public bool KeysDown_466;
		public bool KeysDown_467;
		public bool KeysDown_468;
		public bool KeysDown_469;
		public bool KeysDown_470;
		public bool KeysDown_471;
		public bool KeysDown_472;
		public bool KeysDown_473;
		public bool KeysDown_474;
		public bool KeysDown_475;
		public bool KeysDown_476;
		public bool KeysDown_477;
		public bool KeysDown_478;
		public bool KeysDown_479;
		public bool KeysDown_480;
		public bool KeysDown_481;
		public bool KeysDown_482;
		public bool KeysDown_483;
		public bool KeysDown_484;
		public bool KeysDown_485;
		public bool KeysDown_486;
		public bool KeysDown_487;
		public bool KeysDown_488;
		public bool KeysDown_489;
		public bool KeysDown_490;
		public bool KeysDown_491;
		public bool KeysDown_492;
		public bool KeysDown_493;
		public bool KeysDown_494;
		public bool KeysDown_495;
		public bool KeysDown_496;
		public bool KeysDown_497;
		public bool KeysDown_498;
		public bool KeysDown_499;
		public bool KeysDown_500;
		public bool KeysDown_501;
		public bool KeysDown_502;
		public bool KeysDown_503;
		public bool KeysDown_504;
		public bool KeysDown_505;
		public bool KeysDown_506;
		public bool KeysDown_507;
		public bool KeysDown_508;
		public bool KeysDown_509;
		public bool KeysDown_510;
		public bool KeysDown_511;
		public bool KeysDown_512;
		public bool KeysDown_513;
		public bool KeysDown_514;
		public bool KeysDown_515;
		public bool KeysDown_516;
		public bool KeysDown_517;
		public bool KeysDown_518;
		public bool KeysDown_519;
		public bool KeysDown_520;
		public bool KeysDown_521;
		public bool KeysDown_522;
		public bool KeysDown_523;
		public bool KeysDown_524;
		public bool KeysDown_525;
		public bool KeysDown_526;
		public bool KeysDown_527;
		public bool KeysDown_528;
		public bool KeysDown_529;
		public bool KeysDown_530;
		public bool KeysDown_531;
		public bool KeysDown_532;
		public bool KeysDown_533;
		public bool KeysDown_534;
		public bool KeysDown_535;
		public bool KeysDown_536;
		public bool KeysDown_537;
		public bool KeysDown_538;
		public bool KeysDown_539;
		public bool KeysDown_540;
		public bool KeysDown_541;
		public bool KeysDown_542;
		public bool KeysDown_543;
		public bool KeysDown_544;
		public bool KeysDown_545;
		public bool KeysDown_546;
		public bool KeysDown_547;
		public bool KeysDown_548;
		public bool KeysDown_549;
		public bool KeysDown_550;
		public bool KeysDown_551;
		public bool KeysDown_552;
		public bool KeysDown_553;
		public bool KeysDown_554;
		public bool KeysDown_555;
		public bool KeysDown_556;
		public bool KeysDown_557;
		public bool KeysDown_558;
		public bool KeysDown_559;
		public bool KeysDown_560;
		public bool KeysDown_561;
		public bool KeysDown_562;
		public bool KeysDown_563;
		public bool KeysDown_564;
		public bool KeysDown_565;
		public bool KeysDown_566;
		public bool KeysDown_567;
		public bool KeysDown_568;
		public bool KeysDown_569;
		public bool KeysDown_570;
		public bool KeysDown_571;
		public bool KeysDown_572;
		public bool KeysDown_573;
		public bool KeysDown_574;
		public bool KeysDown_575;
		public bool KeysDown_576;
		public bool KeysDown_577;
		public bool KeysDown_578;
		public bool KeysDown_579;
		public bool KeysDown_580;
		public bool KeysDown_581;
		public bool KeysDown_582;
		public bool KeysDown_583;
		public bool KeysDown_584;
		public bool KeysDown_585;
		public bool KeysDown_586;
		public bool KeysDown_587;
		public bool KeysDown_588;
		public bool KeysDown_589;
		public bool KeysDown_590;
		public bool KeysDown_591;
		public bool KeysDown_592;
		public bool KeysDown_593;
		public bool KeysDown_594;
		public bool KeysDown_595;
		public bool KeysDown_596;
		public bool KeysDown_597;
		public bool KeysDown_598;
		public bool KeysDown_599;
		public bool KeysDown_600;
		public bool KeysDown_601;
		public bool KeysDown_602;
		public bool KeysDown_603;
		public bool KeysDown_604;
		public bool KeysDown_605;
		public bool KeysDown_606;
		public bool KeysDown_607;
		public bool KeysDown_608;
		public bool KeysDown_609;
		public bool KeysDown_610;
		public bool KeysDown_611;
		public bool KeysDown_612;
		public bool KeysDown_613;
		public bool KeysDown_614;
		public bool KeysDown_615;
		public bool KeysDown_616;
		public bool KeysDown_617;
		public bool KeysDown_618;
		public bool KeysDown_619;
		public bool KeysDown_620;
		public bool KeysDown_621;
		public bool KeysDown_622;
		public bool KeysDown_623;
		public bool KeysDown_624;
		public bool KeysDown_625;
		public bool KeysDown_626;
		public bool KeysDown_627;
		public bool KeysDown_628;
		public bool KeysDown_629;
		public bool KeysDown_630;
		public bool KeysDown_631;
		public bool KeysDown_632;
		public bool KeysDown_633;
		public bool KeysDown_634;
		public bool KeysDown_635;
		public bool KeysDown_636;
		public bool KeysDown_637;
		public bool KeysDown_638;
		public bool KeysDown_639;
		public bool KeysDown_640;
		public bool KeysDown_641;
		public bool KeysDown_642;
		public bool KeysDown_643;
		public bool KeysDown_644;
		public bool KeysDown_645;
		public bool KeysDown_646;
		public bool KeysDown_647;
		public bool KeysDown_648;
		public bool KeysDown_649;
		public bool KeysDown_650;
		public bool KeysDown_651;
		public bool KeysDown_652;
		public bool KeysDown_653;
		public bool KeysDown_654;
		public bool KeysDown_655;
		public bool KeysDown_656;
		public bool KeysDown_657;
		public bool KeysDown_658;
		public bool KeysDown_659;
		public bool KeysDown_660;
		public bool KeysDown_661;
		public bool KeysDown_662;
		public bool KeysDown_663;
		public bool KeysDown_664;
		public bool KeysDown_665;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float NavInputs_0;
		public float NavInputs_1;
		public float NavInputs_2;
		public float NavInputs_3;
		public float NavInputs_4;
		public float NavInputs_5;
		public float NavInputs_6;
		public float NavInputs_7;
		public float NavInputs_8;
		public float NavInputs_9;
		public float NavInputs_10;
		public float NavInputs_11;
		public float NavInputs_12;
		public float NavInputs_13;
		public float NavInputs_14;
		public float NavInputs_15;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UnusedPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MousePos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public bool MouseDown_0;
		public bool MouseDown_1;
		public bool MouseDown_2;
		public bool MouseDown_3;
		public bool MouseDown_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseWheel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseWheelH;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiMouseSource MouseSource;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint MouseHoveredViewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte KeyCtrl;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte KeyShift;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte KeyAlt;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte KeySuper;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int KeyMods;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiKeyData KeysData_0;
		public ImGuiKeyData KeysData_1;
		public ImGuiKeyData KeysData_2;
		public ImGuiKeyData KeysData_3;
		public ImGuiKeyData KeysData_4;
		public ImGuiKeyData KeysData_5;
		public ImGuiKeyData KeysData_6;
		public ImGuiKeyData KeysData_7;
		public ImGuiKeyData KeysData_8;
		public ImGuiKeyData KeysData_9;
		public ImGuiKeyData KeysData_10;
		public ImGuiKeyData KeysData_11;
		public ImGuiKeyData KeysData_12;
		public ImGuiKeyData KeysData_13;
		public ImGuiKeyData KeysData_14;
		public ImGuiKeyData KeysData_15;
		public ImGuiKeyData KeysData_16;
		public ImGuiKeyData KeysData_17;
		public ImGuiKeyData KeysData_18;
		public ImGuiKeyData KeysData_19;
		public ImGuiKeyData KeysData_20;
		public ImGuiKeyData KeysData_21;
		public ImGuiKeyData KeysData_22;
		public ImGuiKeyData KeysData_23;
		public ImGuiKeyData KeysData_24;
		public ImGuiKeyData KeysData_25;
		public ImGuiKeyData KeysData_26;
		public ImGuiKeyData KeysData_27;
		public ImGuiKeyData KeysData_28;
		public ImGuiKeyData KeysData_29;
		public ImGuiKeyData KeysData_30;
		public ImGuiKeyData KeysData_31;
		public ImGuiKeyData KeysData_32;
		public ImGuiKeyData KeysData_33;
		public ImGuiKeyData KeysData_34;
		public ImGuiKeyData KeysData_35;
		public ImGuiKeyData KeysData_36;
		public ImGuiKeyData KeysData_37;
		public ImGuiKeyData KeysData_38;
		public ImGuiKeyData KeysData_39;
		public ImGuiKeyData KeysData_40;
		public ImGuiKeyData KeysData_41;
		public ImGuiKeyData KeysData_42;
		public ImGuiKeyData KeysData_43;
		public ImGuiKeyData KeysData_44;
		public ImGuiKeyData KeysData_45;
		public ImGuiKeyData KeysData_46;
		public ImGuiKeyData KeysData_47;
		public ImGuiKeyData KeysData_48;
		public ImGuiKeyData KeysData_49;
		public ImGuiKeyData KeysData_50;
		public ImGuiKeyData KeysData_51;
		public ImGuiKeyData KeysData_52;
		public ImGuiKeyData KeysData_53;
		public ImGuiKeyData KeysData_54;
		public ImGuiKeyData KeysData_55;
		public ImGuiKeyData KeysData_56;
		public ImGuiKeyData KeysData_57;
		public ImGuiKeyData KeysData_58;
		public ImGuiKeyData KeysData_59;
		public ImGuiKeyData KeysData_60;
		public ImGuiKeyData KeysData_61;
		public ImGuiKeyData KeysData_62;
		public ImGuiKeyData KeysData_63;
		public ImGuiKeyData KeysData_64;
		public ImGuiKeyData KeysData_65;
		public ImGuiKeyData KeysData_66;
		public ImGuiKeyData KeysData_67;
		public ImGuiKeyData KeysData_68;
		public ImGuiKeyData KeysData_69;
		public ImGuiKeyData KeysData_70;
		public ImGuiKeyData KeysData_71;
		public ImGuiKeyData KeysData_72;
		public ImGuiKeyData KeysData_73;
		public ImGuiKeyData KeysData_74;
		public ImGuiKeyData KeysData_75;
		public ImGuiKeyData KeysData_76;
		public ImGuiKeyData KeysData_77;
		public ImGuiKeyData KeysData_78;
		public ImGuiKeyData KeysData_79;
		public ImGuiKeyData KeysData_80;
		public ImGuiKeyData KeysData_81;
		public ImGuiKeyData KeysData_82;
		public ImGuiKeyData KeysData_83;
		public ImGuiKeyData KeysData_84;
		public ImGuiKeyData KeysData_85;
		public ImGuiKeyData KeysData_86;
		public ImGuiKeyData KeysData_87;
		public ImGuiKeyData KeysData_88;
		public ImGuiKeyData KeysData_89;
		public ImGuiKeyData KeysData_90;
		public ImGuiKeyData KeysData_91;
		public ImGuiKeyData KeysData_92;
		public ImGuiKeyData KeysData_93;
		public ImGuiKeyData KeysData_94;
		public ImGuiKeyData KeysData_95;
		public ImGuiKeyData KeysData_96;
		public ImGuiKeyData KeysData_97;
		public ImGuiKeyData KeysData_98;
		public ImGuiKeyData KeysData_99;
		public ImGuiKeyData KeysData_100;
		public ImGuiKeyData KeysData_101;
		public ImGuiKeyData KeysData_102;
		public ImGuiKeyData KeysData_103;
		public ImGuiKeyData KeysData_104;
		public ImGuiKeyData KeysData_105;
		public ImGuiKeyData KeysData_106;
		public ImGuiKeyData KeysData_107;
		public ImGuiKeyData KeysData_108;
		public ImGuiKeyData KeysData_109;
		public ImGuiKeyData KeysData_110;
		public ImGuiKeyData KeysData_111;
		public ImGuiKeyData KeysData_112;
		public ImGuiKeyData KeysData_113;
		public ImGuiKeyData KeysData_114;
		public ImGuiKeyData KeysData_115;
		public ImGuiKeyData KeysData_116;
		public ImGuiKeyData KeysData_117;
		public ImGuiKeyData KeysData_118;
		public ImGuiKeyData KeysData_119;
		public ImGuiKeyData KeysData_120;
		public ImGuiKeyData KeysData_121;
		public ImGuiKeyData KeysData_122;
		public ImGuiKeyData KeysData_123;
		public ImGuiKeyData KeysData_124;
		public ImGuiKeyData KeysData_125;
		public ImGuiKeyData KeysData_126;
		public ImGuiKeyData KeysData_127;
		public ImGuiKeyData KeysData_128;
		public ImGuiKeyData KeysData_129;
		public ImGuiKeyData KeysData_130;
		public ImGuiKeyData KeysData_131;
		public ImGuiKeyData KeysData_132;
		public ImGuiKeyData KeysData_133;
		public ImGuiKeyData KeysData_134;
		public ImGuiKeyData KeysData_135;
		public ImGuiKeyData KeysData_136;
		public ImGuiKeyData KeysData_137;
		public ImGuiKeyData KeysData_138;
		public ImGuiKeyData KeysData_139;
		public ImGuiKeyData KeysData_140;
		public ImGuiKeyData KeysData_141;
		public ImGuiKeyData KeysData_142;
		public ImGuiKeyData KeysData_143;
		public ImGuiKeyData KeysData_144;
		public ImGuiKeyData KeysData_145;
		public ImGuiKeyData KeysData_146;
		public ImGuiKeyData KeysData_147;
		public ImGuiKeyData KeysData_148;
		public ImGuiKeyData KeysData_149;
		public ImGuiKeyData KeysData_150;
		public ImGuiKeyData KeysData_151;
		public ImGuiKeyData KeysData_152;
		public ImGuiKeyData KeysData_153;
		public ImGuiKeyData KeysData_154;
		public ImGuiKeyData KeysData_155;
		public ImGuiKeyData KeysData_156;
		public ImGuiKeyData KeysData_157;
		public ImGuiKeyData KeysData_158;
		public ImGuiKeyData KeysData_159;
		public ImGuiKeyData KeysData_160;
		public ImGuiKeyData KeysData_161;
		public ImGuiKeyData KeysData_162;
		public ImGuiKeyData KeysData_163;
		public ImGuiKeyData KeysData_164;
		public ImGuiKeyData KeysData_165;
		public ImGuiKeyData KeysData_166;
		public ImGuiKeyData KeysData_167;
		public ImGuiKeyData KeysData_168;
		public ImGuiKeyData KeysData_169;
		public ImGuiKeyData KeysData_170;
		public ImGuiKeyData KeysData_171;
		public ImGuiKeyData KeysData_172;
		public ImGuiKeyData KeysData_173;
		public ImGuiKeyData KeysData_174;
		public ImGuiKeyData KeysData_175;
		public ImGuiKeyData KeysData_176;
		public ImGuiKeyData KeysData_177;
		public ImGuiKeyData KeysData_178;
		public ImGuiKeyData KeysData_179;
		public ImGuiKeyData KeysData_180;
		public ImGuiKeyData KeysData_181;
		public ImGuiKeyData KeysData_182;
		public ImGuiKeyData KeysData_183;
		public ImGuiKeyData KeysData_184;
		public ImGuiKeyData KeysData_185;
		public ImGuiKeyData KeysData_186;
		public ImGuiKeyData KeysData_187;
		public ImGuiKeyData KeysData_188;
		public ImGuiKeyData KeysData_189;
		public ImGuiKeyData KeysData_190;
		public ImGuiKeyData KeysData_191;
		public ImGuiKeyData KeysData_192;
		public ImGuiKeyData KeysData_193;
		public ImGuiKeyData KeysData_194;
		public ImGuiKeyData KeysData_195;
		public ImGuiKeyData KeysData_196;
		public ImGuiKeyData KeysData_197;
		public ImGuiKeyData KeysData_198;
		public ImGuiKeyData KeysData_199;
		public ImGuiKeyData KeysData_200;
		public ImGuiKeyData KeysData_201;
		public ImGuiKeyData KeysData_202;
		public ImGuiKeyData KeysData_203;
		public ImGuiKeyData KeysData_204;
		public ImGuiKeyData KeysData_205;
		public ImGuiKeyData KeysData_206;
		public ImGuiKeyData KeysData_207;
		public ImGuiKeyData KeysData_208;
		public ImGuiKeyData KeysData_209;
		public ImGuiKeyData KeysData_210;
		public ImGuiKeyData KeysData_211;
		public ImGuiKeyData KeysData_212;
		public ImGuiKeyData KeysData_213;
		public ImGuiKeyData KeysData_214;
		public ImGuiKeyData KeysData_215;
		public ImGuiKeyData KeysData_216;
		public ImGuiKeyData KeysData_217;
		public ImGuiKeyData KeysData_218;
		public ImGuiKeyData KeysData_219;
		public ImGuiKeyData KeysData_220;
		public ImGuiKeyData KeysData_221;
		public ImGuiKeyData KeysData_222;
		public ImGuiKeyData KeysData_223;
		public ImGuiKeyData KeysData_224;
		public ImGuiKeyData KeysData_225;
		public ImGuiKeyData KeysData_226;
		public ImGuiKeyData KeysData_227;
		public ImGuiKeyData KeysData_228;
		public ImGuiKeyData KeysData_229;
		public ImGuiKeyData KeysData_230;
		public ImGuiKeyData KeysData_231;
		public ImGuiKeyData KeysData_232;
		public ImGuiKeyData KeysData_233;
		public ImGuiKeyData KeysData_234;
		public ImGuiKeyData KeysData_235;
		public ImGuiKeyData KeysData_236;
		public ImGuiKeyData KeysData_237;
		public ImGuiKeyData KeysData_238;
		public ImGuiKeyData KeysData_239;
		public ImGuiKeyData KeysData_240;
		public ImGuiKeyData KeysData_241;
		public ImGuiKeyData KeysData_242;
		public ImGuiKeyData KeysData_243;
		public ImGuiKeyData KeysData_244;
		public ImGuiKeyData KeysData_245;
		public ImGuiKeyData KeysData_246;
		public ImGuiKeyData KeysData_247;
		public ImGuiKeyData KeysData_248;
		public ImGuiKeyData KeysData_249;
		public ImGuiKeyData KeysData_250;
		public ImGuiKeyData KeysData_251;
		public ImGuiKeyData KeysData_252;
		public ImGuiKeyData KeysData_253;
		public ImGuiKeyData KeysData_254;
		public ImGuiKeyData KeysData_255;
		public ImGuiKeyData KeysData_256;
		public ImGuiKeyData KeysData_257;
		public ImGuiKeyData KeysData_258;
		public ImGuiKeyData KeysData_259;
		public ImGuiKeyData KeysData_260;
		public ImGuiKeyData KeysData_261;
		public ImGuiKeyData KeysData_262;
		public ImGuiKeyData KeysData_263;
		public ImGuiKeyData KeysData_264;
		public ImGuiKeyData KeysData_265;
		public ImGuiKeyData KeysData_266;
		public ImGuiKeyData KeysData_267;
		public ImGuiKeyData KeysData_268;
		public ImGuiKeyData KeysData_269;
		public ImGuiKeyData KeysData_270;
		public ImGuiKeyData KeysData_271;
		public ImGuiKeyData KeysData_272;
		public ImGuiKeyData KeysData_273;
		public ImGuiKeyData KeysData_274;
		public ImGuiKeyData KeysData_275;
		public ImGuiKeyData KeysData_276;
		public ImGuiKeyData KeysData_277;
		public ImGuiKeyData KeysData_278;
		public ImGuiKeyData KeysData_279;
		public ImGuiKeyData KeysData_280;
		public ImGuiKeyData KeysData_281;
		public ImGuiKeyData KeysData_282;
		public ImGuiKeyData KeysData_283;
		public ImGuiKeyData KeysData_284;
		public ImGuiKeyData KeysData_285;
		public ImGuiKeyData KeysData_286;
		public ImGuiKeyData KeysData_287;
		public ImGuiKeyData KeysData_288;
		public ImGuiKeyData KeysData_289;
		public ImGuiKeyData KeysData_290;
		public ImGuiKeyData KeysData_291;
		public ImGuiKeyData KeysData_292;
		public ImGuiKeyData KeysData_293;
		public ImGuiKeyData KeysData_294;
		public ImGuiKeyData KeysData_295;
		public ImGuiKeyData KeysData_296;
		public ImGuiKeyData KeysData_297;
		public ImGuiKeyData KeysData_298;
		public ImGuiKeyData KeysData_299;
		public ImGuiKeyData KeysData_300;
		public ImGuiKeyData KeysData_301;
		public ImGuiKeyData KeysData_302;
		public ImGuiKeyData KeysData_303;
		public ImGuiKeyData KeysData_304;
		public ImGuiKeyData KeysData_305;
		public ImGuiKeyData KeysData_306;
		public ImGuiKeyData KeysData_307;
		public ImGuiKeyData KeysData_308;
		public ImGuiKeyData KeysData_309;
		public ImGuiKeyData KeysData_310;
		public ImGuiKeyData KeysData_311;
		public ImGuiKeyData KeysData_312;
		public ImGuiKeyData KeysData_313;
		public ImGuiKeyData KeysData_314;
		public ImGuiKeyData KeysData_315;
		public ImGuiKeyData KeysData_316;
		public ImGuiKeyData KeysData_317;
		public ImGuiKeyData KeysData_318;
		public ImGuiKeyData KeysData_319;
		public ImGuiKeyData KeysData_320;
		public ImGuiKeyData KeysData_321;
		public ImGuiKeyData KeysData_322;
		public ImGuiKeyData KeysData_323;
		public ImGuiKeyData KeysData_324;
		public ImGuiKeyData KeysData_325;
		public ImGuiKeyData KeysData_326;
		public ImGuiKeyData KeysData_327;
		public ImGuiKeyData KeysData_328;
		public ImGuiKeyData KeysData_329;
		public ImGuiKeyData KeysData_330;
		public ImGuiKeyData KeysData_331;
		public ImGuiKeyData KeysData_332;
		public ImGuiKeyData KeysData_333;
		public ImGuiKeyData KeysData_334;
		public ImGuiKeyData KeysData_335;
		public ImGuiKeyData KeysData_336;
		public ImGuiKeyData KeysData_337;
		public ImGuiKeyData KeysData_338;
		public ImGuiKeyData KeysData_339;
		public ImGuiKeyData KeysData_340;
		public ImGuiKeyData KeysData_341;
		public ImGuiKeyData KeysData_342;
		public ImGuiKeyData KeysData_343;
		public ImGuiKeyData KeysData_344;
		public ImGuiKeyData KeysData_345;
		public ImGuiKeyData KeysData_346;
		public ImGuiKeyData KeysData_347;
		public ImGuiKeyData KeysData_348;
		public ImGuiKeyData KeysData_349;
		public ImGuiKeyData KeysData_350;
		public ImGuiKeyData KeysData_351;
		public ImGuiKeyData KeysData_352;
		public ImGuiKeyData KeysData_353;
		public ImGuiKeyData KeysData_354;
		public ImGuiKeyData KeysData_355;
		public ImGuiKeyData KeysData_356;
		public ImGuiKeyData KeysData_357;
		public ImGuiKeyData KeysData_358;
		public ImGuiKeyData KeysData_359;
		public ImGuiKeyData KeysData_360;
		public ImGuiKeyData KeysData_361;
		public ImGuiKeyData KeysData_362;
		public ImGuiKeyData KeysData_363;
		public ImGuiKeyData KeysData_364;
		public ImGuiKeyData KeysData_365;
		public ImGuiKeyData KeysData_366;
		public ImGuiKeyData KeysData_367;
		public ImGuiKeyData KeysData_368;
		public ImGuiKeyData KeysData_369;
		public ImGuiKeyData KeysData_370;
		public ImGuiKeyData KeysData_371;
		public ImGuiKeyData KeysData_372;
		public ImGuiKeyData KeysData_373;
		public ImGuiKeyData KeysData_374;
		public ImGuiKeyData KeysData_375;
		public ImGuiKeyData KeysData_376;
		public ImGuiKeyData KeysData_377;
		public ImGuiKeyData KeysData_378;
		public ImGuiKeyData KeysData_379;
		public ImGuiKeyData KeysData_380;
		public ImGuiKeyData KeysData_381;
		public ImGuiKeyData KeysData_382;
		public ImGuiKeyData KeysData_383;
		public ImGuiKeyData KeysData_384;
		public ImGuiKeyData KeysData_385;
		public ImGuiKeyData KeysData_386;
		public ImGuiKeyData KeysData_387;
		public ImGuiKeyData KeysData_388;
		public ImGuiKeyData KeysData_389;
		public ImGuiKeyData KeysData_390;
		public ImGuiKeyData KeysData_391;
		public ImGuiKeyData KeysData_392;
		public ImGuiKeyData KeysData_393;
		public ImGuiKeyData KeysData_394;
		public ImGuiKeyData KeysData_395;
		public ImGuiKeyData KeysData_396;
		public ImGuiKeyData KeysData_397;
		public ImGuiKeyData KeysData_398;
		public ImGuiKeyData KeysData_399;
		public ImGuiKeyData KeysData_400;
		public ImGuiKeyData KeysData_401;
		public ImGuiKeyData KeysData_402;
		public ImGuiKeyData KeysData_403;
		public ImGuiKeyData KeysData_404;
		public ImGuiKeyData KeysData_405;
		public ImGuiKeyData KeysData_406;
		public ImGuiKeyData KeysData_407;
		public ImGuiKeyData KeysData_408;
		public ImGuiKeyData KeysData_409;
		public ImGuiKeyData KeysData_410;
		public ImGuiKeyData KeysData_411;
		public ImGuiKeyData KeysData_412;
		public ImGuiKeyData KeysData_413;
		public ImGuiKeyData KeysData_414;
		public ImGuiKeyData KeysData_415;
		public ImGuiKeyData KeysData_416;
		public ImGuiKeyData KeysData_417;
		public ImGuiKeyData KeysData_418;
		public ImGuiKeyData KeysData_419;
		public ImGuiKeyData KeysData_420;
		public ImGuiKeyData KeysData_421;
		public ImGuiKeyData KeysData_422;
		public ImGuiKeyData KeysData_423;
		public ImGuiKeyData KeysData_424;
		public ImGuiKeyData KeysData_425;
		public ImGuiKeyData KeysData_426;
		public ImGuiKeyData KeysData_427;
		public ImGuiKeyData KeysData_428;
		public ImGuiKeyData KeysData_429;
		public ImGuiKeyData KeysData_430;
		public ImGuiKeyData KeysData_431;
		public ImGuiKeyData KeysData_432;
		public ImGuiKeyData KeysData_433;
		public ImGuiKeyData KeysData_434;
		public ImGuiKeyData KeysData_435;
		public ImGuiKeyData KeysData_436;
		public ImGuiKeyData KeysData_437;
		public ImGuiKeyData KeysData_438;
		public ImGuiKeyData KeysData_439;
		public ImGuiKeyData KeysData_440;
		public ImGuiKeyData KeysData_441;
		public ImGuiKeyData KeysData_442;
		public ImGuiKeyData KeysData_443;
		public ImGuiKeyData KeysData_444;
		public ImGuiKeyData KeysData_445;
		public ImGuiKeyData KeysData_446;
		public ImGuiKeyData KeysData_447;
		public ImGuiKeyData KeysData_448;
		public ImGuiKeyData KeysData_449;
		public ImGuiKeyData KeysData_450;
		public ImGuiKeyData KeysData_451;
		public ImGuiKeyData KeysData_452;
		public ImGuiKeyData KeysData_453;
		public ImGuiKeyData KeysData_454;
		public ImGuiKeyData KeysData_455;
		public ImGuiKeyData KeysData_456;
		public ImGuiKeyData KeysData_457;
		public ImGuiKeyData KeysData_458;
		public ImGuiKeyData KeysData_459;
		public ImGuiKeyData KeysData_460;
		public ImGuiKeyData KeysData_461;
		public ImGuiKeyData KeysData_462;
		public ImGuiKeyData KeysData_463;
		public ImGuiKeyData KeysData_464;
		public ImGuiKeyData KeysData_465;
		public ImGuiKeyData KeysData_466;
		public ImGuiKeyData KeysData_467;
		public ImGuiKeyData KeysData_468;
		public ImGuiKeyData KeysData_469;
		public ImGuiKeyData KeysData_470;
		public ImGuiKeyData KeysData_471;
		public ImGuiKeyData KeysData_472;
		public ImGuiKeyData KeysData_473;
		public ImGuiKeyData KeysData_474;
		public ImGuiKeyData KeysData_475;
		public ImGuiKeyData KeysData_476;
		public ImGuiKeyData KeysData_477;
		public ImGuiKeyData KeysData_478;
		public ImGuiKeyData KeysData_479;
		public ImGuiKeyData KeysData_480;
		public ImGuiKeyData KeysData_481;
		public ImGuiKeyData KeysData_482;
		public ImGuiKeyData KeysData_483;
		public ImGuiKeyData KeysData_484;
		public ImGuiKeyData KeysData_485;
		public ImGuiKeyData KeysData_486;
		public ImGuiKeyData KeysData_487;
		public ImGuiKeyData KeysData_488;
		public ImGuiKeyData KeysData_489;
		public ImGuiKeyData KeysData_490;
		public ImGuiKeyData KeysData_491;
		public ImGuiKeyData KeysData_492;
		public ImGuiKeyData KeysData_493;
		public ImGuiKeyData KeysData_494;
		public ImGuiKeyData KeysData_495;
		public ImGuiKeyData KeysData_496;
		public ImGuiKeyData KeysData_497;
		public ImGuiKeyData KeysData_498;
		public ImGuiKeyData KeysData_499;
		public ImGuiKeyData KeysData_500;
		public ImGuiKeyData KeysData_501;
		public ImGuiKeyData KeysData_502;
		public ImGuiKeyData KeysData_503;
		public ImGuiKeyData KeysData_504;
		public ImGuiKeyData KeysData_505;
		public ImGuiKeyData KeysData_506;
		public ImGuiKeyData KeysData_507;
		public ImGuiKeyData KeysData_508;
		public ImGuiKeyData KeysData_509;
		public ImGuiKeyData KeysData_510;
		public ImGuiKeyData KeysData_511;
		public ImGuiKeyData KeysData_512;
		public ImGuiKeyData KeysData_513;
		public ImGuiKeyData KeysData_514;
		public ImGuiKeyData KeysData_515;
		public ImGuiKeyData KeysData_516;
		public ImGuiKeyData KeysData_517;
		public ImGuiKeyData KeysData_518;
		public ImGuiKeyData KeysData_519;
		public ImGuiKeyData KeysData_520;
		public ImGuiKeyData KeysData_521;
		public ImGuiKeyData KeysData_522;
		public ImGuiKeyData KeysData_523;
		public ImGuiKeyData KeysData_524;
		public ImGuiKeyData KeysData_525;
		public ImGuiKeyData KeysData_526;
		public ImGuiKeyData KeysData_527;
		public ImGuiKeyData KeysData_528;
		public ImGuiKeyData KeysData_529;
		public ImGuiKeyData KeysData_530;
		public ImGuiKeyData KeysData_531;
		public ImGuiKeyData KeysData_532;
		public ImGuiKeyData KeysData_533;
		public ImGuiKeyData KeysData_534;
		public ImGuiKeyData KeysData_535;
		public ImGuiKeyData KeysData_536;
		public ImGuiKeyData KeysData_537;
		public ImGuiKeyData KeysData_538;
		public ImGuiKeyData KeysData_539;
		public ImGuiKeyData KeysData_540;
		public ImGuiKeyData KeysData_541;
		public ImGuiKeyData KeysData_542;
		public ImGuiKeyData KeysData_543;
		public ImGuiKeyData KeysData_544;
		public ImGuiKeyData KeysData_545;
		public ImGuiKeyData KeysData_546;
		public ImGuiKeyData KeysData_547;
		public ImGuiKeyData KeysData_548;
		public ImGuiKeyData KeysData_549;
		public ImGuiKeyData KeysData_550;
		public ImGuiKeyData KeysData_551;
		public ImGuiKeyData KeysData_552;
		public ImGuiKeyData KeysData_553;
		public ImGuiKeyData KeysData_554;
		public ImGuiKeyData KeysData_555;
		public ImGuiKeyData KeysData_556;
		public ImGuiKeyData KeysData_557;
		public ImGuiKeyData KeysData_558;
		public ImGuiKeyData KeysData_559;
		public ImGuiKeyData KeysData_560;
		public ImGuiKeyData KeysData_561;
		public ImGuiKeyData KeysData_562;
		public ImGuiKeyData KeysData_563;
		public ImGuiKeyData KeysData_564;
		public ImGuiKeyData KeysData_565;
		public ImGuiKeyData KeysData_566;
		public ImGuiKeyData KeysData_567;
		public ImGuiKeyData KeysData_568;
		public ImGuiKeyData KeysData_569;
		public ImGuiKeyData KeysData_570;
		public ImGuiKeyData KeysData_571;
		public ImGuiKeyData KeysData_572;
		public ImGuiKeyData KeysData_573;
		public ImGuiKeyData KeysData_574;
		public ImGuiKeyData KeysData_575;
		public ImGuiKeyData KeysData_576;
		public ImGuiKeyData KeysData_577;
		public ImGuiKeyData KeysData_578;
		public ImGuiKeyData KeysData_579;
		public ImGuiKeyData KeysData_580;
		public ImGuiKeyData KeysData_581;
		public ImGuiKeyData KeysData_582;
		public ImGuiKeyData KeysData_583;
		public ImGuiKeyData KeysData_584;
		public ImGuiKeyData KeysData_585;
		public ImGuiKeyData KeysData_586;
		public ImGuiKeyData KeysData_587;
		public ImGuiKeyData KeysData_588;
		public ImGuiKeyData KeysData_589;
		public ImGuiKeyData KeysData_590;
		public ImGuiKeyData KeysData_591;
		public ImGuiKeyData KeysData_592;
		public ImGuiKeyData KeysData_593;
		public ImGuiKeyData KeysData_594;
		public ImGuiKeyData KeysData_595;
		public ImGuiKeyData KeysData_596;
		public ImGuiKeyData KeysData_597;
		public ImGuiKeyData KeysData_598;
		public ImGuiKeyData KeysData_599;
		public ImGuiKeyData KeysData_600;
		public ImGuiKeyData KeysData_601;
		public ImGuiKeyData KeysData_602;
		public ImGuiKeyData KeysData_603;
		public ImGuiKeyData KeysData_604;
		public ImGuiKeyData KeysData_605;
		public ImGuiKeyData KeysData_606;
		public ImGuiKeyData KeysData_607;
		public ImGuiKeyData KeysData_608;
		public ImGuiKeyData KeysData_609;
		public ImGuiKeyData KeysData_610;
		public ImGuiKeyData KeysData_611;
		public ImGuiKeyData KeysData_612;
		public ImGuiKeyData KeysData_613;
		public ImGuiKeyData KeysData_614;
		public ImGuiKeyData KeysData_615;
		public ImGuiKeyData KeysData_616;
		public ImGuiKeyData KeysData_617;
		public ImGuiKeyData KeysData_618;
		public ImGuiKeyData KeysData_619;
		public ImGuiKeyData KeysData_620;
		public ImGuiKeyData KeysData_621;
		public ImGuiKeyData KeysData_622;
		public ImGuiKeyData KeysData_623;
		public ImGuiKeyData KeysData_624;
		public ImGuiKeyData KeysData_625;
		public ImGuiKeyData KeysData_626;
		public ImGuiKeyData KeysData_627;
		public ImGuiKeyData KeysData_628;
		public ImGuiKeyData KeysData_629;
		public ImGuiKeyData KeysData_630;
		public ImGuiKeyData KeysData_631;
		public ImGuiKeyData KeysData_632;
		public ImGuiKeyData KeysData_633;
		public ImGuiKeyData KeysData_634;
		public ImGuiKeyData KeysData_635;
		public ImGuiKeyData KeysData_636;
		public ImGuiKeyData KeysData_637;
		public ImGuiKeyData KeysData_638;
		public ImGuiKeyData KeysData_639;
		public ImGuiKeyData KeysData_640;
		public ImGuiKeyData KeysData_641;
		public ImGuiKeyData KeysData_642;
		public ImGuiKeyData KeysData_643;
		public ImGuiKeyData KeysData_644;
		public ImGuiKeyData KeysData_645;
		public ImGuiKeyData KeysData_646;
		public ImGuiKeyData KeysData_647;
		public ImGuiKeyData KeysData_648;
		public ImGuiKeyData KeysData_649;
		public ImGuiKeyData KeysData_650;
		public ImGuiKeyData KeysData_651;
		public ImGuiKeyData KeysData_652;
		public ImGuiKeyData KeysData_653;
		public ImGuiKeyData KeysData_654;
		public ImGuiKeyData KeysData_655;
		public ImGuiKeyData KeysData_656;
		public ImGuiKeyData KeysData_657;
		public ImGuiKeyData KeysData_658;
		public ImGuiKeyData KeysData_659;
		public ImGuiKeyData KeysData_660;
		public ImGuiKeyData KeysData_661;
		public ImGuiKeyData KeysData_662;
		public ImGuiKeyData KeysData_663;
		public ImGuiKeyData KeysData_664;
		public ImGuiKeyData KeysData_665;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantCaptureMouseUnlessPopupClose;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MousePosPrev;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MouseClickedPos_0;
		public Vector2 MouseClickedPos_1;
		public Vector2 MouseClickedPos_2;
		public Vector2 MouseClickedPos_3;
		public Vector2 MouseClickedPos_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public double MouseClickedTime_0;
		public double MouseClickedTime_1;
		public double MouseClickedTime_2;
		public double MouseClickedTime_3;
		public double MouseClickedTime_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public bool MouseClicked_0;
		public bool MouseClicked_1;
		public bool MouseClicked_2;
		public bool MouseClicked_3;
		public bool MouseClicked_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public bool MouseDoubleClicked_0;
		public bool MouseDoubleClicked_1;
		public bool MouseDoubleClicked_2;
		public bool MouseDoubleClicked_3;
		public bool MouseDoubleClicked_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort MouseClickedCount_0;
		public ushort MouseClickedCount_1;
		public ushort MouseClickedCount_2;
		public ushort MouseClickedCount_3;
		public ushort MouseClickedCount_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort MouseClickedLastCount_0;
		public ushort MouseClickedLastCount_1;
		public ushort MouseClickedLastCount_2;
		public ushort MouseClickedLastCount_3;
		public ushort MouseClickedLastCount_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public bool MouseReleased_0;
		public bool MouseReleased_1;
		public bool MouseReleased_2;
		public bool MouseReleased_3;
		public bool MouseReleased_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public bool MouseDownOwned_0;
		public bool MouseDownOwned_1;
		public bool MouseDownOwned_2;
		public bool MouseDownOwned_3;
		public bool MouseDownOwned_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public bool MouseDownOwnedUnlessPopupClose_0;
		public bool MouseDownOwnedUnlessPopupClose_1;
		public bool MouseDownOwnedUnlessPopupClose_2;
		public bool MouseDownOwnedUnlessPopupClose_3;
		public bool MouseDownOwnedUnlessPopupClose_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte MouseWheelRequestAxisSwap;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseDownDuration_0;
		public float MouseDownDuration_1;
		public float MouseDownDuration_2;
		public float MouseDownDuration_3;
		public float MouseDownDuration_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseDownDurationPrev_0;
		public float MouseDownDurationPrev_1;
		public float MouseDownDurationPrev_2;
		public float MouseDownDurationPrev_3;
		public float MouseDownDurationPrev_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MouseDragMaxDistanceAbs_0;
		public Vector2 MouseDragMaxDistanceAbs_1;
		public Vector2 MouseDragMaxDistanceAbs_2;
		public Vector2 MouseDragMaxDistanceAbs_3;
		public Vector2 MouseDragMaxDistanceAbs_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseDragMaxDistanceSqr_0;
		public float MouseDragMaxDistanceSqr_1;
		public float MouseDragMaxDistanceSqr_2;
		public float MouseDragMaxDistanceSqr_3;
		public float MouseDragMaxDistanceSqr_4;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PenPressure;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AppFocusLost;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AppAcceptingEvents;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BackendUsingLegacyKeyArrays;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BackendUsingLegacyNavInputArray;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort InputQueueSurrogate;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImWchar InputQueueCharacters;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiIO(int configFlags = default, int backendFlags = default, Vector2 displaySize = default, float deltaTime = default, float iniSavingRate = default, byte* iniFilename = default, byte* logFilename = default, void* userData = default, ImFontAtlas* fonts = default, float fontGlobalScale = default, bool fontAllowUserScaling = default, ImFont* fontDefault = default, Vector2 displayFramebufferScale = default, bool configDockingNoSplit = default, bool configDockingWithShift = default, bool configDockingAlwaysTabBar = default, bool configDockingTransparentPayload = default, bool configViewportsNoAutoMerge = default, bool configViewportsNoTaskBarIcon = default, bool configViewportsNoDecoration = default, bool configViewportsNoDefaultParent = default, bool mouseDrawCursor = default, bool configMacOsxBehaviors = default, bool configInputTrickleEventQueue = default, bool configInputTextCursorBlink = default, bool configInputTextEnterKeepActive = default, bool configDragClickToInputText = default, bool configWindowsResizeFromEdges = default, bool configWindowsMoveFromTitleBarOnly = default, float configMemoryCompactTimer = default, float mouseDoubleClickTime = default, float mouseDoubleClickMaxDist = default, float mouseDragThreshold = default, float keyRepeatDelay = default, float keyRepeatRate = default, bool configDebugBeginReturnValueOnce = default, bool configDebugBeginReturnValueLoop = default, bool configDebugIgnoreFocusLoss = default, bool configDebugIniSettings = default, byte* backendPlatformName = default, byte* backendRendererName = default, void* backendPlatformUserData = default, void* backendRendererUserData = default, void* backendLanguageUserData = default, delegate*<void*, byte*> getClipboardTextFn = default, delegate*<void*, byte*, void> setClipboardTextFn = default, void* clipboardUserData = default, delegate*<ImGuiViewport*, ImGuiPlatformImeData*, void> setPlatformImeDataFn = default, char platformLocaleDecimalPoint = default, bool wantCaptureMouse = default, bool wantCaptureKeyboard = default, bool wantTextInput = default, bool wantSetMousePos = default, bool wantSaveIniSettings = default, bool navActive = default, bool navVisible = default, float framerate = default, int metricsRenderVertices = default, int metricsRenderIndices = default, int metricsRenderWindows = default, int metricsActiveWindows = default, Vector2 mouseDelta = default, int* keyMap = default, bool* keysDown = default, float* navInputs = default, void* Unusedpadding = default, ImGuiContext* ctx = default, Vector2 mousePos = default, bool* mouseDown = default, float mouseWheel = default, float mouseWheelH = default, ImGuiMouseSource mouseSource = default, uint mouseHoveredViewport = default, bool keyCtrl = default, bool keyShift = default, bool keyAlt = default, bool keySuper = default, int keyMods = default, ImGuiKeyData* keysData = default, bool wantCaptureMouseUnlessPopupClose = default, Vector2 mousePosPrev = default, Vector2* mouseClickedPos = default, double* mouseClickedTime = default, bool* mouseClicked = default, bool* mouseDoubleClicked = default, ushort* mouseClickedCount = default, ushort* mouseClickedLastCount = default, bool* mouseReleased = default, bool* mouseDownOwned = default, bool* mouseDownOwnedUnlessPopupClose = default, bool mouseWheelRequestAxisSwap = default, float* mouseDownDuration = default, float* mouseDownDurationPrev = default, Vector2* mouseDragMaxDistanceAbs = default, float* mouseDragMaxDistanceSqr = default, float penPressure = default, bool appFocusLost = default, bool appAcceptingEvents = default, byte backendUsingLegacyKeyArrays = default, bool backendUsingLegacyNavInputArray = default, ushort inputQueueSurrogate = default, ImVectorImWchar inputQueueCharacters = default)
		{
			ConfigFlags = configFlags;
			BackendFlags = backendFlags;
			DisplaySize = displaySize;
			DeltaTime = deltaTime;
			IniSavingRate = iniSavingRate;
			IniFilename = iniFilename;
			LogFilename = logFilename;
			UserData = userData;
			Fonts = fonts;
			FontGlobalScale = fontGlobalScale;
			FontAllowUserScaling = fontAllowUserScaling ? (byte)1 : (byte)0;
			FontDefault = fontDefault;
			DisplayFramebufferScale = displayFramebufferScale;
			ConfigDockingNoSplit = configDockingNoSplit ? (byte)1 : (byte)0;
			ConfigDockingWithShift = configDockingWithShift ? (byte)1 : (byte)0;
			ConfigDockingAlwaysTabBar = configDockingAlwaysTabBar ? (byte)1 : (byte)0;
			ConfigDockingTransparentPayload = configDockingTransparentPayload ? (byte)1 : (byte)0;
			ConfigViewportsNoAutoMerge = configViewportsNoAutoMerge ? (byte)1 : (byte)0;
			ConfigViewportsNoTaskBarIcon = configViewportsNoTaskBarIcon ? (byte)1 : (byte)0;
			ConfigViewportsNoDecoration = configViewportsNoDecoration ? (byte)1 : (byte)0;
			ConfigViewportsNoDefaultParent = configViewportsNoDefaultParent ? (byte)1 : (byte)0;
			MouseDrawCursor = mouseDrawCursor ? (byte)1 : (byte)0;
			ConfigMacOSXBehaviors = configMacOsxBehaviors ? (byte)1 : (byte)0;
			ConfigInputTrickleEventQueue = configInputTrickleEventQueue ? (byte)1 : (byte)0;
			ConfigInputTextCursorBlink = configInputTextCursorBlink ? (byte)1 : (byte)0;
			ConfigInputTextEnterKeepActive = configInputTextEnterKeepActive ? (byte)1 : (byte)0;
			ConfigDragClickToInputText = configDragClickToInputText ? (byte)1 : (byte)0;
			ConfigWindowsResizeFromEdges = configWindowsResizeFromEdges ? (byte)1 : (byte)0;
			ConfigWindowsMoveFromTitleBarOnly = configWindowsMoveFromTitleBarOnly ? (byte)1 : (byte)0;
			ConfigMemoryCompactTimer = configMemoryCompactTimer;
			MouseDoubleClickTime = mouseDoubleClickTime;
			MouseDoubleClickMaxDist = mouseDoubleClickMaxDist;
			MouseDragThreshold = mouseDragThreshold;
			KeyRepeatDelay = keyRepeatDelay;
			KeyRepeatRate = keyRepeatRate;
			ConfigDebugBeginReturnValueOnce = configDebugBeginReturnValueOnce ? (byte)1 : (byte)0;
			ConfigDebugBeginReturnValueLoop = configDebugBeginReturnValueLoop ? (byte)1 : (byte)0;
			ConfigDebugIgnoreFocusLoss = configDebugIgnoreFocusLoss ? (byte)1 : (byte)0;
			ConfigDebugIniSettings = configDebugIniSettings ? (byte)1 : (byte)0;
			BackendPlatformName = backendPlatformName;
			BackendRendererName = backendRendererName;
			BackendPlatformUserData = backendPlatformUserData;
			BackendRendererUserData = backendRendererUserData;
			BackendLanguageUserData = backendLanguageUserData;
			GetClipboardTextFn = (void*)getClipboardTextFn;
			SetClipboardTextFn = (void*)setClipboardTextFn;
			ClipboardUserData = clipboardUserData;
			SetPlatformImeDataFn = (void*)setPlatformImeDataFn;
			PlatformLocaleDecimalPoint = platformLocaleDecimalPoint;
			WantCaptureMouse = wantCaptureMouse ? (byte)1 : (byte)0;
			WantCaptureKeyboard = wantCaptureKeyboard ? (byte)1 : (byte)0;
			WantTextInput = wantTextInput ? (byte)1 : (byte)0;
			WantSetMousePos = wantSetMousePos ? (byte)1 : (byte)0;
			WantSaveIniSettings = wantSaveIniSettings ? (byte)1 : (byte)0;
			NavActive = navActive ? (byte)1 : (byte)0;
			NavVisible = navVisible ? (byte)1 : (byte)0;
			Framerate = framerate;
			MetricsRenderVertices = metricsRenderVertices;
			MetricsRenderIndices = metricsRenderIndices;
			MetricsRenderWindows = metricsRenderWindows;
			MetricsActiveWindows = metricsActiveWindows;
			MouseDelta = mouseDelta;
			if (keyMap != default)
			{
				KeyMap_0 = keyMap[0];
				KeyMap_1 = keyMap[1];
				KeyMap_2 = keyMap[2];
				KeyMap_3 = keyMap[3];
				KeyMap_4 = keyMap[4];
				KeyMap_5 = keyMap[5];
				KeyMap_6 = keyMap[6];
				KeyMap_7 = keyMap[7];
				KeyMap_8 = keyMap[8];
				KeyMap_9 = keyMap[9];
				KeyMap_10 = keyMap[10];
				KeyMap_11 = keyMap[11];
				KeyMap_12 = keyMap[12];
				KeyMap_13 = keyMap[13];
				KeyMap_14 = keyMap[14];
				KeyMap_15 = keyMap[15];
				KeyMap_16 = keyMap[16];
				KeyMap_17 = keyMap[17];
				KeyMap_18 = keyMap[18];
				KeyMap_19 = keyMap[19];
				KeyMap_20 = keyMap[20];
				KeyMap_21 = keyMap[21];
				KeyMap_22 = keyMap[22];
				KeyMap_23 = keyMap[23];
				KeyMap_24 = keyMap[24];
				KeyMap_25 = keyMap[25];
				KeyMap_26 = keyMap[26];
				KeyMap_27 = keyMap[27];
				KeyMap_28 = keyMap[28];
				KeyMap_29 = keyMap[29];
				KeyMap_30 = keyMap[30];
				KeyMap_31 = keyMap[31];
				KeyMap_32 = keyMap[32];
				KeyMap_33 = keyMap[33];
				KeyMap_34 = keyMap[34];
				KeyMap_35 = keyMap[35];
				KeyMap_36 = keyMap[36];
				KeyMap_37 = keyMap[37];
				KeyMap_38 = keyMap[38];
				KeyMap_39 = keyMap[39];
				KeyMap_40 = keyMap[40];
				KeyMap_41 = keyMap[41];
				KeyMap_42 = keyMap[42];
				KeyMap_43 = keyMap[43];
				KeyMap_44 = keyMap[44];
				KeyMap_45 = keyMap[45];
				KeyMap_46 = keyMap[46];
				KeyMap_47 = keyMap[47];
				KeyMap_48 = keyMap[48];
				KeyMap_49 = keyMap[49];
				KeyMap_50 = keyMap[50];
				KeyMap_51 = keyMap[51];
				KeyMap_52 = keyMap[52];
				KeyMap_53 = keyMap[53];
				KeyMap_54 = keyMap[54];
				KeyMap_55 = keyMap[55];
				KeyMap_56 = keyMap[56];
				KeyMap_57 = keyMap[57];
				KeyMap_58 = keyMap[58];
				KeyMap_59 = keyMap[59];
				KeyMap_60 = keyMap[60];
				KeyMap_61 = keyMap[61];
				KeyMap_62 = keyMap[62];
				KeyMap_63 = keyMap[63];
				KeyMap_64 = keyMap[64];
				KeyMap_65 = keyMap[65];
				KeyMap_66 = keyMap[66];
				KeyMap_67 = keyMap[67];
				KeyMap_68 = keyMap[68];
				KeyMap_69 = keyMap[69];
				KeyMap_70 = keyMap[70];
				KeyMap_71 = keyMap[71];
				KeyMap_72 = keyMap[72];
				KeyMap_73 = keyMap[73];
				KeyMap_74 = keyMap[74];
				KeyMap_75 = keyMap[75];
				KeyMap_76 = keyMap[76];
				KeyMap_77 = keyMap[77];
				KeyMap_78 = keyMap[78];
				KeyMap_79 = keyMap[79];
				KeyMap_80 = keyMap[80];
				KeyMap_81 = keyMap[81];
				KeyMap_82 = keyMap[82];
				KeyMap_83 = keyMap[83];
				KeyMap_84 = keyMap[84];
				KeyMap_85 = keyMap[85];
				KeyMap_86 = keyMap[86];
				KeyMap_87 = keyMap[87];
				KeyMap_88 = keyMap[88];
				KeyMap_89 = keyMap[89];
				KeyMap_90 = keyMap[90];
				KeyMap_91 = keyMap[91];
				KeyMap_92 = keyMap[92];
				KeyMap_93 = keyMap[93];
				KeyMap_94 = keyMap[94];
				KeyMap_95 = keyMap[95];
				KeyMap_96 = keyMap[96];
				KeyMap_97 = keyMap[97];
				KeyMap_98 = keyMap[98];
				KeyMap_99 = keyMap[99];
				KeyMap_100 = keyMap[100];
				KeyMap_101 = keyMap[101];
				KeyMap_102 = keyMap[102];
				KeyMap_103 = keyMap[103];
				KeyMap_104 = keyMap[104];
				KeyMap_105 = keyMap[105];
				KeyMap_106 = keyMap[106];
				KeyMap_107 = keyMap[107];
				KeyMap_108 = keyMap[108];
				KeyMap_109 = keyMap[109];
				KeyMap_110 = keyMap[110];
				KeyMap_111 = keyMap[111];
				KeyMap_112 = keyMap[112];
				KeyMap_113 = keyMap[113];
				KeyMap_114 = keyMap[114];
				KeyMap_115 = keyMap[115];
				KeyMap_116 = keyMap[116];
				KeyMap_117 = keyMap[117];
				KeyMap_118 = keyMap[118];
				KeyMap_119 = keyMap[119];
				KeyMap_120 = keyMap[120];
				KeyMap_121 = keyMap[121];
				KeyMap_122 = keyMap[122];
				KeyMap_123 = keyMap[123];
				KeyMap_124 = keyMap[124];
				KeyMap_125 = keyMap[125];
				KeyMap_126 = keyMap[126];
				KeyMap_127 = keyMap[127];
				KeyMap_128 = keyMap[128];
				KeyMap_129 = keyMap[129];
				KeyMap_130 = keyMap[130];
				KeyMap_131 = keyMap[131];
				KeyMap_132 = keyMap[132];
				KeyMap_133 = keyMap[133];
				KeyMap_134 = keyMap[134];
				KeyMap_135 = keyMap[135];
				KeyMap_136 = keyMap[136];
				KeyMap_137 = keyMap[137];
				KeyMap_138 = keyMap[138];
				KeyMap_139 = keyMap[139];
				KeyMap_140 = keyMap[140];
				KeyMap_141 = keyMap[141];
				KeyMap_142 = keyMap[142];
				KeyMap_143 = keyMap[143];
				KeyMap_144 = keyMap[144];
				KeyMap_145 = keyMap[145];
				KeyMap_146 = keyMap[146];
				KeyMap_147 = keyMap[147];
				KeyMap_148 = keyMap[148];
				KeyMap_149 = keyMap[149];
				KeyMap_150 = keyMap[150];
				KeyMap_151 = keyMap[151];
				KeyMap_152 = keyMap[152];
				KeyMap_153 = keyMap[153];
				KeyMap_154 = keyMap[154];
				KeyMap_155 = keyMap[155];
				KeyMap_156 = keyMap[156];
				KeyMap_157 = keyMap[157];
				KeyMap_158 = keyMap[158];
				KeyMap_159 = keyMap[159];
				KeyMap_160 = keyMap[160];
				KeyMap_161 = keyMap[161];
				KeyMap_162 = keyMap[162];
				KeyMap_163 = keyMap[163];
				KeyMap_164 = keyMap[164];
				KeyMap_165 = keyMap[165];
				KeyMap_166 = keyMap[166];
				KeyMap_167 = keyMap[167];
				KeyMap_168 = keyMap[168];
				KeyMap_169 = keyMap[169];
				KeyMap_170 = keyMap[170];
				KeyMap_171 = keyMap[171];
				KeyMap_172 = keyMap[172];
				KeyMap_173 = keyMap[173];
				KeyMap_174 = keyMap[174];
				KeyMap_175 = keyMap[175];
				KeyMap_176 = keyMap[176];
				KeyMap_177 = keyMap[177];
				KeyMap_178 = keyMap[178];
				KeyMap_179 = keyMap[179];
				KeyMap_180 = keyMap[180];
				KeyMap_181 = keyMap[181];
				KeyMap_182 = keyMap[182];
				KeyMap_183 = keyMap[183];
				KeyMap_184 = keyMap[184];
				KeyMap_185 = keyMap[185];
				KeyMap_186 = keyMap[186];
				KeyMap_187 = keyMap[187];
				KeyMap_188 = keyMap[188];
				KeyMap_189 = keyMap[189];
				KeyMap_190 = keyMap[190];
				KeyMap_191 = keyMap[191];
				KeyMap_192 = keyMap[192];
				KeyMap_193 = keyMap[193];
				KeyMap_194 = keyMap[194];
				KeyMap_195 = keyMap[195];
				KeyMap_196 = keyMap[196];
				KeyMap_197 = keyMap[197];
				KeyMap_198 = keyMap[198];
				KeyMap_199 = keyMap[199];
				KeyMap_200 = keyMap[200];
				KeyMap_201 = keyMap[201];
				KeyMap_202 = keyMap[202];
				KeyMap_203 = keyMap[203];
				KeyMap_204 = keyMap[204];
				KeyMap_205 = keyMap[205];
				KeyMap_206 = keyMap[206];
				KeyMap_207 = keyMap[207];
				KeyMap_208 = keyMap[208];
				KeyMap_209 = keyMap[209];
				KeyMap_210 = keyMap[210];
				KeyMap_211 = keyMap[211];
				KeyMap_212 = keyMap[212];
				KeyMap_213 = keyMap[213];
				KeyMap_214 = keyMap[214];
				KeyMap_215 = keyMap[215];
				KeyMap_216 = keyMap[216];
				KeyMap_217 = keyMap[217];
				KeyMap_218 = keyMap[218];
				KeyMap_219 = keyMap[219];
				KeyMap_220 = keyMap[220];
				KeyMap_221 = keyMap[221];
				KeyMap_222 = keyMap[222];
				KeyMap_223 = keyMap[223];
				KeyMap_224 = keyMap[224];
				KeyMap_225 = keyMap[225];
				KeyMap_226 = keyMap[226];
				KeyMap_227 = keyMap[227];
				KeyMap_228 = keyMap[228];
				KeyMap_229 = keyMap[229];
				KeyMap_230 = keyMap[230];
				KeyMap_231 = keyMap[231];
				KeyMap_232 = keyMap[232];
				KeyMap_233 = keyMap[233];
				KeyMap_234 = keyMap[234];
				KeyMap_235 = keyMap[235];
				KeyMap_236 = keyMap[236];
				KeyMap_237 = keyMap[237];
				KeyMap_238 = keyMap[238];
				KeyMap_239 = keyMap[239];
				KeyMap_240 = keyMap[240];
				KeyMap_241 = keyMap[241];
				KeyMap_242 = keyMap[242];
				KeyMap_243 = keyMap[243];
				KeyMap_244 = keyMap[244];
				KeyMap_245 = keyMap[245];
				KeyMap_246 = keyMap[246];
				KeyMap_247 = keyMap[247];
				KeyMap_248 = keyMap[248];
				KeyMap_249 = keyMap[249];
				KeyMap_250 = keyMap[250];
				KeyMap_251 = keyMap[251];
				KeyMap_252 = keyMap[252];
				KeyMap_253 = keyMap[253];
				KeyMap_254 = keyMap[254];
				KeyMap_255 = keyMap[255];
				KeyMap_256 = keyMap[256];
				KeyMap_257 = keyMap[257];
				KeyMap_258 = keyMap[258];
				KeyMap_259 = keyMap[259];
				KeyMap_260 = keyMap[260];
				KeyMap_261 = keyMap[261];
				KeyMap_262 = keyMap[262];
				KeyMap_263 = keyMap[263];
				KeyMap_264 = keyMap[264];
				KeyMap_265 = keyMap[265];
				KeyMap_266 = keyMap[266];
				KeyMap_267 = keyMap[267];
				KeyMap_268 = keyMap[268];
				KeyMap_269 = keyMap[269];
				KeyMap_270 = keyMap[270];
				KeyMap_271 = keyMap[271];
				KeyMap_272 = keyMap[272];
				KeyMap_273 = keyMap[273];
				KeyMap_274 = keyMap[274];
				KeyMap_275 = keyMap[275];
				KeyMap_276 = keyMap[276];
				KeyMap_277 = keyMap[277];
				KeyMap_278 = keyMap[278];
				KeyMap_279 = keyMap[279];
				KeyMap_280 = keyMap[280];
				KeyMap_281 = keyMap[281];
				KeyMap_282 = keyMap[282];
				KeyMap_283 = keyMap[283];
				KeyMap_284 = keyMap[284];
				KeyMap_285 = keyMap[285];
				KeyMap_286 = keyMap[286];
				KeyMap_287 = keyMap[287];
				KeyMap_288 = keyMap[288];
				KeyMap_289 = keyMap[289];
				KeyMap_290 = keyMap[290];
				KeyMap_291 = keyMap[291];
				KeyMap_292 = keyMap[292];
				KeyMap_293 = keyMap[293];
				KeyMap_294 = keyMap[294];
				KeyMap_295 = keyMap[295];
				KeyMap_296 = keyMap[296];
				KeyMap_297 = keyMap[297];
				KeyMap_298 = keyMap[298];
				KeyMap_299 = keyMap[299];
				KeyMap_300 = keyMap[300];
				KeyMap_301 = keyMap[301];
				KeyMap_302 = keyMap[302];
				KeyMap_303 = keyMap[303];
				KeyMap_304 = keyMap[304];
				KeyMap_305 = keyMap[305];
				KeyMap_306 = keyMap[306];
				KeyMap_307 = keyMap[307];
				KeyMap_308 = keyMap[308];
				KeyMap_309 = keyMap[309];
				KeyMap_310 = keyMap[310];
				KeyMap_311 = keyMap[311];
				KeyMap_312 = keyMap[312];
				KeyMap_313 = keyMap[313];
				KeyMap_314 = keyMap[314];
				KeyMap_315 = keyMap[315];
				KeyMap_316 = keyMap[316];
				KeyMap_317 = keyMap[317];
				KeyMap_318 = keyMap[318];
				KeyMap_319 = keyMap[319];
				KeyMap_320 = keyMap[320];
				KeyMap_321 = keyMap[321];
				KeyMap_322 = keyMap[322];
				KeyMap_323 = keyMap[323];
				KeyMap_324 = keyMap[324];
				KeyMap_325 = keyMap[325];
				KeyMap_326 = keyMap[326];
				KeyMap_327 = keyMap[327];
				KeyMap_328 = keyMap[328];
				KeyMap_329 = keyMap[329];
				KeyMap_330 = keyMap[330];
				KeyMap_331 = keyMap[331];
				KeyMap_332 = keyMap[332];
				KeyMap_333 = keyMap[333];
				KeyMap_334 = keyMap[334];
				KeyMap_335 = keyMap[335];
				KeyMap_336 = keyMap[336];
				KeyMap_337 = keyMap[337];
				KeyMap_338 = keyMap[338];
				KeyMap_339 = keyMap[339];
				KeyMap_340 = keyMap[340];
				KeyMap_341 = keyMap[341];
				KeyMap_342 = keyMap[342];
				KeyMap_343 = keyMap[343];
				KeyMap_344 = keyMap[344];
				KeyMap_345 = keyMap[345];
				KeyMap_346 = keyMap[346];
				KeyMap_347 = keyMap[347];
				KeyMap_348 = keyMap[348];
				KeyMap_349 = keyMap[349];
				KeyMap_350 = keyMap[350];
				KeyMap_351 = keyMap[351];
				KeyMap_352 = keyMap[352];
				KeyMap_353 = keyMap[353];
				KeyMap_354 = keyMap[354];
				KeyMap_355 = keyMap[355];
				KeyMap_356 = keyMap[356];
				KeyMap_357 = keyMap[357];
				KeyMap_358 = keyMap[358];
				KeyMap_359 = keyMap[359];
				KeyMap_360 = keyMap[360];
				KeyMap_361 = keyMap[361];
				KeyMap_362 = keyMap[362];
				KeyMap_363 = keyMap[363];
				KeyMap_364 = keyMap[364];
				KeyMap_365 = keyMap[365];
				KeyMap_366 = keyMap[366];
				KeyMap_367 = keyMap[367];
				KeyMap_368 = keyMap[368];
				KeyMap_369 = keyMap[369];
				KeyMap_370 = keyMap[370];
				KeyMap_371 = keyMap[371];
				KeyMap_372 = keyMap[372];
				KeyMap_373 = keyMap[373];
				KeyMap_374 = keyMap[374];
				KeyMap_375 = keyMap[375];
				KeyMap_376 = keyMap[376];
				KeyMap_377 = keyMap[377];
				KeyMap_378 = keyMap[378];
				KeyMap_379 = keyMap[379];
				KeyMap_380 = keyMap[380];
				KeyMap_381 = keyMap[381];
				KeyMap_382 = keyMap[382];
				KeyMap_383 = keyMap[383];
				KeyMap_384 = keyMap[384];
				KeyMap_385 = keyMap[385];
				KeyMap_386 = keyMap[386];
				KeyMap_387 = keyMap[387];
				KeyMap_388 = keyMap[388];
				KeyMap_389 = keyMap[389];
				KeyMap_390 = keyMap[390];
				KeyMap_391 = keyMap[391];
				KeyMap_392 = keyMap[392];
				KeyMap_393 = keyMap[393];
				KeyMap_394 = keyMap[394];
				KeyMap_395 = keyMap[395];
				KeyMap_396 = keyMap[396];
				KeyMap_397 = keyMap[397];
				KeyMap_398 = keyMap[398];
				KeyMap_399 = keyMap[399];
				KeyMap_400 = keyMap[400];
				KeyMap_401 = keyMap[401];
				KeyMap_402 = keyMap[402];
				KeyMap_403 = keyMap[403];
				KeyMap_404 = keyMap[404];
				KeyMap_405 = keyMap[405];
				KeyMap_406 = keyMap[406];
				KeyMap_407 = keyMap[407];
				KeyMap_408 = keyMap[408];
				KeyMap_409 = keyMap[409];
				KeyMap_410 = keyMap[410];
				KeyMap_411 = keyMap[411];
				KeyMap_412 = keyMap[412];
				KeyMap_413 = keyMap[413];
				KeyMap_414 = keyMap[414];
				KeyMap_415 = keyMap[415];
				KeyMap_416 = keyMap[416];
				KeyMap_417 = keyMap[417];
				KeyMap_418 = keyMap[418];
				KeyMap_419 = keyMap[419];
				KeyMap_420 = keyMap[420];
				KeyMap_421 = keyMap[421];
				KeyMap_422 = keyMap[422];
				KeyMap_423 = keyMap[423];
				KeyMap_424 = keyMap[424];
				KeyMap_425 = keyMap[425];
				KeyMap_426 = keyMap[426];
				KeyMap_427 = keyMap[427];
				KeyMap_428 = keyMap[428];
				KeyMap_429 = keyMap[429];
				KeyMap_430 = keyMap[430];
				KeyMap_431 = keyMap[431];
				KeyMap_432 = keyMap[432];
				KeyMap_433 = keyMap[433];
				KeyMap_434 = keyMap[434];
				KeyMap_435 = keyMap[435];
				KeyMap_436 = keyMap[436];
				KeyMap_437 = keyMap[437];
				KeyMap_438 = keyMap[438];
				KeyMap_439 = keyMap[439];
				KeyMap_440 = keyMap[440];
				KeyMap_441 = keyMap[441];
				KeyMap_442 = keyMap[442];
				KeyMap_443 = keyMap[443];
				KeyMap_444 = keyMap[444];
				KeyMap_445 = keyMap[445];
				KeyMap_446 = keyMap[446];
				KeyMap_447 = keyMap[447];
				KeyMap_448 = keyMap[448];
				KeyMap_449 = keyMap[449];
				KeyMap_450 = keyMap[450];
				KeyMap_451 = keyMap[451];
				KeyMap_452 = keyMap[452];
				KeyMap_453 = keyMap[453];
				KeyMap_454 = keyMap[454];
				KeyMap_455 = keyMap[455];
				KeyMap_456 = keyMap[456];
				KeyMap_457 = keyMap[457];
				KeyMap_458 = keyMap[458];
				KeyMap_459 = keyMap[459];
				KeyMap_460 = keyMap[460];
				KeyMap_461 = keyMap[461];
				KeyMap_462 = keyMap[462];
				KeyMap_463 = keyMap[463];
				KeyMap_464 = keyMap[464];
				KeyMap_465 = keyMap[465];
				KeyMap_466 = keyMap[466];
				KeyMap_467 = keyMap[467];
				KeyMap_468 = keyMap[468];
				KeyMap_469 = keyMap[469];
				KeyMap_470 = keyMap[470];
				KeyMap_471 = keyMap[471];
				KeyMap_472 = keyMap[472];
				KeyMap_473 = keyMap[473];
				KeyMap_474 = keyMap[474];
				KeyMap_475 = keyMap[475];
				KeyMap_476 = keyMap[476];
				KeyMap_477 = keyMap[477];
				KeyMap_478 = keyMap[478];
				KeyMap_479 = keyMap[479];
				KeyMap_480 = keyMap[480];
				KeyMap_481 = keyMap[481];
				KeyMap_482 = keyMap[482];
				KeyMap_483 = keyMap[483];
				KeyMap_484 = keyMap[484];
				KeyMap_485 = keyMap[485];
				KeyMap_486 = keyMap[486];
				KeyMap_487 = keyMap[487];
				KeyMap_488 = keyMap[488];
				KeyMap_489 = keyMap[489];
				KeyMap_490 = keyMap[490];
				KeyMap_491 = keyMap[491];
				KeyMap_492 = keyMap[492];
				KeyMap_493 = keyMap[493];
				KeyMap_494 = keyMap[494];
				KeyMap_495 = keyMap[495];
				KeyMap_496 = keyMap[496];
				KeyMap_497 = keyMap[497];
				KeyMap_498 = keyMap[498];
				KeyMap_499 = keyMap[499];
				KeyMap_500 = keyMap[500];
				KeyMap_501 = keyMap[501];
				KeyMap_502 = keyMap[502];
				KeyMap_503 = keyMap[503];
				KeyMap_504 = keyMap[504];
				KeyMap_505 = keyMap[505];
				KeyMap_506 = keyMap[506];
				KeyMap_507 = keyMap[507];
				KeyMap_508 = keyMap[508];
				KeyMap_509 = keyMap[509];
				KeyMap_510 = keyMap[510];
				KeyMap_511 = keyMap[511];
				KeyMap_512 = keyMap[512];
				KeyMap_513 = keyMap[513];
				KeyMap_514 = keyMap[514];
				KeyMap_515 = keyMap[515];
				KeyMap_516 = keyMap[516];
				KeyMap_517 = keyMap[517];
				KeyMap_518 = keyMap[518];
				KeyMap_519 = keyMap[519];
				KeyMap_520 = keyMap[520];
				KeyMap_521 = keyMap[521];
				KeyMap_522 = keyMap[522];
				KeyMap_523 = keyMap[523];
				KeyMap_524 = keyMap[524];
				KeyMap_525 = keyMap[525];
				KeyMap_526 = keyMap[526];
				KeyMap_527 = keyMap[527];
				KeyMap_528 = keyMap[528];
				KeyMap_529 = keyMap[529];
				KeyMap_530 = keyMap[530];
				KeyMap_531 = keyMap[531];
				KeyMap_532 = keyMap[532];
				KeyMap_533 = keyMap[533];
				KeyMap_534 = keyMap[534];
				KeyMap_535 = keyMap[535];
				KeyMap_536 = keyMap[536];
				KeyMap_537 = keyMap[537];
				KeyMap_538 = keyMap[538];
				KeyMap_539 = keyMap[539];
				KeyMap_540 = keyMap[540];
				KeyMap_541 = keyMap[541];
				KeyMap_542 = keyMap[542];
				KeyMap_543 = keyMap[543];
				KeyMap_544 = keyMap[544];
				KeyMap_545 = keyMap[545];
				KeyMap_546 = keyMap[546];
				KeyMap_547 = keyMap[547];
				KeyMap_548 = keyMap[548];
				KeyMap_549 = keyMap[549];
				KeyMap_550 = keyMap[550];
				KeyMap_551 = keyMap[551];
				KeyMap_552 = keyMap[552];
				KeyMap_553 = keyMap[553];
				KeyMap_554 = keyMap[554];
				KeyMap_555 = keyMap[555];
				KeyMap_556 = keyMap[556];
				KeyMap_557 = keyMap[557];
				KeyMap_558 = keyMap[558];
				KeyMap_559 = keyMap[559];
				KeyMap_560 = keyMap[560];
				KeyMap_561 = keyMap[561];
				KeyMap_562 = keyMap[562];
				KeyMap_563 = keyMap[563];
				KeyMap_564 = keyMap[564];
				KeyMap_565 = keyMap[565];
				KeyMap_566 = keyMap[566];
				KeyMap_567 = keyMap[567];
				KeyMap_568 = keyMap[568];
				KeyMap_569 = keyMap[569];
				KeyMap_570 = keyMap[570];
				KeyMap_571 = keyMap[571];
				KeyMap_572 = keyMap[572];
				KeyMap_573 = keyMap[573];
				KeyMap_574 = keyMap[574];
				KeyMap_575 = keyMap[575];
				KeyMap_576 = keyMap[576];
				KeyMap_577 = keyMap[577];
				KeyMap_578 = keyMap[578];
				KeyMap_579 = keyMap[579];
				KeyMap_580 = keyMap[580];
				KeyMap_581 = keyMap[581];
				KeyMap_582 = keyMap[582];
				KeyMap_583 = keyMap[583];
				KeyMap_584 = keyMap[584];
				KeyMap_585 = keyMap[585];
				KeyMap_586 = keyMap[586];
				KeyMap_587 = keyMap[587];
				KeyMap_588 = keyMap[588];
				KeyMap_589 = keyMap[589];
				KeyMap_590 = keyMap[590];
				KeyMap_591 = keyMap[591];
				KeyMap_592 = keyMap[592];
				KeyMap_593 = keyMap[593];
				KeyMap_594 = keyMap[594];
				KeyMap_595 = keyMap[595];
				KeyMap_596 = keyMap[596];
				KeyMap_597 = keyMap[597];
				KeyMap_598 = keyMap[598];
				KeyMap_599 = keyMap[599];
				KeyMap_600 = keyMap[600];
				KeyMap_601 = keyMap[601];
				KeyMap_602 = keyMap[602];
				KeyMap_603 = keyMap[603];
				KeyMap_604 = keyMap[604];
				KeyMap_605 = keyMap[605];
				KeyMap_606 = keyMap[606];
				KeyMap_607 = keyMap[607];
				KeyMap_608 = keyMap[608];
				KeyMap_609 = keyMap[609];
				KeyMap_610 = keyMap[610];
				KeyMap_611 = keyMap[611];
				KeyMap_612 = keyMap[612];
				KeyMap_613 = keyMap[613];
				KeyMap_614 = keyMap[614];
				KeyMap_615 = keyMap[615];
				KeyMap_616 = keyMap[616];
				KeyMap_617 = keyMap[617];
				KeyMap_618 = keyMap[618];
				KeyMap_619 = keyMap[619];
				KeyMap_620 = keyMap[620];
				KeyMap_621 = keyMap[621];
				KeyMap_622 = keyMap[622];
				KeyMap_623 = keyMap[623];
				KeyMap_624 = keyMap[624];
				KeyMap_625 = keyMap[625];
				KeyMap_626 = keyMap[626];
				KeyMap_627 = keyMap[627];
				KeyMap_628 = keyMap[628];
				KeyMap_629 = keyMap[629];
				KeyMap_630 = keyMap[630];
				KeyMap_631 = keyMap[631];
				KeyMap_632 = keyMap[632];
				KeyMap_633 = keyMap[633];
				KeyMap_634 = keyMap[634];
				KeyMap_635 = keyMap[635];
				KeyMap_636 = keyMap[636];
				KeyMap_637 = keyMap[637];
				KeyMap_638 = keyMap[638];
				KeyMap_639 = keyMap[639];
				KeyMap_640 = keyMap[640];
				KeyMap_641 = keyMap[641];
				KeyMap_642 = keyMap[642];
				KeyMap_643 = keyMap[643];
				KeyMap_644 = keyMap[644];
				KeyMap_645 = keyMap[645];
				KeyMap_646 = keyMap[646];
				KeyMap_647 = keyMap[647];
				KeyMap_648 = keyMap[648];
				KeyMap_649 = keyMap[649];
				KeyMap_650 = keyMap[650];
				KeyMap_651 = keyMap[651];
				KeyMap_652 = keyMap[652];
				KeyMap_653 = keyMap[653];
				KeyMap_654 = keyMap[654];
				KeyMap_655 = keyMap[655];
				KeyMap_656 = keyMap[656];
				KeyMap_657 = keyMap[657];
				KeyMap_658 = keyMap[658];
				KeyMap_659 = keyMap[659];
				KeyMap_660 = keyMap[660];
				KeyMap_661 = keyMap[661];
				KeyMap_662 = keyMap[662];
				KeyMap_663 = keyMap[663];
				KeyMap_664 = keyMap[664];
				KeyMap_665 = keyMap[665];
			}
			if (keysDown != default)
			{
				KeysDown_0 = keysDown[0];
				KeysDown_1 = keysDown[1];
				KeysDown_2 = keysDown[2];
				KeysDown_3 = keysDown[3];
				KeysDown_4 = keysDown[4];
				KeysDown_5 = keysDown[5];
				KeysDown_6 = keysDown[6];
				KeysDown_7 = keysDown[7];
				KeysDown_8 = keysDown[8];
				KeysDown_9 = keysDown[9];
				KeysDown_10 = keysDown[10];
				KeysDown_11 = keysDown[11];
				KeysDown_12 = keysDown[12];
				KeysDown_13 = keysDown[13];
				KeysDown_14 = keysDown[14];
				KeysDown_15 = keysDown[15];
				KeysDown_16 = keysDown[16];
				KeysDown_17 = keysDown[17];
				KeysDown_18 = keysDown[18];
				KeysDown_19 = keysDown[19];
				KeysDown_20 = keysDown[20];
				KeysDown_21 = keysDown[21];
				KeysDown_22 = keysDown[22];
				KeysDown_23 = keysDown[23];
				KeysDown_24 = keysDown[24];
				KeysDown_25 = keysDown[25];
				KeysDown_26 = keysDown[26];
				KeysDown_27 = keysDown[27];
				KeysDown_28 = keysDown[28];
				KeysDown_29 = keysDown[29];
				KeysDown_30 = keysDown[30];
				KeysDown_31 = keysDown[31];
				KeysDown_32 = keysDown[32];
				KeysDown_33 = keysDown[33];
				KeysDown_34 = keysDown[34];
				KeysDown_35 = keysDown[35];
				KeysDown_36 = keysDown[36];
				KeysDown_37 = keysDown[37];
				KeysDown_38 = keysDown[38];
				KeysDown_39 = keysDown[39];
				KeysDown_40 = keysDown[40];
				KeysDown_41 = keysDown[41];
				KeysDown_42 = keysDown[42];
				KeysDown_43 = keysDown[43];
				KeysDown_44 = keysDown[44];
				KeysDown_45 = keysDown[45];
				KeysDown_46 = keysDown[46];
				KeysDown_47 = keysDown[47];
				KeysDown_48 = keysDown[48];
				KeysDown_49 = keysDown[49];
				KeysDown_50 = keysDown[50];
				KeysDown_51 = keysDown[51];
				KeysDown_52 = keysDown[52];
				KeysDown_53 = keysDown[53];
				KeysDown_54 = keysDown[54];
				KeysDown_55 = keysDown[55];
				KeysDown_56 = keysDown[56];
				KeysDown_57 = keysDown[57];
				KeysDown_58 = keysDown[58];
				KeysDown_59 = keysDown[59];
				KeysDown_60 = keysDown[60];
				KeysDown_61 = keysDown[61];
				KeysDown_62 = keysDown[62];
				KeysDown_63 = keysDown[63];
				KeysDown_64 = keysDown[64];
				KeysDown_65 = keysDown[65];
				KeysDown_66 = keysDown[66];
				KeysDown_67 = keysDown[67];
				KeysDown_68 = keysDown[68];
				KeysDown_69 = keysDown[69];
				KeysDown_70 = keysDown[70];
				KeysDown_71 = keysDown[71];
				KeysDown_72 = keysDown[72];
				KeysDown_73 = keysDown[73];
				KeysDown_74 = keysDown[74];
				KeysDown_75 = keysDown[75];
				KeysDown_76 = keysDown[76];
				KeysDown_77 = keysDown[77];
				KeysDown_78 = keysDown[78];
				KeysDown_79 = keysDown[79];
				KeysDown_80 = keysDown[80];
				KeysDown_81 = keysDown[81];
				KeysDown_82 = keysDown[82];
				KeysDown_83 = keysDown[83];
				KeysDown_84 = keysDown[84];
				KeysDown_85 = keysDown[85];
				KeysDown_86 = keysDown[86];
				KeysDown_87 = keysDown[87];
				KeysDown_88 = keysDown[88];
				KeysDown_89 = keysDown[89];
				KeysDown_90 = keysDown[90];
				KeysDown_91 = keysDown[91];
				KeysDown_92 = keysDown[92];
				KeysDown_93 = keysDown[93];
				KeysDown_94 = keysDown[94];
				KeysDown_95 = keysDown[95];
				KeysDown_96 = keysDown[96];
				KeysDown_97 = keysDown[97];
				KeysDown_98 = keysDown[98];
				KeysDown_99 = keysDown[99];
				KeysDown_100 = keysDown[100];
				KeysDown_101 = keysDown[101];
				KeysDown_102 = keysDown[102];
				KeysDown_103 = keysDown[103];
				KeysDown_104 = keysDown[104];
				KeysDown_105 = keysDown[105];
				KeysDown_106 = keysDown[106];
				KeysDown_107 = keysDown[107];
				KeysDown_108 = keysDown[108];
				KeysDown_109 = keysDown[109];
				KeysDown_110 = keysDown[110];
				KeysDown_111 = keysDown[111];
				KeysDown_112 = keysDown[112];
				KeysDown_113 = keysDown[113];
				KeysDown_114 = keysDown[114];
				KeysDown_115 = keysDown[115];
				KeysDown_116 = keysDown[116];
				KeysDown_117 = keysDown[117];
				KeysDown_118 = keysDown[118];
				KeysDown_119 = keysDown[119];
				KeysDown_120 = keysDown[120];
				KeysDown_121 = keysDown[121];
				KeysDown_122 = keysDown[122];
				KeysDown_123 = keysDown[123];
				KeysDown_124 = keysDown[124];
				KeysDown_125 = keysDown[125];
				KeysDown_126 = keysDown[126];
				KeysDown_127 = keysDown[127];
				KeysDown_128 = keysDown[128];
				KeysDown_129 = keysDown[129];
				KeysDown_130 = keysDown[130];
				KeysDown_131 = keysDown[131];
				KeysDown_132 = keysDown[132];
				KeysDown_133 = keysDown[133];
				KeysDown_134 = keysDown[134];
				KeysDown_135 = keysDown[135];
				KeysDown_136 = keysDown[136];
				KeysDown_137 = keysDown[137];
				KeysDown_138 = keysDown[138];
				KeysDown_139 = keysDown[139];
				KeysDown_140 = keysDown[140];
				KeysDown_141 = keysDown[141];
				KeysDown_142 = keysDown[142];
				KeysDown_143 = keysDown[143];
				KeysDown_144 = keysDown[144];
				KeysDown_145 = keysDown[145];
				KeysDown_146 = keysDown[146];
				KeysDown_147 = keysDown[147];
				KeysDown_148 = keysDown[148];
				KeysDown_149 = keysDown[149];
				KeysDown_150 = keysDown[150];
				KeysDown_151 = keysDown[151];
				KeysDown_152 = keysDown[152];
				KeysDown_153 = keysDown[153];
				KeysDown_154 = keysDown[154];
				KeysDown_155 = keysDown[155];
				KeysDown_156 = keysDown[156];
				KeysDown_157 = keysDown[157];
				KeysDown_158 = keysDown[158];
				KeysDown_159 = keysDown[159];
				KeysDown_160 = keysDown[160];
				KeysDown_161 = keysDown[161];
				KeysDown_162 = keysDown[162];
				KeysDown_163 = keysDown[163];
				KeysDown_164 = keysDown[164];
				KeysDown_165 = keysDown[165];
				KeysDown_166 = keysDown[166];
				KeysDown_167 = keysDown[167];
				KeysDown_168 = keysDown[168];
				KeysDown_169 = keysDown[169];
				KeysDown_170 = keysDown[170];
				KeysDown_171 = keysDown[171];
				KeysDown_172 = keysDown[172];
				KeysDown_173 = keysDown[173];
				KeysDown_174 = keysDown[174];
				KeysDown_175 = keysDown[175];
				KeysDown_176 = keysDown[176];
				KeysDown_177 = keysDown[177];
				KeysDown_178 = keysDown[178];
				KeysDown_179 = keysDown[179];
				KeysDown_180 = keysDown[180];
				KeysDown_181 = keysDown[181];
				KeysDown_182 = keysDown[182];
				KeysDown_183 = keysDown[183];
				KeysDown_184 = keysDown[184];
				KeysDown_185 = keysDown[185];
				KeysDown_186 = keysDown[186];
				KeysDown_187 = keysDown[187];
				KeysDown_188 = keysDown[188];
				KeysDown_189 = keysDown[189];
				KeysDown_190 = keysDown[190];
				KeysDown_191 = keysDown[191];
				KeysDown_192 = keysDown[192];
				KeysDown_193 = keysDown[193];
				KeysDown_194 = keysDown[194];
				KeysDown_195 = keysDown[195];
				KeysDown_196 = keysDown[196];
				KeysDown_197 = keysDown[197];
				KeysDown_198 = keysDown[198];
				KeysDown_199 = keysDown[199];
				KeysDown_200 = keysDown[200];
				KeysDown_201 = keysDown[201];
				KeysDown_202 = keysDown[202];
				KeysDown_203 = keysDown[203];
				KeysDown_204 = keysDown[204];
				KeysDown_205 = keysDown[205];
				KeysDown_206 = keysDown[206];
				KeysDown_207 = keysDown[207];
				KeysDown_208 = keysDown[208];
				KeysDown_209 = keysDown[209];
				KeysDown_210 = keysDown[210];
				KeysDown_211 = keysDown[211];
				KeysDown_212 = keysDown[212];
				KeysDown_213 = keysDown[213];
				KeysDown_214 = keysDown[214];
				KeysDown_215 = keysDown[215];
				KeysDown_216 = keysDown[216];
				KeysDown_217 = keysDown[217];
				KeysDown_218 = keysDown[218];
				KeysDown_219 = keysDown[219];
				KeysDown_220 = keysDown[220];
				KeysDown_221 = keysDown[221];
				KeysDown_222 = keysDown[222];
				KeysDown_223 = keysDown[223];
				KeysDown_224 = keysDown[224];
				KeysDown_225 = keysDown[225];
				KeysDown_226 = keysDown[226];
				KeysDown_227 = keysDown[227];
				KeysDown_228 = keysDown[228];
				KeysDown_229 = keysDown[229];
				KeysDown_230 = keysDown[230];
				KeysDown_231 = keysDown[231];
				KeysDown_232 = keysDown[232];
				KeysDown_233 = keysDown[233];
				KeysDown_234 = keysDown[234];
				KeysDown_235 = keysDown[235];
				KeysDown_236 = keysDown[236];
				KeysDown_237 = keysDown[237];
				KeysDown_238 = keysDown[238];
				KeysDown_239 = keysDown[239];
				KeysDown_240 = keysDown[240];
				KeysDown_241 = keysDown[241];
				KeysDown_242 = keysDown[242];
				KeysDown_243 = keysDown[243];
				KeysDown_244 = keysDown[244];
				KeysDown_245 = keysDown[245];
				KeysDown_246 = keysDown[246];
				KeysDown_247 = keysDown[247];
				KeysDown_248 = keysDown[248];
				KeysDown_249 = keysDown[249];
				KeysDown_250 = keysDown[250];
				KeysDown_251 = keysDown[251];
				KeysDown_252 = keysDown[252];
				KeysDown_253 = keysDown[253];
				KeysDown_254 = keysDown[254];
				KeysDown_255 = keysDown[255];
				KeysDown_256 = keysDown[256];
				KeysDown_257 = keysDown[257];
				KeysDown_258 = keysDown[258];
				KeysDown_259 = keysDown[259];
				KeysDown_260 = keysDown[260];
				KeysDown_261 = keysDown[261];
				KeysDown_262 = keysDown[262];
				KeysDown_263 = keysDown[263];
				KeysDown_264 = keysDown[264];
				KeysDown_265 = keysDown[265];
				KeysDown_266 = keysDown[266];
				KeysDown_267 = keysDown[267];
				KeysDown_268 = keysDown[268];
				KeysDown_269 = keysDown[269];
				KeysDown_270 = keysDown[270];
				KeysDown_271 = keysDown[271];
				KeysDown_272 = keysDown[272];
				KeysDown_273 = keysDown[273];
				KeysDown_274 = keysDown[274];
				KeysDown_275 = keysDown[275];
				KeysDown_276 = keysDown[276];
				KeysDown_277 = keysDown[277];
				KeysDown_278 = keysDown[278];
				KeysDown_279 = keysDown[279];
				KeysDown_280 = keysDown[280];
				KeysDown_281 = keysDown[281];
				KeysDown_282 = keysDown[282];
				KeysDown_283 = keysDown[283];
				KeysDown_284 = keysDown[284];
				KeysDown_285 = keysDown[285];
				KeysDown_286 = keysDown[286];
				KeysDown_287 = keysDown[287];
				KeysDown_288 = keysDown[288];
				KeysDown_289 = keysDown[289];
				KeysDown_290 = keysDown[290];
				KeysDown_291 = keysDown[291];
				KeysDown_292 = keysDown[292];
				KeysDown_293 = keysDown[293];
				KeysDown_294 = keysDown[294];
				KeysDown_295 = keysDown[295];
				KeysDown_296 = keysDown[296];
				KeysDown_297 = keysDown[297];
				KeysDown_298 = keysDown[298];
				KeysDown_299 = keysDown[299];
				KeysDown_300 = keysDown[300];
				KeysDown_301 = keysDown[301];
				KeysDown_302 = keysDown[302];
				KeysDown_303 = keysDown[303];
				KeysDown_304 = keysDown[304];
				KeysDown_305 = keysDown[305];
				KeysDown_306 = keysDown[306];
				KeysDown_307 = keysDown[307];
				KeysDown_308 = keysDown[308];
				KeysDown_309 = keysDown[309];
				KeysDown_310 = keysDown[310];
				KeysDown_311 = keysDown[311];
				KeysDown_312 = keysDown[312];
				KeysDown_313 = keysDown[313];
				KeysDown_314 = keysDown[314];
				KeysDown_315 = keysDown[315];
				KeysDown_316 = keysDown[316];
				KeysDown_317 = keysDown[317];
				KeysDown_318 = keysDown[318];
				KeysDown_319 = keysDown[319];
				KeysDown_320 = keysDown[320];
				KeysDown_321 = keysDown[321];
				KeysDown_322 = keysDown[322];
				KeysDown_323 = keysDown[323];
				KeysDown_324 = keysDown[324];
				KeysDown_325 = keysDown[325];
				KeysDown_326 = keysDown[326];
				KeysDown_327 = keysDown[327];
				KeysDown_328 = keysDown[328];
				KeysDown_329 = keysDown[329];
				KeysDown_330 = keysDown[330];
				KeysDown_331 = keysDown[331];
				KeysDown_332 = keysDown[332];
				KeysDown_333 = keysDown[333];
				KeysDown_334 = keysDown[334];
				KeysDown_335 = keysDown[335];
				KeysDown_336 = keysDown[336];
				KeysDown_337 = keysDown[337];
				KeysDown_338 = keysDown[338];
				KeysDown_339 = keysDown[339];
				KeysDown_340 = keysDown[340];
				KeysDown_341 = keysDown[341];
				KeysDown_342 = keysDown[342];
				KeysDown_343 = keysDown[343];
				KeysDown_344 = keysDown[344];
				KeysDown_345 = keysDown[345];
				KeysDown_346 = keysDown[346];
				KeysDown_347 = keysDown[347];
				KeysDown_348 = keysDown[348];
				KeysDown_349 = keysDown[349];
				KeysDown_350 = keysDown[350];
				KeysDown_351 = keysDown[351];
				KeysDown_352 = keysDown[352];
				KeysDown_353 = keysDown[353];
				KeysDown_354 = keysDown[354];
				KeysDown_355 = keysDown[355];
				KeysDown_356 = keysDown[356];
				KeysDown_357 = keysDown[357];
				KeysDown_358 = keysDown[358];
				KeysDown_359 = keysDown[359];
				KeysDown_360 = keysDown[360];
				KeysDown_361 = keysDown[361];
				KeysDown_362 = keysDown[362];
				KeysDown_363 = keysDown[363];
				KeysDown_364 = keysDown[364];
				KeysDown_365 = keysDown[365];
				KeysDown_366 = keysDown[366];
				KeysDown_367 = keysDown[367];
				KeysDown_368 = keysDown[368];
				KeysDown_369 = keysDown[369];
				KeysDown_370 = keysDown[370];
				KeysDown_371 = keysDown[371];
				KeysDown_372 = keysDown[372];
				KeysDown_373 = keysDown[373];
				KeysDown_374 = keysDown[374];
				KeysDown_375 = keysDown[375];
				KeysDown_376 = keysDown[376];
				KeysDown_377 = keysDown[377];
				KeysDown_378 = keysDown[378];
				KeysDown_379 = keysDown[379];
				KeysDown_380 = keysDown[380];
				KeysDown_381 = keysDown[381];
				KeysDown_382 = keysDown[382];
				KeysDown_383 = keysDown[383];
				KeysDown_384 = keysDown[384];
				KeysDown_385 = keysDown[385];
				KeysDown_386 = keysDown[386];
				KeysDown_387 = keysDown[387];
				KeysDown_388 = keysDown[388];
				KeysDown_389 = keysDown[389];
				KeysDown_390 = keysDown[390];
				KeysDown_391 = keysDown[391];
				KeysDown_392 = keysDown[392];
				KeysDown_393 = keysDown[393];
				KeysDown_394 = keysDown[394];
				KeysDown_395 = keysDown[395];
				KeysDown_396 = keysDown[396];
				KeysDown_397 = keysDown[397];
				KeysDown_398 = keysDown[398];
				KeysDown_399 = keysDown[399];
				KeysDown_400 = keysDown[400];
				KeysDown_401 = keysDown[401];
				KeysDown_402 = keysDown[402];
				KeysDown_403 = keysDown[403];
				KeysDown_404 = keysDown[404];
				KeysDown_405 = keysDown[405];
				KeysDown_406 = keysDown[406];
				KeysDown_407 = keysDown[407];
				KeysDown_408 = keysDown[408];
				KeysDown_409 = keysDown[409];
				KeysDown_410 = keysDown[410];
				KeysDown_411 = keysDown[411];
				KeysDown_412 = keysDown[412];
				KeysDown_413 = keysDown[413];
				KeysDown_414 = keysDown[414];
				KeysDown_415 = keysDown[415];
				KeysDown_416 = keysDown[416];
				KeysDown_417 = keysDown[417];
				KeysDown_418 = keysDown[418];
				KeysDown_419 = keysDown[419];
				KeysDown_420 = keysDown[420];
				KeysDown_421 = keysDown[421];
				KeysDown_422 = keysDown[422];
				KeysDown_423 = keysDown[423];
				KeysDown_424 = keysDown[424];
				KeysDown_425 = keysDown[425];
				KeysDown_426 = keysDown[426];
				KeysDown_427 = keysDown[427];
				KeysDown_428 = keysDown[428];
				KeysDown_429 = keysDown[429];
				KeysDown_430 = keysDown[430];
				KeysDown_431 = keysDown[431];
				KeysDown_432 = keysDown[432];
				KeysDown_433 = keysDown[433];
				KeysDown_434 = keysDown[434];
				KeysDown_435 = keysDown[435];
				KeysDown_436 = keysDown[436];
				KeysDown_437 = keysDown[437];
				KeysDown_438 = keysDown[438];
				KeysDown_439 = keysDown[439];
				KeysDown_440 = keysDown[440];
				KeysDown_441 = keysDown[441];
				KeysDown_442 = keysDown[442];
				KeysDown_443 = keysDown[443];
				KeysDown_444 = keysDown[444];
				KeysDown_445 = keysDown[445];
				KeysDown_446 = keysDown[446];
				KeysDown_447 = keysDown[447];
				KeysDown_448 = keysDown[448];
				KeysDown_449 = keysDown[449];
				KeysDown_450 = keysDown[450];
				KeysDown_451 = keysDown[451];
				KeysDown_452 = keysDown[452];
				KeysDown_453 = keysDown[453];
				KeysDown_454 = keysDown[454];
				KeysDown_455 = keysDown[455];
				KeysDown_456 = keysDown[456];
				KeysDown_457 = keysDown[457];
				KeysDown_458 = keysDown[458];
				KeysDown_459 = keysDown[459];
				KeysDown_460 = keysDown[460];
				KeysDown_461 = keysDown[461];
				KeysDown_462 = keysDown[462];
				KeysDown_463 = keysDown[463];
				KeysDown_464 = keysDown[464];
				KeysDown_465 = keysDown[465];
				KeysDown_466 = keysDown[466];
				KeysDown_467 = keysDown[467];
				KeysDown_468 = keysDown[468];
				KeysDown_469 = keysDown[469];
				KeysDown_470 = keysDown[470];
				KeysDown_471 = keysDown[471];
				KeysDown_472 = keysDown[472];
				KeysDown_473 = keysDown[473];
				KeysDown_474 = keysDown[474];
				KeysDown_475 = keysDown[475];
				KeysDown_476 = keysDown[476];
				KeysDown_477 = keysDown[477];
				KeysDown_478 = keysDown[478];
				KeysDown_479 = keysDown[479];
				KeysDown_480 = keysDown[480];
				KeysDown_481 = keysDown[481];
				KeysDown_482 = keysDown[482];
				KeysDown_483 = keysDown[483];
				KeysDown_484 = keysDown[484];
				KeysDown_485 = keysDown[485];
				KeysDown_486 = keysDown[486];
				KeysDown_487 = keysDown[487];
				KeysDown_488 = keysDown[488];
				KeysDown_489 = keysDown[489];
				KeysDown_490 = keysDown[490];
				KeysDown_491 = keysDown[491];
				KeysDown_492 = keysDown[492];
				KeysDown_493 = keysDown[493];
				KeysDown_494 = keysDown[494];
				KeysDown_495 = keysDown[495];
				KeysDown_496 = keysDown[496];
				KeysDown_497 = keysDown[497];
				KeysDown_498 = keysDown[498];
				KeysDown_499 = keysDown[499];
				KeysDown_500 = keysDown[500];
				KeysDown_501 = keysDown[501];
				KeysDown_502 = keysDown[502];
				KeysDown_503 = keysDown[503];
				KeysDown_504 = keysDown[504];
				KeysDown_505 = keysDown[505];
				KeysDown_506 = keysDown[506];
				KeysDown_507 = keysDown[507];
				KeysDown_508 = keysDown[508];
				KeysDown_509 = keysDown[509];
				KeysDown_510 = keysDown[510];
				KeysDown_511 = keysDown[511];
				KeysDown_512 = keysDown[512];
				KeysDown_513 = keysDown[513];
				KeysDown_514 = keysDown[514];
				KeysDown_515 = keysDown[515];
				KeysDown_516 = keysDown[516];
				KeysDown_517 = keysDown[517];
				KeysDown_518 = keysDown[518];
				KeysDown_519 = keysDown[519];
				KeysDown_520 = keysDown[520];
				KeysDown_521 = keysDown[521];
				KeysDown_522 = keysDown[522];
				KeysDown_523 = keysDown[523];
				KeysDown_524 = keysDown[524];
				KeysDown_525 = keysDown[525];
				KeysDown_526 = keysDown[526];
				KeysDown_527 = keysDown[527];
				KeysDown_528 = keysDown[528];
				KeysDown_529 = keysDown[529];
				KeysDown_530 = keysDown[530];
				KeysDown_531 = keysDown[531];
				KeysDown_532 = keysDown[532];
				KeysDown_533 = keysDown[533];
				KeysDown_534 = keysDown[534];
				KeysDown_535 = keysDown[535];
				KeysDown_536 = keysDown[536];
				KeysDown_537 = keysDown[537];
				KeysDown_538 = keysDown[538];
				KeysDown_539 = keysDown[539];
				KeysDown_540 = keysDown[540];
				KeysDown_541 = keysDown[541];
				KeysDown_542 = keysDown[542];
				KeysDown_543 = keysDown[543];
				KeysDown_544 = keysDown[544];
				KeysDown_545 = keysDown[545];
				KeysDown_546 = keysDown[546];
				KeysDown_547 = keysDown[547];
				KeysDown_548 = keysDown[548];
				KeysDown_549 = keysDown[549];
				KeysDown_550 = keysDown[550];
				KeysDown_551 = keysDown[551];
				KeysDown_552 = keysDown[552];
				KeysDown_553 = keysDown[553];
				KeysDown_554 = keysDown[554];
				KeysDown_555 = keysDown[555];
				KeysDown_556 = keysDown[556];
				KeysDown_557 = keysDown[557];
				KeysDown_558 = keysDown[558];
				KeysDown_559 = keysDown[559];
				KeysDown_560 = keysDown[560];
				KeysDown_561 = keysDown[561];
				KeysDown_562 = keysDown[562];
				KeysDown_563 = keysDown[563];
				KeysDown_564 = keysDown[564];
				KeysDown_565 = keysDown[565];
				KeysDown_566 = keysDown[566];
				KeysDown_567 = keysDown[567];
				KeysDown_568 = keysDown[568];
				KeysDown_569 = keysDown[569];
				KeysDown_570 = keysDown[570];
				KeysDown_571 = keysDown[571];
				KeysDown_572 = keysDown[572];
				KeysDown_573 = keysDown[573];
				KeysDown_574 = keysDown[574];
				KeysDown_575 = keysDown[575];
				KeysDown_576 = keysDown[576];
				KeysDown_577 = keysDown[577];
				KeysDown_578 = keysDown[578];
				KeysDown_579 = keysDown[579];
				KeysDown_580 = keysDown[580];
				KeysDown_581 = keysDown[581];
				KeysDown_582 = keysDown[582];
				KeysDown_583 = keysDown[583];
				KeysDown_584 = keysDown[584];
				KeysDown_585 = keysDown[585];
				KeysDown_586 = keysDown[586];
				KeysDown_587 = keysDown[587];
				KeysDown_588 = keysDown[588];
				KeysDown_589 = keysDown[589];
				KeysDown_590 = keysDown[590];
				KeysDown_591 = keysDown[591];
				KeysDown_592 = keysDown[592];
				KeysDown_593 = keysDown[593];
				KeysDown_594 = keysDown[594];
				KeysDown_595 = keysDown[595];
				KeysDown_596 = keysDown[596];
				KeysDown_597 = keysDown[597];
				KeysDown_598 = keysDown[598];
				KeysDown_599 = keysDown[599];
				KeysDown_600 = keysDown[600];
				KeysDown_601 = keysDown[601];
				KeysDown_602 = keysDown[602];
				KeysDown_603 = keysDown[603];
				KeysDown_604 = keysDown[604];
				KeysDown_605 = keysDown[605];
				KeysDown_606 = keysDown[606];
				KeysDown_607 = keysDown[607];
				KeysDown_608 = keysDown[608];
				KeysDown_609 = keysDown[609];
				KeysDown_610 = keysDown[610];
				KeysDown_611 = keysDown[611];
				KeysDown_612 = keysDown[612];
				KeysDown_613 = keysDown[613];
				KeysDown_614 = keysDown[614];
				KeysDown_615 = keysDown[615];
				KeysDown_616 = keysDown[616];
				KeysDown_617 = keysDown[617];
				KeysDown_618 = keysDown[618];
				KeysDown_619 = keysDown[619];
				KeysDown_620 = keysDown[620];
				KeysDown_621 = keysDown[621];
				KeysDown_622 = keysDown[622];
				KeysDown_623 = keysDown[623];
				KeysDown_624 = keysDown[624];
				KeysDown_625 = keysDown[625];
				KeysDown_626 = keysDown[626];
				KeysDown_627 = keysDown[627];
				KeysDown_628 = keysDown[628];
				KeysDown_629 = keysDown[629];
				KeysDown_630 = keysDown[630];
				KeysDown_631 = keysDown[631];
				KeysDown_632 = keysDown[632];
				KeysDown_633 = keysDown[633];
				KeysDown_634 = keysDown[634];
				KeysDown_635 = keysDown[635];
				KeysDown_636 = keysDown[636];
				KeysDown_637 = keysDown[637];
				KeysDown_638 = keysDown[638];
				KeysDown_639 = keysDown[639];
				KeysDown_640 = keysDown[640];
				KeysDown_641 = keysDown[641];
				KeysDown_642 = keysDown[642];
				KeysDown_643 = keysDown[643];
				KeysDown_644 = keysDown[644];
				KeysDown_645 = keysDown[645];
				KeysDown_646 = keysDown[646];
				KeysDown_647 = keysDown[647];
				KeysDown_648 = keysDown[648];
				KeysDown_649 = keysDown[649];
				KeysDown_650 = keysDown[650];
				KeysDown_651 = keysDown[651];
				KeysDown_652 = keysDown[652];
				KeysDown_653 = keysDown[653];
				KeysDown_654 = keysDown[654];
				KeysDown_655 = keysDown[655];
				KeysDown_656 = keysDown[656];
				KeysDown_657 = keysDown[657];
				KeysDown_658 = keysDown[658];
				KeysDown_659 = keysDown[659];
				KeysDown_660 = keysDown[660];
				KeysDown_661 = keysDown[661];
				KeysDown_662 = keysDown[662];
				KeysDown_663 = keysDown[663];
				KeysDown_664 = keysDown[664];
				KeysDown_665 = keysDown[665];
			}
			if (navInputs != default)
			{
				NavInputs_0 = navInputs[0];
				NavInputs_1 = navInputs[1];
				NavInputs_2 = navInputs[2];
				NavInputs_3 = navInputs[3];
				NavInputs_4 = navInputs[4];
				NavInputs_5 = navInputs[5];
				NavInputs_6 = navInputs[6];
				NavInputs_7 = navInputs[7];
				NavInputs_8 = navInputs[8];
				NavInputs_9 = navInputs[9];
				NavInputs_10 = navInputs[10];
				NavInputs_11 = navInputs[11];
				NavInputs_12 = navInputs[12];
				NavInputs_13 = navInputs[13];
				NavInputs_14 = navInputs[14];
				NavInputs_15 = navInputs[15];
			}
			UnusedPadding = Unusedpadding;
			Ctx = ctx;
			MousePos = mousePos;
			if (mouseDown != default)
			{
				MouseDown_0 = mouseDown[0];
				MouseDown_1 = mouseDown[1];
				MouseDown_2 = mouseDown[2];
				MouseDown_3 = mouseDown[3];
				MouseDown_4 = mouseDown[4];
			}
			MouseWheel = mouseWheel;
			MouseWheelH = mouseWheelH;
			MouseSource = mouseSource;
			MouseHoveredViewport = mouseHoveredViewport;
			KeyCtrl = keyCtrl ? (byte)1 : (byte)0;
			KeyShift = keyShift ? (byte)1 : (byte)0;
			KeyAlt = keyAlt ? (byte)1 : (byte)0;
			KeySuper = keySuper ? (byte)1 : (byte)0;
			KeyMods = keyMods;
			if (keysData != default)
			{
				KeysData_0 = keysData[0];
				KeysData_1 = keysData[1];
				KeysData_2 = keysData[2];
				KeysData_3 = keysData[3];
				KeysData_4 = keysData[4];
				KeysData_5 = keysData[5];
				KeysData_6 = keysData[6];
				KeysData_7 = keysData[7];
				KeysData_8 = keysData[8];
				KeysData_9 = keysData[9];
				KeysData_10 = keysData[10];
				KeysData_11 = keysData[11];
				KeysData_12 = keysData[12];
				KeysData_13 = keysData[13];
				KeysData_14 = keysData[14];
				KeysData_15 = keysData[15];
				KeysData_16 = keysData[16];
				KeysData_17 = keysData[17];
				KeysData_18 = keysData[18];
				KeysData_19 = keysData[19];
				KeysData_20 = keysData[20];
				KeysData_21 = keysData[21];
				KeysData_22 = keysData[22];
				KeysData_23 = keysData[23];
				KeysData_24 = keysData[24];
				KeysData_25 = keysData[25];
				KeysData_26 = keysData[26];
				KeysData_27 = keysData[27];
				KeysData_28 = keysData[28];
				KeysData_29 = keysData[29];
				KeysData_30 = keysData[30];
				KeysData_31 = keysData[31];
				KeysData_32 = keysData[32];
				KeysData_33 = keysData[33];
				KeysData_34 = keysData[34];
				KeysData_35 = keysData[35];
				KeysData_36 = keysData[36];
				KeysData_37 = keysData[37];
				KeysData_38 = keysData[38];
				KeysData_39 = keysData[39];
				KeysData_40 = keysData[40];
				KeysData_41 = keysData[41];
				KeysData_42 = keysData[42];
				KeysData_43 = keysData[43];
				KeysData_44 = keysData[44];
				KeysData_45 = keysData[45];
				KeysData_46 = keysData[46];
				KeysData_47 = keysData[47];
				KeysData_48 = keysData[48];
				KeysData_49 = keysData[49];
				KeysData_50 = keysData[50];
				KeysData_51 = keysData[51];
				KeysData_52 = keysData[52];
				KeysData_53 = keysData[53];
				KeysData_54 = keysData[54];
				KeysData_55 = keysData[55];
				KeysData_56 = keysData[56];
				KeysData_57 = keysData[57];
				KeysData_58 = keysData[58];
				KeysData_59 = keysData[59];
				KeysData_60 = keysData[60];
				KeysData_61 = keysData[61];
				KeysData_62 = keysData[62];
				KeysData_63 = keysData[63];
				KeysData_64 = keysData[64];
				KeysData_65 = keysData[65];
				KeysData_66 = keysData[66];
				KeysData_67 = keysData[67];
				KeysData_68 = keysData[68];
				KeysData_69 = keysData[69];
				KeysData_70 = keysData[70];
				KeysData_71 = keysData[71];
				KeysData_72 = keysData[72];
				KeysData_73 = keysData[73];
				KeysData_74 = keysData[74];
				KeysData_75 = keysData[75];
				KeysData_76 = keysData[76];
				KeysData_77 = keysData[77];
				KeysData_78 = keysData[78];
				KeysData_79 = keysData[79];
				KeysData_80 = keysData[80];
				KeysData_81 = keysData[81];
				KeysData_82 = keysData[82];
				KeysData_83 = keysData[83];
				KeysData_84 = keysData[84];
				KeysData_85 = keysData[85];
				KeysData_86 = keysData[86];
				KeysData_87 = keysData[87];
				KeysData_88 = keysData[88];
				KeysData_89 = keysData[89];
				KeysData_90 = keysData[90];
				KeysData_91 = keysData[91];
				KeysData_92 = keysData[92];
				KeysData_93 = keysData[93];
				KeysData_94 = keysData[94];
				KeysData_95 = keysData[95];
				KeysData_96 = keysData[96];
				KeysData_97 = keysData[97];
				KeysData_98 = keysData[98];
				KeysData_99 = keysData[99];
				KeysData_100 = keysData[100];
				KeysData_101 = keysData[101];
				KeysData_102 = keysData[102];
				KeysData_103 = keysData[103];
				KeysData_104 = keysData[104];
				KeysData_105 = keysData[105];
				KeysData_106 = keysData[106];
				KeysData_107 = keysData[107];
				KeysData_108 = keysData[108];
				KeysData_109 = keysData[109];
				KeysData_110 = keysData[110];
				KeysData_111 = keysData[111];
				KeysData_112 = keysData[112];
				KeysData_113 = keysData[113];
				KeysData_114 = keysData[114];
				KeysData_115 = keysData[115];
				KeysData_116 = keysData[116];
				KeysData_117 = keysData[117];
				KeysData_118 = keysData[118];
				KeysData_119 = keysData[119];
				KeysData_120 = keysData[120];
				KeysData_121 = keysData[121];
				KeysData_122 = keysData[122];
				KeysData_123 = keysData[123];
				KeysData_124 = keysData[124];
				KeysData_125 = keysData[125];
				KeysData_126 = keysData[126];
				KeysData_127 = keysData[127];
				KeysData_128 = keysData[128];
				KeysData_129 = keysData[129];
				KeysData_130 = keysData[130];
				KeysData_131 = keysData[131];
				KeysData_132 = keysData[132];
				KeysData_133 = keysData[133];
				KeysData_134 = keysData[134];
				KeysData_135 = keysData[135];
				KeysData_136 = keysData[136];
				KeysData_137 = keysData[137];
				KeysData_138 = keysData[138];
				KeysData_139 = keysData[139];
				KeysData_140 = keysData[140];
				KeysData_141 = keysData[141];
				KeysData_142 = keysData[142];
				KeysData_143 = keysData[143];
				KeysData_144 = keysData[144];
				KeysData_145 = keysData[145];
				KeysData_146 = keysData[146];
				KeysData_147 = keysData[147];
				KeysData_148 = keysData[148];
				KeysData_149 = keysData[149];
				KeysData_150 = keysData[150];
				KeysData_151 = keysData[151];
				KeysData_152 = keysData[152];
				KeysData_153 = keysData[153];
				KeysData_154 = keysData[154];
				KeysData_155 = keysData[155];
				KeysData_156 = keysData[156];
				KeysData_157 = keysData[157];
				KeysData_158 = keysData[158];
				KeysData_159 = keysData[159];
				KeysData_160 = keysData[160];
				KeysData_161 = keysData[161];
				KeysData_162 = keysData[162];
				KeysData_163 = keysData[163];
				KeysData_164 = keysData[164];
				KeysData_165 = keysData[165];
				KeysData_166 = keysData[166];
				KeysData_167 = keysData[167];
				KeysData_168 = keysData[168];
				KeysData_169 = keysData[169];
				KeysData_170 = keysData[170];
				KeysData_171 = keysData[171];
				KeysData_172 = keysData[172];
				KeysData_173 = keysData[173];
				KeysData_174 = keysData[174];
				KeysData_175 = keysData[175];
				KeysData_176 = keysData[176];
				KeysData_177 = keysData[177];
				KeysData_178 = keysData[178];
				KeysData_179 = keysData[179];
				KeysData_180 = keysData[180];
				KeysData_181 = keysData[181];
				KeysData_182 = keysData[182];
				KeysData_183 = keysData[183];
				KeysData_184 = keysData[184];
				KeysData_185 = keysData[185];
				KeysData_186 = keysData[186];
				KeysData_187 = keysData[187];
				KeysData_188 = keysData[188];
				KeysData_189 = keysData[189];
				KeysData_190 = keysData[190];
				KeysData_191 = keysData[191];
				KeysData_192 = keysData[192];
				KeysData_193 = keysData[193];
				KeysData_194 = keysData[194];
				KeysData_195 = keysData[195];
				KeysData_196 = keysData[196];
				KeysData_197 = keysData[197];
				KeysData_198 = keysData[198];
				KeysData_199 = keysData[199];
				KeysData_200 = keysData[200];
				KeysData_201 = keysData[201];
				KeysData_202 = keysData[202];
				KeysData_203 = keysData[203];
				KeysData_204 = keysData[204];
				KeysData_205 = keysData[205];
				KeysData_206 = keysData[206];
				KeysData_207 = keysData[207];
				KeysData_208 = keysData[208];
				KeysData_209 = keysData[209];
				KeysData_210 = keysData[210];
				KeysData_211 = keysData[211];
				KeysData_212 = keysData[212];
				KeysData_213 = keysData[213];
				KeysData_214 = keysData[214];
				KeysData_215 = keysData[215];
				KeysData_216 = keysData[216];
				KeysData_217 = keysData[217];
				KeysData_218 = keysData[218];
				KeysData_219 = keysData[219];
				KeysData_220 = keysData[220];
				KeysData_221 = keysData[221];
				KeysData_222 = keysData[222];
				KeysData_223 = keysData[223];
				KeysData_224 = keysData[224];
				KeysData_225 = keysData[225];
				KeysData_226 = keysData[226];
				KeysData_227 = keysData[227];
				KeysData_228 = keysData[228];
				KeysData_229 = keysData[229];
				KeysData_230 = keysData[230];
				KeysData_231 = keysData[231];
				KeysData_232 = keysData[232];
				KeysData_233 = keysData[233];
				KeysData_234 = keysData[234];
				KeysData_235 = keysData[235];
				KeysData_236 = keysData[236];
				KeysData_237 = keysData[237];
				KeysData_238 = keysData[238];
				KeysData_239 = keysData[239];
				KeysData_240 = keysData[240];
				KeysData_241 = keysData[241];
				KeysData_242 = keysData[242];
				KeysData_243 = keysData[243];
				KeysData_244 = keysData[244];
				KeysData_245 = keysData[245];
				KeysData_246 = keysData[246];
				KeysData_247 = keysData[247];
				KeysData_248 = keysData[248];
				KeysData_249 = keysData[249];
				KeysData_250 = keysData[250];
				KeysData_251 = keysData[251];
				KeysData_252 = keysData[252];
				KeysData_253 = keysData[253];
				KeysData_254 = keysData[254];
				KeysData_255 = keysData[255];
				KeysData_256 = keysData[256];
				KeysData_257 = keysData[257];
				KeysData_258 = keysData[258];
				KeysData_259 = keysData[259];
				KeysData_260 = keysData[260];
				KeysData_261 = keysData[261];
				KeysData_262 = keysData[262];
				KeysData_263 = keysData[263];
				KeysData_264 = keysData[264];
				KeysData_265 = keysData[265];
				KeysData_266 = keysData[266];
				KeysData_267 = keysData[267];
				KeysData_268 = keysData[268];
				KeysData_269 = keysData[269];
				KeysData_270 = keysData[270];
				KeysData_271 = keysData[271];
				KeysData_272 = keysData[272];
				KeysData_273 = keysData[273];
				KeysData_274 = keysData[274];
				KeysData_275 = keysData[275];
				KeysData_276 = keysData[276];
				KeysData_277 = keysData[277];
				KeysData_278 = keysData[278];
				KeysData_279 = keysData[279];
				KeysData_280 = keysData[280];
				KeysData_281 = keysData[281];
				KeysData_282 = keysData[282];
				KeysData_283 = keysData[283];
				KeysData_284 = keysData[284];
				KeysData_285 = keysData[285];
				KeysData_286 = keysData[286];
				KeysData_287 = keysData[287];
				KeysData_288 = keysData[288];
				KeysData_289 = keysData[289];
				KeysData_290 = keysData[290];
				KeysData_291 = keysData[291];
				KeysData_292 = keysData[292];
				KeysData_293 = keysData[293];
				KeysData_294 = keysData[294];
				KeysData_295 = keysData[295];
				KeysData_296 = keysData[296];
				KeysData_297 = keysData[297];
				KeysData_298 = keysData[298];
				KeysData_299 = keysData[299];
				KeysData_300 = keysData[300];
				KeysData_301 = keysData[301];
				KeysData_302 = keysData[302];
				KeysData_303 = keysData[303];
				KeysData_304 = keysData[304];
				KeysData_305 = keysData[305];
				KeysData_306 = keysData[306];
				KeysData_307 = keysData[307];
				KeysData_308 = keysData[308];
				KeysData_309 = keysData[309];
				KeysData_310 = keysData[310];
				KeysData_311 = keysData[311];
				KeysData_312 = keysData[312];
				KeysData_313 = keysData[313];
				KeysData_314 = keysData[314];
				KeysData_315 = keysData[315];
				KeysData_316 = keysData[316];
				KeysData_317 = keysData[317];
				KeysData_318 = keysData[318];
				KeysData_319 = keysData[319];
				KeysData_320 = keysData[320];
				KeysData_321 = keysData[321];
				KeysData_322 = keysData[322];
				KeysData_323 = keysData[323];
				KeysData_324 = keysData[324];
				KeysData_325 = keysData[325];
				KeysData_326 = keysData[326];
				KeysData_327 = keysData[327];
				KeysData_328 = keysData[328];
				KeysData_329 = keysData[329];
				KeysData_330 = keysData[330];
				KeysData_331 = keysData[331];
				KeysData_332 = keysData[332];
				KeysData_333 = keysData[333];
				KeysData_334 = keysData[334];
				KeysData_335 = keysData[335];
				KeysData_336 = keysData[336];
				KeysData_337 = keysData[337];
				KeysData_338 = keysData[338];
				KeysData_339 = keysData[339];
				KeysData_340 = keysData[340];
				KeysData_341 = keysData[341];
				KeysData_342 = keysData[342];
				KeysData_343 = keysData[343];
				KeysData_344 = keysData[344];
				KeysData_345 = keysData[345];
				KeysData_346 = keysData[346];
				KeysData_347 = keysData[347];
				KeysData_348 = keysData[348];
				KeysData_349 = keysData[349];
				KeysData_350 = keysData[350];
				KeysData_351 = keysData[351];
				KeysData_352 = keysData[352];
				KeysData_353 = keysData[353];
				KeysData_354 = keysData[354];
				KeysData_355 = keysData[355];
				KeysData_356 = keysData[356];
				KeysData_357 = keysData[357];
				KeysData_358 = keysData[358];
				KeysData_359 = keysData[359];
				KeysData_360 = keysData[360];
				KeysData_361 = keysData[361];
				KeysData_362 = keysData[362];
				KeysData_363 = keysData[363];
				KeysData_364 = keysData[364];
				KeysData_365 = keysData[365];
				KeysData_366 = keysData[366];
				KeysData_367 = keysData[367];
				KeysData_368 = keysData[368];
				KeysData_369 = keysData[369];
				KeysData_370 = keysData[370];
				KeysData_371 = keysData[371];
				KeysData_372 = keysData[372];
				KeysData_373 = keysData[373];
				KeysData_374 = keysData[374];
				KeysData_375 = keysData[375];
				KeysData_376 = keysData[376];
				KeysData_377 = keysData[377];
				KeysData_378 = keysData[378];
				KeysData_379 = keysData[379];
				KeysData_380 = keysData[380];
				KeysData_381 = keysData[381];
				KeysData_382 = keysData[382];
				KeysData_383 = keysData[383];
				KeysData_384 = keysData[384];
				KeysData_385 = keysData[385];
				KeysData_386 = keysData[386];
				KeysData_387 = keysData[387];
				KeysData_388 = keysData[388];
				KeysData_389 = keysData[389];
				KeysData_390 = keysData[390];
				KeysData_391 = keysData[391];
				KeysData_392 = keysData[392];
				KeysData_393 = keysData[393];
				KeysData_394 = keysData[394];
				KeysData_395 = keysData[395];
				KeysData_396 = keysData[396];
				KeysData_397 = keysData[397];
				KeysData_398 = keysData[398];
				KeysData_399 = keysData[399];
				KeysData_400 = keysData[400];
				KeysData_401 = keysData[401];
				KeysData_402 = keysData[402];
				KeysData_403 = keysData[403];
				KeysData_404 = keysData[404];
				KeysData_405 = keysData[405];
				KeysData_406 = keysData[406];
				KeysData_407 = keysData[407];
				KeysData_408 = keysData[408];
				KeysData_409 = keysData[409];
				KeysData_410 = keysData[410];
				KeysData_411 = keysData[411];
				KeysData_412 = keysData[412];
				KeysData_413 = keysData[413];
				KeysData_414 = keysData[414];
				KeysData_415 = keysData[415];
				KeysData_416 = keysData[416];
				KeysData_417 = keysData[417];
				KeysData_418 = keysData[418];
				KeysData_419 = keysData[419];
				KeysData_420 = keysData[420];
				KeysData_421 = keysData[421];
				KeysData_422 = keysData[422];
				KeysData_423 = keysData[423];
				KeysData_424 = keysData[424];
				KeysData_425 = keysData[425];
				KeysData_426 = keysData[426];
				KeysData_427 = keysData[427];
				KeysData_428 = keysData[428];
				KeysData_429 = keysData[429];
				KeysData_430 = keysData[430];
				KeysData_431 = keysData[431];
				KeysData_432 = keysData[432];
				KeysData_433 = keysData[433];
				KeysData_434 = keysData[434];
				KeysData_435 = keysData[435];
				KeysData_436 = keysData[436];
				KeysData_437 = keysData[437];
				KeysData_438 = keysData[438];
				KeysData_439 = keysData[439];
				KeysData_440 = keysData[440];
				KeysData_441 = keysData[441];
				KeysData_442 = keysData[442];
				KeysData_443 = keysData[443];
				KeysData_444 = keysData[444];
				KeysData_445 = keysData[445];
				KeysData_446 = keysData[446];
				KeysData_447 = keysData[447];
				KeysData_448 = keysData[448];
				KeysData_449 = keysData[449];
				KeysData_450 = keysData[450];
				KeysData_451 = keysData[451];
				KeysData_452 = keysData[452];
				KeysData_453 = keysData[453];
				KeysData_454 = keysData[454];
				KeysData_455 = keysData[455];
				KeysData_456 = keysData[456];
				KeysData_457 = keysData[457];
				KeysData_458 = keysData[458];
				KeysData_459 = keysData[459];
				KeysData_460 = keysData[460];
				KeysData_461 = keysData[461];
				KeysData_462 = keysData[462];
				KeysData_463 = keysData[463];
				KeysData_464 = keysData[464];
				KeysData_465 = keysData[465];
				KeysData_466 = keysData[466];
				KeysData_467 = keysData[467];
				KeysData_468 = keysData[468];
				KeysData_469 = keysData[469];
				KeysData_470 = keysData[470];
				KeysData_471 = keysData[471];
				KeysData_472 = keysData[472];
				KeysData_473 = keysData[473];
				KeysData_474 = keysData[474];
				KeysData_475 = keysData[475];
				KeysData_476 = keysData[476];
				KeysData_477 = keysData[477];
				KeysData_478 = keysData[478];
				KeysData_479 = keysData[479];
				KeysData_480 = keysData[480];
				KeysData_481 = keysData[481];
				KeysData_482 = keysData[482];
				KeysData_483 = keysData[483];
				KeysData_484 = keysData[484];
				KeysData_485 = keysData[485];
				KeysData_486 = keysData[486];
				KeysData_487 = keysData[487];
				KeysData_488 = keysData[488];
				KeysData_489 = keysData[489];
				KeysData_490 = keysData[490];
				KeysData_491 = keysData[491];
				KeysData_492 = keysData[492];
				KeysData_493 = keysData[493];
				KeysData_494 = keysData[494];
				KeysData_495 = keysData[495];
				KeysData_496 = keysData[496];
				KeysData_497 = keysData[497];
				KeysData_498 = keysData[498];
				KeysData_499 = keysData[499];
				KeysData_500 = keysData[500];
				KeysData_501 = keysData[501];
				KeysData_502 = keysData[502];
				KeysData_503 = keysData[503];
				KeysData_504 = keysData[504];
				KeysData_505 = keysData[505];
				KeysData_506 = keysData[506];
				KeysData_507 = keysData[507];
				KeysData_508 = keysData[508];
				KeysData_509 = keysData[509];
				KeysData_510 = keysData[510];
				KeysData_511 = keysData[511];
				KeysData_512 = keysData[512];
				KeysData_513 = keysData[513];
				KeysData_514 = keysData[514];
				KeysData_515 = keysData[515];
				KeysData_516 = keysData[516];
				KeysData_517 = keysData[517];
				KeysData_518 = keysData[518];
				KeysData_519 = keysData[519];
				KeysData_520 = keysData[520];
				KeysData_521 = keysData[521];
				KeysData_522 = keysData[522];
				KeysData_523 = keysData[523];
				KeysData_524 = keysData[524];
				KeysData_525 = keysData[525];
				KeysData_526 = keysData[526];
				KeysData_527 = keysData[527];
				KeysData_528 = keysData[528];
				KeysData_529 = keysData[529];
				KeysData_530 = keysData[530];
				KeysData_531 = keysData[531];
				KeysData_532 = keysData[532];
				KeysData_533 = keysData[533];
				KeysData_534 = keysData[534];
				KeysData_535 = keysData[535];
				KeysData_536 = keysData[536];
				KeysData_537 = keysData[537];
				KeysData_538 = keysData[538];
				KeysData_539 = keysData[539];
				KeysData_540 = keysData[540];
				KeysData_541 = keysData[541];
				KeysData_542 = keysData[542];
				KeysData_543 = keysData[543];
				KeysData_544 = keysData[544];
				KeysData_545 = keysData[545];
				KeysData_546 = keysData[546];
				KeysData_547 = keysData[547];
				KeysData_548 = keysData[548];
				KeysData_549 = keysData[549];
				KeysData_550 = keysData[550];
				KeysData_551 = keysData[551];
				KeysData_552 = keysData[552];
				KeysData_553 = keysData[553];
				KeysData_554 = keysData[554];
				KeysData_555 = keysData[555];
				KeysData_556 = keysData[556];
				KeysData_557 = keysData[557];
				KeysData_558 = keysData[558];
				KeysData_559 = keysData[559];
				KeysData_560 = keysData[560];
				KeysData_561 = keysData[561];
				KeysData_562 = keysData[562];
				KeysData_563 = keysData[563];
				KeysData_564 = keysData[564];
				KeysData_565 = keysData[565];
				KeysData_566 = keysData[566];
				KeysData_567 = keysData[567];
				KeysData_568 = keysData[568];
				KeysData_569 = keysData[569];
				KeysData_570 = keysData[570];
				KeysData_571 = keysData[571];
				KeysData_572 = keysData[572];
				KeysData_573 = keysData[573];
				KeysData_574 = keysData[574];
				KeysData_575 = keysData[575];
				KeysData_576 = keysData[576];
				KeysData_577 = keysData[577];
				KeysData_578 = keysData[578];
				KeysData_579 = keysData[579];
				KeysData_580 = keysData[580];
				KeysData_581 = keysData[581];
				KeysData_582 = keysData[582];
				KeysData_583 = keysData[583];
				KeysData_584 = keysData[584];
				KeysData_585 = keysData[585];
				KeysData_586 = keysData[586];
				KeysData_587 = keysData[587];
				KeysData_588 = keysData[588];
				KeysData_589 = keysData[589];
				KeysData_590 = keysData[590];
				KeysData_591 = keysData[591];
				KeysData_592 = keysData[592];
				KeysData_593 = keysData[593];
				KeysData_594 = keysData[594];
				KeysData_595 = keysData[595];
				KeysData_596 = keysData[596];
				KeysData_597 = keysData[597];
				KeysData_598 = keysData[598];
				KeysData_599 = keysData[599];
				KeysData_600 = keysData[600];
				KeysData_601 = keysData[601];
				KeysData_602 = keysData[602];
				KeysData_603 = keysData[603];
				KeysData_604 = keysData[604];
				KeysData_605 = keysData[605];
				KeysData_606 = keysData[606];
				KeysData_607 = keysData[607];
				KeysData_608 = keysData[608];
				KeysData_609 = keysData[609];
				KeysData_610 = keysData[610];
				KeysData_611 = keysData[611];
				KeysData_612 = keysData[612];
				KeysData_613 = keysData[613];
				KeysData_614 = keysData[614];
				KeysData_615 = keysData[615];
				KeysData_616 = keysData[616];
				KeysData_617 = keysData[617];
				KeysData_618 = keysData[618];
				KeysData_619 = keysData[619];
				KeysData_620 = keysData[620];
				KeysData_621 = keysData[621];
				KeysData_622 = keysData[622];
				KeysData_623 = keysData[623];
				KeysData_624 = keysData[624];
				KeysData_625 = keysData[625];
				KeysData_626 = keysData[626];
				KeysData_627 = keysData[627];
				KeysData_628 = keysData[628];
				KeysData_629 = keysData[629];
				KeysData_630 = keysData[630];
				KeysData_631 = keysData[631];
				KeysData_632 = keysData[632];
				KeysData_633 = keysData[633];
				KeysData_634 = keysData[634];
				KeysData_635 = keysData[635];
				KeysData_636 = keysData[636];
				KeysData_637 = keysData[637];
				KeysData_638 = keysData[638];
				KeysData_639 = keysData[639];
				KeysData_640 = keysData[640];
				KeysData_641 = keysData[641];
				KeysData_642 = keysData[642];
				KeysData_643 = keysData[643];
				KeysData_644 = keysData[644];
				KeysData_645 = keysData[645];
				KeysData_646 = keysData[646];
				KeysData_647 = keysData[647];
				KeysData_648 = keysData[648];
				KeysData_649 = keysData[649];
				KeysData_650 = keysData[650];
				KeysData_651 = keysData[651];
				KeysData_652 = keysData[652];
				KeysData_653 = keysData[653];
				KeysData_654 = keysData[654];
				KeysData_655 = keysData[655];
				KeysData_656 = keysData[656];
				KeysData_657 = keysData[657];
				KeysData_658 = keysData[658];
				KeysData_659 = keysData[659];
				KeysData_660 = keysData[660];
				KeysData_661 = keysData[661];
				KeysData_662 = keysData[662];
				KeysData_663 = keysData[663];
				KeysData_664 = keysData[664];
				KeysData_665 = keysData[665];
			}
			WantCaptureMouseUnlessPopupClose = wantCaptureMouseUnlessPopupClose ? (byte)1 : (byte)0;
			MousePosPrev = mousePosPrev;
			if (mouseClickedPos != default)
			{
				MouseClickedPos_0 = mouseClickedPos[0];
				MouseClickedPos_1 = mouseClickedPos[1];
				MouseClickedPos_2 = mouseClickedPos[2];
				MouseClickedPos_3 = mouseClickedPos[3];
				MouseClickedPos_4 = mouseClickedPos[4];
			}
			if (mouseClickedTime != default)
			{
				MouseClickedTime_0 = mouseClickedTime[0];
				MouseClickedTime_1 = mouseClickedTime[1];
				MouseClickedTime_2 = mouseClickedTime[2];
				MouseClickedTime_3 = mouseClickedTime[3];
				MouseClickedTime_4 = mouseClickedTime[4];
			}
			if (mouseClicked != default)
			{
				MouseClicked_0 = mouseClicked[0];
				MouseClicked_1 = mouseClicked[1];
				MouseClicked_2 = mouseClicked[2];
				MouseClicked_3 = mouseClicked[3];
				MouseClicked_4 = mouseClicked[4];
			}
			if (mouseDoubleClicked != default)
			{
				MouseDoubleClicked_0 = mouseDoubleClicked[0];
				MouseDoubleClicked_1 = mouseDoubleClicked[1];
				MouseDoubleClicked_2 = mouseDoubleClicked[2];
				MouseDoubleClicked_3 = mouseDoubleClicked[3];
				MouseDoubleClicked_4 = mouseDoubleClicked[4];
			}
			if (mouseClickedCount != default)
			{
				MouseClickedCount_0 = mouseClickedCount[0];
				MouseClickedCount_1 = mouseClickedCount[1];
				MouseClickedCount_2 = mouseClickedCount[2];
				MouseClickedCount_3 = mouseClickedCount[3];
				MouseClickedCount_4 = mouseClickedCount[4];
			}
			if (mouseClickedLastCount != default)
			{
				MouseClickedLastCount_0 = mouseClickedLastCount[0];
				MouseClickedLastCount_1 = mouseClickedLastCount[1];
				MouseClickedLastCount_2 = mouseClickedLastCount[2];
				MouseClickedLastCount_3 = mouseClickedLastCount[3];
				MouseClickedLastCount_4 = mouseClickedLastCount[4];
			}
			if (mouseReleased != default)
			{
				MouseReleased_0 = mouseReleased[0];
				MouseReleased_1 = mouseReleased[1];
				MouseReleased_2 = mouseReleased[2];
				MouseReleased_3 = mouseReleased[3];
				MouseReleased_4 = mouseReleased[4];
			}
			if (mouseDownOwned != default)
			{
				MouseDownOwned_0 = mouseDownOwned[0];
				MouseDownOwned_1 = mouseDownOwned[1];
				MouseDownOwned_2 = mouseDownOwned[2];
				MouseDownOwned_3 = mouseDownOwned[3];
				MouseDownOwned_4 = mouseDownOwned[4];
			}
			if (mouseDownOwnedUnlessPopupClose != default)
			{
				MouseDownOwnedUnlessPopupClose_0 = mouseDownOwnedUnlessPopupClose[0];
				MouseDownOwnedUnlessPopupClose_1 = mouseDownOwnedUnlessPopupClose[1];
				MouseDownOwnedUnlessPopupClose_2 = mouseDownOwnedUnlessPopupClose[2];
				MouseDownOwnedUnlessPopupClose_3 = mouseDownOwnedUnlessPopupClose[3];
				MouseDownOwnedUnlessPopupClose_4 = mouseDownOwnedUnlessPopupClose[4];
			}
			MouseWheelRequestAxisSwap = mouseWheelRequestAxisSwap ? (byte)1 : (byte)0;
			if (mouseDownDuration != default)
			{
				MouseDownDuration_0 = mouseDownDuration[0];
				MouseDownDuration_1 = mouseDownDuration[1];
				MouseDownDuration_2 = mouseDownDuration[2];
				MouseDownDuration_3 = mouseDownDuration[3];
				MouseDownDuration_4 = mouseDownDuration[4];
			}
			if (mouseDownDurationPrev != default)
			{
				MouseDownDurationPrev_0 = mouseDownDurationPrev[0];
				MouseDownDurationPrev_1 = mouseDownDurationPrev[1];
				MouseDownDurationPrev_2 = mouseDownDurationPrev[2];
				MouseDownDurationPrev_3 = mouseDownDurationPrev[3];
				MouseDownDurationPrev_4 = mouseDownDurationPrev[4];
			}
			if (mouseDragMaxDistanceAbs != default)
			{
				MouseDragMaxDistanceAbs_0 = mouseDragMaxDistanceAbs[0];
				MouseDragMaxDistanceAbs_1 = mouseDragMaxDistanceAbs[1];
				MouseDragMaxDistanceAbs_2 = mouseDragMaxDistanceAbs[2];
				MouseDragMaxDistanceAbs_3 = mouseDragMaxDistanceAbs[3];
				MouseDragMaxDistanceAbs_4 = mouseDragMaxDistanceAbs[4];
			}
			if (mouseDragMaxDistanceSqr != default)
			{
				MouseDragMaxDistanceSqr_0 = mouseDragMaxDistanceSqr[0];
				MouseDragMaxDistanceSqr_1 = mouseDragMaxDistanceSqr[1];
				MouseDragMaxDistanceSqr_2 = mouseDragMaxDistanceSqr[2];
				MouseDragMaxDistanceSqr_3 = mouseDragMaxDistanceSqr[3];
				MouseDragMaxDistanceSqr_4 = mouseDragMaxDistanceSqr[4];
			}
			PenPressure = penPressure;
			AppFocusLost = appFocusLost ? (byte)1 : (byte)0;
			AppAcceptingEvents = appAcceptingEvents ? (byte)1 : (byte)0;
			BackendUsingLegacyKeyArrays = backendUsingLegacyKeyArrays;
			BackendUsingLegacyNavInputArray = backendUsingLegacyNavInputArray ? (byte)1 : (byte)0;
			InputQueueSurrogate = inputQueueSurrogate;
			InputQueueCharacters = inputQueueCharacters;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiIO(int configFlags = default, int backendFlags = default, Vector2 displaySize = default, float deltaTime = default, float iniSavingRate = default, byte* iniFilename = default, byte* logFilename = default, void* userData = default, ImFontAtlas* fonts = default, float fontGlobalScale = default, bool fontAllowUserScaling = default, ImFont* fontDefault = default, Vector2 displayFramebufferScale = default, bool configDockingNoSplit = default, bool configDockingWithShift = default, bool configDockingAlwaysTabBar = default, bool configDockingTransparentPayload = default, bool configViewportsNoAutoMerge = default, bool configViewportsNoTaskBarIcon = default, bool configViewportsNoDecoration = default, bool configViewportsNoDefaultParent = default, bool mouseDrawCursor = default, bool configMacOsxBehaviors = default, bool configInputTrickleEventQueue = default, bool configInputTextCursorBlink = default, bool configInputTextEnterKeepActive = default, bool configDragClickToInputText = default, bool configWindowsResizeFromEdges = default, bool configWindowsMoveFromTitleBarOnly = default, float configMemoryCompactTimer = default, float mouseDoubleClickTime = default, float mouseDoubleClickMaxDist = default, float mouseDragThreshold = default, float keyRepeatDelay = default, float keyRepeatRate = default, bool configDebugBeginReturnValueOnce = default, bool configDebugBeginReturnValueLoop = default, bool configDebugIgnoreFocusLoss = default, bool configDebugIniSettings = default, byte* backendPlatformName = default, byte* backendRendererName = default, void* backendPlatformUserData = default, void* backendRendererUserData = default, void* backendLanguageUserData = default, delegate*<void*, byte*> getClipboardTextFn = default, delegate*<void*, byte*, void> setClipboardTextFn = default, void* clipboardUserData = default, delegate*<ImGuiViewport*, ImGuiPlatformImeData*, void> setPlatformImeDataFn = default, char platformLocaleDecimalPoint = default, bool wantCaptureMouse = default, bool wantCaptureKeyboard = default, bool wantTextInput = default, bool wantSetMousePos = default, bool wantSaveIniSettings = default, bool navActive = default, bool navVisible = default, float framerate = default, int metricsRenderVertices = default, int metricsRenderIndices = default, int metricsRenderWindows = default, int metricsActiveWindows = default, Vector2 mouseDelta = default, Span<int> keyMap = default, Span<bool> keysDown = default, Span<float> navInputs = default, void* Unusedpadding = default, ImGuiContext* ctx = default, Vector2 mousePos = default, Span<bool> mouseDown = default, float mouseWheel = default, float mouseWheelH = default, ImGuiMouseSource mouseSource = default, uint mouseHoveredViewport = default, bool keyCtrl = default, bool keyShift = default, bool keyAlt = default, bool keySuper = default, int keyMods = default, Span<ImGuiKeyData> keysData = default, bool wantCaptureMouseUnlessPopupClose = default, Vector2 mousePosPrev = default, Span<Vector2> mouseClickedPos = default, Span<double> mouseClickedTime = default, Span<bool> mouseClicked = default, Span<bool> mouseDoubleClicked = default, Span<ushort> mouseClickedCount = default, Span<ushort> mouseClickedLastCount = default, Span<bool> mouseReleased = default, Span<bool> mouseDownOwned = default, Span<bool> mouseDownOwnedUnlessPopupClose = default, bool mouseWheelRequestAxisSwap = default, Span<float> mouseDownDuration = default, Span<float> mouseDownDurationPrev = default, Span<Vector2> mouseDragMaxDistanceAbs = default, Span<float> mouseDragMaxDistanceSqr = default, float penPressure = default, bool appFocusLost = default, bool appAcceptingEvents = default, byte backendUsingLegacyKeyArrays = default, bool backendUsingLegacyNavInputArray = default, ushort inputQueueSurrogate = default, ImVectorImWchar inputQueueCharacters = default)
		{
			ConfigFlags = configFlags;
			BackendFlags = backendFlags;
			DisplaySize = displaySize;
			DeltaTime = deltaTime;
			IniSavingRate = iniSavingRate;
			IniFilename = iniFilename;
			LogFilename = logFilename;
			UserData = userData;
			Fonts = fonts;
			FontGlobalScale = fontGlobalScale;
			FontAllowUserScaling = fontAllowUserScaling ? (byte)1 : (byte)0;
			FontDefault = fontDefault;
			DisplayFramebufferScale = displayFramebufferScale;
			ConfigDockingNoSplit = configDockingNoSplit ? (byte)1 : (byte)0;
			ConfigDockingWithShift = configDockingWithShift ? (byte)1 : (byte)0;
			ConfigDockingAlwaysTabBar = configDockingAlwaysTabBar ? (byte)1 : (byte)0;
			ConfigDockingTransparentPayload = configDockingTransparentPayload ? (byte)1 : (byte)0;
			ConfigViewportsNoAutoMerge = configViewportsNoAutoMerge ? (byte)1 : (byte)0;
			ConfigViewportsNoTaskBarIcon = configViewportsNoTaskBarIcon ? (byte)1 : (byte)0;
			ConfigViewportsNoDecoration = configViewportsNoDecoration ? (byte)1 : (byte)0;
			ConfigViewportsNoDefaultParent = configViewportsNoDefaultParent ? (byte)1 : (byte)0;
			MouseDrawCursor = mouseDrawCursor ? (byte)1 : (byte)0;
			ConfigMacOSXBehaviors = configMacOsxBehaviors ? (byte)1 : (byte)0;
			ConfigInputTrickleEventQueue = configInputTrickleEventQueue ? (byte)1 : (byte)0;
			ConfigInputTextCursorBlink = configInputTextCursorBlink ? (byte)1 : (byte)0;
			ConfigInputTextEnterKeepActive = configInputTextEnterKeepActive ? (byte)1 : (byte)0;
			ConfigDragClickToInputText = configDragClickToInputText ? (byte)1 : (byte)0;
			ConfigWindowsResizeFromEdges = configWindowsResizeFromEdges ? (byte)1 : (byte)0;
			ConfigWindowsMoveFromTitleBarOnly = configWindowsMoveFromTitleBarOnly ? (byte)1 : (byte)0;
			ConfigMemoryCompactTimer = configMemoryCompactTimer;
			MouseDoubleClickTime = mouseDoubleClickTime;
			MouseDoubleClickMaxDist = mouseDoubleClickMaxDist;
			MouseDragThreshold = mouseDragThreshold;
			KeyRepeatDelay = keyRepeatDelay;
			KeyRepeatRate = keyRepeatRate;
			ConfigDebugBeginReturnValueOnce = configDebugBeginReturnValueOnce ? (byte)1 : (byte)0;
			ConfigDebugBeginReturnValueLoop = configDebugBeginReturnValueLoop ? (byte)1 : (byte)0;
			ConfigDebugIgnoreFocusLoss = configDebugIgnoreFocusLoss ? (byte)1 : (byte)0;
			ConfigDebugIniSettings = configDebugIniSettings ? (byte)1 : (byte)0;
			BackendPlatformName = backendPlatformName;
			BackendRendererName = backendRendererName;
			BackendPlatformUserData = backendPlatformUserData;
			BackendRendererUserData = backendRendererUserData;
			BackendLanguageUserData = backendLanguageUserData;
			GetClipboardTextFn = (void*)getClipboardTextFn;
			SetClipboardTextFn = (void*)setClipboardTextFn;
			ClipboardUserData = clipboardUserData;
			SetPlatformImeDataFn = (void*)setPlatformImeDataFn;
			PlatformLocaleDecimalPoint = platformLocaleDecimalPoint;
			WantCaptureMouse = wantCaptureMouse ? (byte)1 : (byte)0;
			WantCaptureKeyboard = wantCaptureKeyboard ? (byte)1 : (byte)0;
			WantTextInput = wantTextInput ? (byte)1 : (byte)0;
			WantSetMousePos = wantSetMousePos ? (byte)1 : (byte)0;
			WantSaveIniSettings = wantSaveIniSettings ? (byte)1 : (byte)0;
			NavActive = navActive ? (byte)1 : (byte)0;
			NavVisible = navVisible ? (byte)1 : (byte)0;
			Framerate = framerate;
			MetricsRenderVertices = metricsRenderVertices;
			MetricsRenderIndices = metricsRenderIndices;
			MetricsRenderWindows = metricsRenderWindows;
			MetricsActiveWindows = metricsActiveWindows;
			MouseDelta = mouseDelta;
			if (keyMap != default)
			{
				KeyMap_0 = keyMap[0];
				KeyMap_1 = keyMap[1];
				KeyMap_2 = keyMap[2];
				KeyMap_3 = keyMap[3];
				KeyMap_4 = keyMap[4];
				KeyMap_5 = keyMap[5];
				KeyMap_6 = keyMap[6];
				KeyMap_7 = keyMap[7];
				KeyMap_8 = keyMap[8];
				KeyMap_9 = keyMap[9];
				KeyMap_10 = keyMap[10];
				KeyMap_11 = keyMap[11];
				KeyMap_12 = keyMap[12];
				KeyMap_13 = keyMap[13];
				KeyMap_14 = keyMap[14];
				KeyMap_15 = keyMap[15];
				KeyMap_16 = keyMap[16];
				KeyMap_17 = keyMap[17];
				KeyMap_18 = keyMap[18];
				KeyMap_19 = keyMap[19];
				KeyMap_20 = keyMap[20];
				KeyMap_21 = keyMap[21];
				KeyMap_22 = keyMap[22];
				KeyMap_23 = keyMap[23];
				KeyMap_24 = keyMap[24];
				KeyMap_25 = keyMap[25];
				KeyMap_26 = keyMap[26];
				KeyMap_27 = keyMap[27];
				KeyMap_28 = keyMap[28];
				KeyMap_29 = keyMap[29];
				KeyMap_30 = keyMap[30];
				KeyMap_31 = keyMap[31];
				KeyMap_32 = keyMap[32];
				KeyMap_33 = keyMap[33];
				KeyMap_34 = keyMap[34];
				KeyMap_35 = keyMap[35];
				KeyMap_36 = keyMap[36];
				KeyMap_37 = keyMap[37];
				KeyMap_38 = keyMap[38];
				KeyMap_39 = keyMap[39];
				KeyMap_40 = keyMap[40];
				KeyMap_41 = keyMap[41];
				KeyMap_42 = keyMap[42];
				KeyMap_43 = keyMap[43];
				KeyMap_44 = keyMap[44];
				KeyMap_45 = keyMap[45];
				KeyMap_46 = keyMap[46];
				KeyMap_47 = keyMap[47];
				KeyMap_48 = keyMap[48];
				KeyMap_49 = keyMap[49];
				KeyMap_50 = keyMap[50];
				KeyMap_51 = keyMap[51];
				KeyMap_52 = keyMap[52];
				KeyMap_53 = keyMap[53];
				KeyMap_54 = keyMap[54];
				KeyMap_55 = keyMap[55];
				KeyMap_56 = keyMap[56];
				KeyMap_57 = keyMap[57];
				KeyMap_58 = keyMap[58];
				KeyMap_59 = keyMap[59];
				KeyMap_60 = keyMap[60];
				KeyMap_61 = keyMap[61];
				KeyMap_62 = keyMap[62];
				KeyMap_63 = keyMap[63];
				KeyMap_64 = keyMap[64];
				KeyMap_65 = keyMap[65];
				KeyMap_66 = keyMap[66];
				KeyMap_67 = keyMap[67];
				KeyMap_68 = keyMap[68];
				KeyMap_69 = keyMap[69];
				KeyMap_70 = keyMap[70];
				KeyMap_71 = keyMap[71];
				KeyMap_72 = keyMap[72];
				KeyMap_73 = keyMap[73];
				KeyMap_74 = keyMap[74];
				KeyMap_75 = keyMap[75];
				KeyMap_76 = keyMap[76];
				KeyMap_77 = keyMap[77];
				KeyMap_78 = keyMap[78];
				KeyMap_79 = keyMap[79];
				KeyMap_80 = keyMap[80];
				KeyMap_81 = keyMap[81];
				KeyMap_82 = keyMap[82];
				KeyMap_83 = keyMap[83];
				KeyMap_84 = keyMap[84];
				KeyMap_85 = keyMap[85];
				KeyMap_86 = keyMap[86];
				KeyMap_87 = keyMap[87];
				KeyMap_88 = keyMap[88];
				KeyMap_89 = keyMap[89];
				KeyMap_90 = keyMap[90];
				KeyMap_91 = keyMap[91];
				KeyMap_92 = keyMap[92];
				KeyMap_93 = keyMap[93];
				KeyMap_94 = keyMap[94];
				KeyMap_95 = keyMap[95];
				KeyMap_96 = keyMap[96];
				KeyMap_97 = keyMap[97];
				KeyMap_98 = keyMap[98];
				KeyMap_99 = keyMap[99];
				KeyMap_100 = keyMap[100];
				KeyMap_101 = keyMap[101];
				KeyMap_102 = keyMap[102];
				KeyMap_103 = keyMap[103];
				KeyMap_104 = keyMap[104];
				KeyMap_105 = keyMap[105];
				KeyMap_106 = keyMap[106];
				KeyMap_107 = keyMap[107];
				KeyMap_108 = keyMap[108];
				KeyMap_109 = keyMap[109];
				KeyMap_110 = keyMap[110];
				KeyMap_111 = keyMap[111];
				KeyMap_112 = keyMap[112];
				KeyMap_113 = keyMap[113];
				KeyMap_114 = keyMap[114];
				KeyMap_115 = keyMap[115];
				KeyMap_116 = keyMap[116];
				KeyMap_117 = keyMap[117];
				KeyMap_118 = keyMap[118];
				KeyMap_119 = keyMap[119];
				KeyMap_120 = keyMap[120];
				KeyMap_121 = keyMap[121];
				KeyMap_122 = keyMap[122];
				KeyMap_123 = keyMap[123];
				KeyMap_124 = keyMap[124];
				KeyMap_125 = keyMap[125];
				KeyMap_126 = keyMap[126];
				KeyMap_127 = keyMap[127];
				KeyMap_128 = keyMap[128];
				KeyMap_129 = keyMap[129];
				KeyMap_130 = keyMap[130];
				KeyMap_131 = keyMap[131];
				KeyMap_132 = keyMap[132];
				KeyMap_133 = keyMap[133];
				KeyMap_134 = keyMap[134];
				KeyMap_135 = keyMap[135];
				KeyMap_136 = keyMap[136];
				KeyMap_137 = keyMap[137];
				KeyMap_138 = keyMap[138];
				KeyMap_139 = keyMap[139];
				KeyMap_140 = keyMap[140];
				KeyMap_141 = keyMap[141];
				KeyMap_142 = keyMap[142];
				KeyMap_143 = keyMap[143];
				KeyMap_144 = keyMap[144];
				KeyMap_145 = keyMap[145];
				KeyMap_146 = keyMap[146];
				KeyMap_147 = keyMap[147];
				KeyMap_148 = keyMap[148];
				KeyMap_149 = keyMap[149];
				KeyMap_150 = keyMap[150];
				KeyMap_151 = keyMap[151];
				KeyMap_152 = keyMap[152];
				KeyMap_153 = keyMap[153];
				KeyMap_154 = keyMap[154];
				KeyMap_155 = keyMap[155];
				KeyMap_156 = keyMap[156];
				KeyMap_157 = keyMap[157];
				KeyMap_158 = keyMap[158];
				KeyMap_159 = keyMap[159];
				KeyMap_160 = keyMap[160];
				KeyMap_161 = keyMap[161];
				KeyMap_162 = keyMap[162];
				KeyMap_163 = keyMap[163];
				KeyMap_164 = keyMap[164];
				KeyMap_165 = keyMap[165];
				KeyMap_166 = keyMap[166];
				KeyMap_167 = keyMap[167];
				KeyMap_168 = keyMap[168];
				KeyMap_169 = keyMap[169];
				KeyMap_170 = keyMap[170];
				KeyMap_171 = keyMap[171];
				KeyMap_172 = keyMap[172];
				KeyMap_173 = keyMap[173];
				KeyMap_174 = keyMap[174];
				KeyMap_175 = keyMap[175];
				KeyMap_176 = keyMap[176];
				KeyMap_177 = keyMap[177];
				KeyMap_178 = keyMap[178];
				KeyMap_179 = keyMap[179];
				KeyMap_180 = keyMap[180];
				KeyMap_181 = keyMap[181];
				KeyMap_182 = keyMap[182];
				KeyMap_183 = keyMap[183];
				KeyMap_184 = keyMap[184];
				KeyMap_185 = keyMap[185];
				KeyMap_186 = keyMap[186];
				KeyMap_187 = keyMap[187];
				KeyMap_188 = keyMap[188];
				KeyMap_189 = keyMap[189];
				KeyMap_190 = keyMap[190];
				KeyMap_191 = keyMap[191];
				KeyMap_192 = keyMap[192];
				KeyMap_193 = keyMap[193];
				KeyMap_194 = keyMap[194];
				KeyMap_195 = keyMap[195];
				KeyMap_196 = keyMap[196];
				KeyMap_197 = keyMap[197];
				KeyMap_198 = keyMap[198];
				KeyMap_199 = keyMap[199];
				KeyMap_200 = keyMap[200];
				KeyMap_201 = keyMap[201];
				KeyMap_202 = keyMap[202];
				KeyMap_203 = keyMap[203];
				KeyMap_204 = keyMap[204];
				KeyMap_205 = keyMap[205];
				KeyMap_206 = keyMap[206];
				KeyMap_207 = keyMap[207];
				KeyMap_208 = keyMap[208];
				KeyMap_209 = keyMap[209];
				KeyMap_210 = keyMap[210];
				KeyMap_211 = keyMap[211];
				KeyMap_212 = keyMap[212];
				KeyMap_213 = keyMap[213];
				KeyMap_214 = keyMap[214];
				KeyMap_215 = keyMap[215];
				KeyMap_216 = keyMap[216];
				KeyMap_217 = keyMap[217];
				KeyMap_218 = keyMap[218];
				KeyMap_219 = keyMap[219];
				KeyMap_220 = keyMap[220];
				KeyMap_221 = keyMap[221];
				KeyMap_222 = keyMap[222];
				KeyMap_223 = keyMap[223];
				KeyMap_224 = keyMap[224];
				KeyMap_225 = keyMap[225];
				KeyMap_226 = keyMap[226];
				KeyMap_227 = keyMap[227];
				KeyMap_228 = keyMap[228];
				KeyMap_229 = keyMap[229];
				KeyMap_230 = keyMap[230];
				KeyMap_231 = keyMap[231];
				KeyMap_232 = keyMap[232];
				KeyMap_233 = keyMap[233];
				KeyMap_234 = keyMap[234];
				KeyMap_235 = keyMap[235];
				KeyMap_236 = keyMap[236];
				KeyMap_237 = keyMap[237];
				KeyMap_238 = keyMap[238];
				KeyMap_239 = keyMap[239];
				KeyMap_240 = keyMap[240];
				KeyMap_241 = keyMap[241];
				KeyMap_242 = keyMap[242];
				KeyMap_243 = keyMap[243];
				KeyMap_244 = keyMap[244];
				KeyMap_245 = keyMap[245];
				KeyMap_246 = keyMap[246];
				KeyMap_247 = keyMap[247];
				KeyMap_248 = keyMap[248];
				KeyMap_249 = keyMap[249];
				KeyMap_250 = keyMap[250];
				KeyMap_251 = keyMap[251];
				KeyMap_252 = keyMap[252];
				KeyMap_253 = keyMap[253];
				KeyMap_254 = keyMap[254];
				KeyMap_255 = keyMap[255];
				KeyMap_256 = keyMap[256];
				KeyMap_257 = keyMap[257];
				KeyMap_258 = keyMap[258];
				KeyMap_259 = keyMap[259];
				KeyMap_260 = keyMap[260];
				KeyMap_261 = keyMap[261];
				KeyMap_262 = keyMap[262];
				KeyMap_263 = keyMap[263];
				KeyMap_264 = keyMap[264];
				KeyMap_265 = keyMap[265];
				KeyMap_266 = keyMap[266];
				KeyMap_267 = keyMap[267];
				KeyMap_268 = keyMap[268];
				KeyMap_269 = keyMap[269];
				KeyMap_270 = keyMap[270];
				KeyMap_271 = keyMap[271];
				KeyMap_272 = keyMap[272];
				KeyMap_273 = keyMap[273];
				KeyMap_274 = keyMap[274];
				KeyMap_275 = keyMap[275];
				KeyMap_276 = keyMap[276];
				KeyMap_277 = keyMap[277];
				KeyMap_278 = keyMap[278];
				KeyMap_279 = keyMap[279];
				KeyMap_280 = keyMap[280];
				KeyMap_281 = keyMap[281];
				KeyMap_282 = keyMap[282];
				KeyMap_283 = keyMap[283];
				KeyMap_284 = keyMap[284];
				KeyMap_285 = keyMap[285];
				KeyMap_286 = keyMap[286];
				KeyMap_287 = keyMap[287];
				KeyMap_288 = keyMap[288];
				KeyMap_289 = keyMap[289];
				KeyMap_290 = keyMap[290];
				KeyMap_291 = keyMap[291];
				KeyMap_292 = keyMap[292];
				KeyMap_293 = keyMap[293];
				KeyMap_294 = keyMap[294];
				KeyMap_295 = keyMap[295];
				KeyMap_296 = keyMap[296];
				KeyMap_297 = keyMap[297];
				KeyMap_298 = keyMap[298];
				KeyMap_299 = keyMap[299];
				KeyMap_300 = keyMap[300];
				KeyMap_301 = keyMap[301];
				KeyMap_302 = keyMap[302];
				KeyMap_303 = keyMap[303];
				KeyMap_304 = keyMap[304];
				KeyMap_305 = keyMap[305];
				KeyMap_306 = keyMap[306];
				KeyMap_307 = keyMap[307];
				KeyMap_308 = keyMap[308];
				KeyMap_309 = keyMap[309];
				KeyMap_310 = keyMap[310];
				KeyMap_311 = keyMap[311];
				KeyMap_312 = keyMap[312];
				KeyMap_313 = keyMap[313];
				KeyMap_314 = keyMap[314];
				KeyMap_315 = keyMap[315];
				KeyMap_316 = keyMap[316];
				KeyMap_317 = keyMap[317];
				KeyMap_318 = keyMap[318];
				KeyMap_319 = keyMap[319];
				KeyMap_320 = keyMap[320];
				KeyMap_321 = keyMap[321];
				KeyMap_322 = keyMap[322];
				KeyMap_323 = keyMap[323];
				KeyMap_324 = keyMap[324];
				KeyMap_325 = keyMap[325];
				KeyMap_326 = keyMap[326];
				KeyMap_327 = keyMap[327];
				KeyMap_328 = keyMap[328];
				KeyMap_329 = keyMap[329];
				KeyMap_330 = keyMap[330];
				KeyMap_331 = keyMap[331];
				KeyMap_332 = keyMap[332];
				KeyMap_333 = keyMap[333];
				KeyMap_334 = keyMap[334];
				KeyMap_335 = keyMap[335];
				KeyMap_336 = keyMap[336];
				KeyMap_337 = keyMap[337];
				KeyMap_338 = keyMap[338];
				KeyMap_339 = keyMap[339];
				KeyMap_340 = keyMap[340];
				KeyMap_341 = keyMap[341];
				KeyMap_342 = keyMap[342];
				KeyMap_343 = keyMap[343];
				KeyMap_344 = keyMap[344];
				KeyMap_345 = keyMap[345];
				KeyMap_346 = keyMap[346];
				KeyMap_347 = keyMap[347];
				KeyMap_348 = keyMap[348];
				KeyMap_349 = keyMap[349];
				KeyMap_350 = keyMap[350];
				KeyMap_351 = keyMap[351];
				KeyMap_352 = keyMap[352];
				KeyMap_353 = keyMap[353];
				KeyMap_354 = keyMap[354];
				KeyMap_355 = keyMap[355];
				KeyMap_356 = keyMap[356];
				KeyMap_357 = keyMap[357];
				KeyMap_358 = keyMap[358];
				KeyMap_359 = keyMap[359];
				KeyMap_360 = keyMap[360];
				KeyMap_361 = keyMap[361];
				KeyMap_362 = keyMap[362];
				KeyMap_363 = keyMap[363];
				KeyMap_364 = keyMap[364];
				KeyMap_365 = keyMap[365];
				KeyMap_366 = keyMap[366];
				KeyMap_367 = keyMap[367];
				KeyMap_368 = keyMap[368];
				KeyMap_369 = keyMap[369];
				KeyMap_370 = keyMap[370];
				KeyMap_371 = keyMap[371];
				KeyMap_372 = keyMap[372];
				KeyMap_373 = keyMap[373];
				KeyMap_374 = keyMap[374];
				KeyMap_375 = keyMap[375];
				KeyMap_376 = keyMap[376];
				KeyMap_377 = keyMap[377];
				KeyMap_378 = keyMap[378];
				KeyMap_379 = keyMap[379];
				KeyMap_380 = keyMap[380];
				KeyMap_381 = keyMap[381];
				KeyMap_382 = keyMap[382];
				KeyMap_383 = keyMap[383];
				KeyMap_384 = keyMap[384];
				KeyMap_385 = keyMap[385];
				KeyMap_386 = keyMap[386];
				KeyMap_387 = keyMap[387];
				KeyMap_388 = keyMap[388];
				KeyMap_389 = keyMap[389];
				KeyMap_390 = keyMap[390];
				KeyMap_391 = keyMap[391];
				KeyMap_392 = keyMap[392];
				KeyMap_393 = keyMap[393];
				KeyMap_394 = keyMap[394];
				KeyMap_395 = keyMap[395];
				KeyMap_396 = keyMap[396];
				KeyMap_397 = keyMap[397];
				KeyMap_398 = keyMap[398];
				KeyMap_399 = keyMap[399];
				KeyMap_400 = keyMap[400];
				KeyMap_401 = keyMap[401];
				KeyMap_402 = keyMap[402];
				KeyMap_403 = keyMap[403];
				KeyMap_404 = keyMap[404];
				KeyMap_405 = keyMap[405];
				KeyMap_406 = keyMap[406];
				KeyMap_407 = keyMap[407];
				KeyMap_408 = keyMap[408];
				KeyMap_409 = keyMap[409];
				KeyMap_410 = keyMap[410];
				KeyMap_411 = keyMap[411];
				KeyMap_412 = keyMap[412];
				KeyMap_413 = keyMap[413];
				KeyMap_414 = keyMap[414];
				KeyMap_415 = keyMap[415];
				KeyMap_416 = keyMap[416];
				KeyMap_417 = keyMap[417];
				KeyMap_418 = keyMap[418];
				KeyMap_419 = keyMap[419];
				KeyMap_420 = keyMap[420];
				KeyMap_421 = keyMap[421];
				KeyMap_422 = keyMap[422];
				KeyMap_423 = keyMap[423];
				KeyMap_424 = keyMap[424];
				KeyMap_425 = keyMap[425];
				KeyMap_426 = keyMap[426];
				KeyMap_427 = keyMap[427];
				KeyMap_428 = keyMap[428];
				KeyMap_429 = keyMap[429];
				KeyMap_430 = keyMap[430];
				KeyMap_431 = keyMap[431];
				KeyMap_432 = keyMap[432];
				KeyMap_433 = keyMap[433];
				KeyMap_434 = keyMap[434];
				KeyMap_435 = keyMap[435];
				KeyMap_436 = keyMap[436];
				KeyMap_437 = keyMap[437];
				KeyMap_438 = keyMap[438];
				KeyMap_439 = keyMap[439];
				KeyMap_440 = keyMap[440];
				KeyMap_441 = keyMap[441];
				KeyMap_442 = keyMap[442];
				KeyMap_443 = keyMap[443];
				KeyMap_444 = keyMap[444];
				KeyMap_445 = keyMap[445];
				KeyMap_446 = keyMap[446];
				KeyMap_447 = keyMap[447];
				KeyMap_448 = keyMap[448];
				KeyMap_449 = keyMap[449];
				KeyMap_450 = keyMap[450];
				KeyMap_451 = keyMap[451];
				KeyMap_452 = keyMap[452];
				KeyMap_453 = keyMap[453];
				KeyMap_454 = keyMap[454];
				KeyMap_455 = keyMap[455];
				KeyMap_456 = keyMap[456];
				KeyMap_457 = keyMap[457];
				KeyMap_458 = keyMap[458];
				KeyMap_459 = keyMap[459];
				KeyMap_460 = keyMap[460];
				KeyMap_461 = keyMap[461];
				KeyMap_462 = keyMap[462];
				KeyMap_463 = keyMap[463];
				KeyMap_464 = keyMap[464];
				KeyMap_465 = keyMap[465];
				KeyMap_466 = keyMap[466];
				KeyMap_467 = keyMap[467];
				KeyMap_468 = keyMap[468];
				KeyMap_469 = keyMap[469];
				KeyMap_470 = keyMap[470];
				KeyMap_471 = keyMap[471];
				KeyMap_472 = keyMap[472];
				KeyMap_473 = keyMap[473];
				KeyMap_474 = keyMap[474];
				KeyMap_475 = keyMap[475];
				KeyMap_476 = keyMap[476];
				KeyMap_477 = keyMap[477];
				KeyMap_478 = keyMap[478];
				KeyMap_479 = keyMap[479];
				KeyMap_480 = keyMap[480];
				KeyMap_481 = keyMap[481];
				KeyMap_482 = keyMap[482];
				KeyMap_483 = keyMap[483];
				KeyMap_484 = keyMap[484];
				KeyMap_485 = keyMap[485];
				KeyMap_486 = keyMap[486];
				KeyMap_487 = keyMap[487];
				KeyMap_488 = keyMap[488];
				KeyMap_489 = keyMap[489];
				KeyMap_490 = keyMap[490];
				KeyMap_491 = keyMap[491];
				KeyMap_492 = keyMap[492];
				KeyMap_493 = keyMap[493];
				KeyMap_494 = keyMap[494];
				KeyMap_495 = keyMap[495];
				KeyMap_496 = keyMap[496];
				KeyMap_497 = keyMap[497];
				KeyMap_498 = keyMap[498];
				KeyMap_499 = keyMap[499];
				KeyMap_500 = keyMap[500];
				KeyMap_501 = keyMap[501];
				KeyMap_502 = keyMap[502];
				KeyMap_503 = keyMap[503];
				KeyMap_504 = keyMap[504];
				KeyMap_505 = keyMap[505];
				KeyMap_506 = keyMap[506];
				KeyMap_507 = keyMap[507];
				KeyMap_508 = keyMap[508];
				KeyMap_509 = keyMap[509];
				KeyMap_510 = keyMap[510];
				KeyMap_511 = keyMap[511];
				KeyMap_512 = keyMap[512];
				KeyMap_513 = keyMap[513];
				KeyMap_514 = keyMap[514];
				KeyMap_515 = keyMap[515];
				KeyMap_516 = keyMap[516];
				KeyMap_517 = keyMap[517];
				KeyMap_518 = keyMap[518];
				KeyMap_519 = keyMap[519];
				KeyMap_520 = keyMap[520];
				KeyMap_521 = keyMap[521];
				KeyMap_522 = keyMap[522];
				KeyMap_523 = keyMap[523];
				KeyMap_524 = keyMap[524];
				KeyMap_525 = keyMap[525];
				KeyMap_526 = keyMap[526];
				KeyMap_527 = keyMap[527];
				KeyMap_528 = keyMap[528];
				KeyMap_529 = keyMap[529];
				KeyMap_530 = keyMap[530];
				KeyMap_531 = keyMap[531];
				KeyMap_532 = keyMap[532];
				KeyMap_533 = keyMap[533];
				KeyMap_534 = keyMap[534];
				KeyMap_535 = keyMap[535];
				KeyMap_536 = keyMap[536];
				KeyMap_537 = keyMap[537];
				KeyMap_538 = keyMap[538];
				KeyMap_539 = keyMap[539];
				KeyMap_540 = keyMap[540];
				KeyMap_541 = keyMap[541];
				KeyMap_542 = keyMap[542];
				KeyMap_543 = keyMap[543];
				KeyMap_544 = keyMap[544];
				KeyMap_545 = keyMap[545];
				KeyMap_546 = keyMap[546];
				KeyMap_547 = keyMap[547];
				KeyMap_548 = keyMap[548];
				KeyMap_549 = keyMap[549];
				KeyMap_550 = keyMap[550];
				KeyMap_551 = keyMap[551];
				KeyMap_552 = keyMap[552];
				KeyMap_553 = keyMap[553];
				KeyMap_554 = keyMap[554];
				KeyMap_555 = keyMap[555];
				KeyMap_556 = keyMap[556];
				KeyMap_557 = keyMap[557];
				KeyMap_558 = keyMap[558];
				KeyMap_559 = keyMap[559];
				KeyMap_560 = keyMap[560];
				KeyMap_561 = keyMap[561];
				KeyMap_562 = keyMap[562];
				KeyMap_563 = keyMap[563];
				KeyMap_564 = keyMap[564];
				KeyMap_565 = keyMap[565];
				KeyMap_566 = keyMap[566];
				KeyMap_567 = keyMap[567];
				KeyMap_568 = keyMap[568];
				KeyMap_569 = keyMap[569];
				KeyMap_570 = keyMap[570];
				KeyMap_571 = keyMap[571];
				KeyMap_572 = keyMap[572];
				KeyMap_573 = keyMap[573];
				KeyMap_574 = keyMap[574];
				KeyMap_575 = keyMap[575];
				KeyMap_576 = keyMap[576];
				KeyMap_577 = keyMap[577];
				KeyMap_578 = keyMap[578];
				KeyMap_579 = keyMap[579];
				KeyMap_580 = keyMap[580];
				KeyMap_581 = keyMap[581];
				KeyMap_582 = keyMap[582];
				KeyMap_583 = keyMap[583];
				KeyMap_584 = keyMap[584];
				KeyMap_585 = keyMap[585];
				KeyMap_586 = keyMap[586];
				KeyMap_587 = keyMap[587];
				KeyMap_588 = keyMap[588];
				KeyMap_589 = keyMap[589];
				KeyMap_590 = keyMap[590];
				KeyMap_591 = keyMap[591];
				KeyMap_592 = keyMap[592];
				KeyMap_593 = keyMap[593];
				KeyMap_594 = keyMap[594];
				KeyMap_595 = keyMap[595];
				KeyMap_596 = keyMap[596];
				KeyMap_597 = keyMap[597];
				KeyMap_598 = keyMap[598];
				KeyMap_599 = keyMap[599];
				KeyMap_600 = keyMap[600];
				KeyMap_601 = keyMap[601];
				KeyMap_602 = keyMap[602];
				KeyMap_603 = keyMap[603];
				KeyMap_604 = keyMap[604];
				KeyMap_605 = keyMap[605];
				KeyMap_606 = keyMap[606];
				KeyMap_607 = keyMap[607];
				KeyMap_608 = keyMap[608];
				KeyMap_609 = keyMap[609];
				KeyMap_610 = keyMap[610];
				KeyMap_611 = keyMap[611];
				KeyMap_612 = keyMap[612];
				KeyMap_613 = keyMap[613];
				KeyMap_614 = keyMap[614];
				KeyMap_615 = keyMap[615];
				KeyMap_616 = keyMap[616];
				KeyMap_617 = keyMap[617];
				KeyMap_618 = keyMap[618];
				KeyMap_619 = keyMap[619];
				KeyMap_620 = keyMap[620];
				KeyMap_621 = keyMap[621];
				KeyMap_622 = keyMap[622];
				KeyMap_623 = keyMap[623];
				KeyMap_624 = keyMap[624];
				KeyMap_625 = keyMap[625];
				KeyMap_626 = keyMap[626];
				KeyMap_627 = keyMap[627];
				KeyMap_628 = keyMap[628];
				KeyMap_629 = keyMap[629];
				KeyMap_630 = keyMap[630];
				KeyMap_631 = keyMap[631];
				KeyMap_632 = keyMap[632];
				KeyMap_633 = keyMap[633];
				KeyMap_634 = keyMap[634];
				KeyMap_635 = keyMap[635];
				KeyMap_636 = keyMap[636];
				KeyMap_637 = keyMap[637];
				KeyMap_638 = keyMap[638];
				KeyMap_639 = keyMap[639];
				KeyMap_640 = keyMap[640];
				KeyMap_641 = keyMap[641];
				KeyMap_642 = keyMap[642];
				KeyMap_643 = keyMap[643];
				KeyMap_644 = keyMap[644];
				KeyMap_645 = keyMap[645];
				KeyMap_646 = keyMap[646];
				KeyMap_647 = keyMap[647];
				KeyMap_648 = keyMap[648];
				KeyMap_649 = keyMap[649];
				KeyMap_650 = keyMap[650];
				KeyMap_651 = keyMap[651];
				KeyMap_652 = keyMap[652];
				KeyMap_653 = keyMap[653];
				KeyMap_654 = keyMap[654];
				KeyMap_655 = keyMap[655];
				KeyMap_656 = keyMap[656];
				KeyMap_657 = keyMap[657];
				KeyMap_658 = keyMap[658];
				KeyMap_659 = keyMap[659];
				KeyMap_660 = keyMap[660];
				KeyMap_661 = keyMap[661];
				KeyMap_662 = keyMap[662];
				KeyMap_663 = keyMap[663];
				KeyMap_664 = keyMap[664];
				KeyMap_665 = keyMap[665];
			}
			if (keysDown != default)
			{
				KeysDown_0 = keysDown[0];
				KeysDown_1 = keysDown[1];
				KeysDown_2 = keysDown[2];
				KeysDown_3 = keysDown[3];
				KeysDown_4 = keysDown[4];
				KeysDown_5 = keysDown[5];
				KeysDown_6 = keysDown[6];
				KeysDown_7 = keysDown[7];
				KeysDown_8 = keysDown[8];
				KeysDown_9 = keysDown[9];
				KeysDown_10 = keysDown[10];
				KeysDown_11 = keysDown[11];
				KeysDown_12 = keysDown[12];
				KeysDown_13 = keysDown[13];
				KeysDown_14 = keysDown[14];
				KeysDown_15 = keysDown[15];
				KeysDown_16 = keysDown[16];
				KeysDown_17 = keysDown[17];
				KeysDown_18 = keysDown[18];
				KeysDown_19 = keysDown[19];
				KeysDown_20 = keysDown[20];
				KeysDown_21 = keysDown[21];
				KeysDown_22 = keysDown[22];
				KeysDown_23 = keysDown[23];
				KeysDown_24 = keysDown[24];
				KeysDown_25 = keysDown[25];
				KeysDown_26 = keysDown[26];
				KeysDown_27 = keysDown[27];
				KeysDown_28 = keysDown[28];
				KeysDown_29 = keysDown[29];
				KeysDown_30 = keysDown[30];
				KeysDown_31 = keysDown[31];
				KeysDown_32 = keysDown[32];
				KeysDown_33 = keysDown[33];
				KeysDown_34 = keysDown[34];
				KeysDown_35 = keysDown[35];
				KeysDown_36 = keysDown[36];
				KeysDown_37 = keysDown[37];
				KeysDown_38 = keysDown[38];
				KeysDown_39 = keysDown[39];
				KeysDown_40 = keysDown[40];
				KeysDown_41 = keysDown[41];
				KeysDown_42 = keysDown[42];
				KeysDown_43 = keysDown[43];
				KeysDown_44 = keysDown[44];
				KeysDown_45 = keysDown[45];
				KeysDown_46 = keysDown[46];
				KeysDown_47 = keysDown[47];
				KeysDown_48 = keysDown[48];
				KeysDown_49 = keysDown[49];
				KeysDown_50 = keysDown[50];
				KeysDown_51 = keysDown[51];
				KeysDown_52 = keysDown[52];
				KeysDown_53 = keysDown[53];
				KeysDown_54 = keysDown[54];
				KeysDown_55 = keysDown[55];
				KeysDown_56 = keysDown[56];
				KeysDown_57 = keysDown[57];
				KeysDown_58 = keysDown[58];
				KeysDown_59 = keysDown[59];
				KeysDown_60 = keysDown[60];
				KeysDown_61 = keysDown[61];
				KeysDown_62 = keysDown[62];
				KeysDown_63 = keysDown[63];
				KeysDown_64 = keysDown[64];
				KeysDown_65 = keysDown[65];
				KeysDown_66 = keysDown[66];
				KeysDown_67 = keysDown[67];
				KeysDown_68 = keysDown[68];
				KeysDown_69 = keysDown[69];
				KeysDown_70 = keysDown[70];
				KeysDown_71 = keysDown[71];
				KeysDown_72 = keysDown[72];
				KeysDown_73 = keysDown[73];
				KeysDown_74 = keysDown[74];
				KeysDown_75 = keysDown[75];
				KeysDown_76 = keysDown[76];
				KeysDown_77 = keysDown[77];
				KeysDown_78 = keysDown[78];
				KeysDown_79 = keysDown[79];
				KeysDown_80 = keysDown[80];
				KeysDown_81 = keysDown[81];
				KeysDown_82 = keysDown[82];
				KeysDown_83 = keysDown[83];
				KeysDown_84 = keysDown[84];
				KeysDown_85 = keysDown[85];
				KeysDown_86 = keysDown[86];
				KeysDown_87 = keysDown[87];
				KeysDown_88 = keysDown[88];
				KeysDown_89 = keysDown[89];
				KeysDown_90 = keysDown[90];
				KeysDown_91 = keysDown[91];
				KeysDown_92 = keysDown[92];
				KeysDown_93 = keysDown[93];
				KeysDown_94 = keysDown[94];
				KeysDown_95 = keysDown[95];
				KeysDown_96 = keysDown[96];
				KeysDown_97 = keysDown[97];
				KeysDown_98 = keysDown[98];
				KeysDown_99 = keysDown[99];
				KeysDown_100 = keysDown[100];
				KeysDown_101 = keysDown[101];
				KeysDown_102 = keysDown[102];
				KeysDown_103 = keysDown[103];
				KeysDown_104 = keysDown[104];
				KeysDown_105 = keysDown[105];
				KeysDown_106 = keysDown[106];
				KeysDown_107 = keysDown[107];
				KeysDown_108 = keysDown[108];
				KeysDown_109 = keysDown[109];
				KeysDown_110 = keysDown[110];
				KeysDown_111 = keysDown[111];
				KeysDown_112 = keysDown[112];
				KeysDown_113 = keysDown[113];
				KeysDown_114 = keysDown[114];
				KeysDown_115 = keysDown[115];
				KeysDown_116 = keysDown[116];
				KeysDown_117 = keysDown[117];
				KeysDown_118 = keysDown[118];
				KeysDown_119 = keysDown[119];
				KeysDown_120 = keysDown[120];
				KeysDown_121 = keysDown[121];
				KeysDown_122 = keysDown[122];
				KeysDown_123 = keysDown[123];
				KeysDown_124 = keysDown[124];
				KeysDown_125 = keysDown[125];
				KeysDown_126 = keysDown[126];
				KeysDown_127 = keysDown[127];
				KeysDown_128 = keysDown[128];
				KeysDown_129 = keysDown[129];
				KeysDown_130 = keysDown[130];
				KeysDown_131 = keysDown[131];
				KeysDown_132 = keysDown[132];
				KeysDown_133 = keysDown[133];
				KeysDown_134 = keysDown[134];
				KeysDown_135 = keysDown[135];
				KeysDown_136 = keysDown[136];
				KeysDown_137 = keysDown[137];
				KeysDown_138 = keysDown[138];
				KeysDown_139 = keysDown[139];
				KeysDown_140 = keysDown[140];
				KeysDown_141 = keysDown[141];
				KeysDown_142 = keysDown[142];
				KeysDown_143 = keysDown[143];
				KeysDown_144 = keysDown[144];
				KeysDown_145 = keysDown[145];
				KeysDown_146 = keysDown[146];
				KeysDown_147 = keysDown[147];
				KeysDown_148 = keysDown[148];
				KeysDown_149 = keysDown[149];
				KeysDown_150 = keysDown[150];
				KeysDown_151 = keysDown[151];
				KeysDown_152 = keysDown[152];
				KeysDown_153 = keysDown[153];
				KeysDown_154 = keysDown[154];
				KeysDown_155 = keysDown[155];
				KeysDown_156 = keysDown[156];
				KeysDown_157 = keysDown[157];
				KeysDown_158 = keysDown[158];
				KeysDown_159 = keysDown[159];
				KeysDown_160 = keysDown[160];
				KeysDown_161 = keysDown[161];
				KeysDown_162 = keysDown[162];
				KeysDown_163 = keysDown[163];
				KeysDown_164 = keysDown[164];
				KeysDown_165 = keysDown[165];
				KeysDown_166 = keysDown[166];
				KeysDown_167 = keysDown[167];
				KeysDown_168 = keysDown[168];
				KeysDown_169 = keysDown[169];
				KeysDown_170 = keysDown[170];
				KeysDown_171 = keysDown[171];
				KeysDown_172 = keysDown[172];
				KeysDown_173 = keysDown[173];
				KeysDown_174 = keysDown[174];
				KeysDown_175 = keysDown[175];
				KeysDown_176 = keysDown[176];
				KeysDown_177 = keysDown[177];
				KeysDown_178 = keysDown[178];
				KeysDown_179 = keysDown[179];
				KeysDown_180 = keysDown[180];
				KeysDown_181 = keysDown[181];
				KeysDown_182 = keysDown[182];
				KeysDown_183 = keysDown[183];
				KeysDown_184 = keysDown[184];
				KeysDown_185 = keysDown[185];
				KeysDown_186 = keysDown[186];
				KeysDown_187 = keysDown[187];
				KeysDown_188 = keysDown[188];
				KeysDown_189 = keysDown[189];
				KeysDown_190 = keysDown[190];
				KeysDown_191 = keysDown[191];
				KeysDown_192 = keysDown[192];
				KeysDown_193 = keysDown[193];
				KeysDown_194 = keysDown[194];
				KeysDown_195 = keysDown[195];
				KeysDown_196 = keysDown[196];
				KeysDown_197 = keysDown[197];
				KeysDown_198 = keysDown[198];
				KeysDown_199 = keysDown[199];
				KeysDown_200 = keysDown[200];
				KeysDown_201 = keysDown[201];
				KeysDown_202 = keysDown[202];
				KeysDown_203 = keysDown[203];
				KeysDown_204 = keysDown[204];
				KeysDown_205 = keysDown[205];
				KeysDown_206 = keysDown[206];
				KeysDown_207 = keysDown[207];
				KeysDown_208 = keysDown[208];
				KeysDown_209 = keysDown[209];
				KeysDown_210 = keysDown[210];
				KeysDown_211 = keysDown[211];
				KeysDown_212 = keysDown[212];
				KeysDown_213 = keysDown[213];
				KeysDown_214 = keysDown[214];
				KeysDown_215 = keysDown[215];
				KeysDown_216 = keysDown[216];
				KeysDown_217 = keysDown[217];
				KeysDown_218 = keysDown[218];
				KeysDown_219 = keysDown[219];
				KeysDown_220 = keysDown[220];
				KeysDown_221 = keysDown[221];
				KeysDown_222 = keysDown[222];
				KeysDown_223 = keysDown[223];
				KeysDown_224 = keysDown[224];
				KeysDown_225 = keysDown[225];
				KeysDown_226 = keysDown[226];
				KeysDown_227 = keysDown[227];
				KeysDown_228 = keysDown[228];
				KeysDown_229 = keysDown[229];
				KeysDown_230 = keysDown[230];
				KeysDown_231 = keysDown[231];
				KeysDown_232 = keysDown[232];
				KeysDown_233 = keysDown[233];
				KeysDown_234 = keysDown[234];
				KeysDown_235 = keysDown[235];
				KeysDown_236 = keysDown[236];
				KeysDown_237 = keysDown[237];
				KeysDown_238 = keysDown[238];
				KeysDown_239 = keysDown[239];
				KeysDown_240 = keysDown[240];
				KeysDown_241 = keysDown[241];
				KeysDown_242 = keysDown[242];
				KeysDown_243 = keysDown[243];
				KeysDown_244 = keysDown[244];
				KeysDown_245 = keysDown[245];
				KeysDown_246 = keysDown[246];
				KeysDown_247 = keysDown[247];
				KeysDown_248 = keysDown[248];
				KeysDown_249 = keysDown[249];
				KeysDown_250 = keysDown[250];
				KeysDown_251 = keysDown[251];
				KeysDown_252 = keysDown[252];
				KeysDown_253 = keysDown[253];
				KeysDown_254 = keysDown[254];
				KeysDown_255 = keysDown[255];
				KeysDown_256 = keysDown[256];
				KeysDown_257 = keysDown[257];
				KeysDown_258 = keysDown[258];
				KeysDown_259 = keysDown[259];
				KeysDown_260 = keysDown[260];
				KeysDown_261 = keysDown[261];
				KeysDown_262 = keysDown[262];
				KeysDown_263 = keysDown[263];
				KeysDown_264 = keysDown[264];
				KeysDown_265 = keysDown[265];
				KeysDown_266 = keysDown[266];
				KeysDown_267 = keysDown[267];
				KeysDown_268 = keysDown[268];
				KeysDown_269 = keysDown[269];
				KeysDown_270 = keysDown[270];
				KeysDown_271 = keysDown[271];
				KeysDown_272 = keysDown[272];
				KeysDown_273 = keysDown[273];
				KeysDown_274 = keysDown[274];
				KeysDown_275 = keysDown[275];
				KeysDown_276 = keysDown[276];
				KeysDown_277 = keysDown[277];
				KeysDown_278 = keysDown[278];
				KeysDown_279 = keysDown[279];
				KeysDown_280 = keysDown[280];
				KeysDown_281 = keysDown[281];
				KeysDown_282 = keysDown[282];
				KeysDown_283 = keysDown[283];
				KeysDown_284 = keysDown[284];
				KeysDown_285 = keysDown[285];
				KeysDown_286 = keysDown[286];
				KeysDown_287 = keysDown[287];
				KeysDown_288 = keysDown[288];
				KeysDown_289 = keysDown[289];
				KeysDown_290 = keysDown[290];
				KeysDown_291 = keysDown[291];
				KeysDown_292 = keysDown[292];
				KeysDown_293 = keysDown[293];
				KeysDown_294 = keysDown[294];
				KeysDown_295 = keysDown[295];
				KeysDown_296 = keysDown[296];
				KeysDown_297 = keysDown[297];
				KeysDown_298 = keysDown[298];
				KeysDown_299 = keysDown[299];
				KeysDown_300 = keysDown[300];
				KeysDown_301 = keysDown[301];
				KeysDown_302 = keysDown[302];
				KeysDown_303 = keysDown[303];
				KeysDown_304 = keysDown[304];
				KeysDown_305 = keysDown[305];
				KeysDown_306 = keysDown[306];
				KeysDown_307 = keysDown[307];
				KeysDown_308 = keysDown[308];
				KeysDown_309 = keysDown[309];
				KeysDown_310 = keysDown[310];
				KeysDown_311 = keysDown[311];
				KeysDown_312 = keysDown[312];
				KeysDown_313 = keysDown[313];
				KeysDown_314 = keysDown[314];
				KeysDown_315 = keysDown[315];
				KeysDown_316 = keysDown[316];
				KeysDown_317 = keysDown[317];
				KeysDown_318 = keysDown[318];
				KeysDown_319 = keysDown[319];
				KeysDown_320 = keysDown[320];
				KeysDown_321 = keysDown[321];
				KeysDown_322 = keysDown[322];
				KeysDown_323 = keysDown[323];
				KeysDown_324 = keysDown[324];
				KeysDown_325 = keysDown[325];
				KeysDown_326 = keysDown[326];
				KeysDown_327 = keysDown[327];
				KeysDown_328 = keysDown[328];
				KeysDown_329 = keysDown[329];
				KeysDown_330 = keysDown[330];
				KeysDown_331 = keysDown[331];
				KeysDown_332 = keysDown[332];
				KeysDown_333 = keysDown[333];
				KeysDown_334 = keysDown[334];
				KeysDown_335 = keysDown[335];
				KeysDown_336 = keysDown[336];
				KeysDown_337 = keysDown[337];
				KeysDown_338 = keysDown[338];
				KeysDown_339 = keysDown[339];
				KeysDown_340 = keysDown[340];
				KeysDown_341 = keysDown[341];
				KeysDown_342 = keysDown[342];
				KeysDown_343 = keysDown[343];
				KeysDown_344 = keysDown[344];
				KeysDown_345 = keysDown[345];
				KeysDown_346 = keysDown[346];
				KeysDown_347 = keysDown[347];
				KeysDown_348 = keysDown[348];
				KeysDown_349 = keysDown[349];
				KeysDown_350 = keysDown[350];
				KeysDown_351 = keysDown[351];
				KeysDown_352 = keysDown[352];
				KeysDown_353 = keysDown[353];
				KeysDown_354 = keysDown[354];
				KeysDown_355 = keysDown[355];
				KeysDown_356 = keysDown[356];
				KeysDown_357 = keysDown[357];
				KeysDown_358 = keysDown[358];
				KeysDown_359 = keysDown[359];
				KeysDown_360 = keysDown[360];
				KeysDown_361 = keysDown[361];
				KeysDown_362 = keysDown[362];
				KeysDown_363 = keysDown[363];
				KeysDown_364 = keysDown[364];
				KeysDown_365 = keysDown[365];
				KeysDown_366 = keysDown[366];
				KeysDown_367 = keysDown[367];
				KeysDown_368 = keysDown[368];
				KeysDown_369 = keysDown[369];
				KeysDown_370 = keysDown[370];
				KeysDown_371 = keysDown[371];
				KeysDown_372 = keysDown[372];
				KeysDown_373 = keysDown[373];
				KeysDown_374 = keysDown[374];
				KeysDown_375 = keysDown[375];
				KeysDown_376 = keysDown[376];
				KeysDown_377 = keysDown[377];
				KeysDown_378 = keysDown[378];
				KeysDown_379 = keysDown[379];
				KeysDown_380 = keysDown[380];
				KeysDown_381 = keysDown[381];
				KeysDown_382 = keysDown[382];
				KeysDown_383 = keysDown[383];
				KeysDown_384 = keysDown[384];
				KeysDown_385 = keysDown[385];
				KeysDown_386 = keysDown[386];
				KeysDown_387 = keysDown[387];
				KeysDown_388 = keysDown[388];
				KeysDown_389 = keysDown[389];
				KeysDown_390 = keysDown[390];
				KeysDown_391 = keysDown[391];
				KeysDown_392 = keysDown[392];
				KeysDown_393 = keysDown[393];
				KeysDown_394 = keysDown[394];
				KeysDown_395 = keysDown[395];
				KeysDown_396 = keysDown[396];
				KeysDown_397 = keysDown[397];
				KeysDown_398 = keysDown[398];
				KeysDown_399 = keysDown[399];
				KeysDown_400 = keysDown[400];
				KeysDown_401 = keysDown[401];
				KeysDown_402 = keysDown[402];
				KeysDown_403 = keysDown[403];
				KeysDown_404 = keysDown[404];
				KeysDown_405 = keysDown[405];
				KeysDown_406 = keysDown[406];
				KeysDown_407 = keysDown[407];
				KeysDown_408 = keysDown[408];
				KeysDown_409 = keysDown[409];
				KeysDown_410 = keysDown[410];
				KeysDown_411 = keysDown[411];
				KeysDown_412 = keysDown[412];
				KeysDown_413 = keysDown[413];
				KeysDown_414 = keysDown[414];
				KeysDown_415 = keysDown[415];
				KeysDown_416 = keysDown[416];
				KeysDown_417 = keysDown[417];
				KeysDown_418 = keysDown[418];
				KeysDown_419 = keysDown[419];
				KeysDown_420 = keysDown[420];
				KeysDown_421 = keysDown[421];
				KeysDown_422 = keysDown[422];
				KeysDown_423 = keysDown[423];
				KeysDown_424 = keysDown[424];
				KeysDown_425 = keysDown[425];
				KeysDown_426 = keysDown[426];
				KeysDown_427 = keysDown[427];
				KeysDown_428 = keysDown[428];
				KeysDown_429 = keysDown[429];
				KeysDown_430 = keysDown[430];
				KeysDown_431 = keysDown[431];
				KeysDown_432 = keysDown[432];
				KeysDown_433 = keysDown[433];
				KeysDown_434 = keysDown[434];
				KeysDown_435 = keysDown[435];
				KeysDown_436 = keysDown[436];
				KeysDown_437 = keysDown[437];
				KeysDown_438 = keysDown[438];
				KeysDown_439 = keysDown[439];
				KeysDown_440 = keysDown[440];
				KeysDown_441 = keysDown[441];
				KeysDown_442 = keysDown[442];
				KeysDown_443 = keysDown[443];
				KeysDown_444 = keysDown[444];
				KeysDown_445 = keysDown[445];
				KeysDown_446 = keysDown[446];
				KeysDown_447 = keysDown[447];
				KeysDown_448 = keysDown[448];
				KeysDown_449 = keysDown[449];
				KeysDown_450 = keysDown[450];
				KeysDown_451 = keysDown[451];
				KeysDown_452 = keysDown[452];
				KeysDown_453 = keysDown[453];
				KeysDown_454 = keysDown[454];
				KeysDown_455 = keysDown[455];
				KeysDown_456 = keysDown[456];
				KeysDown_457 = keysDown[457];
				KeysDown_458 = keysDown[458];
				KeysDown_459 = keysDown[459];
				KeysDown_460 = keysDown[460];
				KeysDown_461 = keysDown[461];
				KeysDown_462 = keysDown[462];
				KeysDown_463 = keysDown[463];
				KeysDown_464 = keysDown[464];
				KeysDown_465 = keysDown[465];
				KeysDown_466 = keysDown[466];
				KeysDown_467 = keysDown[467];
				KeysDown_468 = keysDown[468];
				KeysDown_469 = keysDown[469];
				KeysDown_470 = keysDown[470];
				KeysDown_471 = keysDown[471];
				KeysDown_472 = keysDown[472];
				KeysDown_473 = keysDown[473];
				KeysDown_474 = keysDown[474];
				KeysDown_475 = keysDown[475];
				KeysDown_476 = keysDown[476];
				KeysDown_477 = keysDown[477];
				KeysDown_478 = keysDown[478];
				KeysDown_479 = keysDown[479];
				KeysDown_480 = keysDown[480];
				KeysDown_481 = keysDown[481];
				KeysDown_482 = keysDown[482];
				KeysDown_483 = keysDown[483];
				KeysDown_484 = keysDown[484];
				KeysDown_485 = keysDown[485];
				KeysDown_486 = keysDown[486];
				KeysDown_487 = keysDown[487];
				KeysDown_488 = keysDown[488];
				KeysDown_489 = keysDown[489];
				KeysDown_490 = keysDown[490];
				KeysDown_491 = keysDown[491];
				KeysDown_492 = keysDown[492];
				KeysDown_493 = keysDown[493];
				KeysDown_494 = keysDown[494];
				KeysDown_495 = keysDown[495];
				KeysDown_496 = keysDown[496];
				KeysDown_497 = keysDown[497];
				KeysDown_498 = keysDown[498];
				KeysDown_499 = keysDown[499];
				KeysDown_500 = keysDown[500];
				KeysDown_501 = keysDown[501];
				KeysDown_502 = keysDown[502];
				KeysDown_503 = keysDown[503];
				KeysDown_504 = keysDown[504];
				KeysDown_505 = keysDown[505];
				KeysDown_506 = keysDown[506];
				KeysDown_507 = keysDown[507];
				KeysDown_508 = keysDown[508];
				KeysDown_509 = keysDown[509];
				KeysDown_510 = keysDown[510];
				KeysDown_511 = keysDown[511];
				KeysDown_512 = keysDown[512];
				KeysDown_513 = keysDown[513];
				KeysDown_514 = keysDown[514];
				KeysDown_515 = keysDown[515];
				KeysDown_516 = keysDown[516];
				KeysDown_517 = keysDown[517];
				KeysDown_518 = keysDown[518];
				KeysDown_519 = keysDown[519];
				KeysDown_520 = keysDown[520];
				KeysDown_521 = keysDown[521];
				KeysDown_522 = keysDown[522];
				KeysDown_523 = keysDown[523];
				KeysDown_524 = keysDown[524];
				KeysDown_525 = keysDown[525];
				KeysDown_526 = keysDown[526];
				KeysDown_527 = keysDown[527];
				KeysDown_528 = keysDown[528];
				KeysDown_529 = keysDown[529];
				KeysDown_530 = keysDown[530];
				KeysDown_531 = keysDown[531];
				KeysDown_532 = keysDown[532];
				KeysDown_533 = keysDown[533];
				KeysDown_534 = keysDown[534];
				KeysDown_535 = keysDown[535];
				KeysDown_536 = keysDown[536];
				KeysDown_537 = keysDown[537];
				KeysDown_538 = keysDown[538];
				KeysDown_539 = keysDown[539];
				KeysDown_540 = keysDown[540];
				KeysDown_541 = keysDown[541];
				KeysDown_542 = keysDown[542];
				KeysDown_543 = keysDown[543];
				KeysDown_544 = keysDown[544];
				KeysDown_545 = keysDown[545];
				KeysDown_546 = keysDown[546];
				KeysDown_547 = keysDown[547];
				KeysDown_548 = keysDown[548];
				KeysDown_549 = keysDown[549];
				KeysDown_550 = keysDown[550];
				KeysDown_551 = keysDown[551];
				KeysDown_552 = keysDown[552];
				KeysDown_553 = keysDown[553];
				KeysDown_554 = keysDown[554];
				KeysDown_555 = keysDown[555];
				KeysDown_556 = keysDown[556];
				KeysDown_557 = keysDown[557];
				KeysDown_558 = keysDown[558];
				KeysDown_559 = keysDown[559];
				KeysDown_560 = keysDown[560];
				KeysDown_561 = keysDown[561];
				KeysDown_562 = keysDown[562];
				KeysDown_563 = keysDown[563];
				KeysDown_564 = keysDown[564];
				KeysDown_565 = keysDown[565];
				KeysDown_566 = keysDown[566];
				KeysDown_567 = keysDown[567];
				KeysDown_568 = keysDown[568];
				KeysDown_569 = keysDown[569];
				KeysDown_570 = keysDown[570];
				KeysDown_571 = keysDown[571];
				KeysDown_572 = keysDown[572];
				KeysDown_573 = keysDown[573];
				KeysDown_574 = keysDown[574];
				KeysDown_575 = keysDown[575];
				KeysDown_576 = keysDown[576];
				KeysDown_577 = keysDown[577];
				KeysDown_578 = keysDown[578];
				KeysDown_579 = keysDown[579];
				KeysDown_580 = keysDown[580];
				KeysDown_581 = keysDown[581];
				KeysDown_582 = keysDown[582];
				KeysDown_583 = keysDown[583];
				KeysDown_584 = keysDown[584];
				KeysDown_585 = keysDown[585];
				KeysDown_586 = keysDown[586];
				KeysDown_587 = keysDown[587];
				KeysDown_588 = keysDown[588];
				KeysDown_589 = keysDown[589];
				KeysDown_590 = keysDown[590];
				KeysDown_591 = keysDown[591];
				KeysDown_592 = keysDown[592];
				KeysDown_593 = keysDown[593];
				KeysDown_594 = keysDown[594];
				KeysDown_595 = keysDown[595];
				KeysDown_596 = keysDown[596];
				KeysDown_597 = keysDown[597];
				KeysDown_598 = keysDown[598];
				KeysDown_599 = keysDown[599];
				KeysDown_600 = keysDown[600];
				KeysDown_601 = keysDown[601];
				KeysDown_602 = keysDown[602];
				KeysDown_603 = keysDown[603];
				KeysDown_604 = keysDown[604];
				KeysDown_605 = keysDown[605];
				KeysDown_606 = keysDown[606];
				KeysDown_607 = keysDown[607];
				KeysDown_608 = keysDown[608];
				KeysDown_609 = keysDown[609];
				KeysDown_610 = keysDown[610];
				KeysDown_611 = keysDown[611];
				KeysDown_612 = keysDown[612];
				KeysDown_613 = keysDown[613];
				KeysDown_614 = keysDown[614];
				KeysDown_615 = keysDown[615];
				KeysDown_616 = keysDown[616];
				KeysDown_617 = keysDown[617];
				KeysDown_618 = keysDown[618];
				KeysDown_619 = keysDown[619];
				KeysDown_620 = keysDown[620];
				KeysDown_621 = keysDown[621];
				KeysDown_622 = keysDown[622];
				KeysDown_623 = keysDown[623];
				KeysDown_624 = keysDown[624];
				KeysDown_625 = keysDown[625];
				KeysDown_626 = keysDown[626];
				KeysDown_627 = keysDown[627];
				KeysDown_628 = keysDown[628];
				KeysDown_629 = keysDown[629];
				KeysDown_630 = keysDown[630];
				KeysDown_631 = keysDown[631];
				KeysDown_632 = keysDown[632];
				KeysDown_633 = keysDown[633];
				KeysDown_634 = keysDown[634];
				KeysDown_635 = keysDown[635];
				KeysDown_636 = keysDown[636];
				KeysDown_637 = keysDown[637];
				KeysDown_638 = keysDown[638];
				KeysDown_639 = keysDown[639];
				KeysDown_640 = keysDown[640];
				KeysDown_641 = keysDown[641];
				KeysDown_642 = keysDown[642];
				KeysDown_643 = keysDown[643];
				KeysDown_644 = keysDown[644];
				KeysDown_645 = keysDown[645];
				KeysDown_646 = keysDown[646];
				KeysDown_647 = keysDown[647];
				KeysDown_648 = keysDown[648];
				KeysDown_649 = keysDown[649];
				KeysDown_650 = keysDown[650];
				KeysDown_651 = keysDown[651];
				KeysDown_652 = keysDown[652];
				KeysDown_653 = keysDown[653];
				KeysDown_654 = keysDown[654];
				KeysDown_655 = keysDown[655];
				KeysDown_656 = keysDown[656];
				KeysDown_657 = keysDown[657];
				KeysDown_658 = keysDown[658];
				KeysDown_659 = keysDown[659];
				KeysDown_660 = keysDown[660];
				KeysDown_661 = keysDown[661];
				KeysDown_662 = keysDown[662];
				KeysDown_663 = keysDown[663];
				KeysDown_664 = keysDown[664];
				KeysDown_665 = keysDown[665];
			}
			if (navInputs != default)
			{
				NavInputs_0 = navInputs[0];
				NavInputs_1 = navInputs[1];
				NavInputs_2 = navInputs[2];
				NavInputs_3 = navInputs[3];
				NavInputs_4 = navInputs[4];
				NavInputs_5 = navInputs[5];
				NavInputs_6 = navInputs[6];
				NavInputs_7 = navInputs[7];
				NavInputs_8 = navInputs[8];
				NavInputs_9 = navInputs[9];
				NavInputs_10 = navInputs[10];
				NavInputs_11 = navInputs[11];
				NavInputs_12 = navInputs[12];
				NavInputs_13 = navInputs[13];
				NavInputs_14 = navInputs[14];
				NavInputs_15 = navInputs[15];
			}
			UnusedPadding = Unusedpadding;
			Ctx = ctx;
			MousePos = mousePos;
			if (mouseDown != default)
			{
				MouseDown_0 = mouseDown[0];
				MouseDown_1 = mouseDown[1];
				MouseDown_2 = mouseDown[2];
				MouseDown_3 = mouseDown[3];
				MouseDown_4 = mouseDown[4];
			}
			MouseWheel = mouseWheel;
			MouseWheelH = mouseWheelH;
			MouseSource = mouseSource;
			MouseHoveredViewport = mouseHoveredViewport;
			KeyCtrl = keyCtrl ? (byte)1 : (byte)0;
			KeyShift = keyShift ? (byte)1 : (byte)0;
			KeyAlt = keyAlt ? (byte)1 : (byte)0;
			KeySuper = keySuper ? (byte)1 : (byte)0;
			KeyMods = keyMods;
			if (keysData != default)
			{
				KeysData_0 = keysData[0];
				KeysData_1 = keysData[1];
				KeysData_2 = keysData[2];
				KeysData_3 = keysData[3];
				KeysData_4 = keysData[4];
				KeysData_5 = keysData[5];
				KeysData_6 = keysData[6];
				KeysData_7 = keysData[7];
				KeysData_8 = keysData[8];
				KeysData_9 = keysData[9];
				KeysData_10 = keysData[10];
				KeysData_11 = keysData[11];
				KeysData_12 = keysData[12];
				KeysData_13 = keysData[13];
				KeysData_14 = keysData[14];
				KeysData_15 = keysData[15];
				KeysData_16 = keysData[16];
				KeysData_17 = keysData[17];
				KeysData_18 = keysData[18];
				KeysData_19 = keysData[19];
				KeysData_20 = keysData[20];
				KeysData_21 = keysData[21];
				KeysData_22 = keysData[22];
				KeysData_23 = keysData[23];
				KeysData_24 = keysData[24];
				KeysData_25 = keysData[25];
				KeysData_26 = keysData[26];
				KeysData_27 = keysData[27];
				KeysData_28 = keysData[28];
				KeysData_29 = keysData[29];
				KeysData_30 = keysData[30];
				KeysData_31 = keysData[31];
				KeysData_32 = keysData[32];
				KeysData_33 = keysData[33];
				KeysData_34 = keysData[34];
				KeysData_35 = keysData[35];
				KeysData_36 = keysData[36];
				KeysData_37 = keysData[37];
				KeysData_38 = keysData[38];
				KeysData_39 = keysData[39];
				KeysData_40 = keysData[40];
				KeysData_41 = keysData[41];
				KeysData_42 = keysData[42];
				KeysData_43 = keysData[43];
				KeysData_44 = keysData[44];
				KeysData_45 = keysData[45];
				KeysData_46 = keysData[46];
				KeysData_47 = keysData[47];
				KeysData_48 = keysData[48];
				KeysData_49 = keysData[49];
				KeysData_50 = keysData[50];
				KeysData_51 = keysData[51];
				KeysData_52 = keysData[52];
				KeysData_53 = keysData[53];
				KeysData_54 = keysData[54];
				KeysData_55 = keysData[55];
				KeysData_56 = keysData[56];
				KeysData_57 = keysData[57];
				KeysData_58 = keysData[58];
				KeysData_59 = keysData[59];
				KeysData_60 = keysData[60];
				KeysData_61 = keysData[61];
				KeysData_62 = keysData[62];
				KeysData_63 = keysData[63];
				KeysData_64 = keysData[64];
				KeysData_65 = keysData[65];
				KeysData_66 = keysData[66];
				KeysData_67 = keysData[67];
				KeysData_68 = keysData[68];
				KeysData_69 = keysData[69];
				KeysData_70 = keysData[70];
				KeysData_71 = keysData[71];
				KeysData_72 = keysData[72];
				KeysData_73 = keysData[73];
				KeysData_74 = keysData[74];
				KeysData_75 = keysData[75];
				KeysData_76 = keysData[76];
				KeysData_77 = keysData[77];
				KeysData_78 = keysData[78];
				KeysData_79 = keysData[79];
				KeysData_80 = keysData[80];
				KeysData_81 = keysData[81];
				KeysData_82 = keysData[82];
				KeysData_83 = keysData[83];
				KeysData_84 = keysData[84];
				KeysData_85 = keysData[85];
				KeysData_86 = keysData[86];
				KeysData_87 = keysData[87];
				KeysData_88 = keysData[88];
				KeysData_89 = keysData[89];
				KeysData_90 = keysData[90];
				KeysData_91 = keysData[91];
				KeysData_92 = keysData[92];
				KeysData_93 = keysData[93];
				KeysData_94 = keysData[94];
				KeysData_95 = keysData[95];
				KeysData_96 = keysData[96];
				KeysData_97 = keysData[97];
				KeysData_98 = keysData[98];
				KeysData_99 = keysData[99];
				KeysData_100 = keysData[100];
				KeysData_101 = keysData[101];
				KeysData_102 = keysData[102];
				KeysData_103 = keysData[103];
				KeysData_104 = keysData[104];
				KeysData_105 = keysData[105];
				KeysData_106 = keysData[106];
				KeysData_107 = keysData[107];
				KeysData_108 = keysData[108];
				KeysData_109 = keysData[109];
				KeysData_110 = keysData[110];
				KeysData_111 = keysData[111];
				KeysData_112 = keysData[112];
				KeysData_113 = keysData[113];
				KeysData_114 = keysData[114];
				KeysData_115 = keysData[115];
				KeysData_116 = keysData[116];
				KeysData_117 = keysData[117];
				KeysData_118 = keysData[118];
				KeysData_119 = keysData[119];
				KeysData_120 = keysData[120];
				KeysData_121 = keysData[121];
				KeysData_122 = keysData[122];
				KeysData_123 = keysData[123];
				KeysData_124 = keysData[124];
				KeysData_125 = keysData[125];
				KeysData_126 = keysData[126];
				KeysData_127 = keysData[127];
				KeysData_128 = keysData[128];
				KeysData_129 = keysData[129];
				KeysData_130 = keysData[130];
				KeysData_131 = keysData[131];
				KeysData_132 = keysData[132];
				KeysData_133 = keysData[133];
				KeysData_134 = keysData[134];
				KeysData_135 = keysData[135];
				KeysData_136 = keysData[136];
				KeysData_137 = keysData[137];
				KeysData_138 = keysData[138];
				KeysData_139 = keysData[139];
				KeysData_140 = keysData[140];
				KeysData_141 = keysData[141];
				KeysData_142 = keysData[142];
				KeysData_143 = keysData[143];
				KeysData_144 = keysData[144];
				KeysData_145 = keysData[145];
				KeysData_146 = keysData[146];
				KeysData_147 = keysData[147];
				KeysData_148 = keysData[148];
				KeysData_149 = keysData[149];
				KeysData_150 = keysData[150];
				KeysData_151 = keysData[151];
				KeysData_152 = keysData[152];
				KeysData_153 = keysData[153];
				KeysData_154 = keysData[154];
				KeysData_155 = keysData[155];
				KeysData_156 = keysData[156];
				KeysData_157 = keysData[157];
				KeysData_158 = keysData[158];
				KeysData_159 = keysData[159];
				KeysData_160 = keysData[160];
				KeysData_161 = keysData[161];
				KeysData_162 = keysData[162];
				KeysData_163 = keysData[163];
				KeysData_164 = keysData[164];
				KeysData_165 = keysData[165];
				KeysData_166 = keysData[166];
				KeysData_167 = keysData[167];
				KeysData_168 = keysData[168];
				KeysData_169 = keysData[169];
				KeysData_170 = keysData[170];
				KeysData_171 = keysData[171];
				KeysData_172 = keysData[172];
				KeysData_173 = keysData[173];
				KeysData_174 = keysData[174];
				KeysData_175 = keysData[175];
				KeysData_176 = keysData[176];
				KeysData_177 = keysData[177];
				KeysData_178 = keysData[178];
				KeysData_179 = keysData[179];
				KeysData_180 = keysData[180];
				KeysData_181 = keysData[181];
				KeysData_182 = keysData[182];
				KeysData_183 = keysData[183];
				KeysData_184 = keysData[184];
				KeysData_185 = keysData[185];
				KeysData_186 = keysData[186];
				KeysData_187 = keysData[187];
				KeysData_188 = keysData[188];
				KeysData_189 = keysData[189];
				KeysData_190 = keysData[190];
				KeysData_191 = keysData[191];
				KeysData_192 = keysData[192];
				KeysData_193 = keysData[193];
				KeysData_194 = keysData[194];
				KeysData_195 = keysData[195];
				KeysData_196 = keysData[196];
				KeysData_197 = keysData[197];
				KeysData_198 = keysData[198];
				KeysData_199 = keysData[199];
				KeysData_200 = keysData[200];
				KeysData_201 = keysData[201];
				KeysData_202 = keysData[202];
				KeysData_203 = keysData[203];
				KeysData_204 = keysData[204];
				KeysData_205 = keysData[205];
				KeysData_206 = keysData[206];
				KeysData_207 = keysData[207];
				KeysData_208 = keysData[208];
				KeysData_209 = keysData[209];
				KeysData_210 = keysData[210];
				KeysData_211 = keysData[211];
				KeysData_212 = keysData[212];
				KeysData_213 = keysData[213];
				KeysData_214 = keysData[214];
				KeysData_215 = keysData[215];
				KeysData_216 = keysData[216];
				KeysData_217 = keysData[217];
				KeysData_218 = keysData[218];
				KeysData_219 = keysData[219];
				KeysData_220 = keysData[220];
				KeysData_221 = keysData[221];
				KeysData_222 = keysData[222];
				KeysData_223 = keysData[223];
				KeysData_224 = keysData[224];
				KeysData_225 = keysData[225];
				KeysData_226 = keysData[226];
				KeysData_227 = keysData[227];
				KeysData_228 = keysData[228];
				KeysData_229 = keysData[229];
				KeysData_230 = keysData[230];
				KeysData_231 = keysData[231];
				KeysData_232 = keysData[232];
				KeysData_233 = keysData[233];
				KeysData_234 = keysData[234];
				KeysData_235 = keysData[235];
				KeysData_236 = keysData[236];
				KeysData_237 = keysData[237];
				KeysData_238 = keysData[238];
				KeysData_239 = keysData[239];
				KeysData_240 = keysData[240];
				KeysData_241 = keysData[241];
				KeysData_242 = keysData[242];
				KeysData_243 = keysData[243];
				KeysData_244 = keysData[244];
				KeysData_245 = keysData[245];
				KeysData_246 = keysData[246];
				KeysData_247 = keysData[247];
				KeysData_248 = keysData[248];
				KeysData_249 = keysData[249];
				KeysData_250 = keysData[250];
				KeysData_251 = keysData[251];
				KeysData_252 = keysData[252];
				KeysData_253 = keysData[253];
				KeysData_254 = keysData[254];
				KeysData_255 = keysData[255];
				KeysData_256 = keysData[256];
				KeysData_257 = keysData[257];
				KeysData_258 = keysData[258];
				KeysData_259 = keysData[259];
				KeysData_260 = keysData[260];
				KeysData_261 = keysData[261];
				KeysData_262 = keysData[262];
				KeysData_263 = keysData[263];
				KeysData_264 = keysData[264];
				KeysData_265 = keysData[265];
				KeysData_266 = keysData[266];
				KeysData_267 = keysData[267];
				KeysData_268 = keysData[268];
				KeysData_269 = keysData[269];
				KeysData_270 = keysData[270];
				KeysData_271 = keysData[271];
				KeysData_272 = keysData[272];
				KeysData_273 = keysData[273];
				KeysData_274 = keysData[274];
				KeysData_275 = keysData[275];
				KeysData_276 = keysData[276];
				KeysData_277 = keysData[277];
				KeysData_278 = keysData[278];
				KeysData_279 = keysData[279];
				KeysData_280 = keysData[280];
				KeysData_281 = keysData[281];
				KeysData_282 = keysData[282];
				KeysData_283 = keysData[283];
				KeysData_284 = keysData[284];
				KeysData_285 = keysData[285];
				KeysData_286 = keysData[286];
				KeysData_287 = keysData[287];
				KeysData_288 = keysData[288];
				KeysData_289 = keysData[289];
				KeysData_290 = keysData[290];
				KeysData_291 = keysData[291];
				KeysData_292 = keysData[292];
				KeysData_293 = keysData[293];
				KeysData_294 = keysData[294];
				KeysData_295 = keysData[295];
				KeysData_296 = keysData[296];
				KeysData_297 = keysData[297];
				KeysData_298 = keysData[298];
				KeysData_299 = keysData[299];
				KeysData_300 = keysData[300];
				KeysData_301 = keysData[301];
				KeysData_302 = keysData[302];
				KeysData_303 = keysData[303];
				KeysData_304 = keysData[304];
				KeysData_305 = keysData[305];
				KeysData_306 = keysData[306];
				KeysData_307 = keysData[307];
				KeysData_308 = keysData[308];
				KeysData_309 = keysData[309];
				KeysData_310 = keysData[310];
				KeysData_311 = keysData[311];
				KeysData_312 = keysData[312];
				KeysData_313 = keysData[313];
				KeysData_314 = keysData[314];
				KeysData_315 = keysData[315];
				KeysData_316 = keysData[316];
				KeysData_317 = keysData[317];
				KeysData_318 = keysData[318];
				KeysData_319 = keysData[319];
				KeysData_320 = keysData[320];
				KeysData_321 = keysData[321];
				KeysData_322 = keysData[322];
				KeysData_323 = keysData[323];
				KeysData_324 = keysData[324];
				KeysData_325 = keysData[325];
				KeysData_326 = keysData[326];
				KeysData_327 = keysData[327];
				KeysData_328 = keysData[328];
				KeysData_329 = keysData[329];
				KeysData_330 = keysData[330];
				KeysData_331 = keysData[331];
				KeysData_332 = keysData[332];
				KeysData_333 = keysData[333];
				KeysData_334 = keysData[334];
				KeysData_335 = keysData[335];
				KeysData_336 = keysData[336];
				KeysData_337 = keysData[337];
				KeysData_338 = keysData[338];
				KeysData_339 = keysData[339];
				KeysData_340 = keysData[340];
				KeysData_341 = keysData[341];
				KeysData_342 = keysData[342];
				KeysData_343 = keysData[343];
				KeysData_344 = keysData[344];
				KeysData_345 = keysData[345];
				KeysData_346 = keysData[346];
				KeysData_347 = keysData[347];
				KeysData_348 = keysData[348];
				KeysData_349 = keysData[349];
				KeysData_350 = keysData[350];
				KeysData_351 = keysData[351];
				KeysData_352 = keysData[352];
				KeysData_353 = keysData[353];
				KeysData_354 = keysData[354];
				KeysData_355 = keysData[355];
				KeysData_356 = keysData[356];
				KeysData_357 = keysData[357];
				KeysData_358 = keysData[358];
				KeysData_359 = keysData[359];
				KeysData_360 = keysData[360];
				KeysData_361 = keysData[361];
				KeysData_362 = keysData[362];
				KeysData_363 = keysData[363];
				KeysData_364 = keysData[364];
				KeysData_365 = keysData[365];
				KeysData_366 = keysData[366];
				KeysData_367 = keysData[367];
				KeysData_368 = keysData[368];
				KeysData_369 = keysData[369];
				KeysData_370 = keysData[370];
				KeysData_371 = keysData[371];
				KeysData_372 = keysData[372];
				KeysData_373 = keysData[373];
				KeysData_374 = keysData[374];
				KeysData_375 = keysData[375];
				KeysData_376 = keysData[376];
				KeysData_377 = keysData[377];
				KeysData_378 = keysData[378];
				KeysData_379 = keysData[379];
				KeysData_380 = keysData[380];
				KeysData_381 = keysData[381];
				KeysData_382 = keysData[382];
				KeysData_383 = keysData[383];
				KeysData_384 = keysData[384];
				KeysData_385 = keysData[385];
				KeysData_386 = keysData[386];
				KeysData_387 = keysData[387];
				KeysData_388 = keysData[388];
				KeysData_389 = keysData[389];
				KeysData_390 = keysData[390];
				KeysData_391 = keysData[391];
				KeysData_392 = keysData[392];
				KeysData_393 = keysData[393];
				KeysData_394 = keysData[394];
				KeysData_395 = keysData[395];
				KeysData_396 = keysData[396];
				KeysData_397 = keysData[397];
				KeysData_398 = keysData[398];
				KeysData_399 = keysData[399];
				KeysData_400 = keysData[400];
				KeysData_401 = keysData[401];
				KeysData_402 = keysData[402];
				KeysData_403 = keysData[403];
				KeysData_404 = keysData[404];
				KeysData_405 = keysData[405];
				KeysData_406 = keysData[406];
				KeysData_407 = keysData[407];
				KeysData_408 = keysData[408];
				KeysData_409 = keysData[409];
				KeysData_410 = keysData[410];
				KeysData_411 = keysData[411];
				KeysData_412 = keysData[412];
				KeysData_413 = keysData[413];
				KeysData_414 = keysData[414];
				KeysData_415 = keysData[415];
				KeysData_416 = keysData[416];
				KeysData_417 = keysData[417];
				KeysData_418 = keysData[418];
				KeysData_419 = keysData[419];
				KeysData_420 = keysData[420];
				KeysData_421 = keysData[421];
				KeysData_422 = keysData[422];
				KeysData_423 = keysData[423];
				KeysData_424 = keysData[424];
				KeysData_425 = keysData[425];
				KeysData_426 = keysData[426];
				KeysData_427 = keysData[427];
				KeysData_428 = keysData[428];
				KeysData_429 = keysData[429];
				KeysData_430 = keysData[430];
				KeysData_431 = keysData[431];
				KeysData_432 = keysData[432];
				KeysData_433 = keysData[433];
				KeysData_434 = keysData[434];
				KeysData_435 = keysData[435];
				KeysData_436 = keysData[436];
				KeysData_437 = keysData[437];
				KeysData_438 = keysData[438];
				KeysData_439 = keysData[439];
				KeysData_440 = keysData[440];
				KeysData_441 = keysData[441];
				KeysData_442 = keysData[442];
				KeysData_443 = keysData[443];
				KeysData_444 = keysData[444];
				KeysData_445 = keysData[445];
				KeysData_446 = keysData[446];
				KeysData_447 = keysData[447];
				KeysData_448 = keysData[448];
				KeysData_449 = keysData[449];
				KeysData_450 = keysData[450];
				KeysData_451 = keysData[451];
				KeysData_452 = keysData[452];
				KeysData_453 = keysData[453];
				KeysData_454 = keysData[454];
				KeysData_455 = keysData[455];
				KeysData_456 = keysData[456];
				KeysData_457 = keysData[457];
				KeysData_458 = keysData[458];
				KeysData_459 = keysData[459];
				KeysData_460 = keysData[460];
				KeysData_461 = keysData[461];
				KeysData_462 = keysData[462];
				KeysData_463 = keysData[463];
				KeysData_464 = keysData[464];
				KeysData_465 = keysData[465];
				KeysData_466 = keysData[466];
				KeysData_467 = keysData[467];
				KeysData_468 = keysData[468];
				KeysData_469 = keysData[469];
				KeysData_470 = keysData[470];
				KeysData_471 = keysData[471];
				KeysData_472 = keysData[472];
				KeysData_473 = keysData[473];
				KeysData_474 = keysData[474];
				KeysData_475 = keysData[475];
				KeysData_476 = keysData[476];
				KeysData_477 = keysData[477];
				KeysData_478 = keysData[478];
				KeysData_479 = keysData[479];
				KeysData_480 = keysData[480];
				KeysData_481 = keysData[481];
				KeysData_482 = keysData[482];
				KeysData_483 = keysData[483];
				KeysData_484 = keysData[484];
				KeysData_485 = keysData[485];
				KeysData_486 = keysData[486];
				KeysData_487 = keysData[487];
				KeysData_488 = keysData[488];
				KeysData_489 = keysData[489];
				KeysData_490 = keysData[490];
				KeysData_491 = keysData[491];
				KeysData_492 = keysData[492];
				KeysData_493 = keysData[493];
				KeysData_494 = keysData[494];
				KeysData_495 = keysData[495];
				KeysData_496 = keysData[496];
				KeysData_497 = keysData[497];
				KeysData_498 = keysData[498];
				KeysData_499 = keysData[499];
				KeysData_500 = keysData[500];
				KeysData_501 = keysData[501];
				KeysData_502 = keysData[502];
				KeysData_503 = keysData[503];
				KeysData_504 = keysData[504];
				KeysData_505 = keysData[505];
				KeysData_506 = keysData[506];
				KeysData_507 = keysData[507];
				KeysData_508 = keysData[508];
				KeysData_509 = keysData[509];
				KeysData_510 = keysData[510];
				KeysData_511 = keysData[511];
				KeysData_512 = keysData[512];
				KeysData_513 = keysData[513];
				KeysData_514 = keysData[514];
				KeysData_515 = keysData[515];
				KeysData_516 = keysData[516];
				KeysData_517 = keysData[517];
				KeysData_518 = keysData[518];
				KeysData_519 = keysData[519];
				KeysData_520 = keysData[520];
				KeysData_521 = keysData[521];
				KeysData_522 = keysData[522];
				KeysData_523 = keysData[523];
				KeysData_524 = keysData[524];
				KeysData_525 = keysData[525];
				KeysData_526 = keysData[526];
				KeysData_527 = keysData[527];
				KeysData_528 = keysData[528];
				KeysData_529 = keysData[529];
				KeysData_530 = keysData[530];
				KeysData_531 = keysData[531];
				KeysData_532 = keysData[532];
				KeysData_533 = keysData[533];
				KeysData_534 = keysData[534];
				KeysData_535 = keysData[535];
				KeysData_536 = keysData[536];
				KeysData_537 = keysData[537];
				KeysData_538 = keysData[538];
				KeysData_539 = keysData[539];
				KeysData_540 = keysData[540];
				KeysData_541 = keysData[541];
				KeysData_542 = keysData[542];
				KeysData_543 = keysData[543];
				KeysData_544 = keysData[544];
				KeysData_545 = keysData[545];
				KeysData_546 = keysData[546];
				KeysData_547 = keysData[547];
				KeysData_548 = keysData[548];
				KeysData_549 = keysData[549];
				KeysData_550 = keysData[550];
				KeysData_551 = keysData[551];
				KeysData_552 = keysData[552];
				KeysData_553 = keysData[553];
				KeysData_554 = keysData[554];
				KeysData_555 = keysData[555];
				KeysData_556 = keysData[556];
				KeysData_557 = keysData[557];
				KeysData_558 = keysData[558];
				KeysData_559 = keysData[559];
				KeysData_560 = keysData[560];
				KeysData_561 = keysData[561];
				KeysData_562 = keysData[562];
				KeysData_563 = keysData[563];
				KeysData_564 = keysData[564];
				KeysData_565 = keysData[565];
				KeysData_566 = keysData[566];
				KeysData_567 = keysData[567];
				KeysData_568 = keysData[568];
				KeysData_569 = keysData[569];
				KeysData_570 = keysData[570];
				KeysData_571 = keysData[571];
				KeysData_572 = keysData[572];
				KeysData_573 = keysData[573];
				KeysData_574 = keysData[574];
				KeysData_575 = keysData[575];
				KeysData_576 = keysData[576];
				KeysData_577 = keysData[577];
				KeysData_578 = keysData[578];
				KeysData_579 = keysData[579];
				KeysData_580 = keysData[580];
				KeysData_581 = keysData[581];
				KeysData_582 = keysData[582];
				KeysData_583 = keysData[583];
				KeysData_584 = keysData[584];
				KeysData_585 = keysData[585];
				KeysData_586 = keysData[586];
				KeysData_587 = keysData[587];
				KeysData_588 = keysData[588];
				KeysData_589 = keysData[589];
				KeysData_590 = keysData[590];
				KeysData_591 = keysData[591];
				KeysData_592 = keysData[592];
				KeysData_593 = keysData[593];
				KeysData_594 = keysData[594];
				KeysData_595 = keysData[595];
				KeysData_596 = keysData[596];
				KeysData_597 = keysData[597];
				KeysData_598 = keysData[598];
				KeysData_599 = keysData[599];
				KeysData_600 = keysData[600];
				KeysData_601 = keysData[601];
				KeysData_602 = keysData[602];
				KeysData_603 = keysData[603];
				KeysData_604 = keysData[604];
				KeysData_605 = keysData[605];
				KeysData_606 = keysData[606];
				KeysData_607 = keysData[607];
				KeysData_608 = keysData[608];
				KeysData_609 = keysData[609];
				KeysData_610 = keysData[610];
				KeysData_611 = keysData[611];
				KeysData_612 = keysData[612];
				KeysData_613 = keysData[613];
				KeysData_614 = keysData[614];
				KeysData_615 = keysData[615];
				KeysData_616 = keysData[616];
				KeysData_617 = keysData[617];
				KeysData_618 = keysData[618];
				KeysData_619 = keysData[619];
				KeysData_620 = keysData[620];
				KeysData_621 = keysData[621];
				KeysData_622 = keysData[622];
				KeysData_623 = keysData[623];
				KeysData_624 = keysData[624];
				KeysData_625 = keysData[625];
				KeysData_626 = keysData[626];
				KeysData_627 = keysData[627];
				KeysData_628 = keysData[628];
				KeysData_629 = keysData[629];
				KeysData_630 = keysData[630];
				KeysData_631 = keysData[631];
				KeysData_632 = keysData[632];
				KeysData_633 = keysData[633];
				KeysData_634 = keysData[634];
				KeysData_635 = keysData[635];
				KeysData_636 = keysData[636];
				KeysData_637 = keysData[637];
				KeysData_638 = keysData[638];
				KeysData_639 = keysData[639];
				KeysData_640 = keysData[640];
				KeysData_641 = keysData[641];
				KeysData_642 = keysData[642];
				KeysData_643 = keysData[643];
				KeysData_644 = keysData[644];
				KeysData_645 = keysData[645];
				KeysData_646 = keysData[646];
				KeysData_647 = keysData[647];
				KeysData_648 = keysData[648];
				KeysData_649 = keysData[649];
				KeysData_650 = keysData[650];
				KeysData_651 = keysData[651];
				KeysData_652 = keysData[652];
				KeysData_653 = keysData[653];
				KeysData_654 = keysData[654];
				KeysData_655 = keysData[655];
				KeysData_656 = keysData[656];
				KeysData_657 = keysData[657];
				KeysData_658 = keysData[658];
				KeysData_659 = keysData[659];
				KeysData_660 = keysData[660];
				KeysData_661 = keysData[661];
				KeysData_662 = keysData[662];
				KeysData_663 = keysData[663];
				KeysData_664 = keysData[664];
				KeysData_665 = keysData[665];
			}
			WantCaptureMouseUnlessPopupClose = wantCaptureMouseUnlessPopupClose ? (byte)1 : (byte)0;
			MousePosPrev = mousePosPrev;
			if (mouseClickedPos != default)
			{
				MouseClickedPos_0 = mouseClickedPos[0];
				MouseClickedPos_1 = mouseClickedPos[1];
				MouseClickedPos_2 = mouseClickedPos[2];
				MouseClickedPos_3 = mouseClickedPos[3];
				MouseClickedPos_4 = mouseClickedPos[4];
			}
			if (mouseClickedTime != default)
			{
				MouseClickedTime_0 = mouseClickedTime[0];
				MouseClickedTime_1 = mouseClickedTime[1];
				MouseClickedTime_2 = mouseClickedTime[2];
				MouseClickedTime_3 = mouseClickedTime[3];
				MouseClickedTime_4 = mouseClickedTime[4];
			}
			if (mouseClicked != default)
			{
				MouseClicked_0 = mouseClicked[0];
				MouseClicked_1 = mouseClicked[1];
				MouseClicked_2 = mouseClicked[2];
				MouseClicked_3 = mouseClicked[3];
				MouseClicked_4 = mouseClicked[4];
			}
			if (mouseDoubleClicked != default)
			{
				MouseDoubleClicked_0 = mouseDoubleClicked[0];
				MouseDoubleClicked_1 = mouseDoubleClicked[1];
				MouseDoubleClicked_2 = mouseDoubleClicked[2];
				MouseDoubleClicked_3 = mouseDoubleClicked[3];
				MouseDoubleClicked_4 = mouseDoubleClicked[4];
			}
			if (mouseClickedCount != default)
			{
				MouseClickedCount_0 = mouseClickedCount[0];
				MouseClickedCount_1 = mouseClickedCount[1];
				MouseClickedCount_2 = mouseClickedCount[2];
				MouseClickedCount_3 = mouseClickedCount[3];
				MouseClickedCount_4 = mouseClickedCount[4];
			}
			if (mouseClickedLastCount != default)
			{
				MouseClickedLastCount_0 = mouseClickedLastCount[0];
				MouseClickedLastCount_1 = mouseClickedLastCount[1];
				MouseClickedLastCount_2 = mouseClickedLastCount[2];
				MouseClickedLastCount_3 = mouseClickedLastCount[3];
				MouseClickedLastCount_4 = mouseClickedLastCount[4];
			}
			if (mouseReleased != default)
			{
				MouseReleased_0 = mouseReleased[0];
				MouseReleased_1 = mouseReleased[1];
				MouseReleased_2 = mouseReleased[2];
				MouseReleased_3 = mouseReleased[3];
				MouseReleased_4 = mouseReleased[4];
			}
			if (mouseDownOwned != default)
			{
				MouseDownOwned_0 = mouseDownOwned[0];
				MouseDownOwned_1 = mouseDownOwned[1];
				MouseDownOwned_2 = mouseDownOwned[2];
				MouseDownOwned_3 = mouseDownOwned[3];
				MouseDownOwned_4 = mouseDownOwned[4];
			}
			if (mouseDownOwnedUnlessPopupClose != default)
			{
				MouseDownOwnedUnlessPopupClose_0 = mouseDownOwnedUnlessPopupClose[0];
				MouseDownOwnedUnlessPopupClose_1 = mouseDownOwnedUnlessPopupClose[1];
				MouseDownOwnedUnlessPopupClose_2 = mouseDownOwnedUnlessPopupClose[2];
				MouseDownOwnedUnlessPopupClose_3 = mouseDownOwnedUnlessPopupClose[3];
				MouseDownOwnedUnlessPopupClose_4 = mouseDownOwnedUnlessPopupClose[4];
			}
			MouseWheelRequestAxisSwap = mouseWheelRequestAxisSwap ? (byte)1 : (byte)0;
			if (mouseDownDuration != default)
			{
				MouseDownDuration_0 = mouseDownDuration[0];
				MouseDownDuration_1 = mouseDownDuration[1];
				MouseDownDuration_2 = mouseDownDuration[2];
				MouseDownDuration_3 = mouseDownDuration[3];
				MouseDownDuration_4 = mouseDownDuration[4];
			}
			if (mouseDownDurationPrev != default)
			{
				MouseDownDurationPrev_0 = mouseDownDurationPrev[0];
				MouseDownDurationPrev_1 = mouseDownDurationPrev[1];
				MouseDownDurationPrev_2 = mouseDownDurationPrev[2];
				MouseDownDurationPrev_3 = mouseDownDurationPrev[3];
				MouseDownDurationPrev_4 = mouseDownDurationPrev[4];
			}
			if (mouseDragMaxDistanceAbs != default)
			{
				MouseDragMaxDistanceAbs_0 = mouseDragMaxDistanceAbs[0];
				MouseDragMaxDistanceAbs_1 = mouseDragMaxDistanceAbs[1];
				MouseDragMaxDistanceAbs_2 = mouseDragMaxDistanceAbs[2];
				MouseDragMaxDistanceAbs_3 = mouseDragMaxDistanceAbs[3];
				MouseDragMaxDistanceAbs_4 = mouseDragMaxDistanceAbs[4];
			}
			if (mouseDragMaxDistanceSqr != default)
			{
				MouseDragMaxDistanceSqr_0 = mouseDragMaxDistanceSqr[0];
				MouseDragMaxDistanceSqr_1 = mouseDragMaxDistanceSqr[1];
				MouseDragMaxDistanceSqr_2 = mouseDragMaxDistanceSqr[2];
				MouseDragMaxDistanceSqr_3 = mouseDragMaxDistanceSqr[3];
				MouseDragMaxDistanceSqr_4 = mouseDragMaxDistanceSqr[4];
			}
			PenPressure = penPressure;
			AppFocusLost = appFocusLost ? (byte)1 : (byte)0;
			AppAcceptingEvents = appAcceptingEvents ? (byte)1 : (byte)0;
			BackendUsingLegacyKeyArrays = backendUsingLegacyKeyArrays;
			BackendUsingLegacyNavInputArray = backendUsingLegacyNavInputArray ? (byte)1 : (byte)0;
			InputQueueSurrogate = inputQueueSurrogate;
			InputQueueCharacters = inputQueueCharacters;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<ImGuiKeyData> KeysData
		
		{
			get
			{
				fixed (ImGuiKeyData* p = &this.KeysData_0)
				{
					return new Span<ImGuiKeyData>(p, 666);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Vector2> MouseClickedPos
		
		{
			get
			{
				fixed (Vector2* p = &this.MouseClickedPos_0)
				{
					return new Span<Vector2>(p, 5);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Vector2> MouseDragMaxDistanceAbs
		
		{
			get
			{
				fixed (Vector2* p = &this.MouseDragMaxDistanceAbs_0)
				{
					return new Span<Vector2>(p, 5);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddFocusEvent( bool focused)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddFocusEventNative(@this, focused ? (byte)1 : (byte)0);
			}
		}

		public unsafe void AddInputCharacter( uint c)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharacterNative(@this, c);
			}
		}

		public unsafe void AddInputCharactersUTF8( byte* str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharactersUTF8Native(@this, str);
			}
		}

		public unsafe void AddInputCharactersUTF8( ref byte str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.AddInputCharactersUTF8Native(@this, (byte*)pstr);
				}
			}
		}

		public unsafe void AddInputCharactersUTF8( string str)
		{
			fixed (ImGuiIO* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.AddInputCharactersUTF8Native(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void AddInputCharacterUTF16( ushort c)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddInputCharacterUTF16Native(@this, c);
			}
		}

		public unsafe void AddKeyAnalogEvent( ImGuiKey key,  bool down,  float v)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddKeyAnalogEventNative(@this, key, down ? (byte)1 : (byte)0, v);
			}
		}

		public unsafe void AddKeyEvent( ImGuiKey key,  bool down)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddKeyEventNative(@this, key, down ? (byte)1 : (byte)0);
			}
		}

		public unsafe void AddMouseButtonEvent( int button,  bool down)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseButtonEventNative(@this, button, down ? (byte)1 : (byte)0);
			}
		}

		public unsafe void AddMousePosEvent( float x,  float y)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMousePosEventNative(@this, x, y);
			}
		}

		public unsafe void AddMouseSourceEvent( ImGuiMouseSource source)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseSourceEventNative(@this, source);
			}
		}

		public unsafe void AddMouseViewportEvent( uint id)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseViewportEventNative(@this, id);
			}
		}

		public unsafe void AddMouseWheelEvent( float wheelX,  float wheelY)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.AddMouseWheelEventNative(@this, wheelX, wheelY);
			}
		}

		public unsafe void ClearEventsQueue()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.ClearEventsQueueNative(@this);
			}
		}

		public unsafe void ClearInputKeys()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.ClearInputKeysNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void SetAppAcceptingEvents( bool acceptingEvents)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetAppAcceptingEventsNative(@this, acceptingEvents ? (byte)1 : (byte)0);
			}
		}

		public unsafe void SetKeyEventNativeData( ImGuiKey key,  int nativeKeycode,  int nativeScancode,  int nativeLegacyIndex)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetKeyEventNativeDataNative(@this, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			}
		}

		public unsafe void SetKeyEventNativeData( ImGuiKey key,  int nativeKeycode,  int nativeScancode)
		{
			fixed (ImGuiIO* @this = &this)
			{
				ImGui.SetKeyEventNativeDataNative(@this, key, nativeKeycode, nativeScancode, (int)(-1));
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformImeData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 InputPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float InputLineHeight;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiPlatformImeData(bool wantVisible = default, Vector2 inputPos = default, float inputLineHeight = default)
		{
			WantVisible = wantVisible ? (byte)1 : (byte)0;
			InputPos = inputPos;
			InputLineHeight = inputLineHeight;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformImeData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Down;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DownDuration;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DownDurationPrev;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float AnalogValue;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiKeyData(bool down = default, float downDuration = default, float downDurationPrev = default, float analogValue = default)
		{
			Down = down ? (byte)1 : (byte)0;
			DownDuration = downDuration;
			DownDurationPrev = downDurationPrev;
			AnalogValue = analogValue;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformIO
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformCreateWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformDestroyWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformShowWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformSetWindowPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformGetWindowPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformSetWindowSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformGetWindowSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformSetWindowFocus;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformGetWindowFocus;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformGetWindowMinimized;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformSetWindowTitle;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformSetWindowAlpha;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformUpdateWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformRenderWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformSwapBuffers;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformGetWindowDpiScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformOnChangedViewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformCreateVkSurface;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* RendererCreateWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* RendererDestroyWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* RendererSetWindowSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* RendererRenderWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* RendererSwapBuffers;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiPlatformMonitor Monitors;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiViewportPtr Viewports;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiPlatformIO(delegate*<ImGuiViewport*, void> platformCreatewindow = default, delegate*<ImGuiViewport*, void> platformDestroywindow = default, delegate*<ImGuiViewport*, void> platformShowwindow = default, delegate*<ImGuiViewport*, Vector2, void> platformSetwindowpos = default, delegate*<ImGuiViewport*, Vector2> platformGetwindowpos = default, delegate*<ImGuiViewport*, Vector2, void> platformSetwindowsize = default, delegate*<ImGuiViewport*, Vector2> platformGetwindowsize = default, delegate*<ImGuiViewport*, void> platformSetwindowfocus = default, delegate*<ImGuiViewport*, bool> platformGetwindowfocus = default, delegate*<ImGuiViewport*, bool> platformGetwindowminimized = default, delegate*<ImGuiViewport*, byte*, void> platformSetwindowtitle = default, delegate*<ImGuiViewport*, float, void> platformSetwindowalpha = default, delegate*<ImGuiViewport*, void> platformUpdatewindow = default, delegate*<ImGuiViewport*, void*, void> platformRenderwindow = default, delegate*<ImGuiViewport*, void*, void> platformSwapbuffers = default, delegate*<ImGuiViewport*, float> platformGetwindowdpiscale = default, delegate*<ImGuiViewport*, void> platformOnchangedviewport = default, delegate*<ImGuiViewport*, ulong, void*, ulong*, int> platformCreatevksurface = default, delegate*<ImGuiViewport*, void> rendererCreatewindow = default, delegate*<ImGuiViewport*, void> rendererDestroywindow = default, delegate*<ImGuiViewport*, Vector2, void> rendererSetwindowsize = default, delegate*<ImGuiViewport*, void*, void> rendererRenderwindow = default, delegate*<ImGuiViewport*, void*, void> rendererSwapbuffers = default, ImVectorImGuiPlatformMonitor monitors = default, ImVectorImGuiViewportPtr viewports = default)
		{
			PlatformCreateWindow = (void*)platformCreatewindow;
			PlatformDestroyWindow = (void*)platformDestroywindow;
			PlatformShowWindow = (void*)platformShowwindow;
			PlatformSetWindowPos = (void*)platformSetwindowpos;
			PlatformGetWindowPos = (void*)platformGetwindowpos;
			PlatformSetWindowSize = (void*)platformSetwindowsize;
			PlatformGetWindowSize = (void*)platformGetwindowsize;
			PlatformSetWindowFocus = (void*)platformSetwindowfocus;
			PlatformGetWindowFocus = (void*)platformGetwindowfocus;
			PlatformGetWindowMinimized = (void*)platformGetwindowminimized;
			PlatformSetWindowTitle = (void*)platformSetwindowtitle;
			PlatformSetWindowAlpha = (void*)platformSetwindowalpha;
			PlatformUpdateWindow = (void*)platformUpdatewindow;
			PlatformRenderWindow = (void*)platformRenderwindow;
			PlatformSwapBuffers = (void*)platformSwapbuffers;
			PlatformGetWindowDpiScale = (void*)platformGetwindowdpiscale;
			PlatformOnChangedViewport = (void*)platformOnchangedviewport;
			PlatformCreateVkSurface = (void*)platformCreatevksurface;
			RendererCreateWindow = (void*)rendererCreatewindow;
			RendererDestroyWindow = (void*)rendererDestroywindow;
			RendererSetWindowSize = (void*)rendererSetwindowsize;
			RendererRenderWindow = (void*)rendererRenderwindow;
			RendererSwapBuffers = (void*)rendererSwapbuffers;
			Monitors = monitors;
			Viewports = viewports;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformIO* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPlatformMonitor
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiPlatformMonitor* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiPlatformMonitor(int size = default, int capacity = default, ImGuiPlatformMonitor* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPlatformMonitor
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MainPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MainSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WorkPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WorkSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DpiScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* PlatformHandle;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiPlatformMonitor(Vector2 mainPos = default, Vector2 mainSize = default, Vector2 workPos = default, Vector2 workSize = default, float dpiScale = default, void* platformHandle = default)
		{
			MainPos = mainPos;
			MainSize = mainSize;
			WorkPos = workPos;
			WorkSize = workSize;
			DpiScale = dpiScale;
			PlatformHandle = platformHandle;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiPlatformMonitor* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiViewportPtr
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiViewport** Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiViewportPtr(int size = default, int capacity = default, ImGuiViewport** data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStyle
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float Alpha;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DisabledAlpha;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WindowPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WindowRounding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WindowBorderSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WindowMinSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WindowTitleAlign;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int WindowMenuButtonPosition;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ChildRounding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ChildBorderSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PopupRounding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PopupBorderSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 FramePadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FrameRounding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FrameBorderSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ItemSpacing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ItemInnerSpacing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CellPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 TouchExtraPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float IndentSpacing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ColumnsMinSpacing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollbarSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollbarRounding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float GrabMinSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float GrabRounding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LogSliderDeadzone;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float TabRounding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float TabBorderSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float TabMinWidthForCloseButton;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float TabBarBorderSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float TableAngledHeadersAngle;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ColorButtonPosition;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ButtonTextAlign;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SelectableTextAlign;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float SeparatorTextBorderSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SeparatorTextAlign;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SeparatorTextPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 DisplayWindowPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 DisplaySafeAreaPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DockingSeparatorSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MouseCursorScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AntiAliasedLines;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AntiAliasedLinesUseTex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AntiAliasedFill;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CurveTessellationTol;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CircleTessellationMaxError;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 Colors_0;
		public Vector4 Colors_1;
		public Vector4 Colors_2;
		public Vector4 Colors_3;
		public Vector4 Colors_4;
		public Vector4 Colors_5;
		public Vector4 Colors_6;
		public Vector4 Colors_7;
		public Vector4 Colors_8;
		public Vector4 Colors_9;
		public Vector4 Colors_10;
		public Vector4 Colors_11;
		public Vector4 Colors_12;
		public Vector4 Colors_13;
		public Vector4 Colors_14;
		public Vector4 Colors_15;
		public Vector4 Colors_16;
		public Vector4 Colors_17;
		public Vector4 Colors_18;
		public Vector4 Colors_19;
		public Vector4 Colors_20;
		public Vector4 Colors_21;
		public Vector4 Colors_22;
		public Vector4 Colors_23;
		public Vector4 Colors_24;
		public Vector4 Colors_25;
		public Vector4 Colors_26;
		public Vector4 Colors_27;
		public Vector4 Colors_28;
		public Vector4 Colors_29;
		public Vector4 Colors_30;
		public Vector4 Colors_31;
		public Vector4 Colors_32;
		public Vector4 Colors_33;
		public Vector4 Colors_34;
		public Vector4 Colors_35;
		public Vector4 Colors_36;
		public Vector4 Colors_37;
		public Vector4 Colors_38;
		public Vector4 Colors_39;
		public Vector4 Colors_40;
		public Vector4 Colors_41;
		public Vector4 Colors_42;
		public Vector4 Colors_43;
		public Vector4 Colors_44;
		public Vector4 Colors_45;
		public Vector4 Colors_46;
		public Vector4 Colors_47;
		public Vector4 Colors_48;
		public Vector4 Colors_49;
		public Vector4 Colors_50;
		public Vector4 Colors_51;
		public Vector4 Colors_52;
		public Vector4 Colors_53;
		public Vector4 Colors_54;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HoverStationaryDelay;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HoverDelayShort;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HoverDelayNormal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int HoverFlagsForTooltipMouse;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int HoverFlagsForTooltipNav;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiStyle(float alpha = default, float disabledAlpha = default, Vector2 windowPadding = default, float windowRounding = default, float windowBorderSize = default, Vector2 windowMinSize = default, Vector2 windowTitleAlign = default, int windowMenuButtonPosition = default, float childRounding = default, float childBorderSize = default, float popupRounding = default, float popupBorderSize = default, Vector2 framePadding = default, float frameRounding = default, float frameBorderSize = default, Vector2 itemSpacing = default, Vector2 itemInnerSpacing = default, Vector2 cellPadding = default, Vector2 touchExtraPadding = default, float indentSpacing = default, float columnsMinSpacing = default, float scrollbarSize = default, float scrollbarRounding = default, float grabMinSize = default, float grabRounding = default, float logSliderDeadzone = default, float tabRounding = default, float tabBorderSize = default, float tabMinWidthForCloseButton = default, float tabBarBorderSize = default, float tableAngledHeadersAngle = default, int colorButtonPosition = default, Vector2 buttonTextAlign = default, Vector2 selectableTextAlign = default, float separatorTextBorderSize = default, Vector2 separatorTextAlign = default, Vector2 separatorTextPadding = default, Vector2 displayWindowPadding = default, Vector2 displaySafeAreaPadding = default, float dockingSeparatorSize = default, float mouseCursorScale = default, bool antiAliasedLines = default, bool antiAliasedLinesUseTex = default, bool antiAliasedFill = default, float curveTessellationTol = default, float circleTessellationMaxError = default, Vector4* colors = default, float hoverStationaryDelay = default, float hoverDelayShort = default, float hoverDelayNormal = default, int hoverFlagsForTooltipMouse = default, int hoverFlagsForTooltipNav = default)
		{
			Alpha = alpha;
			DisabledAlpha = disabledAlpha;
			WindowPadding = windowPadding;
			WindowRounding = windowRounding;
			WindowBorderSize = windowBorderSize;
			WindowMinSize = windowMinSize;
			WindowTitleAlign = windowTitleAlign;
			WindowMenuButtonPosition = windowMenuButtonPosition;
			ChildRounding = childRounding;
			ChildBorderSize = childBorderSize;
			PopupRounding = popupRounding;
			PopupBorderSize = popupBorderSize;
			FramePadding = framePadding;
			FrameRounding = frameRounding;
			FrameBorderSize = frameBorderSize;
			ItemSpacing = itemSpacing;
			ItemInnerSpacing = itemInnerSpacing;
			CellPadding = cellPadding;
			TouchExtraPadding = touchExtraPadding;
			IndentSpacing = indentSpacing;
			ColumnsMinSpacing = columnsMinSpacing;
			ScrollbarSize = scrollbarSize;
			ScrollbarRounding = scrollbarRounding;
			GrabMinSize = grabMinSize;
			GrabRounding = grabRounding;
			LogSliderDeadzone = logSliderDeadzone;
			TabRounding = tabRounding;
			TabBorderSize = tabBorderSize;
			TabMinWidthForCloseButton = tabMinWidthForCloseButton;
			TabBarBorderSize = tabBarBorderSize;
			TableAngledHeadersAngle = tableAngledHeadersAngle;
			ColorButtonPosition = colorButtonPosition;
			ButtonTextAlign = buttonTextAlign;
			SelectableTextAlign = selectableTextAlign;
			SeparatorTextBorderSize = separatorTextBorderSize;
			SeparatorTextAlign = separatorTextAlign;
			SeparatorTextPadding = separatorTextPadding;
			DisplayWindowPadding = displayWindowPadding;
			DisplaySafeAreaPadding = displaySafeAreaPadding;
			DockingSeparatorSize = dockingSeparatorSize;
			MouseCursorScale = mouseCursorScale;
			AntiAliasedLines = antiAliasedLines ? (byte)1 : (byte)0;
			AntiAliasedLinesUseTex = antiAliasedLinesUseTex ? (byte)1 : (byte)0;
			AntiAliasedFill = antiAliasedFill ? (byte)1 : (byte)0;
			CurveTessellationTol = curveTessellationTol;
			CircleTessellationMaxError = circleTessellationMaxError;
			if (colors != default)
			{
				Colors_0 = colors[0];
				Colors_1 = colors[1];
				Colors_2 = colors[2];
				Colors_3 = colors[3];
				Colors_4 = colors[4];
				Colors_5 = colors[5];
				Colors_6 = colors[6];
				Colors_7 = colors[7];
				Colors_8 = colors[8];
				Colors_9 = colors[9];
				Colors_10 = colors[10];
				Colors_11 = colors[11];
				Colors_12 = colors[12];
				Colors_13 = colors[13];
				Colors_14 = colors[14];
				Colors_15 = colors[15];
				Colors_16 = colors[16];
				Colors_17 = colors[17];
				Colors_18 = colors[18];
				Colors_19 = colors[19];
				Colors_20 = colors[20];
				Colors_21 = colors[21];
				Colors_22 = colors[22];
				Colors_23 = colors[23];
				Colors_24 = colors[24];
				Colors_25 = colors[25];
				Colors_26 = colors[26];
				Colors_27 = colors[27];
				Colors_28 = colors[28];
				Colors_29 = colors[29];
				Colors_30 = colors[30];
				Colors_31 = colors[31];
				Colors_32 = colors[32];
				Colors_33 = colors[33];
				Colors_34 = colors[34];
				Colors_35 = colors[35];
				Colors_36 = colors[36];
				Colors_37 = colors[37];
				Colors_38 = colors[38];
				Colors_39 = colors[39];
				Colors_40 = colors[40];
				Colors_41 = colors[41];
				Colors_42 = colors[42];
				Colors_43 = colors[43];
				Colors_44 = colors[44];
				Colors_45 = colors[45];
				Colors_46 = colors[46];
				Colors_47 = colors[47];
				Colors_48 = colors[48];
				Colors_49 = colors[49];
				Colors_50 = colors[50];
				Colors_51 = colors[51];
				Colors_52 = colors[52];
				Colors_53 = colors[53];
				Colors_54 = colors[54];
			}
			HoverStationaryDelay = hoverStationaryDelay;
			HoverDelayShort = hoverDelayShort;
			HoverDelayNormal = hoverDelayNormal;
			HoverFlagsForTooltipMouse = hoverFlagsForTooltipMouse;
			HoverFlagsForTooltipNav = hoverFlagsForTooltipNav;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiStyle(float alpha = default, float disabledAlpha = default, Vector2 windowPadding = default, float windowRounding = default, float windowBorderSize = default, Vector2 windowMinSize = default, Vector2 windowTitleAlign = default, int windowMenuButtonPosition = default, float childRounding = default, float childBorderSize = default, float popupRounding = default, float popupBorderSize = default, Vector2 framePadding = default, float frameRounding = default, float frameBorderSize = default, Vector2 itemSpacing = default, Vector2 itemInnerSpacing = default, Vector2 cellPadding = default, Vector2 touchExtraPadding = default, float indentSpacing = default, float columnsMinSpacing = default, float scrollbarSize = default, float scrollbarRounding = default, float grabMinSize = default, float grabRounding = default, float logSliderDeadzone = default, float tabRounding = default, float tabBorderSize = default, float tabMinWidthForCloseButton = default, float tabBarBorderSize = default, float tableAngledHeadersAngle = default, int colorButtonPosition = default, Vector2 buttonTextAlign = default, Vector2 selectableTextAlign = default, float separatorTextBorderSize = default, Vector2 separatorTextAlign = default, Vector2 separatorTextPadding = default, Vector2 displayWindowPadding = default, Vector2 displaySafeAreaPadding = default, float dockingSeparatorSize = default, float mouseCursorScale = default, bool antiAliasedLines = default, bool antiAliasedLinesUseTex = default, bool antiAliasedFill = default, float curveTessellationTol = default, float circleTessellationMaxError = default, Span<Vector4> colors = default, float hoverStationaryDelay = default, float hoverDelayShort = default, float hoverDelayNormal = default, int hoverFlagsForTooltipMouse = default, int hoverFlagsForTooltipNav = default)
		{
			Alpha = alpha;
			DisabledAlpha = disabledAlpha;
			WindowPadding = windowPadding;
			WindowRounding = windowRounding;
			WindowBorderSize = windowBorderSize;
			WindowMinSize = windowMinSize;
			WindowTitleAlign = windowTitleAlign;
			WindowMenuButtonPosition = windowMenuButtonPosition;
			ChildRounding = childRounding;
			ChildBorderSize = childBorderSize;
			PopupRounding = popupRounding;
			PopupBorderSize = popupBorderSize;
			FramePadding = framePadding;
			FrameRounding = frameRounding;
			FrameBorderSize = frameBorderSize;
			ItemSpacing = itemSpacing;
			ItemInnerSpacing = itemInnerSpacing;
			CellPadding = cellPadding;
			TouchExtraPadding = touchExtraPadding;
			IndentSpacing = indentSpacing;
			ColumnsMinSpacing = columnsMinSpacing;
			ScrollbarSize = scrollbarSize;
			ScrollbarRounding = scrollbarRounding;
			GrabMinSize = grabMinSize;
			GrabRounding = grabRounding;
			LogSliderDeadzone = logSliderDeadzone;
			TabRounding = tabRounding;
			TabBorderSize = tabBorderSize;
			TabMinWidthForCloseButton = tabMinWidthForCloseButton;
			TabBarBorderSize = tabBarBorderSize;
			TableAngledHeadersAngle = tableAngledHeadersAngle;
			ColorButtonPosition = colorButtonPosition;
			ButtonTextAlign = buttonTextAlign;
			SelectableTextAlign = selectableTextAlign;
			SeparatorTextBorderSize = separatorTextBorderSize;
			SeparatorTextAlign = separatorTextAlign;
			SeparatorTextPadding = separatorTextPadding;
			DisplayWindowPadding = displayWindowPadding;
			DisplaySafeAreaPadding = displaySafeAreaPadding;
			DockingSeparatorSize = dockingSeparatorSize;
			MouseCursorScale = mouseCursorScale;
			AntiAliasedLines = antiAliasedLines ? (byte)1 : (byte)0;
			AntiAliasedLinesUseTex = antiAliasedLinesUseTex ? (byte)1 : (byte)0;
			AntiAliasedFill = antiAliasedFill ? (byte)1 : (byte)0;
			CurveTessellationTol = curveTessellationTol;
			CircleTessellationMaxError = circleTessellationMaxError;
			if (colors != default)
			{
				Colors_0 = colors[0];
				Colors_1 = colors[1];
				Colors_2 = colors[2];
				Colors_3 = colors[3];
				Colors_4 = colors[4];
				Colors_5 = colors[5];
				Colors_6 = colors[6];
				Colors_7 = colors[7];
				Colors_8 = colors[8];
				Colors_9 = colors[9];
				Colors_10 = colors[10];
				Colors_11 = colors[11];
				Colors_12 = colors[12];
				Colors_13 = colors[13];
				Colors_14 = colors[14];
				Colors_15 = colors[15];
				Colors_16 = colors[16];
				Colors_17 = colors[17];
				Colors_18 = colors[18];
				Colors_19 = colors[19];
				Colors_20 = colors[20];
				Colors_21 = colors[21];
				Colors_22 = colors[22];
				Colors_23 = colors[23];
				Colors_24 = colors[24];
				Colors_25 = colors[25];
				Colors_26 = colors[26];
				Colors_27 = colors[27];
				Colors_28 = colors[28];
				Colors_29 = colors[29];
				Colors_30 = colors[30];
				Colors_31 = colors[31];
				Colors_32 = colors[32];
				Colors_33 = colors[33];
				Colors_34 = colors[34];
				Colors_35 = colors[35];
				Colors_36 = colors[36];
				Colors_37 = colors[37];
				Colors_38 = colors[38];
				Colors_39 = colors[39];
				Colors_40 = colors[40];
				Colors_41 = colors[41];
				Colors_42 = colors[42];
				Colors_43 = colors[43];
				Colors_44 = colors[44];
				Colors_45 = colors[45];
				Colors_46 = colors[46];
				Colors_47 = colors[47];
				Colors_48 = colors[48];
				Colors_49 = colors[49];
				Colors_50 = colors[50];
				Colors_51 = colors[51];
				Colors_52 = colors[52];
				Colors_53 = colors[53];
				Colors_54 = colors[54];
			}
			HoverStationaryDelay = hoverStationaryDelay;
			HoverDelayShort = hoverDelayShort;
			HoverDelayNormal = hoverDelayNormal;
			HoverFlagsForTooltipMouse = hoverFlagsForTooltipMouse;
			HoverFlagsForTooltipNav = hoverFlagsForTooltipNav;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Vector4> Colors
		
		{
			get
			{
				fixed (Vector4* p = &this.Colors_0)
				{
					return new Span<Vector4>(p, 55);
				}
			}
		}
		public unsafe void Destroy()
		{
			fixed (ImGuiStyle* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void ScaleAllSizes( float scaleFactor)
		{
			fixed (ImGuiStyle* @this = &this)
			{
				ImGui.ScaleAllSizesNative(@this, scaleFactor);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiInputEvent
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiInputEvent* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiInputEvent(int size = default, int capacity = default, ImGuiInputEvent* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEvent
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		[StructLayout(LayoutKind.Explicit)]
		public partial struct ImGuiInputEventUnion
		{
			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public ImGuiInputEventMousePos MousePos;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public ImGuiInputEventMouseWheel MouseWheel;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public ImGuiInputEventMouseButton MouseButton;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public ImGuiInputEventMouseViewport MouseViewport;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public ImGuiInputEventKey Key;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public ImGuiInputEventText Text;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public ImGuiInputEventAppFocused AppFocused;


			/// <summary>			/// To be documented.			/// </summary>			public unsafe ImGuiInputEventUnion(ImGuiInputEventMousePos mousePos = default, ImGuiInputEventMouseWheel mouseWheel = default, ImGuiInputEventMouseButton mouseButton = default, ImGuiInputEventMouseViewport mouseViewport = default, ImGuiInputEventKey key = default, ImGuiInputEventText text = default, ImGuiInputEventAppFocused appFocused = default)
			{
				MousePos = mousePos;
				MouseWheel = mouseWheel;
				MouseButton = mouseButton;
				MouseViewport = mouseViewport;
				Key = key;
				Text = text;
				AppFocused = appFocused;
			}


		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiInputEventType Type;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiInputSource Source;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint EventId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiInputEventUnion Union;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AddedByTestEngine;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputEvent(ImGuiInputEventType type = default, ImGuiInputSource source = default, uint eventId = default, ImGuiInputEventUnion union = default, bool addedByTestEngine = default)
		{
			Type = type;
			Source = source;
			EventId = eventId;
			Union = union;
			AddedByTestEngine = addedByTestEngine ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMousePos
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float PosX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PosY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiMouseSource MouseSource;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputEventMousePos(float posX = default, float posY = default, ImGuiMouseSource mouseSource = default)
		{
			PosX = posX;
			PosY = posY;
			MouseSource = mouseSource;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseWheel
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float WheelX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WheelY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiMouseSource MouseSource;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputEventMouseWheel(float wheelX = default, float wheelY = default, ImGuiMouseSource mouseSource = default)
		{
			WheelX = wheelX;
			WheelY = wheelY;
			MouseSource = mouseSource;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseButton
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Button;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Down;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiMouseSource MouseSource;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputEventMouseButton(int button = default, bool down = default, ImGuiMouseSource mouseSource = default)
		{
			Button = button;
			Down = down ? (byte)1 : (byte)0;
			MouseSource = mouseSource;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventMouseViewport
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint HoveredViewportID;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputEventMouseViewport(uint hoveredViewportId = default)
		{
			HoveredViewportID = hoveredViewportId;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventKey
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiKey Key;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Down;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float AnalogValue;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputEventKey(ImGuiKey key = default, bool down = default, float analogValue = default)
		{
			Key = key;
			Down = down ? (byte)1 : (byte)0;
			AnalogValue = analogValue;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventText
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Char;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputEventText(uint @char = default)
		{
			Char = @char;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputEventAppFocused
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Focused;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputEventAppFocused(bool focused = default)
		{
			Focused = focused ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiWindowPtr
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow** Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiWindowPtr(int size = default, int capacity = default, ImGuiWindow** data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindow
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Name;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FlagsPreviousFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiWindowClass WindowClass;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiViewportP* Viewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ViewportId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ViewportPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ViewportAllowPlatformMonitorExtend;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SizeFull;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ContentSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ContentSizeIdeal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ContentSizeExplicit;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WindowPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WindowRounding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WindowBorderSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DecoOuterSizeX1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DecoOuterSizeY1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DecoOuterSizeX2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DecoOuterSizeY2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DecoInnerSizeX1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DecoInnerSizeY1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NameBufLen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint MoveId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint TabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ChildId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Scroll;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ScrollMax;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ScrollTarget;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ScrollTargetCenterRatio;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ScrollTargetEdgeSnapDist;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ScrollbarSizes;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ScrollbarX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ScrollbarY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ViewportOwned;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Active;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WasActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WriteAccessed;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Collapsed;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantCollapseToggle;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SkipItems;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Appearing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Hidden;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsFallbackWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsExplicitChild;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasCloseButton;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ResizeBorderHeld;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short BeginCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short BeginCountPreviousFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short BeginOrderWithinParent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short BeginOrderWithinContext;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short FocusOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint PopupId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AutoFitFramesX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AutoFitFramesY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AutoFitOnlyGrows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int AutoPosLastDirection;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HiddenFramesCanSkipItems;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HiddenFramesCannotSkipItems;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HiddenFramesForRenderOnly;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DisableInputsFrames;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SetWindowPosAllowFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SetWindowSizeAllowFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SetWindowCollapsedAllowFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SetWindowDockAllowFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SetWindowPosVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SetWindowPosPivot;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiID IDStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiWindowTempData DC;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect OuterRectClipped;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect InnerRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect InnerClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect WorkRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect ParentWorkRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect ClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect ContentRegionRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec2Ih HitTestHoleSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec2Ih HitTestHoleOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameJustFocused;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LastTimeActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ItemWidthDefault;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStorage StateStorage;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiOldColumns ColumnsStorage;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FontWindowScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float FontDpiScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SettingsOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawList* DrawList;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawList DrawListInst;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* ParentWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* ParentWindowInBeginStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* RootWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* RootWindowPopupTree;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* RootWindowDockTree;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* RootWindowForTitleBarHighlight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* RootWindowForNav;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* NavLastChildNavWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavLastIds_0;
		public uint NavLastIds_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect NavRectRel_0;
		public ImRect NavRectRel_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 NavPreferredScoringPosRel_0;
		public Vector2 NavPreferredScoringPosRel_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NavRootFocusScopeId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MemoryDrawListIdxCapacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MemoryDrawListVtxCapacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte MemoryCompacted;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DockIsActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DockNodeIsVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DockTabIsVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DockTabWantClose;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short DockOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiWindowDockStyle DockStyle;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* DockNode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* DockNodeAsHost;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DockId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DockTabItemStatusFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect DockTabItemRect;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiWindow(ImGuiContext* ctx = default, byte* name = default, uint id = default, int flags = default, int flagsPreviousFrame = default, ImGuiWindowClass windowClass = default, ImGuiViewportP* viewport = default, uint viewportId = default, Vector2 viewportPos = default, int viewportAllowPlatformMonitorExtend = default, Vector2 pos = default, Vector2 size = default, Vector2 sizeFull = default, Vector2 contentSize = default, Vector2 contentSizeIdeal = default, Vector2 contentSizeExplicit = default, Vector2 windowPadding = default, float windowRounding = default, float windowBorderSize = default, float decoOuterSizeX1 = default, float decoOuterSizeY1 = default, float decoOuterSizeX2 = default, float decoOuterSizeY2 = default, float decoInnerSizeX1 = default, float decoInnerSizeY1 = default, int nameBufLen = default, uint moveId = default, uint tabId = default, uint childId = default, Vector2 scroll = default, Vector2 scrollMax = default, Vector2 scrollTarget = default, Vector2 scrollTargetCenterRatio = default, Vector2 scrollTargetEdgeSnapDist = default, Vector2 scrollbarSizes = default, bool scrollbarX = default, bool scrollbarY = default, bool viewportOwned = default, bool active = default, bool wasActive = default, bool writeAccessed = default, bool collapsed = default, bool wantCollapseToggle = default, bool skipItems = default, bool appearing = default, bool hidden = default, bool isFallbackWindow = default, bool isExplicitChild = default, bool hasCloseButton = default, byte resizeBorderHeld = default, short beginCount = default, short beginCountPreviousFrame = default, short beginOrderWithinParent = default, short beginOrderWithinContext = default, short focusOrder = default, uint popupId = default, byte autoFitFramesX = default, byte autoFitFramesY = default, bool autoFitOnlyGrows = default, int autoPosLastDirection = default, byte hiddenFramesCanSkipItems = default, byte hiddenFramesCannotSkipItems = default, byte hiddenFramesForRenderOnly = default, byte disableInputsFrames = default, int setWindowPosAllowFlags = default, int setWindowSizeAllowFlags = default, int setWindowCollapsedAllowFlags = default, int setWindowDockAllowFlags = default, Vector2 setWindowPosVal = default, Vector2 setWindowPosPivot = default, ImVectorImGuiID idStack = default, ImGuiWindowTempData dc = default, ImRect outerRectClipped = default, ImRect innerRect = default, ImRect innerClipRect = default, ImRect workRect = default, ImRect parentWorkRect = default, ImRect clipRect = default, ImRect contentRegionRect = default, ImVec2Ih hitTestHoleSize = default, ImVec2Ih hitTestHoleOffset = default, int lastFrameActive = default, int lastFrameJustFocused = default, float lastTimeActive = default, float itemWidthDefault = default, ImGuiStorage stateStorage = default, ImVectorImGuiOldColumns columnsStorage = default, float fontWindowScale = default, float fontDpiScale = default, int settingsOffset = default, ImDrawList* drawList = default, ImDrawList drawListInst = default, ImGuiWindow* parentWindow = default, ImGuiWindow* parentWindowInBeginStack = default, ImGuiWindow* rootWindow = default, ImGuiWindow* rootWindowPopupTree = default, ImGuiWindow* rootWindowDockTree = default, ImGuiWindow* rootWindowForTitleBarHighlight = default, ImGuiWindow* rootWindowForNav = default, ImGuiWindow* navLastChildNavWindow = default, uint* navLastIds = default, ImRect* navRectRel = default, Vector2* navPreferredScoringPosRel = default, uint navRootFocusScopeId = default, int memoryDrawListIdxCapacity = default, int memoryDrawListVtxCapacity = default, bool memoryCompacted = default, bool dockIsActive = default, bool dockNodeIsVisible = default, bool dockTabIsVisible = default, bool dockTabWantClose = default, short dockOrder = default, ImGuiWindowDockStyle dockStyle = default, ImGuiDockNode* dockNode = default, ImGuiDockNode* dockNodeAsHost = default, uint dockId = default, int dockTabItemStatusFlags = default, ImRect dockTabItemRect = default)
		{
			Ctx = ctx;
			Name = name;
			ID = id;
			Flags = flags;
			FlagsPreviousFrame = flagsPreviousFrame;
			WindowClass = windowClass;
			Viewport = viewport;
			ViewportId = viewportId;
			ViewportPos = viewportPos;
			ViewportAllowPlatformMonitorExtend = viewportAllowPlatformMonitorExtend;
			Pos = pos;
			Size = size;
			SizeFull = sizeFull;
			ContentSize = contentSize;
			ContentSizeIdeal = contentSizeIdeal;
			ContentSizeExplicit = contentSizeExplicit;
			WindowPadding = windowPadding;
			WindowRounding = windowRounding;
			WindowBorderSize = windowBorderSize;
			DecoOuterSizeX1 = decoOuterSizeX1;
			DecoOuterSizeY1 = decoOuterSizeY1;
			DecoOuterSizeX2 = decoOuterSizeX2;
			DecoOuterSizeY2 = decoOuterSizeY2;
			DecoInnerSizeX1 = decoInnerSizeX1;
			DecoInnerSizeY1 = decoInnerSizeY1;
			NameBufLen = nameBufLen;
			MoveId = moveId;
			TabId = tabId;
			ChildId = childId;
			Scroll = scroll;
			ScrollMax = scrollMax;
			ScrollTarget = scrollTarget;
			ScrollTargetCenterRatio = scrollTargetCenterRatio;
			ScrollTargetEdgeSnapDist = scrollTargetEdgeSnapDist;
			ScrollbarSizes = scrollbarSizes;
			ScrollbarX = scrollbarX ? (byte)1 : (byte)0;
			ScrollbarY = scrollbarY ? (byte)1 : (byte)0;
			ViewportOwned = viewportOwned ? (byte)1 : (byte)0;
			Active = active ? (byte)1 : (byte)0;
			WasActive = wasActive ? (byte)1 : (byte)0;
			WriteAccessed = writeAccessed ? (byte)1 : (byte)0;
			Collapsed = collapsed ? (byte)1 : (byte)0;
			WantCollapseToggle = wantCollapseToggle ? (byte)1 : (byte)0;
			SkipItems = skipItems ? (byte)1 : (byte)0;
			Appearing = appearing ? (byte)1 : (byte)0;
			Hidden = hidden ? (byte)1 : (byte)0;
			IsFallbackWindow = isFallbackWindow ? (byte)1 : (byte)0;
			IsExplicitChild = isExplicitChild ? (byte)1 : (byte)0;
			HasCloseButton = hasCloseButton ? (byte)1 : (byte)0;
			ResizeBorderHeld = resizeBorderHeld;
			BeginCount = beginCount;
			BeginCountPreviousFrame = beginCountPreviousFrame;
			BeginOrderWithinParent = beginOrderWithinParent;
			BeginOrderWithinContext = beginOrderWithinContext;
			FocusOrder = focusOrder;
			PopupId = popupId;
			AutoFitFramesX = autoFitFramesX;
			AutoFitFramesY = autoFitFramesY;
			AutoFitOnlyGrows = autoFitOnlyGrows ? (byte)1 : (byte)0;
			AutoPosLastDirection = autoPosLastDirection;
			HiddenFramesCanSkipItems = hiddenFramesCanSkipItems;
			HiddenFramesCannotSkipItems = hiddenFramesCannotSkipItems;
			HiddenFramesForRenderOnly = hiddenFramesForRenderOnly;
			DisableInputsFrames = disableInputsFrames;
			SetWindowPosAllowFlags = setWindowPosAllowFlags;
			SetWindowSizeAllowFlags = setWindowSizeAllowFlags;
			SetWindowCollapsedAllowFlags = setWindowCollapsedAllowFlags;
			SetWindowDockAllowFlags = setWindowDockAllowFlags;
			SetWindowPosVal = setWindowPosVal;
			SetWindowPosPivot = setWindowPosPivot;
			IDStack = idStack;
			DC = dc;
			OuterRectClipped = outerRectClipped;
			InnerRect = innerRect;
			InnerClipRect = innerClipRect;
			WorkRect = workRect;
			ParentWorkRect = parentWorkRect;
			ClipRect = clipRect;
			ContentRegionRect = contentRegionRect;
			HitTestHoleSize = hitTestHoleSize;
			HitTestHoleOffset = hitTestHoleOffset;
			LastFrameActive = lastFrameActive;
			LastFrameJustFocused = lastFrameJustFocused;
			LastTimeActive = lastTimeActive;
			ItemWidthDefault = itemWidthDefault;
			StateStorage = stateStorage;
			ColumnsStorage = columnsStorage;
			FontWindowScale = fontWindowScale;
			FontDpiScale = fontDpiScale;
			SettingsOffset = settingsOffset;
			DrawList = drawList;
			DrawListInst = drawListInst;
			ParentWindow = parentWindow;
			ParentWindowInBeginStack = parentWindowInBeginStack;
			RootWindow = rootWindow;
			RootWindowPopupTree = rootWindowPopupTree;
			RootWindowDockTree = rootWindowDockTree;
			RootWindowForTitleBarHighlight = rootWindowForTitleBarHighlight;
			RootWindowForNav = rootWindowForNav;
			NavLastChildNavWindow = navLastChildNavWindow;
			if (navLastIds != default)
			{
				NavLastIds_0 = navLastIds[0];
				NavLastIds_1 = navLastIds[1];
			}
			if (navRectRel != default)
			{
				NavRectRel_0 = navRectRel[0];
				NavRectRel_1 = navRectRel[1];
			}
			if (navPreferredScoringPosRel != default)
			{
				NavPreferredScoringPosRel_0 = navPreferredScoringPosRel[0];
				NavPreferredScoringPosRel_1 = navPreferredScoringPosRel[1];
			}
			NavRootFocusScopeId = navRootFocusScopeId;
			MemoryDrawListIdxCapacity = memoryDrawListIdxCapacity;
			MemoryDrawListVtxCapacity = memoryDrawListVtxCapacity;
			MemoryCompacted = memoryCompacted ? (byte)1 : (byte)0;
			DockIsActive = dockIsActive ? (byte)1 : (byte)0;
			DockNodeIsVisible = dockNodeIsVisible ? (byte)1 : (byte)0;
			DockTabIsVisible = dockTabIsVisible ? (byte)1 : (byte)0;
			DockTabWantClose = dockTabWantClose ? (byte)1 : (byte)0;
			DockOrder = dockOrder;
			DockStyle = dockStyle;
			DockNode = dockNode;
			DockNodeAsHost = dockNodeAsHost;
			DockId = dockId;
			DockTabItemStatusFlags = dockTabItemStatusFlags;
			DockTabItemRect = dockTabItemRect;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiWindow(ImGuiContext* ctx = default, byte* name = default, uint id = default, int flags = default, int flagsPreviousFrame = default, ImGuiWindowClass windowClass = default, ImGuiViewportP* viewport = default, uint viewportId = default, Vector2 viewportPos = default, int viewportAllowPlatformMonitorExtend = default, Vector2 pos = default, Vector2 size = default, Vector2 sizeFull = default, Vector2 contentSize = default, Vector2 contentSizeIdeal = default, Vector2 contentSizeExplicit = default, Vector2 windowPadding = default, float windowRounding = default, float windowBorderSize = default, float decoOuterSizeX1 = default, float decoOuterSizeY1 = default, float decoOuterSizeX2 = default, float decoOuterSizeY2 = default, float decoInnerSizeX1 = default, float decoInnerSizeY1 = default, int nameBufLen = default, uint moveId = default, uint tabId = default, uint childId = default, Vector2 scroll = default, Vector2 scrollMax = default, Vector2 scrollTarget = default, Vector2 scrollTargetCenterRatio = default, Vector2 scrollTargetEdgeSnapDist = default, Vector2 scrollbarSizes = default, bool scrollbarX = default, bool scrollbarY = default, bool viewportOwned = default, bool active = default, bool wasActive = default, bool writeAccessed = default, bool collapsed = default, bool wantCollapseToggle = default, bool skipItems = default, bool appearing = default, bool hidden = default, bool isFallbackWindow = default, bool isExplicitChild = default, bool hasCloseButton = default, byte resizeBorderHeld = default, short beginCount = default, short beginCountPreviousFrame = default, short beginOrderWithinParent = default, short beginOrderWithinContext = default, short focusOrder = default, uint popupId = default, byte autoFitFramesX = default, byte autoFitFramesY = default, bool autoFitOnlyGrows = default, int autoPosLastDirection = default, byte hiddenFramesCanSkipItems = default, byte hiddenFramesCannotSkipItems = default, byte hiddenFramesForRenderOnly = default, byte disableInputsFrames = default, int setWindowPosAllowFlags = default, int setWindowSizeAllowFlags = default, int setWindowCollapsedAllowFlags = default, int setWindowDockAllowFlags = default, Vector2 setWindowPosVal = default, Vector2 setWindowPosPivot = default, ImVectorImGuiID idStack = default, ImGuiWindowTempData dc = default, ImRect outerRectClipped = default, ImRect innerRect = default, ImRect innerClipRect = default, ImRect workRect = default, ImRect parentWorkRect = default, ImRect clipRect = default, ImRect contentRegionRect = default, ImVec2Ih hitTestHoleSize = default, ImVec2Ih hitTestHoleOffset = default, int lastFrameActive = default, int lastFrameJustFocused = default, float lastTimeActive = default, float itemWidthDefault = default, ImGuiStorage stateStorage = default, ImVectorImGuiOldColumns columnsStorage = default, float fontWindowScale = default, float fontDpiScale = default, int settingsOffset = default, ImDrawList* drawList = default, ImDrawList drawListInst = default, ImGuiWindow* parentWindow = default, ImGuiWindow* parentWindowInBeginStack = default, ImGuiWindow* rootWindow = default, ImGuiWindow* rootWindowPopupTree = default, ImGuiWindow* rootWindowDockTree = default, ImGuiWindow* rootWindowForTitleBarHighlight = default, ImGuiWindow* rootWindowForNav = default, ImGuiWindow* navLastChildNavWindow = default, Span<uint> navLastIds = default, Span<ImRect> navRectRel = default, Span<Vector2> navPreferredScoringPosRel = default, uint navRootFocusScopeId = default, int memoryDrawListIdxCapacity = default, int memoryDrawListVtxCapacity = default, bool memoryCompacted = default, bool dockIsActive = default, bool dockNodeIsVisible = default, bool dockTabIsVisible = default, bool dockTabWantClose = default, short dockOrder = default, ImGuiWindowDockStyle dockStyle = default, ImGuiDockNode* dockNode = default, ImGuiDockNode* dockNodeAsHost = default, uint dockId = default, int dockTabItemStatusFlags = default, ImRect dockTabItemRect = default)
		{
			Ctx = ctx;
			Name = name;
			ID = id;
			Flags = flags;
			FlagsPreviousFrame = flagsPreviousFrame;
			WindowClass = windowClass;
			Viewport = viewport;
			ViewportId = viewportId;
			ViewportPos = viewportPos;
			ViewportAllowPlatformMonitorExtend = viewportAllowPlatformMonitorExtend;
			Pos = pos;
			Size = size;
			SizeFull = sizeFull;
			ContentSize = contentSize;
			ContentSizeIdeal = contentSizeIdeal;
			ContentSizeExplicit = contentSizeExplicit;
			WindowPadding = windowPadding;
			WindowRounding = windowRounding;
			WindowBorderSize = windowBorderSize;
			DecoOuterSizeX1 = decoOuterSizeX1;
			DecoOuterSizeY1 = decoOuterSizeY1;
			DecoOuterSizeX2 = decoOuterSizeX2;
			DecoOuterSizeY2 = decoOuterSizeY2;
			DecoInnerSizeX1 = decoInnerSizeX1;
			DecoInnerSizeY1 = decoInnerSizeY1;
			NameBufLen = nameBufLen;
			MoveId = moveId;
			TabId = tabId;
			ChildId = childId;
			Scroll = scroll;
			ScrollMax = scrollMax;
			ScrollTarget = scrollTarget;
			ScrollTargetCenterRatio = scrollTargetCenterRatio;
			ScrollTargetEdgeSnapDist = scrollTargetEdgeSnapDist;
			ScrollbarSizes = scrollbarSizes;
			ScrollbarX = scrollbarX ? (byte)1 : (byte)0;
			ScrollbarY = scrollbarY ? (byte)1 : (byte)0;
			ViewportOwned = viewportOwned ? (byte)1 : (byte)0;
			Active = active ? (byte)1 : (byte)0;
			WasActive = wasActive ? (byte)1 : (byte)0;
			WriteAccessed = writeAccessed ? (byte)1 : (byte)0;
			Collapsed = collapsed ? (byte)1 : (byte)0;
			WantCollapseToggle = wantCollapseToggle ? (byte)1 : (byte)0;
			SkipItems = skipItems ? (byte)1 : (byte)0;
			Appearing = appearing ? (byte)1 : (byte)0;
			Hidden = hidden ? (byte)1 : (byte)0;
			IsFallbackWindow = isFallbackWindow ? (byte)1 : (byte)0;
			IsExplicitChild = isExplicitChild ? (byte)1 : (byte)0;
			HasCloseButton = hasCloseButton ? (byte)1 : (byte)0;
			ResizeBorderHeld = resizeBorderHeld;
			BeginCount = beginCount;
			BeginCountPreviousFrame = beginCountPreviousFrame;
			BeginOrderWithinParent = beginOrderWithinParent;
			BeginOrderWithinContext = beginOrderWithinContext;
			FocusOrder = focusOrder;
			PopupId = popupId;
			AutoFitFramesX = autoFitFramesX;
			AutoFitFramesY = autoFitFramesY;
			AutoFitOnlyGrows = autoFitOnlyGrows ? (byte)1 : (byte)0;
			AutoPosLastDirection = autoPosLastDirection;
			HiddenFramesCanSkipItems = hiddenFramesCanSkipItems;
			HiddenFramesCannotSkipItems = hiddenFramesCannotSkipItems;
			HiddenFramesForRenderOnly = hiddenFramesForRenderOnly;
			DisableInputsFrames = disableInputsFrames;
			SetWindowPosAllowFlags = setWindowPosAllowFlags;
			SetWindowSizeAllowFlags = setWindowSizeAllowFlags;
			SetWindowCollapsedAllowFlags = setWindowCollapsedAllowFlags;
			SetWindowDockAllowFlags = setWindowDockAllowFlags;
			SetWindowPosVal = setWindowPosVal;
			SetWindowPosPivot = setWindowPosPivot;
			IDStack = idStack;
			DC = dc;
			OuterRectClipped = outerRectClipped;
			InnerRect = innerRect;
			InnerClipRect = innerClipRect;
			WorkRect = workRect;
			ParentWorkRect = parentWorkRect;
			ClipRect = clipRect;
			ContentRegionRect = contentRegionRect;
			HitTestHoleSize = hitTestHoleSize;
			HitTestHoleOffset = hitTestHoleOffset;
			LastFrameActive = lastFrameActive;
			LastFrameJustFocused = lastFrameJustFocused;
			LastTimeActive = lastTimeActive;
			ItemWidthDefault = itemWidthDefault;
			StateStorage = stateStorage;
			ColumnsStorage = columnsStorage;
			FontWindowScale = fontWindowScale;
			FontDpiScale = fontDpiScale;
			SettingsOffset = settingsOffset;
			DrawList = drawList;
			DrawListInst = drawListInst;
			ParentWindow = parentWindow;
			ParentWindowInBeginStack = parentWindowInBeginStack;
			RootWindow = rootWindow;
			RootWindowPopupTree = rootWindowPopupTree;
			RootWindowDockTree = rootWindowDockTree;
			RootWindowForTitleBarHighlight = rootWindowForTitleBarHighlight;
			RootWindowForNav = rootWindowForNav;
			NavLastChildNavWindow = navLastChildNavWindow;
			if (navLastIds != default)
			{
				NavLastIds_0 = navLastIds[0];
				NavLastIds_1 = navLastIds[1];
			}
			if (navRectRel != default)
			{
				NavRectRel_0 = navRectRel[0];
				NavRectRel_1 = navRectRel[1];
			}
			if (navPreferredScoringPosRel != default)
			{
				NavPreferredScoringPosRel_0 = navPreferredScoringPosRel[0];
				NavPreferredScoringPosRel_1 = navPreferredScoringPosRel[1];
			}
			NavRootFocusScopeId = navRootFocusScopeId;
			MemoryDrawListIdxCapacity = memoryDrawListIdxCapacity;
			MemoryDrawListVtxCapacity = memoryDrawListVtxCapacity;
			MemoryCompacted = memoryCompacted ? (byte)1 : (byte)0;
			DockIsActive = dockIsActive ? (byte)1 : (byte)0;
			DockNodeIsVisible = dockNodeIsVisible ? (byte)1 : (byte)0;
			DockTabIsVisible = dockTabIsVisible ? (byte)1 : (byte)0;
			DockTabWantClose = dockTabWantClose ? (byte)1 : (byte)0;
			DockOrder = dockOrder;
			DockStyle = dockStyle;
			DockNode = dockNode;
			DockNodeAsHost = dockNodeAsHost;
			DockId = dockId;
			DockTabItemStatusFlags = dockTabItemStatusFlags;
			DockTabItemRect = dockTabItemRect;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<ImRect> NavRectRel
		
		{
			get
			{
				fixed (ImRect* p = &this.NavRectRel_0)
				{
					return new Span<ImRect>(p, 2);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Vector2> NavPreferredScoringPosRel
		
		{
			get
			{
				fixed (Vector2* p = &this.NavPreferredScoringPosRel_0)
				{
					return new Span<Vector2>(p, 2);
				}
			}
		}
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowClass
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ClassId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ParentViewportId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ViewportFlagsOverrideSet;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ViewportFlagsOverrideClear;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TabItemFlagsOverrideSet;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DockNodeFlagsOverrideSet;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DockingAlwaysTabBar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DockingAllowUnclassed;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiWindowClass(uint classId = default, uint parentViewportId = default, int viewportFlagsOverrideSet = default, int viewportFlagsOverrideClear = default, int tabItemFlagsOverrideSet = default, int dockNodeFlagsOverrideSet = default, bool dockingAlwaysTabBar = default, bool dockingAllowUnclassed = default)
		{
			ClassId = classId;
			ParentViewportId = parentViewportId;
			ViewportFlagsOverrideSet = viewportFlagsOverrideSet;
			ViewportFlagsOverrideClear = viewportFlagsOverrideClear;
			TabItemFlagsOverrideSet = tabItemFlagsOverrideSet;
			DockNodeFlagsOverrideSet = dockNodeFlagsOverrideSet;
			DockingAlwaysTabBar = dockingAlwaysTabBar ? (byte)1 : (byte)0;
			DockingAllowUnclassed = dockingAllowUnclassed ? (byte)1 : (byte)0;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiWindowClass* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiViewportP
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiViewport ImGuiViewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Idx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFocusedStampCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint LastNameHash;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 LastPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Alpha;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LastAlpha;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte LastFocusedHadNavWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short PlatformMonitor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BgFgDrawListsLastFrame_0;
		public int BgFgDrawListsLastFrame_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawList* BgFgDrawLists_0;
		public unsafe ImDrawList* BgFgDrawLists_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawData DrawDataP;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawDataBuilder DrawDataBuilder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 LastPlatformPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 LastPlatformSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 LastRendererSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WorkOffsetMin;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 WorkOffsetMax;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BuildWorkOffsetMin;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BuildWorkOffsetMax;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiViewportP(ImGuiViewport Imguiviewport = default, ImGuiWindow* window = default, int idx = default, int lastFrameActive = default, int lastFocusedStampCount = default, uint lastNameHash = default, Vector2 lastPos = default, float alpha = default, float lastAlpha = default, bool lastFocusedHadNavWindow = default, short platformMonitor = default, int* bgFgDrawListsLastFrame = default, ImDrawList** bgFgDrawLists = default, ImDrawData drawDataP = default, ImDrawDataBuilder drawDataBuilder = default, Vector2 lastPlatformPos = default, Vector2 lastPlatformSize = default, Vector2 lastRendererSize = default, Vector2 workOffsetMin = default, Vector2 workOffsetMax = default, Vector2 buildWorkOffsetMin = default, Vector2 buildWorkOffsetMax = default)
		{
			ImGuiViewport = Imguiviewport;
			Window = window;
			Idx = idx;
			LastFrameActive = lastFrameActive;
			LastFocusedStampCount = lastFocusedStampCount;
			LastNameHash = lastNameHash;
			LastPos = lastPos;
			Alpha = alpha;
			LastAlpha = lastAlpha;
			LastFocusedHadNavWindow = lastFocusedHadNavWindow ? (byte)1 : (byte)0;
			PlatformMonitor = platformMonitor;
			if (bgFgDrawListsLastFrame != default)
			{
				BgFgDrawListsLastFrame_0 = bgFgDrawListsLastFrame[0];
				BgFgDrawListsLastFrame_1 = bgFgDrawListsLastFrame[1];
			}
			if (bgFgDrawLists != default)
			{
				BgFgDrawLists_0 = bgFgDrawLists[0];
				BgFgDrawLists_1 = bgFgDrawLists[1];
			}
			DrawDataP = drawDataP;
			DrawDataBuilder = drawDataBuilder;
			LastPlatformPos = lastPlatformPos;
			LastPlatformSize = lastPlatformSize;
			LastRendererSize = lastRendererSize;
			WorkOffsetMin = workOffsetMin;
			WorkOffsetMax = workOffsetMax;
			BuildWorkOffsetMin = buildWorkOffsetMin;
			BuildWorkOffsetMax = buildWorkOffsetMax;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiViewportP(ImGuiViewport Imguiviewport = default, ImGuiWindow* window = default, int idx = default, int lastFrameActive = default, int lastFocusedStampCount = default, uint lastNameHash = default, Vector2 lastPos = default, float alpha = default, float lastAlpha = default, bool lastFocusedHadNavWindow = default, short platformMonitor = default, Span<int> bgFgDrawListsLastFrame = default, Span<Pointer<ImDrawList>> bgFgDrawLists = default, ImDrawData drawDataP = default, ImDrawDataBuilder drawDataBuilder = default, Vector2 lastPlatformPos = default, Vector2 lastPlatformSize = default, Vector2 lastRendererSize = default, Vector2 workOffsetMin = default, Vector2 workOffsetMax = default, Vector2 buildWorkOffsetMin = default, Vector2 buildWorkOffsetMax = default)
		{
			ImGuiViewport = Imguiviewport;
			Window = window;
			Idx = idx;
			LastFrameActive = lastFrameActive;
			LastFocusedStampCount = lastFocusedStampCount;
			LastNameHash = lastNameHash;
			LastPos = lastPos;
			Alpha = alpha;
			LastAlpha = lastAlpha;
			LastFocusedHadNavWindow = lastFocusedHadNavWindow ? (byte)1 : (byte)0;
			PlatformMonitor = platformMonitor;
			if (bgFgDrawListsLastFrame != default)
			{
				BgFgDrawListsLastFrame_0 = bgFgDrawListsLastFrame[0];
				BgFgDrawListsLastFrame_1 = bgFgDrawListsLastFrame[1];
			}
			if (bgFgDrawLists != default)
			{
				BgFgDrawLists_0 = bgFgDrawLists[0];
				BgFgDrawLists_1 = bgFgDrawLists[1];
			}
			DrawDataP = drawDataP;
			DrawDataBuilder = drawDataBuilder;
			LastPlatformPos = lastPlatformPos;
			LastPlatformSize = lastPlatformSize;
			LastRendererSize = lastRendererSize;
			WorkOffsetMin = workOffsetMin;
			WorkOffsetMax = workOffsetMax;
			BuildWorkOffsetMin = buildWorkOffsetMin;
			BuildWorkOffsetMax = buildWorkOffsetMax;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawDataBuilder
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImVectorImDrawListPtr* Layers_0;
		public unsafe ImVectorImDrawListPtr* Layers_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImDrawListPtr LayerData1;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawDataBuilder(ImVectorImDrawListPtr** layers = default, ImVectorImDrawListPtr layerData1 = default)
		{
			if (layers != default)
			{
				Layers_0 = layers[0];
				Layers_1 = layers[1];
			}
			LayerData1 = layerData1;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImDrawDataBuilder(Span<Pointer<ImVectorImDrawListPtr>> layers = default, ImVectorImDrawListPtr layerData1 = default)
		{
			if (layers != default)
			{
				Layers_0 = layers[0];
				Layers_1 = layers[1];
			}
			LayerData1 = layerData1;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiID
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe uint* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiID(int size = default, int capacity = default, uint* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowTempData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorPosPrevLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorStartPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorMaxPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 IdealMaxPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CurrLineSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 PrevLineSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CurrLineTextBaseOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PrevLineTextBaseOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSameLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSetPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 Indent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 ColumnsOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 GroupOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CursorStartPosLossyness;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiNavLayer NavLayerCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short NavLayersActiveMask;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short NavLayersActiveMaskNext;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavIsScrollPushableX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavHideHighlightOneFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavWindowHasScrollY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte MenuBarAppending;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MenuBarOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiMenuColumns MenuColumns;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TreeDepth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint TreeJumpToParentOnPopMask;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiWindowPtr ChildWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiStorage* StateStorage;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiOldColumns* CurrentColumns;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurrentTableIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LayoutType;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ParentLayoutType;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ItemWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float TextWrapPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorFloat ItemWidthStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorFloat TextWrapPosStack;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiWindowTempData(Vector2 cursorPos = default, Vector2 cursorPosPrevLine = default, Vector2 cursorStartPos = default, Vector2 cursorMaxPos = default, Vector2 idealMaxPos = default, Vector2 currLineSize = default, Vector2 prevLineSize = default, float currLineTextBaseOffset = default, float prevLineTextBaseOffset = default, bool isSameLine = default, bool isSetPos = default, ImVec1 indent = default, ImVec1 columnsOffset = default, ImVec1 groupOffset = default, Vector2 cursorStartPosLossyness = default, ImGuiNavLayer navLayerCurrent = default, short navLayersActiveMask = default, short navLayersActiveMaskNext = default, bool navIsScrollPushableX = default, bool navHideHighlightOneFrame = default, bool navWindowHasScrollY = default, bool menuBarAppending = default, Vector2 menuBarOffset = default, ImGuiMenuColumns menuColumns = default, int treeDepth = default, uint treeJumpToParentOnPopMask = default, ImVectorImGuiWindowPtr childWindows = default, ImGuiStorage* stateStorage = default, ImGuiOldColumns* currentColumns = default, int currentTableIdx = default, int layoutType = default, int parentLayoutType = default, float itemWidth = default, float textWrapPos = default, ImVectorFloat itemWidthStack = default, ImVectorFloat textWrapPosStack = default)
		{
			CursorPos = cursorPos;
			CursorPosPrevLine = cursorPosPrevLine;
			CursorStartPos = cursorStartPos;
			CursorMaxPos = cursorMaxPos;
			IdealMaxPos = idealMaxPos;
			CurrLineSize = currLineSize;
			PrevLineSize = prevLineSize;
			CurrLineTextBaseOffset = currLineTextBaseOffset;
			PrevLineTextBaseOffset = prevLineTextBaseOffset;
			IsSameLine = isSameLine ? (byte)1 : (byte)0;
			IsSetPos = isSetPos ? (byte)1 : (byte)0;
			Indent = indent;
			ColumnsOffset = columnsOffset;
			GroupOffset = groupOffset;
			CursorStartPosLossyness = cursorStartPosLossyness;
			NavLayerCurrent = navLayerCurrent;
			NavLayersActiveMask = navLayersActiveMask;
			NavLayersActiveMaskNext = navLayersActiveMaskNext;
			NavIsScrollPushableX = navIsScrollPushableX ? (byte)1 : (byte)0;
			NavHideHighlightOneFrame = navHideHighlightOneFrame ? (byte)1 : (byte)0;
			NavWindowHasScrollY = navWindowHasScrollY ? (byte)1 : (byte)0;
			MenuBarAppending = menuBarAppending ? (byte)1 : (byte)0;
			MenuBarOffset = menuBarOffset;
			MenuColumns = menuColumns;
			TreeDepth = treeDepth;
			TreeJumpToParentOnPopMask = treeJumpToParentOnPopMask;
			ChildWindows = childWindows;
			StateStorage = stateStorage;
			CurrentColumns = currentColumns;
			CurrentTableIdx = currentTableIdx;
			LayoutType = layoutType;
			ParentLayoutType = parentLayoutType;
			ItemWidth = itemWidth;
			TextWrapPos = textWrapPos;
			ItemWidthStack = itemWidthStack;
			TextWrapPosStack = textWrapPosStack;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec1
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float X;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVec1(float x = default)
		{
			X = x;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiMenuColumns
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint TotalWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NextTotalWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Spacing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort OffsetIcon;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort OffsetLabel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort OffsetShortcut;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort OffsetMark;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Widths_0;
		public ushort Widths_1;
		public ushort Widths_2;
		public ushort Widths_3;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiMenuColumns(uint totalWidth = default, uint nextTotalWidth = default, ushort spacing = default, ushort offsetIcon = default, ushort offsetLabel = default, ushort offsetShortcut = default, ushort offsetMark = default, ushort* widths = default)
		{
			TotalWidth = totalWidth;
			NextTotalWidth = nextTotalWidth;
			Spacing = spacing;
			OffsetIcon = offsetIcon;
			OffsetLabel = offsetLabel;
			OffsetShortcut = offsetShortcut;
			OffsetMark = offsetMark;
			if (widths != default)
			{
				Widths_0 = widths[0];
				Widths_1 = widths[1];
				Widths_2 = widths[2];
				Widths_3 = widths[3];
			}
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiMenuColumns(uint totalWidth = default, uint nextTotalWidth = default, ushort spacing = default, ushort offsetIcon = default, ushort offsetLabel = default, ushort offsetShortcut = default, ushort offsetMark = default, Span<ushort> widths = default)
		{
			TotalWidth = totalWidth;
			NextTotalWidth = nextTotalWidth;
			Spacing = spacing;
			OffsetIcon = offsetIcon;
			OffsetLabel = offsetLabel;
			OffsetShortcut = offsetShortcut;
			OffsetMark = offsetMark;
			if (widths != default)
			{
				Widths_0 = widths[0];
				Widths_1 = widths[1];
				Widths_2 = widths[2];
				Widths_3 = widths[3];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStorage
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiStoragePair Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiStorage(ImVectorImGuiStoragePair data = default)
		{
			Data = data;
		}


		public unsafe void BuildSortByKey()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.BuildSortByKeyNative(@this);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe bool GetBool( uint key,  bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte ret = ImGui.GetBoolNative(@this, key, defaultVal ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public unsafe bool GetBool( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte ret = ImGui.GetBoolNative(@this, key, (byte)(0));
				return ret != 0;
			}
		}

		public unsafe byte* GetBoolRef( uint key,  bool defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte* ret = ImGui.GetBoolRefNative(@this, key, defaultVal ? (byte)1 : (byte)0);
				return ret;
			}
		}

		public unsafe byte* GetBoolRef( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				byte* ret = ImGui.GetBoolRefNative(@this, key, (byte)(0));
				return ret;
			}
		}

		public unsafe float GetFloat( uint key,  float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float ret = ImGui.GetFloatNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float GetFloat( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float ret = ImGui.GetFloatNative(@this, key, (float)(0.0f));
				return ret;
			}
		}

		public unsafe float* GetFloatRef( uint key,  float defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float* ret = ImGui.GetFloatRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe float* GetFloatRef( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				float* ret = ImGui.GetFloatRefNative(@this, key, (float)(0.0f));
				return ret;
			}
		}

		public unsafe int GetInt( uint key,  int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int ret = ImGui.GetIntNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int GetInt( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int ret = ImGui.GetIntNative(@this, key, (int)(0));
				return ret;
			}
		}

		public unsafe int* GetIntRef( uint key,  int defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int* ret = ImGui.GetIntRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe int* GetIntRef( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				int* ret = ImGui.GetIntRefNative(@this, key, (int)(0));
				return ret;
			}
		}

		public unsafe void* GetVoidPtr( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void* ret = ImGui.GetVoidPtrNative(@this, key);
				return ret;
			}
		}

		public unsafe void** GetVoidPtrRef( uint key,  void* defaultVal)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void** ret = ImGui.GetVoidPtrRefNative(@this, key, defaultVal);
				return ret;
			}
		}

		public unsafe void** GetVoidPtrRef( uint key)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				void** ret = ImGui.GetVoidPtrRefNative(@this, key, (void*)(default));
				return ret;
			}
		}

		public unsafe void SetAllInt( int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetAllIntNative(@this, val);
			}
		}

		public unsafe void SetBool( uint key,  bool val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetBoolNative(@this, key, val ? (byte)1 : (byte)0);
			}
		}

		public unsafe void SetFloat( uint key,  float val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetFloatNative(@this, key, val);
			}
		}

		public unsafe void SetInt( uint key,  int val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetIntNative(@this, key, val);
			}
		}

		public unsafe void SetVoidPtr( uint key,  void* val)
		{
			fixed (ImGuiStorage* @this = &this)
			{
				ImGui.SetVoidPtrNative(@this, key, val);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStoragePair
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiStoragePair* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiStoragePair(int size = default, int capacity = default, ImGuiStoragePair* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStoragePair
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		[StructLayout(LayoutKind.Explicit)]
		public partial struct ImGuiStoragePairUnion
		{
			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public int ValI;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public float ValF;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public unsafe void* ValP;


			/// <summary>			/// To be documented.			/// </summary>			public unsafe ImGuiStoragePairUnion(int valI = default, float valF = default, void* valP = default)
			{
				ValI = valI;
				ValF = valF;
				ValP = valP;
			}


		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Key;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStoragePairUnion Union;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiStoragePair(uint key = default, ImGuiStoragePairUnion union = default)
		{
			Key = key;
			Union = union;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiStoragePair* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumns
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsFirstFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsBeingResized;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Current;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Count;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float OffMinX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float OffMaxX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LineMinY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LineMaxY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HostCursorPosY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HostCursorMaxPosX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostInitialClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostBackupClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostBackupParentWorkRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiOldColumnData Columns;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawListSplitter Splitter;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiOldColumns(uint id = default, int flags = default, bool isFirstFrame = default, bool isBeingResized = default, int current = default, int count = default, float offMinX = default, float offMaxX = default, float lineMinY = default, float lineMaxY = default, float hostCursorPosY = default, float hostCursorMaxPosX = default, ImRect hostInitialClipRect = default, ImRect hostBackupClipRect = default, ImRect hostBackupParentWorkRect = default, ImVectorImGuiOldColumnData columns = default, ImDrawListSplitter splitter = default)
		{
			ID = id;
			Flags = flags;
			IsFirstFrame = isFirstFrame ? (byte)1 : (byte)0;
			IsBeingResized = isBeingResized ? (byte)1 : (byte)0;
			Current = current;
			Count = count;
			OffMinX = offMinX;
			OffMaxX = offMaxX;
			LineMinY = lineMinY;
			LineMaxY = lineMaxY;
			HostCursorPosY = hostCursorPosY;
			HostCursorMaxPosX = hostCursorMaxPosX;
			HostInitialClipRect = hostInitialClipRect;
			HostBackupClipRect = hostBackupClipRect;
			HostBackupParentWorkRect = hostBackupParentWorkRect;
			Columns = columns;
			Splitter = splitter;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImRect
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Min;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Max;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImRect(Vector2 min = default, Vector2 max = default)
		{
			Min = min;
			Max = max;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumnData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiOldColumnData* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiOldColumnData(int size = default, int capacity = default, ImGuiOldColumnData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOldColumnData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float OffsetNorm;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float OffsetNormBeforeResize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect ClipRect;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiOldColumnData(float offsetNorm = default, float offsetNormBeforeResize = default, int flags = default, ImRect clipRect = default)
		{
			OffsetNorm = offsetNorm;
			OffsetNormBeforeResize = offsetNormBeforeResize;
			Flags = flags;
			ClipRect = clipRect;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVec2Ih
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public short X;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short Y;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVec2Ih(short x = default, short y = default)
		{
			X = x;
			Y = y;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiOldColumns
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiOldColumns* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiOldColumns(int size = default, int capacity = default, ImGuiOldColumns* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowDockStyle
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Colors_0;
		public uint Colors_1;
		public uint Colors_2;
		public uint Colors_3;
		public uint Colors_4;
		public uint Colors_5;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiWindowDockStyle(uint* colors = default)
		{
			if (colors != default)
			{
				Colors_0 = colors[0];
				Colors_1 = colors[1];
				Colors_2 = colors[2];
				Colors_3 = colors[3];
				Colors_4 = colors[4];
				Colors_5 = colors[5];
			}
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiWindowDockStyle(Span<uint> colors = default)
		{
			if (colors != default)
			{
				Colors_0 = colors[0];
				Colors_1 = colors[1];
				Colors_2 = colors[2];
				Colors_3 = colors[3];
				Colors_4 = colors[4];
				Colors_5 = colors[5];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockNode
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SharedFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LocalFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LocalFlagsInWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int MergedFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiDockNodeState State;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* ParentNode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* ChildNodes_0;
		public unsafe ImGuiDockNode* ChildNodes_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiWindowPtr Windows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTabBar* TabBar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SizeRef;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiAxis SplitAxis;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiWindowClass WindowClass;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint LastBgColor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* HostWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* VisibleWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* CentralNode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNode* OnlyNodeWithWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CountNodeWithWindows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameFocused;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint LastFocusedNodeId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint SelectedTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint WantCloseTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint RefViewportId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int AuthorityForPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int AuthorityForSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int AuthorityForViewport;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsFocused;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsBgDrawnThisFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasCloseButton;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasWindowMenuButton;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasCentralNodeChild;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantCloseAll;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantLockSizeOnce;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantMouseMove;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantHiddenTabBarUpdate;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantHiddenTabBarToggle;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDockNode(uint id = default, int sharedFlags = default, int localFlags = default, int localFlagsInWindows = default, int mergedFlags = default, ImGuiDockNodeState state = default, ImGuiDockNode* parentNode = default, ImGuiDockNode** childNodes = default, ImVectorImGuiWindowPtr windows = default, ImGuiTabBar* tabBar = default, Vector2 pos = default, Vector2 size = default, Vector2 sizeRef = default, ImGuiAxis splitAxis = default, ImGuiWindowClass windowClass = default, uint lastBgColor = default, ImGuiWindow* hostWindow = default, ImGuiWindow* visibleWindow = default, ImGuiDockNode* centralNode = default, ImGuiDockNode* onlyNodeWithWindows = default, int countNodeWithWindows = default, int lastFrameAlive = default, int lastFrameActive = default, int lastFrameFocused = default, uint lastFocusedNodeId = default, uint selectedTabId = default, uint wantCloseTabId = default, uint refViewportId = default, int authorityForPos = default, int authorityForSize = default, int authorityForViewport = default, bool isVisible = default, bool isFocused = default, bool isBgDrawnThisFrame = default, bool hasCloseButton = default, bool hasWindowMenuButton = default, bool hasCentralNodeChild = default, bool wantCloseAll = default, bool wantLockSizeOnce = default, bool wantMouseMove = default, bool wantHiddenTabBarUpdate = default, bool wantHiddenTabBarToggle = default)
		{
			ID = id;
			SharedFlags = sharedFlags;
			LocalFlags = localFlags;
			LocalFlagsInWindows = localFlagsInWindows;
			MergedFlags = mergedFlags;
			State = state;
			ParentNode = parentNode;
			if (childNodes != default)
			{
				ChildNodes_0 = childNodes[0];
				ChildNodes_1 = childNodes[1];
			}
			Windows = windows;
			TabBar = tabBar;
			Pos = pos;
			Size = size;
			SizeRef = sizeRef;
			SplitAxis = splitAxis;
			WindowClass = windowClass;
			LastBgColor = lastBgColor;
			HostWindow = hostWindow;
			VisibleWindow = visibleWindow;
			CentralNode = centralNode;
			OnlyNodeWithWindows = onlyNodeWithWindows;
			CountNodeWithWindows = countNodeWithWindows;
			LastFrameAlive = lastFrameAlive;
			LastFrameActive = lastFrameActive;
			LastFrameFocused = lastFrameFocused;
			LastFocusedNodeId = lastFocusedNodeId;
			SelectedTabId = selectedTabId;
			WantCloseTabId = wantCloseTabId;
			RefViewportId = refViewportId;
			AuthorityForPos = authorityForPos;
			AuthorityForSize = authorityForSize;
			AuthorityForViewport = authorityForViewport;
			IsVisible = isVisible ? (byte)1 : (byte)0;
			IsFocused = isFocused ? (byte)1 : (byte)0;
			IsBgDrawnThisFrame = isBgDrawnThisFrame ? (byte)1 : (byte)0;
			HasCloseButton = hasCloseButton ? (byte)1 : (byte)0;
			HasWindowMenuButton = hasWindowMenuButton ? (byte)1 : (byte)0;
			HasCentralNodeChild = hasCentralNodeChild ? (byte)1 : (byte)0;
			WantCloseAll = wantCloseAll ? (byte)1 : (byte)0;
			WantLockSizeOnce = wantLockSizeOnce ? (byte)1 : (byte)0;
			WantMouseMove = wantMouseMove ? (byte)1 : (byte)0;
			WantHiddenTabBarUpdate = wantHiddenTabBarUpdate ? (byte)1 : (byte)0;
			WantHiddenTabBarToggle = wantHiddenTabBarToggle ? (byte)1 : (byte)0;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDockNode(uint id = default, int sharedFlags = default, int localFlags = default, int localFlagsInWindows = default, int mergedFlags = default, ImGuiDockNodeState state = default, ImGuiDockNode* parentNode = default, Span<Pointer<ImGuiDockNode>> childNodes = default, ImVectorImGuiWindowPtr windows = default, ImGuiTabBar* tabBar = default, Vector2 pos = default, Vector2 size = default, Vector2 sizeRef = default, ImGuiAxis splitAxis = default, ImGuiWindowClass windowClass = default, uint lastBgColor = default, ImGuiWindow* hostWindow = default, ImGuiWindow* visibleWindow = default, ImGuiDockNode* centralNode = default, ImGuiDockNode* onlyNodeWithWindows = default, int countNodeWithWindows = default, int lastFrameAlive = default, int lastFrameActive = default, int lastFrameFocused = default, uint lastFocusedNodeId = default, uint selectedTabId = default, uint wantCloseTabId = default, uint refViewportId = default, int authorityForPos = default, int authorityForSize = default, int authorityForViewport = default, bool isVisible = default, bool isFocused = default, bool isBgDrawnThisFrame = default, bool hasCloseButton = default, bool hasWindowMenuButton = default, bool hasCentralNodeChild = default, bool wantCloseAll = default, bool wantLockSizeOnce = default, bool wantMouseMove = default, bool wantHiddenTabBarUpdate = default, bool wantHiddenTabBarToggle = default)
		{
			ID = id;
			SharedFlags = sharedFlags;
			LocalFlags = localFlags;
			LocalFlagsInWindows = localFlagsInWindows;
			MergedFlags = mergedFlags;
			State = state;
			ParentNode = parentNode;
			if (childNodes != default)
			{
				ChildNodes_0 = childNodes[0];
				ChildNodes_1 = childNodes[1];
			}
			Windows = windows;
			TabBar = tabBar;
			Pos = pos;
			Size = size;
			SizeRef = sizeRef;
			SplitAxis = splitAxis;
			WindowClass = windowClass;
			LastBgColor = lastBgColor;
			HostWindow = hostWindow;
			VisibleWindow = visibleWindow;
			CentralNode = centralNode;
			OnlyNodeWithWindows = onlyNodeWithWindows;
			CountNodeWithWindows = countNodeWithWindows;
			LastFrameAlive = lastFrameAlive;
			LastFrameActive = lastFrameActive;
			LastFrameFocused = lastFrameFocused;
			LastFocusedNodeId = lastFocusedNodeId;
			SelectedTabId = selectedTabId;
			WantCloseTabId = wantCloseTabId;
			RefViewportId = refViewportId;
			AuthorityForPos = authorityForPos;
			AuthorityForSize = authorityForSize;
			AuthorityForViewport = authorityForViewport;
			IsVisible = isVisible ? (byte)1 : (byte)0;
			IsFocused = isFocused ? (byte)1 : (byte)0;
			IsBgDrawnThisFrame = isBgDrawnThisFrame ? (byte)1 : (byte)0;
			HasCloseButton = hasCloseButton ? (byte)1 : (byte)0;
			HasWindowMenuButton = hasWindowMenuButton ? (byte)1 : (byte)0;
			HasCentralNodeChild = hasCentralNodeChild ? (byte)1 : (byte)0;
			WantCloseAll = wantCloseAll ? (byte)1 : (byte)0;
			WantLockSizeOnce = wantLockSizeOnce ? (byte)1 : (byte)0;
			WantMouseMove = wantMouseMove ? (byte)1 : (byte)0;
			WantHiddenTabBarUpdate = wantHiddenTabBarUpdate ? (byte)1 : (byte)0;
			WantHiddenTabBarToggle = wantHiddenTabBarToggle ? (byte)1 : (byte)0;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabBar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTabItem Tabs;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint SelectedTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint NextSelectedTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint VisibleTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurrFrameVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int PrevFrameVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect BarRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CurrTabsContentsHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PrevTabsContentsHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WidthAllTabs;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WidthAllTabsIdeal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingAnim;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingTarget;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingTargetDistToVisibility;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingSpeed;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingRectMinX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollingRectMaxX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float SeparatorMinX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float SeparatorMaxX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ReorderRequestTabId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ReorderRequestOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BeginCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantLayout;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte VisibleTabWasSubmitted;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte TabsAddedNew;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short TabsActiveCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short LastTabItemIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ItemSpacingY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 FramePadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTextBuffer TabsNames;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTabBar(ImVectorImGuiTabItem tabs = default, int flags = default, uint id = default, uint selectedTabId = default, uint nextSelectedTabId = default, uint visibleTabId = default, int currFrameVisible = default, int prevFrameVisible = default, ImRect barRect = default, float currTabsContentsHeight = default, float prevTabsContentsHeight = default, float widthAllTabs = default, float widthAllTabsIdeal = default, float scrollingAnim = default, float scrollingTarget = default, float scrollingTargetDistToVisibility = default, float scrollingSpeed = default, float scrollingRectMinX = default, float scrollingRectMaxX = default, float separatorMinX = default, float separatorMaxX = default, uint reorderRequestTabId = default, short reorderRequestOffset = default, byte beginCount = default, bool wantLayout = default, bool visibleTabWasSubmitted = default, bool tabsAddedNew = default, short tabsActiveCount = default, short lastTabItemIdx = default, float itemSpacingY = default, Vector2 framePadding = default, Vector2 backupCursorPos = default, ImGuiTextBuffer tabsNames = default)
		{
			Tabs = tabs;
			Flags = flags;
			ID = id;
			SelectedTabId = selectedTabId;
			NextSelectedTabId = nextSelectedTabId;
			VisibleTabId = visibleTabId;
			CurrFrameVisible = currFrameVisible;
			PrevFrameVisible = prevFrameVisible;
			BarRect = barRect;
			CurrTabsContentsHeight = currTabsContentsHeight;
			PrevTabsContentsHeight = prevTabsContentsHeight;
			WidthAllTabs = widthAllTabs;
			WidthAllTabsIdeal = widthAllTabsIdeal;
			ScrollingAnim = scrollingAnim;
			ScrollingTarget = scrollingTarget;
			ScrollingTargetDistToVisibility = scrollingTargetDistToVisibility;
			ScrollingSpeed = scrollingSpeed;
			ScrollingRectMinX = scrollingRectMinX;
			ScrollingRectMaxX = scrollingRectMaxX;
			SeparatorMinX = separatorMinX;
			SeparatorMaxX = separatorMaxX;
			ReorderRequestTabId = reorderRequestTabId;
			ReorderRequestOffset = reorderRequestOffset;
			BeginCount = beginCount;
			WantLayout = wantLayout ? (byte)1 : (byte)0;
			VisibleTabWasSubmitted = visibleTabWasSubmitted ? (byte)1 : (byte)0;
			TabsAddedNew = tabsAddedNew ? (byte)1 : (byte)0;
			TabsActiveCount = tabsActiveCount;
			LastTabItemIdx = lastTabItemIdx;
			ItemSpacingY = itemSpacingY;
			FramePadding = framePadding;
			BackupCursorPos = backupCursorPos;
			TabsNames = tabsNames;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTabItem
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTabItem* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiTabItem(int size = default, int capacity = default, ImGuiTabItem* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTabItem
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameVisible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameSelected;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Offset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Width;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ContentWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RequestedWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NameOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short BeginOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short IndexDuringLayout;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantClose;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTabItem(uint id = default, int flags = default, ImGuiWindow* window = default, int lastFrameVisible = default, int lastFrameSelected = default, float offset = default, float width = default, float contentWidth = default, float requestedWidth = default, int nameOffset = default, short beginOrder = default, short indexDuringLayout = default, bool wantClose = default)
		{
			ID = id;
			Flags = flags;
			Window = window;
			LastFrameVisible = lastFrameVisible;
			LastFrameSelected = lastFrameSelected;
			Offset = offset;
			Width = width;
			ContentWidth = contentWidth;
			RequestedWidth = requestedWidth;
			NameOffset = nameOffset;
			BeginOrder = beginOrder;
			IndexDuringLayout = indexDuringLayout;
			WantClose = wantClose ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextBuffer
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorChar Buf;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTextBuffer(ImVectorChar buf = default)
		{
			Buf = buf;
		}


		public unsafe void append( byte* str,  byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendNative(@this, str, strEnd);
			}
		}

		public unsafe void append( byte* str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendNative(@this, str, (byte*)(default));
			}
		}

		public unsafe void append( ref byte str,  byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.appendNative(@this, (byte*)pstr, strEnd);
				}
			}
		}

		public unsafe void append( ref byte str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					ImGui.appendNative(@this, (byte*)pstr, (byte*)(default));
				}
			}
		}

		public unsafe void append( string str,  byte* strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, pStr0, strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append( string str)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append( byte* str,  ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					ImGui.appendNative(@this, str, (byte*)pstrEnd);
				}
			}
		}

		public unsafe void append( byte* str,  string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (strEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendNative(@this, str, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void append( ref byte str,  ref byte strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pstr = &str)
				{
					fixed (byte* pstrEnd = &strEnd)
					{
						ImGui.appendNative(@this, (byte*)pstr, (byte*)pstrEnd);
					}
				}
			}
		}

		public unsafe void append( string str,  string strEnd)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (strEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(strEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.appendNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void appendf( byte* fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendfNative(@this, fmt);
			}
		}

		public unsafe void appendf( ref byte fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendfNative(@this, (byte*)pfmt);
				}
			}
		}

		public unsafe void appendf( string fmt)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendfNative(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void appendfv( byte* fmt,  nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.appendfvNative(@this, fmt, args);
			}
		}

		public unsafe void appendfv( ref byte fmt,  nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				fixed (byte* pfmt = &fmt)
				{
					ImGui.appendfvNative(@this, (byte*)pfmt, args);
				}
			}
		}

		public unsafe void appendfv( string fmt,  nuint args)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.appendfvNative(@this, pStr0, args);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe byte* begin()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.beginNative(@this);
				return ret;
			}
		}

		public unsafe string beginS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.beginNative(@this));
				return ret;
			}
		}

		public unsafe byte* c_str()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.c_strNative(@this);
				return ret;
			}
		}

		public unsafe string c_strS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.c_strNative(@this));
				return ret;
			}
		}

		public unsafe void clear()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.clearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool empty()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte ret = ImGui.emptyNative(@this);
				return ret != 0;
			}
		}

		public unsafe byte* end()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				byte* ret = ImGui.endNative(@this);
				return ret;
			}
		}

		public unsafe string endS()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.endNative(@this));
				return ret;
			}
		}

		public unsafe void reserve( int capacity)
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				ImGui.reserveNative(@this, capacity);
			}
		}

		public unsafe int size()
		{
			fixed (ImGuiTextBuffer* @this = &this)
			{
				int ret = ImGui.sizeNative(@this);
				return ret;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorChar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorChar(int size = default, int capacity = default, byte* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiWindowStackData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindowStackData* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiWindowStackData(int size = default, int capacity = default, ImGuiWindowStackData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowStackData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiLastItemData ParentLastItemDataBackup;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStackSizes StackSizesOnBegin;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiWindowStackData(ImGuiWindow* window = default, ImGuiLastItemData parentLastItemDataBackup = default, ImGuiStackSizes stackSizesOnBegin = default)
		{
			Window = window;
			ParentLastItemDataBackup = parentLastItemDataBackup;
			StackSizesOnBegin = stackSizesOnBegin;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiLastItemData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int InFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int StatusFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect Rect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect NavRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect DisplayRect;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiLastItemData(uint id = default, int inFlags = default, int statusFlags = default, ImRect rect = default, ImRect navRect = default, ImRect displayRect = default)
		{
			ID = id;
			InFlags = inFlags;
			StatusFlags = statusFlags;
			Rect = rect;
			NavRect = navRect;
			DisplayRect = displayRect;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackSizes
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfIDStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfColorStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfStyleVarStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfFontStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfFocusScopeStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfGroupStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfItemFlagsStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfBeginPopupStack;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SizeOfDisabledStack;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiStackSizes(short sizeOfIdStack = default, short sizeOfColorStack = default, short sizeOfStyleVarStack = default, short sizeOfFontStack = default, short sizeOfFocusScopeStack = default, short sizeOfGroupStack = default, short sizeOfItemFlagsStack = default, short sizeOfBeginPopupStack = default, short sizeOfDisabledStack = default)
		{
			SizeOfIDStack = sizeOfIdStack;
			SizeOfColorStack = sizeOfColorStack;
			SizeOfStyleVarStack = sizeOfStyleVarStack;
			SizeOfFontStack = sizeOfFontStack;
			SizeOfFocusScopeStack = sizeOfFocusScopeStack;
			SizeOfGroupStack = sizeOfGroupStack;
			SizeOfItemFlagsStack = sizeOfItemFlagsStack;
			SizeOfBeginPopupStack = sizeOfBeginPopupStack;
			SizeOfDisabledStack = sizeOfDisabledStack;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyOwnerData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint OwnerCurr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint OwnerNext;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte LockThisFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte LockUntilRelease;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiKeyOwnerData(uint ownerCurr = default, uint ownerNext = default, bool lockThisFrame = default, bool lockUntilRelease = default)
		{
			OwnerCurr = ownerCurr;
			OwnerNext = ownerNext;
			LockThisFrame = lockThisFrame ? (byte)1 : (byte)0;
			LockUntilRelease = lockUntilRelease ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingTable
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public short Index_0;
		public short Index_1;
		public short Index_2;
		public short Index_3;
		public short Index_4;
		public short Index_5;
		public short Index_6;
		public short Index_7;
		public short Index_8;
		public short Index_9;
		public short Index_10;
		public short Index_11;
		public short Index_12;
		public short Index_13;
		public short Index_14;
		public short Index_15;
		public short Index_16;
		public short Index_17;
		public short Index_18;
		public short Index_19;
		public short Index_20;
		public short Index_21;
		public short Index_22;
		public short Index_23;
		public short Index_24;
		public short Index_25;
		public short Index_26;
		public short Index_27;
		public short Index_28;
		public short Index_29;
		public short Index_30;
		public short Index_31;
		public short Index_32;
		public short Index_33;
		public short Index_34;
		public short Index_35;
		public short Index_36;
		public short Index_37;
		public short Index_38;
		public short Index_39;
		public short Index_40;
		public short Index_41;
		public short Index_42;
		public short Index_43;
		public short Index_44;
		public short Index_45;
		public short Index_46;
		public short Index_47;
		public short Index_48;
		public short Index_49;
		public short Index_50;
		public short Index_51;
		public short Index_52;
		public short Index_53;
		public short Index_54;
		public short Index_55;
		public short Index_56;
		public short Index_57;
		public short Index_58;
		public short Index_59;
		public short Index_60;
		public short Index_61;
		public short Index_62;
		public short Index_63;
		public short Index_64;
		public short Index_65;
		public short Index_66;
		public short Index_67;
		public short Index_68;
		public short Index_69;
		public short Index_70;
		public short Index_71;
		public short Index_72;
		public short Index_73;
		public short Index_74;
		public short Index_75;
		public short Index_76;
		public short Index_77;
		public short Index_78;
		public short Index_79;
		public short Index_80;
		public short Index_81;
		public short Index_82;
		public short Index_83;
		public short Index_84;
		public short Index_85;
		public short Index_86;
		public short Index_87;
		public short Index_88;
		public short Index_89;
		public short Index_90;
		public short Index_91;
		public short Index_92;
		public short Index_93;
		public short Index_94;
		public short Index_95;
		public short Index_96;
		public short Index_97;
		public short Index_98;
		public short Index_99;
		public short Index_100;
		public short Index_101;
		public short Index_102;
		public short Index_103;
		public short Index_104;
		public short Index_105;
		public short Index_106;
		public short Index_107;
		public short Index_108;
		public short Index_109;
		public short Index_110;
		public short Index_111;
		public short Index_112;
		public short Index_113;
		public short Index_114;
		public short Index_115;
		public short Index_116;
		public short Index_117;
		public short Index_118;
		public short Index_119;
		public short Index_120;
		public short Index_121;
		public short Index_122;
		public short Index_123;
		public short Index_124;
		public short Index_125;
		public short Index_126;
		public short Index_127;
		public short Index_128;
		public short Index_129;
		public short Index_130;
		public short Index_131;
		public short Index_132;
		public short Index_133;
		public short Index_134;
		public short Index_135;
		public short Index_136;
		public short Index_137;
		public short Index_138;
		public short Index_139;
		public short Index_140;
		public short Index_141;
		public short Index_142;
		public short Index_143;
		public short Index_144;
		public short Index_145;
		public short Index_146;
		public short Index_147;
		public short Index_148;
		public short Index_149;
		public short Index_150;
		public short Index_151;
		public short Index_152;
		public short Index_153;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiKeyRoutingData Entries;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiKeyRoutingData EntriesNext;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiKeyRoutingTable(short* index = default, ImVectorImGuiKeyRoutingData entries = default, ImVectorImGuiKeyRoutingData entriesNext = default)
		{
			if (index != default)
			{
				Index_0 = index[0];
				Index_1 = index[1];
				Index_2 = index[2];
				Index_3 = index[3];
				Index_4 = index[4];
				Index_5 = index[5];
				Index_6 = index[6];
				Index_7 = index[7];
				Index_8 = index[8];
				Index_9 = index[9];
				Index_10 = index[10];
				Index_11 = index[11];
				Index_12 = index[12];
				Index_13 = index[13];
				Index_14 = index[14];
				Index_15 = index[15];
				Index_16 = index[16];
				Index_17 = index[17];
				Index_18 = index[18];
				Index_19 = index[19];
				Index_20 = index[20];
				Index_21 = index[21];
				Index_22 = index[22];
				Index_23 = index[23];
				Index_24 = index[24];
				Index_25 = index[25];
				Index_26 = index[26];
				Index_27 = index[27];
				Index_28 = index[28];
				Index_29 = index[29];
				Index_30 = index[30];
				Index_31 = index[31];
				Index_32 = index[32];
				Index_33 = index[33];
				Index_34 = index[34];
				Index_35 = index[35];
				Index_36 = index[36];
				Index_37 = index[37];
				Index_38 = index[38];
				Index_39 = index[39];
				Index_40 = index[40];
				Index_41 = index[41];
				Index_42 = index[42];
				Index_43 = index[43];
				Index_44 = index[44];
				Index_45 = index[45];
				Index_46 = index[46];
				Index_47 = index[47];
				Index_48 = index[48];
				Index_49 = index[49];
				Index_50 = index[50];
				Index_51 = index[51];
				Index_52 = index[52];
				Index_53 = index[53];
				Index_54 = index[54];
				Index_55 = index[55];
				Index_56 = index[56];
				Index_57 = index[57];
				Index_58 = index[58];
				Index_59 = index[59];
				Index_60 = index[60];
				Index_61 = index[61];
				Index_62 = index[62];
				Index_63 = index[63];
				Index_64 = index[64];
				Index_65 = index[65];
				Index_66 = index[66];
				Index_67 = index[67];
				Index_68 = index[68];
				Index_69 = index[69];
				Index_70 = index[70];
				Index_71 = index[71];
				Index_72 = index[72];
				Index_73 = index[73];
				Index_74 = index[74];
				Index_75 = index[75];
				Index_76 = index[76];
				Index_77 = index[77];
				Index_78 = index[78];
				Index_79 = index[79];
				Index_80 = index[80];
				Index_81 = index[81];
				Index_82 = index[82];
				Index_83 = index[83];
				Index_84 = index[84];
				Index_85 = index[85];
				Index_86 = index[86];
				Index_87 = index[87];
				Index_88 = index[88];
				Index_89 = index[89];
				Index_90 = index[90];
				Index_91 = index[91];
				Index_92 = index[92];
				Index_93 = index[93];
				Index_94 = index[94];
				Index_95 = index[95];
				Index_96 = index[96];
				Index_97 = index[97];
				Index_98 = index[98];
				Index_99 = index[99];
				Index_100 = index[100];
				Index_101 = index[101];
				Index_102 = index[102];
				Index_103 = index[103];
				Index_104 = index[104];
				Index_105 = index[105];
				Index_106 = index[106];
				Index_107 = index[107];
				Index_108 = index[108];
				Index_109 = index[109];
				Index_110 = index[110];
				Index_111 = index[111];
				Index_112 = index[112];
				Index_113 = index[113];
				Index_114 = index[114];
				Index_115 = index[115];
				Index_116 = index[116];
				Index_117 = index[117];
				Index_118 = index[118];
				Index_119 = index[119];
				Index_120 = index[120];
				Index_121 = index[121];
				Index_122 = index[122];
				Index_123 = index[123];
				Index_124 = index[124];
				Index_125 = index[125];
				Index_126 = index[126];
				Index_127 = index[127];
				Index_128 = index[128];
				Index_129 = index[129];
				Index_130 = index[130];
				Index_131 = index[131];
				Index_132 = index[132];
				Index_133 = index[133];
				Index_134 = index[134];
				Index_135 = index[135];
				Index_136 = index[136];
				Index_137 = index[137];
				Index_138 = index[138];
				Index_139 = index[139];
				Index_140 = index[140];
				Index_141 = index[141];
				Index_142 = index[142];
				Index_143 = index[143];
				Index_144 = index[144];
				Index_145 = index[145];
				Index_146 = index[146];
				Index_147 = index[147];
				Index_148 = index[148];
				Index_149 = index[149];
				Index_150 = index[150];
				Index_151 = index[151];
				Index_152 = index[152];
				Index_153 = index[153];
			}
			Entries = entries;
			EntriesNext = entriesNext;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiKeyRoutingTable(Span<short> index = default, ImVectorImGuiKeyRoutingData entries = default, ImVectorImGuiKeyRoutingData entriesNext = default)
		{
			if (index != default)
			{
				Index_0 = index[0];
				Index_1 = index[1];
				Index_2 = index[2];
				Index_3 = index[3];
				Index_4 = index[4];
				Index_5 = index[5];
				Index_6 = index[6];
				Index_7 = index[7];
				Index_8 = index[8];
				Index_9 = index[9];
				Index_10 = index[10];
				Index_11 = index[11];
				Index_12 = index[12];
				Index_13 = index[13];
				Index_14 = index[14];
				Index_15 = index[15];
				Index_16 = index[16];
				Index_17 = index[17];
				Index_18 = index[18];
				Index_19 = index[19];
				Index_20 = index[20];
				Index_21 = index[21];
				Index_22 = index[22];
				Index_23 = index[23];
				Index_24 = index[24];
				Index_25 = index[25];
				Index_26 = index[26];
				Index_27 = index[27];
				Index_28 = index[28];
				Index_29 = index[29];
				Index_30 = index[30];
				Index_31 = index[31];
				Index_32 = index[32];
				Index_33 = index[33];
				Index_34 = index[34];
				Index_35 = index[35];
				Index_36 = index[36];
				Index_37 = index[37];
				Index_38 = index[38];
				Index_39 = index[39];
				Index_40 = index[40];
				Index_41 = index[41];
				Index_42 = index[42];
				Index_43 = index[43];
				Index_44 = index[44];
				Index_45 = index[45];
				Index_46 = index[46];
				Index_47 = index[47];
				Index_48 = index[48];
				Index_49 = index[49];
				Index_50 = index[50];
				Index_51 = index[51];
				Index_52 = index[52];
				Index_53 = index[53];
				Index_54 = index[54];
				Index_55 = index[55];
				Index_56 = index[56];
				Index_57 = index[57];
				Index_58 = index[58];
				Index_59 = index[59];
				Index_60 = index[60];
				Index_61 = index[61];
				Index_62 = index[62];
				Index_63 = index[63];
				Index_64 = index[64];
				Index_65 = index[65];
				Index_66 = index[66];
				Index_67 = index[67];
				Index_68 = index[68];
				Index_69 = index[69];
				Index_70 = index[70];
				Index_71 = index[71];
				Index_72 = index[72];
				Index_73 = index[73];
				Index_74 = index[74];
				Index_75 = index[75];
				Index_76 = index[76];
				Index_77 = index[77];
				Index_78 = index[78];
				Index_79 = index[79];
				Index_80 = index[80];
				Index_81 = index[81];
				Index_82 = index[82];
				Index_83 = index[83];
				Index_84 = index[84];
				Index_85 = index[85];
				Index_86 = index[86];
				Index_87 = index[87];
				Index_88 = index[88];
				Index_89 = index[89];
				Index_90 = index[90];
				Index_91 = index[91];
				Index_92 = index[92];
				Index_93 = index[93];
				Index_94 = index[94];
				Index_95 = index[95];
				Index_96 = index[96];
				Index_97 = index[97];
				Index_98 = index[98];
				Index_99 = index[99];
				Index_100 = index[100];
				Index_101 = index[101];
				Index_102 = index[102];
				Index_103 = index[103];
				Index_104 = index[104];
				Index_105 = index[105];
				Index_106 = index[106];
				Index_107 = index[107];
				Index_108 = index[108];
				Index_109 = index[109];
				Index_110 = index[110];
				Index_111 = index[111];
				Index_112 = index[112];
				Index_113 = index[113];
				Index_114 = index[114];
				Index_115 = index[115];
				Index_116 = index[116];
				Index_117 = index[117];
				Index_118 = index[118];
				Index_119 = index[119];
				Index_120 = index[120];
				Index_121 = index[121];
				Index_122 = index[122];
				Index_123 = index[123];
				Index_124 = index[124];
				Index_125 = index[125];
				Index_126 = index[126];
				Index_127 = index[127];
				Index_128 = index[128];
				Index_129 = index[129];
				Index_130 = index[130];
				Index_131 = index[131];
				Index_132 = index[132];
				Index_133 = index[133];
				Index_134 = index[134];
				Index_135 = index[135];
				Index_136 = index[136];
				Index_137 = index[137];
				Index_138 = index[138];
				Index_139 = index[139];
				Index_140 = index[140];
				Index_141 = index[141];
				Index_142 = index[142];
				Index_143 = index[143];
				Index_144 = index[144];
				Index_145 = index[145];
				Index_146 = index[146];
				Index_147 = index[147];
				Index_148 = index[148];
				Index_149 = index[149];
				Index_150 = index[150];
				Index_151 = index[151];
				Index_152 = index[152];
				Index_153 = index[153];
			}
			Entries = entries;
			EntriesNext = entriesNext;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiKeyRoutingData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiKeyRoutingData* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiKeyRoutingData(int size = default, int capacity = default, ImGuiKeyRoutingData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiKeyRoutingData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public short NextEntryIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Mods;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte RoutingNextScore;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint RoutingCurr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint RoutingNext;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiKeyRoutingData(short nextEntryIndex = default, ushort mods = default, byte routingNextScore = default, uint routingCurr = default, uint routingNext = default)
		{
			NextEntryIndex = nextEntryIndex;
			Mods = mods;
			RoutingNextScore = routingNextScore;
			RoutingCurr = routingCurr;
			RoutingNext = routingNext;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextItemData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ItemFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Width;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiSelectionUserData SelectionUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int OpenCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte OpenVal;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiNextItemData(int flags = default, int itemFlags = default, float width = default, ImGuiSelectionUserData selectionUserData = default, int openCond = default, bool openVal = default)
		{
			Flags = flags;
			ItemFlags = itemFlags;
			Width = width;
			SelectionUserData = selectionUserData;
			OpenCond = openCond;
			OpenVal = openVal ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNextWindowData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int PosCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SizeCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CollapsedCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DockCond;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 PosVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 PosPivotVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 SizeVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ContentSizeVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 ScrollVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PosUndock;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CollapsedVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect SizeConstraintRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* SizeCallback;
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* SizeCallbackUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BgAlphaVal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ViewportId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DockId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiWindowClass WindowClass;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 MenuBarOffsetMinVal;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiNextWindowData(int flags = default, int posCond = default, int sizeCond = default, int collapsedCond = default, int dockCond = default, Vector2 posVal = default, Vector2 posPivotVal = default, Vector2 sizeVal = default, Vector2 contentSizeVal = default, Vector2 scrollVal = default, bool posUndock = default, bool collapsedVal = default, ImRect sizeConstraintRect = default, ImGuiSizeCallback sizeCallback = default, void* sizeCallbackUserData = default, float bgAlphaVal = default, uint viewportId = default, uint dockId = default, ImGuiWindowClass windowClass = default, Vector2 menuBarOffsetMinVal = default)
		{
			Flags = flags;
			PosCond = posCond;
			SizeCond = sizeCond;
			CollapsedCond = collapsedCond;
			DockCond = dockCond;
			PosVal = posVal;
			PosPivotVal = posPivotVal;
			SizeVal = sizeVal;
			ContentSizeVal = contentSizeVal;
			ScrollVal = scrollVal;
			PosUndock = posUndock ? (byte)1 : (byte)0;
			CollapsedVal = collapsedVal ? (byte)1 : (byte)0;
			SizeConstraintRect = sizeConstraintRect;
			SizeCallback = (void*)Marshal.GetFunctionPointerForDelegate(sizeCallback);
			SizeCallbackUserData = sizeCallbackUserData;
			BgAlphaVal = bgAlphaVal;
			ViewportId = viewportId;
			DockId = dockId;
			WindowClass = windowClass;
			MenuBarOffsetMinVal = menuBarOffsetMinVal;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiSizeCallbackData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 Pos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 CurrentSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 DesiredSize;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiSizeCallbackData(void* userData = default, Vector2 pos = default, Vector2 currentSize = default, Vector2 desiredSize = default)
		{
			UserData = userData;
			Pos = pos;
			CurrentSize = currentSize;
			DesiredSize = desiredSize;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiColorMod
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiColorMod* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiColorMod(int size = default, int capacity = default, ImGuiColorMod* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiColorMod
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Col;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 BackupValue;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiColorMod(int col = default, Vector4 backupValue = default)
		{
			Col = col;
			BackupValue = backupValue;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStyleMod
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiStyleMod* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiStyleMod(int size = default, int capacity = default, ImGuiStyleMod* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStyleMod
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		[StructLayout(LayoutKind.Explicit)]
		public partial struct ImGuiStyleModUnion
		{
			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public int BackupInt_0;
			[FieldOffset(8)]
			public int BackupInt_1;

			/// <summary>
			/// To be documented.
			/// </summary>
			[FieldOffset(0)]
			public float BackupFloat_0;
			[FieldOffset(8)]
			public float BackupFloat_1;


			/// <summary>			/// To be documented.			/// </summary>			public unsafe ImGuiStyleModUnion(int* backupInt = default, float* backupFloat = default)
			{
				if (backupInt != default)
				{
					BackupInt_0 = backupInt[0];
					BackupInt_1 = backupInt[1];
				}
				if (backupFloat != default)
				{
					BackupFloat_0 = backupFloat[0];
					BackupFloat_1 = backupFloat[1];
				}
			}

			/// <summary>			/// To be documented.			/// </summary>			public unsafe ImGuiStyleModUnion(Span<int> backupInt = default, Span<float> backupFloat = default)
			{
				if (backupInt != default)
				{
					BackupInt_0 = backupInt[0];
					BackupInt_1 = backupInt[1];
				}
				if (backupFloat != default)
				{
					BackupFloat_0 = backupFloat[0];
					BackupFloat_1 = backupFloat[1];
				}
			}


			/// <summary>
			/// To be documented.
			/// </summary>
			/// <summary>
			/// To be documented.
			/// </summary>
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public int VarIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStyleModUnion Union;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiStyleMod(int varIdx = default, ImGuiStyleModUnion union = default)
		{
			VarIdx = varIdx;
			Union = union;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiItemFlags
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe int* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiItemFlags(int size = default, int capacity = default, int* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiGroupData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiGroupData* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiGroupData(int size = default, int capacity = default, ImGuiGroupData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiGroupData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint WindowID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorMaxPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorPosPrevLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 BackupIndent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 BackupGroupOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCurrLineSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BackupCurrLineTextBaseOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint BackupActiveIdIsAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BackupActiveIdPreviousFrameIsAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BackupHoveredIdIsAlive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BackupIsSameLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte EmitItem;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiGroupData(uint windowId = default, Vector2 backupCursorPos = default, Vector2 backupCursorMaxPos = default, Vector2 backupCursorPosPrevLine = default, ImVec1 backupIndent = default, ImVec1 backupGroupOffset = default, Vector2 backupCurrLineSize = default, float backupCurrLineTextBaseOffset = default, uint backupActiveIdIsAlive = default, bool backupActiveIdPreviousFrameIsAlive = default, bool backupHoveredIdIsAlive = default, bool backupIsSameLine = default, bool emitItem = default)
		{
			WindowID = windowId;
			BackupCursorPos = backupCursorPos;
			BackupCursorMaxPos = backupCursorMaxPos;
			BackupCursorPosPrevLine = backupCursorPosPrevLine;
			BackupIndent = backupIndent;
			BackupGroupOffset = backupGroupOffset;
			BackupCurrLineSize = backupCurrLineSize;
			BackupCurrLineTextBaseOffset = backupCurrLineTextBaseOffset;
			BackupActiveIdIsAlive = backupActiveIdIsAlive;
			BackupActiveIdPreviousFrameIsAlive = backupActiveIdPreviousFrameIsAlive ? (byte)1 : (byte)0;
			BackupHoveredIdIsAlive = backupHoveredIdIsAlive ? (byte)1 : (byte)0;
			BackupIsSameLine = backupIsSameLine ? (byte)1 : (byte)0;
			EmitItem = emitItem ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPopupData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiPopupData* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiPopupData(int size = default, int capacity = default, ImGuiPopupData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPopupData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint PopupId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* BackupNavWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ParentNavLayer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int OpenFrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint OpenParentId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 OpenPopupPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 OpenMousePos;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiPopupData(uint popupId = default, ImGuiWindow* window = default, ImGuiWindow* backupNavWindow = default, int parentNavLayer = default, int openFrameCount = default, uint openParentId = default, Vector2 openPopupPos = default, Vector2 openMousePos = default)
		{
			PopupId = popupId;
			Window = window;
			BackupNavWindow = backupNavWindow;
			ParentNavLayer = parentNavLayer;
			OpenFrameCount = openFrameCount;
			OpenParentId = openParentId;
			OpenPopupPos = openPopupPos;
			OpenMousePos = openMousePos;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiNavTreeNodeData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiNavTreeNodeData* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiNavTreeNodeData(int size = default, int capacity = default, ImGuiNavTreeNodeData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNavTreeNodeData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int InFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect NavRect;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiNavTreeNodeData(uint id = default, int inFlags = default, ImRect navRect = default)
		{
			ID = id;
			InFlags = inFlags;
			NavRect = navRect;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiViewportPPtr
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiViewportP** Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiViewportPPtr(int size = default, int capacity = default, ImGuiViewportP** data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiNavItemData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* Window;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint FocusScopeId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect RectRel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int InFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiSelectionUserData SelectionUserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DistBox;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DistCenter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float DistAxial;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiNavItemData(ImGuiWindow* window = default, uint id = default, uint focusScopeId = default, ImRect rectRel = default, int inFlags = default, ImGuiSelectionUserData selectionUserData = default, float distBox = default, float distCenter = default, float distAxial = default)
		{
			Window = window;
			ID = id;
			FocusScopeId = focusScopeId;
			RectRel = rectRel;
			InFlags = inFlags;
			SelectionUserData = selectionUserData;
			DistBox = distBox;
			DistCenter = distCenter;
			DistAxial = distAxial;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPayload
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* Data;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DataSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint SourceId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint SourceParentId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DataFrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DataType_0;
		public byte DataType_1;
		public byte DataType_2;
		public byte DataType_3;
		public byte DataType_4;
		public byte DataType_5;
		public byte DataType_6;
		public byte DataType_7;
		public byte DataType_8;
		public byte DataType_9;
		public byte DataType_10;
		public byte DataType_11;
		public byte DataType_12;
		public byte DataType_13;
		public byte DataType_14;
		public byte DataType_15;
		public byte DataType_16;
		public byte DataType_17;
		public byte DataType_18;
		public byte DataType_19;
		public byte DataType_20;
		public byte DataType_21;
		public byte DataType_22;
		public byte DataType_23;
		public byte DataType_24;
		public byte DataType_25;
		public byte DataType_26;
		public byte DataType_27;
		public byte DataType_28;
		public byte DataType_29;
		public byte DataType_30;
		public byte DataType_31;
		public byte DataType_32;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Preview;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Delivery;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiPayload(void* data = default, int dataSize = default, uint sourceId = default, uint sourceParentId = default, int dataFrameCount = default, byte* dataType = default, bool preview = default, bool delivery = default)
		{
			Data = data;
			DataSize = dataSize;
			SourceId = sourceId;
			SourceParentId = sourceParentId;
			DataFrameCount = dataFrameCount;
			if (dataType != default)
			{
				DataType_0 = dataType[0];
				DataType_1 = dataType[1];
				DataType_2 = dataType[2];
				DataType_3 = dataType[3];
				DataType_4 = dataType[4];
				DataType_5 = dataType[5];
				DataType_6 = dataType[6];
				DataType_7 = dataType[7];
				DataType_8 = dataType[8];
				DataType_9 = dataType[9];
				DataType_10 = dataType[10];
				DataType_11 = dataType[11];
				DataType_12 = dataType[12];
				DataType_13 = dataType[13];
				DataType_14 = dataType[14];
				DataType_15 = dataType[15];
				DataType_16 = dataType[16];
				DataType_17 = dataType[17];
				DataType_18 = dataType[18];
				DataType_19 = dataType[19];
				DataType_20 = dataType[20];
				DataType_21 = dataType[21];
				DataType_22 = dataType[22];
				DataType_23 = dataType[23];
				DataType_24 = dataType[24];
				DataType_25 = dataType[25];
				DataType_26 = dataType[26];
				DataType_27 = dataType[27];
				DataType_28 = dataType[28];
				DataType_29 = dataType[29];
				DataType_30 = dataType[30];
				DataType_31 = dataType[31];
				DataType_32 = dataType[32];
			}
			Preview = preview ? (byte)1 : (byte)0;
			Delivery = delivery ? (byte)1 : (byte)0;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiPayload(void* data = default, int dataSize = default, uint sourceId = default, uint sourceParentId = default, int dataFrameCount = default, Span<byte> dataType = default, bool preview = default, bool delivery = default)
		{
			Data = data;
			DataSize = dataSize;
			SourceId = sourceId;
			SourceParentId = sourceParentId;
			DataFrameCount = dataFrameCount;
			if (dataType != default)
			{
				DataType_0 = dataType[0];
				DataType_1 = dataType[1];
				DataType_2 = dataType[2];
				DataType_3 = dataType[3];
				DataType_4 = dataType[4];
				DataType_5 = dataType[5];
				DataType_6 = dataType[6];
				DataType_7 = dataType[7];
				DataType_8 = dataType[8];
				DataType_9 = dataType[9];
				DataType_10 = dataType[10];
				DataType_11 = dataType[11];
				DataType_12 = dataType[12];
				DataType_13 = dataType[13];
				DataType_14 = dataType[14];
				DataType_15 = dataType[15];
				DataType_16 = dataType[16];
				DataType_17 = dataType[17];
				DataType_18 = dataType[18];
				DataType_19 = dataType[19];
				DataType_20 = dataType[20];
				DataType_21 = dataType[21];
				DataType_22 = dataType[22];
				DataType_23 = dataType[23];
				DataType_24 = dataType[24];
				DataType_25 = dataType[25];
				DataType_26 = dataType[26];
				DataType_27 = dataType[27];
				DataType_28 = dataType[28];
				DataType_29 = dataType[29];
				DataType_30 = dataType[30];
				DataType_31 = dataType[31];
				DataType_32 = dataType[32];
			}
			Preview = preview ? (byte)1 : (byte)0;
			Delivery = delivery ? (byte)1 : (byte)0;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Clear()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool IsDataType( byte* type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsDataTypeNative(@this, type);
				return ret != 0;
			}
		}

		public unsafe bool IsDataType( ref byte type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				fixed (byte* ptype = &type)
				{
					byte ret = ImGui.IsDataTypeNative(@this, (byte*)ptype);
					return ret != 0;
				}
			}
		}

		public unsafe bool IsDataType( string type)
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.IsDataTypeNative(@this, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool IsDelivery()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsDeliveryNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool IsPreview()
		{
			fixed (ImGuiPayload* @this = &this)
			{
				byte ret = ImGui.IsPreviewNative(@this);
				return ret != 0;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorUnsignedChar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorUnsignedChar(int size = default, int capacity = default, byte* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiListClipperData* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiListClipperData(int size = default, int capacity = default, ImGuiListClipperData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiListClipper* ListClipper;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LossynessOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int StepNo;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ItemsFrozen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiListClipperRange Ranges;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiListClipperData(ImGuiListClipper* listClipper = default, float lossynessOffset = default, int stepNo = default, int itemsFrozen = default, ImVectorImGuiListClipperRange ranges = default)
		{
			ListClipper = listClipper;
			LossynessOffset = lossynessOffset;
			StepNo = stepNo;
			ItemsFrozen = itemsFrozen;
			Ranges = ranges;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipper
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DisplayStart;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DisplayEnd;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ItemsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ItemsHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float StartPosY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* TempData;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiListClipper(ImGuiContext* ctx = default, int displayStart = default, int displayEnd = default, int itemsCount = default, float itemsHeight = default, float startPosY = default, void* tempData = default)
		{
			Ctx = ctx;
			DisplayStart = displayStart;
			DisplayEnd = displayEnd;
			ItemsCount = itemsCount;
			ItemsHeight = itemsHeight;
			StartPosY = startPosY;
			TempData = tempData;
		}


		public unsafe void Begin( int itemsCount,  float itemsHeight)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.BeginNative(@this, itemsCount, itemsHeight);
			}
		}

		public unsafe void Begin( int itemsCount)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.BeginNative(@this, itemsCount, (float)(-1.0f));
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe void End()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.EndNative(@this);
			}
		}

		public unsafe void IncludeItemByIndex( int itemIndex)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.IncludeItemByIndexNative(@this, itemIndex);
			}
		}

		public unsafe void IncludeItemsByIndex( int itemBegin,  int itemEnd)
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				ImGui.IncludeItemsByIndexNative(@this, itemBegin, itemEnd);
			}
		}

		public unsafe bool Step()
		{
			fixed (ImGuiListClipper* @this = &this)
			{
				byte ret = ImGui.StepNative(@this);
				return ret != 0;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiListClipperRange
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiListClipperRange* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiListClipperRange(int size = default, int capacity = default, ImGuiListClipperRange* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiListClipperRange
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Min;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Max;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PosToIndexConvert;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PosToIndexOffsetMin;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte PosToIndexOffsetMax;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiListClipperRange(int min = default, int max = default, bool posToIndexConvert = default, byte posToIndexOffsetMin = default, byte posToIndexOffsetMax = default)
		{
			Min = min;
			Max = max;
			PosToIndexConvert = posToIndexConvert ? (byte)1 : (byte)0;
			PosToIndexOffsetMin = posToIndexOffsetMin;
			PosToIndexOffsetMax = posToIndexOffsetMax;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTable
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* RawData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableTempData* TempData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImSpanImGuiTableColumn Columns;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImSpanImGuiTableColumnIdx DisplayOrderToIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImSpanImGuiTableCellData RowCellData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImBitArrayPtr EnabledMaskByDisplayOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImBitArrayPtr EnabledMaskByIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImBitArrayPtr VisibleMaskByIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SettingsLoadedFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SettingsOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastFrameActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ColumnsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurrentRow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurrentColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short InstanceCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short InstanceInteracted;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowPosY1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowPosY2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowMinHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowCellPaddingY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowTextBaseline;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RowIndentOffsetX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int RowFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastRowFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int RowBgColorCounter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint RowBgColor_0;
		public uint RowBgColor_1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint BorderColorStrong;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint BorderColorLight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BorderX1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BorderX2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HostIndentX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MinColumnWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float OuterPaddingX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CellPaddingX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CellSpacingX1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CellSpacingX2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float InnerWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ColumnsGivenWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ColumnsAutoFitWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ColumnsStretchSumWeights;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ResizedColumnNextWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ResizeLockMinContentsX2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RefScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float AngledHeadersHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float AngledHeadersSlope;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect OuterRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect InnerRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect WorkRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect InnerClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect BgClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect Bg0ClipRectForDrawCmd;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect Bg2ClipRectForDrawCmd;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostBackupInnerClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* OuterWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiWindow* InnerWindow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTextBuffer ColumnsNames;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImDrawListSplitter* DrawSplitter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTableInstanceData InstanceDataFirst;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTableInstanceData InstanceDataExtra;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTableColumnSortSpecs SortSpecsSingle;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTableColumnSortSpecs SortSpecsMulti;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTableSortSpecs SortSpecs;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte SortSpecsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte ColumnsEnabledCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte ColumnsEnabledFixedCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte DeclColumnsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte AngledHeadersCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte HoveredColumnBody;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte HoveredColumnBorder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte HighlightColumnHeader;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte AutoFitSingleColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte ResizedColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte LastResizedColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte HeldHeaderColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte ReorderColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte ReorderColumnDir;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte LeftMostEnabledColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte RightMostEnabledColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte LeftMostStretchedColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte RightMostStretchedColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte ContextPopupColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte FreezeRowsRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte FreezeRowsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte FreezeColumnsRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte FreezeColumnsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte RowCellDataCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DummyDrawChannel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Bg2DrawChannelCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Bg2DrawChannelUnfrozen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsLayoutLocked;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsInsideRow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsInitializing;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSortSpecsDirty;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsUsingHeaders;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsContextPopupOpen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSettingsRequestLoad;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSettingsDirty;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsDefaultDisplayOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsResetAllRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsResetDisplayOrderRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsUnfrozenRows;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsDefaultSizingPolicy;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsActiveIdAliveBeforeTable;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsActiveIdInTable;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasScrollbarYCurr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasScrollbarYPrev;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte MemoryCompacted;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HostSkipItems;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTable(uint id = default, int flags = default, void* rawData = default, ImGuiTableTempData* tempData = default, ImSpanImGuiTableColumn columns = default, ImSpanImGuiTableColumnIdx displayOrderToIndex = default, ImSpanImGuiTableCellData rowCellData = default, ImBitArrayPtr enabledMaskByDisplayOrder = default, ImBitArrayPtr enabledMaskByIndex = default, ImBitArrayPtr visibleMaskByIndex = default, int settingsLoadedFlags = default, int settingsOffset = default, int lastFrameActive = default, int columnsCount = default, int currentRow = default, int currentColumn = default, short instanceCurrent = default, short instanceInteracted = default, float rowPosY1 = default, float rowPosY2 = default, float rowMinHeight = default, float rowCellPaddingY = default, float rowTextBaseline = default, float rowIndentOffsetX = default, int rowFlags = default, int lastRowFlags = default, int rowBgColorCounter = default, uint* rowBgColor = default, uint borderColorStrong = default, uint borderColorLight = default, float borderX1 = default, float borderX2 = default, float hostIndentX = default, float minColumnWidth = default, float outerPaddingX = default, float cellPaddingX = default, float cellSpacingX1 = default, float cellSpacingX2 = default, float innerWidth = default, float columnsGivenWidth = default, float columnsAutoFitWidth = default, float columnsStretchSumWeights = default, float resizedColumnNextWidth = default, float resizeLockMinContentsX2 = default, float refScale = default, float angledHeadersHeight = default, float angledHeadersSlope = default, ImRect outerRect = default, ImRect innerRect = default, ImRect workRect = default, ImRect innerClipRect = default, ImRect bgClipRect = default, ImRect bg0ClipRectForDrawCmd = default, ImRect bg2ClipRectForDrawCmd = default, ImRect hostClipRect = default, ImRect hostBackupInnerClipRect = default, ImGuiWindow* outerWindow = default, ImGuiWindow* innerWindow = default, ImGuiTextBuffer columnsNames = default, ImDrawListSplitter* drawSplitter = default, ImGuiTableInstanceData instanceDataFirst = default, ImVectorImGuiTableInstanceData instanceDataExtra = default, ImGuiTableColumnSortSpecs sortSpecsSingle = default, ImVectorImGuiTableColumnSortSpecs sortSpecsMulti = default, ImGuiTableSortSpecs sortSpecs = default, sbyte sortSpecsCount = default, sbyte columnsEnabledCount = default, sbyte columnsEnabledFixedCount = default, sbyte declColumnsCount = default, sbyte angledHeadersCount = default, sbyte hoveredColumnBody = default, sbyte hoveredColumnBorder = default, sbyte highlightColumnHeader = default, sbyte autoFitSingleColumn = default, sbyte resizedColumn = default, sbyte lastResizedColumn = default, sbyte heldHeaderColumn = default, sbyte reorderColumn = default, sbyte reorderColumnDir = default, sbyte leftMostEnabledColumn = default, sbyte rightMostEnabledColumn = default, sbyte leftMostStretchedColumn = default, sbyte rightMostStretchedColumn = default, sbyte contextPopupColumn = default, sbyte freezeRowsRequest = default, sbyte freezeRowsCount = default, sbyte freezeColumnsRequest = default, sbyte freezeColumnsCount = default, sbyte rowCellDataCurrent = default, byte dummyDrawChannel = default, byte bg2DrawChannelCurrent = default, byte bg2DrawChannelUnfrozen = default, bool isLayoutLocked = default, bool isInsideRow = default, bool isInitializing = default, bool isSortSpecsDirty = default, bool isUsingHeaders = default, bool isContextPopupOpen = default, bool isSettingsRequestLoad = default, bool isSettingsDirty = default, bool isDefaultDisplayOrder = default, bool isResetAllRequest = default, bool isResetDisplayOrderRequest = default, bool isUnfrozenRows = default, bool isDefaultSizingPolicy = default, bool isActiveIdAliveBeforeTable = default, bool isActiveIdInTable = default, bool hasScrollbarYCurr = default, bool hasScrollbarYPrev = default, bool memoryCompacted = default, bool hostSkipItems = default)
		{
			ID = id;
			Flags = flags;
			RawData = rawData;
			TempData = tempData;
			Columns = columns;
			DisplayOrderToIndex = displayOrderToIndex;
			RowCellData = rowCellData;
			EnabledMaskByDisplayOrder = enabledMaskByDisplayOrder;
			EnabledMaskByIndex = enabledMaskByIndex;
			VisibleMaskByIndex = visibleMaskByIndex;
			SettingsLoadedFlags = settingsLoadedFlags;
			SettingsOffset = settingsOffset;
			LastFrameActive = lastFrameActive;
			ColumnsCount = columnsCount;
			CurrentRow = currentRow;
			CurrentColumn = currentColumn;
			InstanceCurrent = instanceCurrent;
			InstanceInteracted = instanceInteracted;
			RowPosY1 = rowPosY1;
			RowPosY2 = rowPosY2;
			RowMinHeight = rowMinHeight;
			RowCellPaddingY = rowCellPaddingY;
			RowTextBaseline = rowTextBaseline;
			RowIndentOffsetX = rowIndentOffsetX;
			RowFlags = rowFlags;
			LastRowFlags = lastRowFlags;
			RowBgColorCounter = rowBgColorCounter;
			if (rowBgColor != default)
			{
				RowBgColor_0 = rowBgColor[0];
				RowBgColor_1 = rowBgColor[1];
			}
			BorderColorStrong = borderColorStrong;
			BorderColorLight = borderColorLight;
			BorderX1 = borderX1;
			BorderX2 = borderX2;
			HostIndentX = hostIndentX;
			MinColumnWidth = minColumnWidth;
			OuterPaddingX = outerPaddingX;
			CellPaddingX = cellPaddingX;
			CellSpacingX1 = cellSpacingX1;
			CellSpacingX2 = cellSpacingX2;
			InnerWidth = innerWidth;
			ColumnsGivenWidth = columnsGivenWidth;
			ColumnsAutoFitWidth = columnsAutoFitWidth;
			ColumnsStretchSumWeights = columnsStretchSumWeights;
			ResizedColumnNextWidth = resizedColumnNextWidth;
			ResizeLockMinContentsX2 = resizeLockMinContentsX2;
			RefScale = refScale;
			AngledHeadersHeight = angledHeadersHeight;
			AngledHeadersSlope = angledHeadersSlope;
			OuterRect = outerRect;
			InnerRect = innerRect;
			WorkRect = workRect;
			InnerClipRect = innerClipRect;
			BgClipRect = bgClipRect;
			Bg0ClipRectForDrawCmd = bg0ClipRectForDrawCmd;
			Bg2ClipRectForDrawCmd = bg2ClipRectForDrawCmd;
			HostClipRect = hostClipRect;
			HostBackupInnerClipRect = hostBackupInnerClipRect;
			OuterWindow = outerWindow;
			InnerWindow = innerWindow;
			ColumnsNames = columnsNames;
			DrawSplitter = drawSplitter;
			InstanceDataFirst = instanceDataFirst;
			InstanceDataExtra = instanceDataExtra;
			SortSpecsSingle = sortSpecsSingle;
			SortSpecsMulti = sortSpecsMulti;
			SortSpecs = sortSpecs;
			SortSpecsCount = sortSpecsCount;
			ColumnsEnabledCount = columnsEnabledCount;
			ColumnsEnabledFixedCount = columnsEnabledFixedCount;
			DeclColumnsCount = declColumnsCount;
			AngledHeadersCount = angledHeadersCount;
			HoveredColumnBody = hoveredColumnBody;
			HoveredColumnBorder = hoveredColumnBorder;
			HighlightColumnHeader = highlightColumnHeader;
			AutoFitSingleColumn = autoFitSingleColumn;
			ResizedColumn = resizedColumn;
			LastResizedColumn = lastResizedColumn;
			HeldHeaderColumn = heldHeaderColumn;
			ReorderColumn = reorderColumn;
			ReorderColumnDir = reorderColumnDir;
			LeftMostEnabledColumn = leftMostEnabledColumn;
			RightMostEnabledColumn = rightMostEnabledColumn;
			LeftMostStretchedColumn = leftMostStretchedColumn;
			RightMostStretchedColumn = rightMostStretchedColumn;
			ContextPopupColumn = contextPopupColumn;
			FreezeRowsRequest = freezeRowsRequest;
			FreezeRowsCount = freezeRowsCount;
			FreezeColumnsRequest = freezeColumnsRequest;
			FreezeColumnsCount = freezeColumnsCount;
			RowCellDataCurrent = rowCellDataCurrent;
			DummyDrawChannel = dummyDrawChannel;
			Bg2DrawChannelCurrent = bg2DrawChannelCurrent;
			Bg2DrawChannelUnfrozen = bg2DrawChannelUnfrozen;
			IsLayoutLocked = isLayoutLocked ? (byte)1 : (byte)0;
			IsInsideRow = isInsideRow ? (byte)1 : (byte)0;
			IsInitializing = isInitializing ? (byte)1 : (byte)0;
			IsSortSpecsDirty = isSortSpecsDirty ? (byte)1 : (byte)0;
			IsUsingHeaders = isUsingHeaders ? (byte)1 : (byte)0;
			IsContextPopupOpen = isContextPopupOpen ? (byte)1 : (byte)0;
			IsSettingsRequestLoad = isSettingsRequestLoad ? (byte)1 : (byte)0;
			IsSettingsDirty = isSettingsDirty ? (byte)1 : (byte)0;
			IsDefaultDisplayOrder = isDefaultDisplayOrder ? (byte)1 : (byte)0;
			IsResetAllRequest = isResetAllRequest ? (byte)1 : (byte)0;
			IsResetDisplayOrderRequest = isResetDisplayOrderRequest ? (byte)1 : (byte)0;
			IsUnfrozenRows = isUnfrozenRows ? (byte)1 : (byte)0;
			IsDefaultSizingPolicy = isDefaultSizingPolicy ? (byte)1 : (byte)0;
			IsActiveIdAliveBeforeTable = isActiveIdAliveBeforeTable ? (byte)1 : (byte)0;
			IsActiveIdInTable = isActiveIdInTable ? (byte)1 : (byte)0;
			HasScrollbarYCurr = hasScrollbarYCurr ? (byte)1 : (byte)0;
			HasScrollbarYPrev = hasScrollbarYPrev ? (byte)1 : (byte)0;
			MemoryCompacted = memoryCompacted ? (byte)1 : (byte)0;
			HostSkipItems = hostSkipItems ? (byte)1 : (byte)0;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTable(uint id = default, int flags = default, void* rawData = default, ImGuiTableTempData* tempData = default, ImSpanImGuiTableColumn columns = default, ImSpanImGuiTableColumnIdx displayOrderToIndex = default, ImSpanImGuiTableCellData rowCellData = default, ImBitArrayPtr enabledMaskByDisplayOrder = default, ImBitArrayPtr enabledMaskByIndex = default, ImBitArrayPtr visibleMaskByIndex = default, int settingsLoadedFlags = default, int settingsOffset = default, int lastFrameActive = default, int columnsCount = default, int currentRow = default, int currentColumn = default, short instanceCurrent = default, short instanceInteracted = default, float rowPosY1 = default, float rowPosY2 = default, float rowMinHeight = default, float rowCellPaddingY = default, float rowTextBaseline = default, float rowIndentOffsetX = default, int rowFlags = default, int lastRowFlags = default, int rowBgColorCounter = default, Span<uint> rowBgColor = default, uint borderColorStrong = default, uint borderColorLight = default, float borderX1 = default, float borderX2 = default, float hostIndentX = default, float minColumnWidth = default, float outerPaddingX = default, float cellPaddingX = default, float cellSpacingX1 = default, float cellSpacingX2 = default, float innerWidth = default, float columnsGivenWidth = default, float columnsAutoFitWidth = default, float columnsStretchSumWeights = default, float resizedColumnNextWidth = default, float resizeLockMinContentsX2 = default, float refScale = default, float angledHeadersHeight = default, float angledHeadersSlope = default, ImRect outerRect = default, ImRect innerRect = default, ImRect workRect = default, ImRect innerClipRect = default, ImRect bgClipRect = default, ImRect bg0ClipRectForDrawCmd = default, ImRect bg2ClipRectForDrawCmd = default, ImRect hostClipRect = default, ImRect hostBackupInnerClipRect = default, ImGuiWindow* outerWindow = default, ImGuiWindow* innerWindow = default, ImGuiTextBuffer columnsNames = default, ImDrawListSplitter* drawSplitter = default, ImGuiTableInstanceData instanceDataFirst = default, ImVectorImGuiTableInstanceData instanceDataExtra = default, ImGuiTableColumnSortSpecs sortSpecsSingle = default, ImVectorImGuiTableColumnSortSpecs sortSpecsMulti = default, ImGuiTableSortSpecs sortSpecs = default, sbyte sortSpecsCount = default, sbyte columnsEnabledCount = default, sbyte columnsEnabledFixedCount = default, sbyte declColumnsCount = default, sbyte angledHeadersCount = default, sbyte hoveredColumnBody = default, sbyte hoveredColumnBorder = default, sbyte highlightColumnHeader = default, sbyte autoFitSingleColumn = default, sbyte resizedColumn = default, sbyte lastResizedColumn = default, sbyte heldHeaderColumn = default, sbyte reorderColumn = default, sbyte reorderColumnDir = default, sbyte leftMostEnabledColumn = default, sbyte rightMostEnabledColumn = default, sbyte leftMostStretchedColumn = default, sbyte rightMostStretchedColumn = default, sbyte contextPopupColumn = default, sbyte freezeRowsRequest = default, sbyte freezeRowsCount = default, sbyte freezeColumnsRequest = default, sbyte freezeColumnsCount = default, sbyte rowCellDataCurrent = default, byte dummyDrawChannel = default, byte bg2DrawChannelCurrent = default, byte bg2DrawChannelUnfrozen = default, bool isLayoutLocked = default, bool isInsideRow = default, bool isInitializing = default, bool isSortSpecsDirty = default, bool isUsingHeaders = default, bool isContextPopupOpen = default, bool isSettingsRequestLoad = default, bool isSettingsDirty = default, bool isDefaultDisplayOrder = default, bool isResetAllRequest = default, bool isResetDisplayOrderRequest = default, bool isUnfrozenRows = default, bool isDefaultSizingPolicy = default, bool isActiveIdAliveBeforeTable = default, bool isActiveIdInTable = default, bool hasScrollbarYCurr = default, bool hasScrollbarYPrev = default, bool memoryCompacted = default, bool hostSkipItems = default)
		{
			ID = id;
			Flags = flags;
			RawData = rawData;
			TempData = tempData;
			Columns = columns;
			DisplayOrderToIndex = displayOrderToIndex;
			RowCellData = rowCellData;
			EnabledMaskByDisplayOrder = enabledMaskByDisplayOrder;
			EnabledMaskByIndex = enabledMaskByIndex;
			VisibleMaskByIndex = visibleMaskByIndex;
			SettingsLoadedFlags = settingsLoadedFlags;
			SettingsOffset = settingsOffset;
			LastFrameActive = lastFrameActive;
			ColumnsCount = columnsCount;
			CurrentRow = currentRow;
			CurrentColumn = currentColumn;
			InstanceCurrent = instanceCurrent;
			InstanceInteracted = instanceInteracted;
			RowPosY1 = rowPosY1;
			RowPosY2 = rowPosY2;
			RowMinHeight = rowMinHeight;
			RowCellPaddingY = rowCellPaddingY;
			RowTextBaseline = rowTextBaseline;
			RowIndentOffsetX = rowIndentOffsetX;
			RowFlags = rowFlags;
			LastRowFlags = lastRowFlags;
			RowBgColorCounter = rowBgColorCounter;
			if (rowBgColor != default)
			{
				RowBgColor_0 = rowBgColor[0];
				RowBgColor_1 = rowBgColor[1];
			}
			BorderColorStrong = borderColorStrong;
			BorderColorLight = borderColorLight;
			BorderX1 = borderX1;
			BorderX2 = borderX2;
			HostIndentX = hostIndentX;
			MinColumnWidth = minColumnWidth;
			OuterPaddingX = outerPaddingX;
			CellPaddingX = cellPaddingX;
			CellSpacingX1 = cellSpacingX1;
			CellSpacingX2 = cellSpacingX2;
			InnerWidth = innerWidth;
			ColumnsGivenWidth = columnsGivenWidth;
			ColumnsAutoFitWidth = columnsAutoFitWidth;
			ColumnsStretchSumWeights = columnsStretchSumWeights;
			ResizedColumnNextWidth = resizedColumnNextWidth;
			ResizeLockMinContentsX2 = resizeLockMinContentsX2;
			RefScale = refScale;
			AngledHeadersHeight = angledHeadersHeight;
			AngledHeadersSlope = angledHeadersSlope;
			OuterRect = outerRect;
			InnerRect = innerRect;
			WorkRect = workRect;
			InnerClipRect = innerClipRect;
			BgClipRect = bgClipRect;
			Bg0ClipRectForDrawCmd = bg0ClipRectForDrawCmd;
			Bg2ClipRectForDrawCmd = bg2ClipRectForDrawCmd;
			HostClipRect = hostClipRect;
			HostBackupInnerClipRect = hostBackupInnerClipRect;
			OuterWindow = outerWindow;
			InnerWindow = innerWindow;
			ColumnsNames = columnsNames;
			DrawSplitter = drawSplitter;
			InstanceDataFirst = instanceDataFirst;
			InstanceDataExtra = instanceDataExtra;
			SortSpecsSingle = sortSpecsSingle;
			SortSpecsMulti = sortSpecsMulti;
			SortSpecs = sortSpecs;
			SortSpecsCount = sortSpecsCount;
			ColumnsEnabledCount = columnsEnabledCount;
			ColumnsEnabledFixedCount = columnsEnabledFixedCount;
			DeclColumnsCount = declColumnsCount;
			AngledHeadersCount = angledHeadersCount;
			HoveredColumnBody = hoveredColumnBody;
			HoveredColumnBorder = hoveredColumnBorder;
			HighlightColumnHeader = highlightColumnHeader;
			AutoFitSingleColumn = autoFitSingleColumn;
			ResizedColumn = resizedColumn;
			LastResizedColumn = lastResizedColumn;
			HeldHeaderColumn = heldHeaderColumn;
			ReorderColumn = reorderColumn;
			ReorderColumnDir = reorderColumnDir;
			LeftMostEnabledColumn = leftMostEnabledColumn;
			RightMostEnabledColumn = rightMostEnabledColumn;
			LeftMostStretchedColumn = leftMostStretchedColumn;
			RightMostStretchedColumn = rightMostStretchedColumn;
			ContextPopupColumn = contextPopupColumn;
			FreezeRowsRequest = freezeRowsRequest;
			FreezeRowsCount = freezeRowsCount;
			FreezeColumnsRequest = freezeColumnsRequest;
			FreezeColumnsCount = freezeColumnsCount;
			RowCellDataCurrent = rowCellDataCurrent;
			DummyDrawChannel = dummyDrawChannel;
			Bg2DrawChannelCurrent = bg2DrawChannelCurrent;
			Bg2DrawChannelUnfrozen = bg2DrawChannelUnfrozen;
			IsLayoutLocked = isLayoutLocked ? (byte)1 : (byte)0;
			IsInsideRow = isInsideRow ? (byte)1 : (byte)0;
			IsInitializing = isInitializing ? (byte)1 : (byte)0;
			IsSortSpecsDirty = isSortSpecsDirty ? (byte)1 : (byte)0;
			IsUsingHeaders = isUsingHeaders ? (byte)1 : (byte)0;
			IsContextPopupOpen = isContextPopupOpen ? (byte)1 : (byte)0;
			IsSettingsRequestLoad = isSettingsRequestLoad ? (byte)1 : (byte)0;
			IsSettingsDirty = isSettingsDirty ? (byte)1 : (byte)0;
			IsDefaultDisplayOrder = isDefaultDisplayOrder ? (byte)1 : (byte)0;
			IsResetAllRequest = isResetAllRequest ? (byte)1 : (byte)0;
			IsResetDisplayOrderRequest = isResetDisplayOrderRequest ? (byte)1 : (byte)0;
			IsUnfrozenRows = isUnfrozenRows ? (byte)1 : (byte)0;
			IsDefaultSizingPolicy = isDefaultSizingPolicy ? (byte)1 : (byte)0;
			IsActiveIdAliveBeforeTable = isActiveIdAliveBeforeTable ? (byte)1 : (byte)0;
			IsActiveIdInTable = isActiveIdInTable ? (byte)1 : (byte)0;
			HasScrollbarYCurr = hasScrollbarYCurr ? (byte)1 : (byte)0;
			HasScrollbarYPrev = hasScrollbarYPrev ? (byte)1 : (byte)0;
			MemoryCompacted = memoryCompacted ? (byte)1 : (byte)0;
			HostSkipItems = hostSkipItems ? (byte)1 : (byte)0;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableTempData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int TableIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LastTimeActive;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float AngledheadersExtraWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 UserOuterSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImDrawListSplitter DrawSplitter;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostBackupWorkRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect HostBackupParentWorkRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 HostBackupPrevLineSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 HostBackupCurrLineSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 HostBackupCursorMaxPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec1 HostBackupColumnsOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float HostBackupItemWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int HostBackupItemWidthStackSize;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTableTempData(int tableIndex = default, float lastTimeActive = default, float angledheadersExtraWidth = default, Vector2 userOuterSize = default, ImDrawListSplitter drawSplitter = default, ImRect hostBackupWorkRect = default, ImRect hostBackupParentWorkRect = default, Vector2 hostBackupPrevLineSize = default, Vector2 hostBackupCurrLineSize = default, Vector2 hostBackupCursorMaxPos = default, ImVec1 hostBackupColumnsOffset = default, float hostBackupItemWidth = default, int hostBackupItemWidthStackSize = default)
		{
			TableIndex = tableIndex;
			LastTimeActive = lastTimeActive;
			AngledheadersExtraWidth = angledheadersExtraWidth;
			UserOuterSize = userOuterSize;
			DrawSplitter = drawSplitter;
			HostBackupWorkRect = hostBackupWorkRect;
			HostBackupParentWorkRect = hostBackupParentWorkRect;
			HostBackupPrevLineSize = hostBackupPrevLineSize;
			HostBackupCurrLineSize = hostBackupCurrLineSize;
			HostBackupCursorMaxPos = hostBackupCursorMaxPos;
			HostBackupColumnsOffset = hostBackupColumnsOffset;
			HostBackupItemWidth = hostBackupItemWidth;
			HostBackupItemWidthStackSize = hostBackupItemWidthStackSize;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableColumn
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableColumn* Data;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableColumn* DataEnd;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImSpanImGuiTableColumn(ImGuiTableColumn* data = default, ImGuiTableColumn* dataEnd = default)
		{
			Data = data;
			DataEnd = dataEnd;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumn
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WidthGiven;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MinX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float MaxX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WidthRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WidthAuto;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float StretchWeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float InitStretchWeightOrWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect ClipRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint UserID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WorkMinX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float WorkMaxX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ItemWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ContentMaxXFrozen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ContentMaxXUnfrozen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ContentMaxXHeadersUsed;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ContentMaxXHeadersIdeal;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short NameOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte DisplayOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte IndexWithinEnabledSet;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte PrevEnabledColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte NextEnabledColumn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte SortOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DrawChannelCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DrawChannelFrozen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte DrawChannelUnfrozen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsEnabled;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsUserEnabled;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsUserEnabledNextFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsVisibleX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsVisibleY;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsRequestOutput;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsSkipItems;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsPreserveWidthAuto;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte NavLayerCurrent;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte AutoFitQueue;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CannotSkipItemsQueue;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SortDirection;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SortDirectionsAvailCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SortDirectionsAvailMask;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SortDirectionsAvailList;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTableColumn(int flags = default, float widthGiven = default, float minX = default, float maxX = default, float widthRequest = default, float widthAuto = default, float stretchWeight = default, float initStretchWeightOrWidth = default, ImRect clipRect = default, uint userId = default, float workMinX = default, float workMaxX = default, float itemWidth = default, float contentMaxXFrozen = default, float contentMaxXUnfrozen = default, float contentMaxXHeadersUsed = default, float contentMaxXHeadersIdeal = default, short nameOffset = default, sbyte displayOrder = default, sbyte indexWithinEnabledSet = default, sbyte prevEnabledColumn = default, sbyte nextEnabledColumn = default, sbyte sortOrder = default, byte drawChannelCurrent = default, byte drawChannelFrozen = default, byte drawChannelUnfrozen = default, bool isEnabled = default, bool isUserEnabled = default, bool isUserEnabledNextFrame = default, bool isVisibleX = default, bool isVisibleY = default, bool isRequestOutput = default, bool isSkipItems = default, bool isPreserveWidthAuto = default, byte navLayerCurrent = default, byte autoFitQueue = default, byte cannotSkipItemsQueue = default, byte sortDirection = default, byte sortDirectionsAvailCount = default, byte sortDirectionsAvailMask = default, byte sortDirectionsAvailList = default)
		{
			Flags = flags;
			WidthGiven = widthGiven;
			MinX = minX;
			MaxX = maxX;
			WidthRequest = widthRequest;
			WidthAuto = widthAuto;
			StretchWeight = stretchWeight;
			InitStretchWeightOrWidth = initStretchWeightOrWidth;
			ClipRect = clipRect;
			UserID = userId;
			WorkMinX = workMinX;
			WorkMaxX = workMaxX;
			ItemWidth = itemWidth;
			ContentMaxXFrozen = contentMaxXFrozen;
			ContentMaxXUnfrozen = contentMaxXUnfrozen;
			ContentMaxXHeadersUsed = contentMaxXHeadersUsed;
			ContentMaxXHeadersIdeal = contentMaxXHeadersIdeal;
			NameOffset = nameOffset;
			DisplayOrder = displayOrder;
			IndexWithinEnabledSet = indexWithinEnabledSet;
			PrevEnabledColumn = prevEnabledColumn;
			NextEnabledColumn = nextEnabledColumn;
			SortOrder = sortOrder;
			DrawChannelCurrent = drawChannelCurrent;
			DrawChannelFrozen = drawChannelFrozen;
			DrawChannelUnfrozen = drawChannelUnfrozen;
			IsEnabled = isEnabled ? (byte)1 : (byte)0;
			IsUserEnabled = isUserEnabled ? (byte)1 : (byte)0;
			IsUserEnabledNextFrame = isUserEnabledNextFrame ? (byte)1 : (byte)0;
			IsVisibleX = isVisibleX ? (byte)1 : (byte)0;
			IsVisibleY = isVisibleY ? (byte)1 : (byte)0;
			IsRequestOutput = isRequestOutput ? (byte)1 : (byte)0;
			IsSkipItems = isSkipItems ? (byte)1 : (byte)0;
			IsPreserveWidthAuto = isPreserveWidthAuto ? (byte)1 : (byte)0;
			NavLayerCurrent = navLayerCurrent;
			AutoFitQueue = autoFitQueue;
			CannotSkipItemsQueue = cannotSkipItemsQueue;
			SortDirection = sortDirection;
			SortDirectionsAvailCount = sortDirectionsAvailCount;
			SortDirectionsAvailMask = sortDirectionsAvailMask;
			SortDirectionsAvailList = sortDirectionsAvailList;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableColumnIdx
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe sbyte* Data;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe sbyte* DataEnd;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImSpanImGuiTableColumnIdx(sbyte* data = default, sbyte* dataEnd = default)
		{
			Data = data;
			DataEnd = dataEnd;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImSpanImGuiTableCellData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableCellData* Data;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableCellData* DataEnd;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImSpanImGuiTableCellData(ImGuiTableCellData* data = default, ImGuiTableCellData* dataEnd = default)
		{
			Data = data;
			DataEnd = dataEnd;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableCellData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint BgColor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte Column;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTableCellData(uint bgColor = default, sbyte column = default)
		{
			BgColor = bgColor;
			Column = column;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableInstanceData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint TableInstanceID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LastOuterHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LastTopHeadersRowHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LastFrozenHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int HoveredRowLast;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int HoveredRowNext;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTableInstanceData(uint tableInstanceId = default, float lastOuterHeight = default, float lastTopHeadersRowHeight = default, float lastFrozenHeight = default, int hoveredRowLast = default, int hoveredRowNext = default)
		{
			TableInstanceID = tableInstanceId;
			LastOuterHeight = lastOuterHeight;
			LastTopHeadersRowHeight = lastTopHeadersRowHeight;
			LastFrozenHeight = lastFrozenHeight;
			HoveredRowLast = hoveredRowLast;
			HoveredRowNext = hoveredRowNext;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableInstanceData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableInstanceData* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiTableInstanceData(int size = default, int capacity = default, ImGuiTableInstanceData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnSortSpecs
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ColumnUserID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short ColumnIndex;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short SortOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SortDirection;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTableColumnSortSpecs(uint columnUserId = default, short columnIndex = default, short sortOrder = default, int sortDirection = default)
		{
			ColumnUserID = columnUserId;
			ColumnIndex = columnIndex;
			SortOrder = sortOrder;
			SortDirection = sortDirection;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiTableColumnSortSpecs* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableColumnSortSpecs
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableColumnSortSpecs* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiTableColumnSortSpecs(int size = default, int capacity = default, ImGuiTableColumnSortSpecs* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableSortSpecs
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableColumnSortSpecs* Specs;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SpecsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SpecsDirty;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTableSortSpecs(ImGuiTableColumnSortSpecs* specs = default, int specsCount = default, bool specsDirty = default)
		{
			Specs = specs;
			SpecsCount = specsCount;
			SpecsDirty = specsDirty ? (byte)1 : (byte)0;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiTableSortSpecs* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTableTempData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTableTempData* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiTableTempData(int size = default, int capacity = default, ImGuiTableTempData* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImGuiTable
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTable Buf;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStorage Map;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FreeIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int AliveCount;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImPoolImGuiTable(ImVectorImGuiTable buf = default, ImGuiStorage map = default, int freeIdx = default, int aliveCount = default)
		{
			Buf = buf;
			Map = map;
			FreeIdx = freeIdx;
			AliveCount = aliveCount;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTable
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTable* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiTable(int size = default, int capacity = default, ImGuiTable* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImPoolImGuiTabBar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTabBar Buf;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStorage Map;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int FreeIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int AliveCount;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImPoolImGuiTabBar(ImVectorImGuiTabBar buf = default, ImGuiStorage map = default, int freeIdx = default, int aliveCount = default)
		{
			Buf = buf;
			Map = map;
			FreeIdx = freeIdx;
			AliveCount = aliveCount;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTabBar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTabBar* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiTabBar(int size = default, int capacity = default, ImGuiTabBar* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiPtrOrIndex
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiPtrOrIndex* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiPtrOrIndex(int size = default, int capacity = default, ImGuiPtrOrIndex* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiPtrOrIndex
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* Ptr;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Index;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiPtrOrIndex(void* ptr = default, int index = default)
		{
			Ptr = ptr;
			Index = index;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiShrinkWidthItem
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiShrinkWidthItem* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiShrinkWidthItem(int size = default, int capacity = default, ImGuiShrinkWidthItem* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiShrinkWidthItem
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Index;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Width;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float InitialWidth;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiShrinkWidthItem(int index = default, float width = default, float initialWidth = default)
		{
			Index = index;
			Width = width;
			InitialWidth = initialWidth;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextState
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurLenW;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CurLenA;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImWchar TextW;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorChar TextA;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorChar InitialTextA;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte TextAIsValid;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BufCapacityA;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float ScrollX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public STBTexteditState Stb;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CursorAnim;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CursorFollow;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SelectedAllMouseLock;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Edited;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputTextState(ImGuiContext* ctx = default, uint id = default, int curLenW = default, int curLenA = default, ImVectorImWchar textW = default, ImVectorChar textA = default, ImVectorChar initialTextA = default, bool textAIsValid = default, int bufCapacityA = default, float scrollX = default, STBTexteditState stb = default, float cursorAnim = default, bool cursorFollow = default, bool selectedAllMouseLock = default, bool edited = default, int flags = default)
		{
			Ctx = ctx;
			ID = id;
			CurLenW = curLenW;
			CurLenA = curLenA;
			TextW = textW;
			TextA = textA;
			InitialTextA = initialTextA;
			TextAIsValid = textAIsValid ? (byte)1 : (byte)0;
			BufCapacityA = bufCapacityA;
			ScrollX = scrollX;
			Stb = stb;
			CursorAnim = cursorAnim;
			CursorFollow = cursorFollow ? (byte)1 : (byte)0;
			SelectedAllMouseLock = selectedAllMouseLock ? (byte)1 : (byte)0;
			Edited = edited ? (byte)1 : (byte)0;
			Flags = flags;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct STBTexteditState
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Cursor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SelectStart;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SelectEnd;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte InsertMode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int RowCountPerPage;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CursorAtEndOfLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Initialized;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte HasPreferredX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SingleLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Padding1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Padding2;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Padding3;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float PreferredX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public StbUndoState Undostate;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe STBTexteditState(int cursor = default, int selectStart = default, int selectEnd = default, byte insertMode = default, int rowCountPerPage = default, byte cursorAtEndOfLine = default, byte initialized = default, byte hasPreferredX = default, byte singleLine = default, byte padding1 = default, byte padding2 = default, byte padding3 = default, float preferredX = default, StbUndoState undostate = default)
		{
			Cursor = cursor;
			SelectStart = selectStart;
			SelectEnd = selectEnd;
			InsertMode = insertMode;
			RowCountPerPage = rowCountPerPage;
			CursorAtEndOfLine = cursorAtEndOfLine;
			Initialized = initialized;
			HasPreferredX = hasPreferredX;
			SingleLine = singleLine;
			Padding1 = padding1;
			Padding2 = padding2;
			Padding3 = padding3;
			PreferredX = preferredX;
			Undostate = undostate;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbUndoState
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public StbUndoRecord UndoRec_0;
		public StbUndoRecord UndoRec_1;
		public StbUndoRecord UndoRec_2;
		public StbUndoRecord UndoRec_3;
		public StbUndoRecord UndoRec_4;
		public StbUndoRecord UndoRec_5;
		public StbUndoRecord UndoRec_6;
		public StbUndoRecord UndoRec_7;
		public StbUndoRecord UndoRec_8;
		public StbUndoRecord UndoRec_9;
		public StbUndoRecord UndoRec_10;
		public StbUndoRecord UndoRec_11;
		public StbUndoRecord UndoRec_12;
		public StbUndoRecord UndoRec_13;
		public StbUndoRecord UndoRec_14;
		public StbUndoRecord UndoRec_15;
		public StbUndoRecord UndoRec_16;
		public StbUndoRecord UndoRec_17;
		public StbUndoRecord UndoRec_18;
		public StbUndoRecord UndoRec_19;
		public StbUndoRecord UndoRec_20;
		public StbUndoRecord UndoRec_21;
		public StbUndoRecord UndoRec_22;
		public StbUndoRecord UndoRec_23;
		public StbUndoRecord UndoRec_24;
		public StbUndoRecord UndoRec_25;
		public StbUndoRecord UndoRec_26;
		public StbUndoRecord UndoRec_27;
		public StbUndoRecord UndoRec_28;
		public StbUndoRecord UndoRec_29;
		public StbUndoRecord UndoRec_30;
		public StbUndoRecord UndoRec_31;
		public StbUndoRecord UndoRec_32;
		public StbUndoRecord UndoRec_33;
		public StbUndoRecord UndoRec_34;
		public StbUndoRecord UndoRec_35;
		public StbUndoRecord UndoRec_36;
		public StbUndoRecord UndoRec_37;
		public StbUndoRecord UndoRec_38;
		public StbUndoRecord UndoRec_39;
		public StbUndoRecord UndoRec_40;
		public StbUndoRecord UndoRec_41;
		public StbUndoRecord UndoRec_42;
		public StbUndoRecord UndoRec_43;
		public StbUndoRecord UndoRec_44;
		public StbUndoRecord UndoRec_45;
		public StbUndoRecord UndoRec_46;
		public StbUndoRecord UndoRec_47;
		public StbUndoRecord UndoRec_48;
		public StbUndoRecord UndoRec_49;
		public StbUndoRecord UndoRec_50;
		public StbUndoRecord UndoRec_51;
		public StbUndoRecord UndoRec_52;
		public StbUndoRecord UndoRec_53;
		public StbUndoRecord UndoRec_54;
		public StbUndoRecord UndoRec_55;
		public StbUndoRecord UndoRec_56;
		public StbUndoRecord UndoRec_57;
		public StbUndoRecord UndoRec_58;
		public StbUndoRecord UndoRec_59;
		public StbUndoRecord UndoRec_60;
		public StbUndoRecord UndoRec_61;
		public StbUndoRecord UndoRec_62;
		public StbUndoRecord UndoRec_63;
		public StbUndoRecord UndoRec_64;
		public StbUndoRecord UndoRec_65;
		public StbUndoRecord UndoRec_66;
		public StbUndoRecord UndoRec_67;
		public StbUndoRecord UndoRec_68;
		public StbUndoRecord UndoRec_69;
		public StbUndoRecord UndoRec_70;
		public StbUndoRecord UndoRec_71;
		public StbUndoRecord UndoRec_72;
		public StbUndoRecord UndoRec_73;
		public StbUndoRecord UndoRec_74;
		public StbUndoRecord UndoRec_75;
		public StbUndoRecord UndoRec_76;
		public StbUndoRecord UndoRec_77;
		public StbUndoRecord UndoRec_78;
		public StbUndoRecord UndoRec_79;
		public StbUndoRecord UndoRec_80;
		public StbUndoRecord UndoRec_81;
		public StbUndoRecord UndoRec_82;
		public StbUndoRecord UndoRec_83;
		public StbUndoRecord UndoRec_84;
		public StbUndoRecord UndoRec_85;
		public StbUndoRecord UndoRec_86;
		public StbUndoRecord UndoRec_87;
		public StbUndoRecord UndoRec_88;
		public StbUndoRecord UndoRec_89;
		public StbUndoRecord UndoRec_90;
		public StbUndoRecord UndoRec_91;
		public StbUndoRecord UndoRec_92;
		public StbUndoRecord UndoRec_93;
		public StbUndoRecord UndoRec_94;
		public StbUndoRecord UndoRec_95;
		public StbUndoRecord UndoRec_96;
		public StbUndoRecord UndoRec_97;
		public StbUndoRecord UndoRec_98;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort UndoChar_0;
		public ushort UndoChar_1;
		public ushort UndoChar_2;
		public ushort UndoChar_3;
		public ushort UndoChar_4;
		public ushort UndoChar_5;
		public ushort UndoChar_6;
		public ushort UndoChar_7;
		public ushort UndoChar_8;
		public ushort UndoChar_9;
		public ushort UndoChar_10;
		public ushort UndoChar_11;
		public ushort UndoChar_12;
		public ushort UndoChar_13;
		public ushort UndoChar_14;
		public ushort UndoChar_15;
		public ushort UndoChar_16;
		public ushort UndoChar_17;
		public ushort UndoChar_18;
		public ushort UndoChar_19;
		public ushort UndoChar_20;
		public ushort UndoChar_21;
		public ushort UndoChar_22;
		public ushort UndoChar_23;
		public ushort UndoChar_24;
		public ushort UndoChar_25;
		public ushort UndoChar_26;
		public ushort UndoChar_27;
		public ushort UndoChar_28;
		public ushort UndoChar_29;
		public ushort UndoChar_30;
		public ushort UndoChar_31;
		public ushort UndoChar_32;
		public ushort UndoChar_33;
		public ushort UndoChar_34;
		public ushort UndoChar_35;
		public ushort UndoChar_36;
		public ushort UndoChar_37;
		public ushort UndoChar_38;
		public ushort UndoChar_39;
		public ushort UndoChar_40;
		public ushort UndoChar_41;
		public ushort UndoChar_42;
		public ushort UndoChar_43;
		public ushort UndoChar_44;
		public ushort UndoChar_45;
		public ushort UndoChar_46;
		public ushort UndoChar_47;
		public ushort UndoChar_48;
		public ushort UndoChar_49;
		public ushort UndoChar_50;
		public ushort UndoChar_51;
		public ushort UndoChar_52;
		public ushort UndoChar_53;
		public ushort UndoChar_54;
		public ushort UndoChar_55;
		public ushort UndoChar_56;
		public ushort UndoChar_57;
		public ushort UndoChar_58;
		public ushort UndoChar_59;
		public ushort UndoChar_60;
		public ushort UndoChar_61;
		public ushort UndoChar_62;
		public ushort UndoChar_63;
		public ushort UndoChar_64;
		public ushort UndoChar_65;
		public ushort UndoChar_66;
		public ushort UndoChar_67;
		public ushort UndoChar_68;
		public ushort UndoChar_69;
		public ushort UndoChar_70;
		public ushort UndoChar_71;
		public ushort UndoChar_72;
		public ushort UndoChar_73;
		public ushort UndoChar_74;
		public ushort UndoChar_75;
		public ushort UndoChar_76;
		public ushort UndoChar_77;
		public ushort UndoChar_78;
		public ushort UndoChar_79;
		public ushort UndoChar_80;
		public ushort UndoChar_81;
		public ushort UndoChar_82;
		public ushort UndoChar_83;
		public ushort UndoChar_84;
		public ushort UndoChar_85;
		public ushort UndoChar_86;
		public ushort UndoChar_87;
		public ushort UndoChar_88;
		public ushort UndoChar_89;
		public ushort UndoChar_90;
		public ushort UndoChar_91;
		public ushort UndoChar_92;
		public ushort UndoChar_93;
		public ushort UndoChar_94;
		public ushort UndoChar_95;
		public ushort UndoChar_96;
		public ushort UndoChar_97;
		public ushort UndoChar_98;
		public ushort UndoChar_99;
		public ushort UndoChar_100;
		public ushort UndoChar_101;
		public ushort UndoChar_102;
		public ushort UndoChar_103;
		public ushort UndoChar_104;
		public ushort UndoChar_105;
		public ushort UndoChar_106;
		public ushort UndoChar_107;
		public ushort UndoChar_108;
		public ushort UndoChar_109;
		public ushort UndoChar_110;
		public ushort UndoChar_111;
		public ushort UndoChar_112;
		public ushort UndoChar_113;
		public ushort UndoChar_114;
		public ushort UndoChar_115;
		public ushort UndoChar_116;
		public ushort UndoChar_117;
		public ushort UndoChar_118;
		public ushort UndoChar_119;
		public ushort UndoChar_120;
		public ushort UndoChar_121;
		public ushort UndoChar_122;
		public ushort UndoChar_123;
		public ushort UndoChar_124;
		public ushort UndoChar_125;
		public ushort UndoChar_126;
		public ushort UndoChar_127;
		public ushort UndoChar_128;
		public ushort UndoChar_129;
		public ushort UndoChar_130;
		public ushort UndoChar_131;
		public ushort UndoChar_132;
		public ushort UndoChar_133;
		public ushort UndoChar_134;
		public ushort UndoChar_135;
		public ushort UndoChar_136;
		public ushort UndoChar_137;
		public ushort UndoChar_138;
		public ushort UndoChar_139;
		public ushort UndoChar_140;
		public ushort UndoChar_141;
		public ushort UndoChar_142;
		public ushort UndoChar_143;
		public ushort UndoChar_144;
		public ushort UndoChar_145;
		public ushort UndoChar_146;
		public ushort UndoChar_147;
		public ushort UndoChar_148;
		public ushort UndoChar_149;
		public ushort UndoChar_150;
		public ushort UndoChar_151;
		public ushort UndoChar_152;
		public ushort UndoChar_153;
		public ushort UndoChar_154;
		public ushort UndoChar_155;
		public ushort UndoChar_156;
		public ushort UndoChar_157;
		public ushort UndoChar_158;
		public ushort UndoChar_159;
		public ushort UndoChar_160;
		public ushort UndoChar_161;
		public ushort UndoChar_162;
		public ushort UndoChar_163;
		public ushort UndoChar_164;
		public ushort UndoChar_165;
		public ushort UndoChar_166;
		public ushort UndoChar_167;
		public ushort UndoChar_168;
		public ushort UndoChar_169;
		public ushort UndoChar_170;
		public ushort UndoChar_171;
		public ushort UndoChar_172;
		public ushort UndoChar_173;
		public ushort UndoChar_174;
		public ushort UndoChar_175;
		public ushort UndoChar_176;
		public ushort UndoChar_177;
		public ushort UndoChar_178;
		public ushort UndoChar_179;
		public ushort UndoChar_180;
		public ushort UndoChar_181;
		public ushort UndoChar_182;
		public ushort UndoChar_183;
		public ushort UndoChar_184;
		public ushort UndoChar_185;
		public ushort UndoChar_186;
		public ushort UndoChar_187;
		public ushort UndoChar_188;
		public ushort UndoChar_189;
		public ushort UndoChar_190;
		public ushort UndoChar_191;
		public ushort UndoChar_192;
		public ushort UndoChar_193;
		public ushort UndoChar_194;
		public ushort UndoChar_195;
		public ushort UndoChar_196;
		public ushort UndoChar_197;
		public ushort UndoChar_198;
		public ushort UndoChar_199;
		public ushort UndoChar_200;
		public ushort UndoChar_201;
		public ushort UndoChar_202;
		public ushort UndoChar_203;
		public ushort UndoChar_204;
		public ushort UndoChar_205;
		public ushort UndoChar_206;
		public ushort UndoChar_207;
		public ushort UndoChar_208;
		public ushort UndoChar_209;
		public ushort UndoChar_210;
		public ushort UndoChar_211;
		public ushort UndoChar_212;
		public ushort UndoChar_213;
		public ushort UndoChar_214;
		public ushort UndoChar_215;
		public ushort UndoChar_216;
		public ushort UndoChar_217;
		public ushort UndoChar_218;
		public ushort UndoChar_219;
		public ushort UndoChar_220;
		public ushort UndoChar_221;
		public ushort UndoChar_222;
		public ushort UndoChar_223;
		public ushort UndoChar_224;
		public ushort UndoChar_225;
		public ushort UndoChar_226;
		public ushort UndoChar_227;
		public ushort UndoChar_228;
		public ushort UndoChar_229;
		public ushort UndoChar_230;
		public ushort UndoChar_231;
		public ushort UndoChar_232;
		public ushort UndoChar_233;
		public ushort UndoChar_234;
		public ushort UndoChar_235;
		public ushort UndoChar_236;
		public ushort UndoChar_237;
		public ushort UndoChar_238;
		public ushort UndoChar_239;
		public ushort UndoChar_240;
		public ushort UndoChar_241;
		public ushort UndoChar_242;
		public ushort UndoChar_243;
		public ushort UndoChar_244;
		public ushort UndoChar_245;
		public ushort UndoChar_246;
		public ushort UndoChar_247;
		public ushort UndoChar_248;
		public ushort UndoChar_249;
		public ushort UndoChar_250;
		public ushort UndoChar_251;
		public ushort UndoChar_252;
		public ushort UndoChar_253;
		public ushort UndoChar_254;
		public ushort UndoChar_255;
		public ushort UndoChar_256;
		public ushort UndoChar_257;
		public ushort UndoChar_258;
		public ushort UndoChar_259;
		public ushort UndoChar_260;
		public ushort UndoChar_261;
		public ushort UndoChar_262;
		public ushort UndoChar_263;
		public ushort UndoChar_264;
		public ushort UndoChar_265;
		public ushort UndoChar_266;
		public ushort UndoChar_267;
		public ushort UndoChar_268;
		public ushort UndoChar_269;
		public ushort UndoChar_270;
		public ushort UndoChar_271;
		public ushort UndoChar_272;
		public ushort UndoChar_273;
		public ushort UndoChar_274;
		public ushort UndoChar_275;
		public ushort UndoChar_276;
		public ushort UndoChar_277;
		public ushort UndoChar_278;
		public ushort UndoChar_279;
		public ushort UndoChar_280;
		public ushort UndoChar_281;
		public ushort UndoChar_282;
		public ushort UndoChar_283;
		public ushort UndoChar_284;
		public ushort UndoChar_285;
		public ushort UndoChar_286;
		public ushort UndoChar_287;
		public ushort UndoChar_288;
		public ushort UndoChar_289;
		public ushort UndoChar_290;
		public ushort UndoChar_291;
		public ushort UndoChar_292;
		public ushort UndoChar_293;
		public ushort UndoChar_294;
		public ushort UndoChar_295;
		public ushort UndoChar_296;
		public ushort UndoChar_297;
		public ushort UndoChar_298;
		public ushort UndoChar_299;
		public ushort UndoChar_300;
		public ushort UndoChar_301;
		public ushort UndoChar_302;
		public ushort UndoChar_303;
		public ushort UndoChar_304;
		public ushort UndoChar_305;
		public ushort UndoChar_306;
		public ushort UndoChar_307;
		public ushort UndoChar_308;
		public ushort UndoChar_309;
		public ushort UndoChar_310;
		public ushort UndoChar_311;
		public ushort UndoChar_312;
		public ushort UndoChar_313;
		public ushort UndoChar_314;
		public ushort UndoChar_315;
		public ushort UndoChar_316;
		public ushort UndoChar_317;
		public ushort UndoChar_318;
		public ushort UndoChar_319;
		public ushort UndoChar_320;
		public ushort UndoChar_321;
		public ushort UndoChar_322;
		public ushort UndoChar_323;
		public ushort UndoChar_324;
		public ushort UndoChar_325;
		public ushort UndoChar_326;
		public ushort UndoChar_327;
		public ushort UndoChar_328;
		public ushort UndoChar_329;
		public ushort UndoChar_330;
		public ushort UndoChar_331;
		public ushort UndoChar_332;
		public ushort UndoChar_333;
		public ushort UndoChar_334;
		public ushort UndoChar_335;
		public ushort UndoChar_336;
		public ushort UndoChar_337;
		public ushort UndoChar_338;
		public ushort UndoChar_339;
		public ushort UndoChar_340;
		public ushort UndoChar_341;
		public ushort UndoChar_342;
		public ushort UndoChar_343;
		public ushort UndoChar_344;
		public ushort UndoChar_345;
		public ushort UndoChar_346;
		public ushort UndoChar_347;
		public ushort UndoChar_348;
		public ushort UndoChar_349;
		public ushort UndoChar_350;
		public ushort UndoChar_351;
		public ushort UndoChar_352;
		public ushort UndoChar_353;
		public ushort UndoChar_354;
		public ushort UndoChar_355;
		public ushort UndoChar_356;
		public ushort UndoChar_357;
		public ushort UndoChar_358;
		public ushort UndoChar_359;
		public ushort UndoChar_360;
		public ushort UndoChar_361;
		public ushort UndoChar_362;
		public ushort UndoChar_363;
		public ushort UndoChar_364;
		public ushort UndoChar_365;
		public ushort UndoChar_366;
		public ushort UndoChar_367;
		public ushort UndoChar_368;
		public ushort UndoChar_369;
		public ushort UndoChar_370;
		public ushort UndoChar_371;
		public ushort UndoChar_372;
		public ushort UndoChar_373;
		public ushort UndoChar_374;
		public ushort UndoChar_375;
		public ushort UndoChar_376;
		public ushort UndoChar_377;
		public ushort UndoChar_378;
		public ushort UndoChar_379;
		public ushort UndoChar_380;
		public ushort UndoChar_381;
		public ushort UndoChar_382;
		public ushort UndoChar_383;
		public ushort UndoChar_384;
		public ushort UndoChar_385;
		public ushort UndoChar_386;
		public ushort UndoChar_387;
		public ushort UndoChar_388;
		public ushort UndoChar_389;
		public ushort UndoChar_390;
		public ushort UndoChar_391;
		public ushort UndoChar_392;
		public ushort UndoChar_393;
		public ushort UndoChar_394;
		public ushort UndoChar_395;
		public ushort UndoChar_396;
		public ushort UndoChar_397;
		public ushort UndoChar_398;
		public ushort UndoChar_399;
		public ushort UndoChar_400;
		public ushort UndoChar_401;
		public ushort UndoChar_402;
		public ushort UndoChar_403;
		public ushort UndoChar_404;
		public ushort UndoChar_405;
		public ushort UndoChar_406;
		public ushort UndoChar_407;
		public ushort UndoChar_408;
		public ushort UndoChar_409;
		public ushort UndoChar_410;
		public ushort UndoChar_411;
		public ushort UndoChar_412;
		public ushort UndoChar_413;
		public ushort UndoChar_414;
		public ushort UndoChar_415;
		public ushort UndoChar_416;
		public ushort UndoChar_417;
		public ushort UndoChar_418;
		public ushort UndoChar_419;
		public ushort UndoChar_420;
		public ushort UndoChar_421;
		public ushort UndoChar_422;
		public ushort UndoChar_423;
		public ushort UndoChar_424;
		public ushort UndoChar_425;
		public ushort UndoChar_426;
		public ushort UndoChar_427;
		public ushort UndoChar_428;
		public ushort UndoChar_429;
		public ushort UndoChar_430;
		public ushort UndoChar_431;
		public ushort UndoChar_432;
		public ushort UndoChar_433;
		public ushort UndoChar_434;
		public ushort UndoChar_435;
		public ushort UndoChar_436;
		public ushort UndoChar_437;
		public ushort UndoChar_438;
		public ushort UndoChar_439;
		public ushort UndoChar_440;
		public ushort UndoChar_441;
		public ushort UndoChar_442;
		public ushort UndoChar_443;
		public ushort UndoChar_444;
		public ushort UndoChar_445;
		public ushort UndoChar_446;
		public ushort UndoChar_447;
		public ushort UndoChar_448;
		public ushort UndoChar_449;
		public ushort UndoChar_450;
		public ushort UndoChar_451;
		public ushort UndoChar_452;
		public ushort UndoChar_453;
		public ushort UndoChar_454;
		public ushort UndoChar_455;
		public ushort UndoChar_456;
		public ushort UndoChar_457;
		public ushort UndoChar_458;
		public ushort UndoChar_459;
		public ushort UndoChar_460;
		public ushort UndoChar_461;
		public ushort UndoChar_462;
		public ushort UndoChar_463;
		public ushort UndoChar_464;
		public ushort UndoChar_465;
		public ushort UndoChar_466;
		public ushort UndoChar_467;
		public ushort UndoChar_468;
		public ushort UndoChar_469;
		public ushort UndoChar_470;
		public ushort UndoChar_471;
		public ushort UndoChar_472;
		public ushort UndoChar_473;
		public ushort UndoChar_474;
		public ushort UndoChar_475;
		public ushort UndoChar_476;
		public ushort UndoChar_477;
		public ushort UndoChar_478;
		public ushort UndoChar_479;
		public ushort UndoChar_480;
		public ushort UndoChar_481;
		public ushort UndoChar_482;
		public ushort UndoChar_483;
		public ushort UndoChar_484;
		public ushort UndoChar_485;
		public ushort UndoChar_486;
		public ushort UndoChar_487;
		public ushort UndoChar_488;
		public ushort UndoChar_489;
		public ushort UndoChar_490;
		public ushort UndoChar_491;
		public ushort UndoChar_492;
		public ushort UndoChar_493;
		public ushort UndoChar_494;
		public ushort UndoChar_495;
		public ushort UndoChar_496;
		public ushort UndoChar_497;
		public ushort UndoChar_498;
		public ushort UndoChar_499;
		public ushort UndoChar_500;
		public ushort UndoChar_501;
		public ushort UndoChar_502;
		public ushort UndoChar_503;
		public ushort UndoChar_504;
		public ushort UndoChar_505;
		public ushort UndoChar_506;
		public ushort UndoChar_507;
		public ushort UndoChar_508;
		public ushort UndoChar_509;
		public ushort UndoChar_510;
		public ushort UndoChar_511;
		public ushort UndoChar_512;
		public ushort UndoChar_513;
		public ushort UndoChar_514;
		public ushort UndoChar_515;
		public ushort UndoChar_516;
		public ushort UndoChar_517;
		public ushort UndoChar_518;
		public ushort UndoChar_519;
		public ushort UndoChar_520;
		public ushort UndoChar_521;
		public ushort UndoChar_522;
		public ushort UndoChar_523;
		public ushort UndoChar_524;
		public ushort UndoChar_525;
		public ushort UndoChar_526;
		public ushort UndoChar_527;
		public ushort UndoChar_528;
		public ushort UndoChar_529;
		public ushort UndoChar_530;
		public ushort UndoChar_531;
		public ushort UndoChar_532;
		public ushort UndoChar_533;
		public ushort UndoChar_534;
		public ushort UndoChar_535;
		public ushort UndoChar_536;
		public ushort UndoChar_537;
		public ushort UndoChar_538;
		public ushort UndoChar_539;
		public ushort UndoChar_540;
		public ushort UndoChar_541;
		public ushort UndoChar_542;
		public ushort UndoChar_543;
		public ushort UndoChar_544;
		public ushort UndoChar_545;
		public ushort UndoChar_546;
		public ushort UndoChar_547;
		public ushort UndoChar_548;
		public ushort UndoChar_549;
		public ushort UndoChar_550;
		public ushort UndoChar_551;
		public ushort UndoChar_552;
		public ushort UndoChar_553;
		public ushort UndoChar_554;
		public ushort UndoChar_555;
		public ushort UndoChar_556;
		public ushort UndoChar_557;
		public ushort UndoChar_558;
		public ushort UndoChar_559;
		public ushort UndoChar_560;
		public ushort UndoChar_561;
		public ushort UndoChar_562;
		public ushort UndoChar_563;
		public ushort UndoChar_564;
		public ushort UndoChar_565;
		public ushort UndoChar_566;
		public ushort UndoChar_567;
		public ushort UndoChar_568;
		public ushort UndoChar_569;
		public ushort UndoChar_570;
		public ushort UndoChar_571;
		public ushort UndoChar_572;
		public ushort UndoChar_573;
		public ushort UndoChar_574;
		public ushort UndoChar_575;
		public ushort UndoChar_576;
		public ushort UndoChar_577;
		public ushort UndoChar_578;
		public ushort UndoChar_579;
		public ushort UndoChar_580;
		public ushort UndoChar_581;
		public ushort UndoChar_582;
		public ushort UndoChar_583;
		public ushort UndoChar_584;
		public ushort UndoChar_585;
		public ushort UndoChar_586;
		public ushort UndoChar_587;
		public ushort UndoChar_588;
		public ushort UndoChar_589;
		public ushort UndoChar_590;
		public ushort UndoChar_591;
		public ushort UndoChar_592;
		public ushort UndoChar_593;
		public ushort UndoChar_594;
		public ushort UndoChar_595;
		public ushort UndoChar_596;
		public ushort UndoChar_597;
		public ushort UndoChar_598;
		public ushort UndoChar_599;
		public ushort UndoChar_600;
		public ushort UndoChar_601;
		public ushort UndoChar_602;
		public ushort UndoChar_603;
		public ushort UndoChar_604;
		public ushort UndoChar_605;
		public ushort UndoChar_606;
		public ushort UndoChar_607;
		public ushort UndoChar_608;
		public ushort UndoChar_609;
		public ushort UndoChar_610;
		public ushort UndoChar_611;
		public ushort UndoChar_612;
		public ushort UndoChar_613;
		public ushort UndoChar_614;
		public ushort UndoChar_615;
		public ushort UndoChar_616;
		public ushort UndoChar_617;
		public ushort UndoChar_618;
		public ushort UndoChar_619;
		public ushort UndoChar_620;
		public ushort UndoChar_621;
		public ushort UndoChar_622;
		public ushort UndoChar_623;
		public ushort UndoChar_624;
		public ushort UndoChar_625;
		public ushort UndoChar_626;
		public ushort UndoChar_627;
		public ushort UndoChar_628;
		public ushort UndoChar_629;
		public ushort UndoChar_630;
		public ushort UndoChar_631;
		public ushort UndoChar_632;
		public ushort UndoChar_633;
		public ushort UndoChar_634;
		public ushort UndoChar_635;
		public ushort UndoChar_636;
		public ushort UndoChar_637;
		public ushort UndoChar_638;
		public ushort UndoChar_639;
		public ushort UndoChar_640;
		public ushort UndoChar_641;
		public ushort UndoChar_642;
		public ushort UndoChar_643;
		public ushort UndoChar_644;
		public ushort UndoChar_645;
		public ushort UndoChar_646;
		public ushort UndoChar_647;
		public ushort UndoChar_648;
		public ushort UndoChar_649;
		public ushort UndoChar_650;
		public ushort UndoChar_651;
		public ushort UndoChar_652;
		public ushort UndoChar_653;
		public ushort UndoChar_654;
		public ushort UndoChar_655;
		public ushort UndoChar_656;
		public ushort UndoChar_657;
		public ushort UndoChar_658;
		public ushort UndoChar_659;
		public ushort UndoChar_660;
		public ushort UndoChar_661;
		public ushort UndoChar_662;
		public ushort UndoChar_663;
		public ushort UndoChar_664;
		public ushort UndoChar_665;
		public ushort UndoChar_666;
		public ushort UndoChar_667;
		public ushort UndoChar_668;
		public ushort UndoChar_669;
		public ushort UndoChar_670;
		public ushort UndoChar_671;
		public ushort UndoChar_672;
		public ushort UndoChar_673;
		public ushort UndoChar_674;
		public ushort UndoChar_675;
		public ushort UndoChar_676;
		public ushort UndoChar_677;
		public ushort UndoChar_678;
		public ushort UndoChar_679;
		public ushort UndoChar_680;
		public ushort UndoChar_681;
		public ushort UndoChar_682;
		public ushort UndoChar_683;
		public ushort UndoChar_684;
		public ushort UndoChar_685;
		public ushort UndoChar_686;
		public ushort UndoChar_687;
		public ushort UndoChar_688;
		public ushort UndoChar_689;
		public ushort UndoChar_690;
		public ushort UndoChar_691;
		public ushort UndoChar_692;
		public ushort UndoChar_693;
		public ushort UndoChar_694;
		public ushort UndoChar_695;
		public ushort UndoChar_696;
		public ushort UndoChar_697;
		public ushort UndoChar_698;
		public ushort UndoChar_699;
		public ushort UndoChar_700;
		public ushort UndoChar_701;
		public ushort UndoChar_702;
		public ushort UndoChar_703;
		public ushort UndoChar_704;
		public ushort UndoChar_705;
		public ushort UndoChar_706;
		public ushort UndoChar_707;
		public ushort UndoChar_708;
		public ushort UndoChar_709;
		public ushort UndoChar_710;
		public ushort UndoChar_711;
		public ushort UndoChar_712;
		public ushort UndoChar_713;
		public ushort UndoChar_714;
		public ushort UndoChar_715;
		public ushort UndoChar_716;
		public ushort UndoChar_717;
		public ushort UndoChar_718;
		public ushort UndoChar_719;
		public ushort UndoChar_720;
		public ushort UndoChar_721;
		public ushort UndoChar_722;
		public ushort UndoChar_723;
		public ushort UndoChar_724;
		public ushort UndoChar_725;
		public ushort UndoChar_726;
		public ushort UndoChar_727;
		public ushort UndoChar_728;
		public ushort UndoChar_729;
		public ushort UndoChar_730;
		public ushort UndoChar_731;
		public ushort UndoChar_732;
		public ushort UndoChar_733;
		public ushort UndoChar_734;
		public ushort UndoChar_735;
		public ushort UndoChar_736;
		public ushort UndoChar_737;
		public ushort UndoChar_738;
		public ushort UndoChar_739;
		public ushort UndoChar_740;
		public ushort UndoChar_741;
		public ushort UndoChar_742;
		public ushort UndoChar_743;
		public ushort UndoChar_744;
		public ushort UndoChar_745;
		public ushort UndoChar_746;
		public ushort UndoChar_747;
		public ushort UndoChar_748;
		public ushort UndoChar_749;
		public ushort UndoChar_750;
		public ushort UndoChar_751;
		public ushort UndoChar_752;
		public ushort UndoChar_753;
		public ushort UndoChar_754;
		public ushort UndoChar_755;
		public ushort UndoChar_756;
		public ushort UndoChar_757;
		public ushort UndoChar_758;
		public ushort UndoChar_759;
		public ushort UndoChar_760;
		public ushort UndoChar_761;
		public ushort UndoChar_762;
		public ushort UndoChar_763;
		public ushort UndoChar_764;
		public ushort UndoChar_765;
		public ushort UndoChar_766;
		public ushort UndoChar_767;
		public ushort UndoChar_768;
		public ushort UndoChar_769;
		public ushort UndoChar_770;
		public ushort UndoChar_771;
		public ushort UndoChar_772;
		public ushort UndoChar_773;
		public ushort UndoChar_774;
		public ushort UndoChar_775;
		public ushort UndoChar_776;
		public ushort UndoChar_777;
		public ushort UndoChar_778;
		public ushort UndoChar_779;
		public ushort UndoChar_780;
		public ushort UndoChar_781;
		public ushort UndoChar_782;
		public ushort UndoChar_783;
		public ushort UndoChar_784;
		public ushort UndoChar_785;
		public ushort UndoChar_786;
		public ushort UndoChar_787;
		public ushort UndoChar_788;
		public ushort UndoChar_789;
		public ushort UndoChar_790;
		public ushort UndoChar_791;
		public ushort UndoChar_792;
		public ushort UndoChar_793;
		public ushort UndoChar_794;
		public ushort UndoChar_795;
		public ushort UndoChar_796;
		public ushort UndoChar_797;
		public ushort UndoChar_798;
		public ushort UndoChar_799;
		public ushort UndoChar_800;
		public ushort UndoChar_801;
		public ushort UndoChar_802;
		public ushort UndoChar_803;
		public ushort UndoChar_804;
		public ushort UndoChar_805;
		public ushort UndoChar_806;
		public ushort UndoChar_807;
		public ushort UndoChar_808;
		public ushort UndoChar_809;
		public ushort UndoChar_810;
		public ushort UndoChar_811;
		public ushort UndoChar_812;
		public ushort UndoChar_813;
		public ushort UndoChar_814;
		public ushort UndoChar_815;
		public ushort UndoChar_816;
		public ushort UndoChar_817;
		public ushort UndoChar_818;
		public ushort UndoChar_819;
		public ushort UndoChar_820;
		public ushort UndoChar_821;
		public ushort UndoChar_822;
		public ushort UndoChar_823;
		public ushort UndoChar_824;
		public ushort UndoChar_825;
		public ushort UndoChar_826;
		public ushort UndoChar_827;
		public ushort UndoChar_828;
		public ushort UndoChar_829;
		public ushort UndoChar_830;
		public ushort UndoChar_831;
		public ushort UndoChar_832;
		public ushort UndoChar_833;
		public ushort UndoChar_834;
		public ushort UndoChar_835;
		public ushort UndoChar_836;
		public ushort UndoChar_837;
		public ushort UndoChar_838;
		public ushort UndoChar_839;
		public ushort UndoChar_840;
		public ushort UndoChar_841;
		public ushort UndoChar_842;
		public ushort UndoChar_843;
		public ushort UndoChar_844;
		public ushort UndoChar_845;
		public ushort UndoChar_846;
		public ushort UndoChar_847;
		public ushort UndoChar_848;
		public ushort UndoChar_849;
		public ushort UndoChar_850;
		public ushort UndoChar_851;
		public ushort UndoChar_852;
		public ushort UndoChar_853;
		public ushort UndoChar_854;
		public ushort UndoChar_855;
		public ushort UndoChar_856;
		public ushort UndoChar_857;
		public ushort UndoChar_858;
		public ushort UndoChar_859;
		public ushort UndoChar_860;
		public ushort UndoChar_861;
		public ushort UndoChar_862;
		public ushort UndoChar_863;
		public ushort UndoChar_864;
		public ushort UndoChar_865;
		public ushort UndoChar_866;
		public ushort UndoChar_867;
		public ushort UndoChar_868;
		public ushort UndoChar_869;
		public ushort UndoChar_870;
		public ushort UndoChar_871;
		public ushort UndoChar_872;
		public ushort UndoChar_873;
		public ushort UndoChar_874;
		public ushort UndoChar_875;
		public ushort UndoChar_876;
		public ushort UndoChar_877;
		public ushort UndoChar_878;
		public ushort UndoChar_879;
		public ushort UndoChar_880;
		public ushort UndoChar_881;
		public ushort UndoChar_882;
		public ushort UndoChar_883;
		public ushort UndoChar_884;
		public ushort UndoChar_885;
		public ushort UndoChar_886;
		public ushort UndoChar_887;
		public ushort UndoChar_888;
		public ushort UndoChar_889;
		public ushort UndoChar_890;
		public ushort UndoChar_891;
		public ushort UndoChar_892;
		public ushort UndoChar_893;
		public ushort UndoChar_894;
		public ushort UndoChar_895;
		public ushort UndoChar_896;
		public ushort UndoChar_897;
		public ushort UndoChar_898;
		public ushort UndoChar_899;
		public ushort UndoChar_900;
		public ushort UndoChar_901;
		public ushort UndoChar_902;
		public ushort UndoChar_903;
		public ushort UndoChar_904;
		public ushort UndoChar_905;
		public ushort UndoChar_906;
		public ushort UndoChar_907;
		public ushort UndoChar_908;
		public ushort UndoChar_909;
		public ushort UndoChar_910;
		public ushort UndoChar_911;
		public ushort UndoChar_912;
		public ushort UndoChar_913;
		public ushort UndoChar_914;
		public ushort UndoChar_915;
		public ushort UndoChar_916;
		public ushort UndoChar_917;
		public ushort UndoChar_918;
		public ushort UndoChar_919;
		public ushort UndoChar_920;
		public ushort UndoChar_921;
		public ushort UndoChar_922;
		public ushort UndoChar_923;
		public ushort UndoChar_924;
		public ushort UndoChar_925;
		public ushort UndoChar_926;
		public ushort UndoChar_927;
		public ushort UndoChar_928;
		public ushort UndoChar_929;
		public ushort UndoChar_930;
		public ushort UndoChar_931;
		public ushort UndoChar_932;
		public ushort UndoChar_933;
		public ushort UndoChar_934;
		public ushort UndoChar_935;
		public ushort UndoChar_936;
		public ushort UndoChar_937;
		public ushort UndoChar_938;
		public ushort UndoChar_939;
		public ushort UndoChar_940;
		public ushort UndoChar_941;
		public ushort UndoChar_942;
		public ushort UndoChar_943;
		public ushort UndoChar_944;
		public ushort UndoChar_945;
		public ushort UndoChar_946;
		public ushort UndoChar_947;
		public ushort UndoChar_948;
		public ushort UndoChar_949;
		public ushort UndoChar_950;
		public ushort UndoChar_951;
		public ushort UndoChar_952;
		public ushort UndoChar_953;
		public ushort UndoChar_954;
		public ushort UndoChar_955;
		public ushort UndoChar_956;
		public ushort UndoChar_957;
		public ushort UndoChar_958;
		public ushort UndoChar_959;
		public ushort UndoChar_960;
		public ushort UndoChar_961;
		public ushort UndoChar_962;
		public ushort UndoChar_963;
		public ushort UndoChar_964;
		public ushort UndoChar_965;
		public ushort UndoChar_966;
		public ushort UndoChar_967;
		public ushort UndoChar_968;
		public ushort UndoChar_969;
		public ushort UndoChar_970;
		public ushort UndoChar_971;
		public ushort UndoChar_972;
		public ushort UndoChar_973;
		public ushort UndoChar_974;
		public ushort UndoChar_975;
		public ushort UndoChar_976;
		public ushort UndoChar_977;
		public ushort UndoChar_978;
		public ushort UndoChar_979;
		public ushort UndoChar_980;
		public ushort UndoChar_981;
		public ushort UndoChar_982;
		public ushort UndoChar_983;
		public ushort UndoChar_984;
		public ushort UndoChar_985;
		public ushort UndoChar_986;
		public ushort UndoChar_987;
		public ushort UndoChar_988;
		public ushort UndoChar_989;
		public ushort UndoChar_990;
		public ushort UndoChar_991;
		public ushort UndoChar_992;
		public ushort UndoChar_993;
		public ushort UndoChar_994;
		public ushort UndoChar_995;
		public ushort UndoChar_996;
		public ushort UndoChar_997;
		public ushort UndoChar_998;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short UndoPoint;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short RedoPoint;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int UndoCharPoint;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int RedoCharPoint;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe StbUndoState(StbUndoRecord* undoRec = default, char* undoChar = default, short undoPoint = default, short redoPoint = default, int undoCharPoint = default, int redoCharPoint = default)
		{
			if (undoRec != default)
			{
				UndoRec_0 = undoRec[0];
				UndoRec_1 = undoRec[1];
				UndoRec_2 = undoRec[2];
				UndoRec_3 = undoRec[3];
				UndoRec_4 = undoRec[4];
				UndoRec_5 = undoRec[5];
				UndoRec_6 = undoRec[6];
				UndoRec_7 = undoRec[7];
				UndoRec_8 = undoRec[8];
				UndoRec_9 = undoRec[9];
				UndoRec_10 = undoRec[10];
				UndoRec_11 = undoRec[11];
				UndoRec_12 = undoRec[12];
				UndoRec_13 = undoRec[13];
				UndoRec_14 = undoRec[14];
				UndoRec_15 = undoRec[15];
				UndoRec_16 = undoRec[16];
				UndoRec_17 = undoRec[17];
				UndoRec_18 = undoRec[18];
				UndoRec_19 = undoRec[19];
				UndoRec_20 = undoRec[20];
				UndoRec_21 = undoRec[21];
				UndoRec_22 = undoRec[22];
				UndoRec_23 = undoRec[23];
				UndoRec_24 = undoRec[24];
				UndoRec_25 = undoRec[25];
				UndoRec_26 = undoRec[26];
				UndoRec_27 = undoRec[27];
				UndoRec_28 = undoRec[28];
				UndoRec_29 = undoRec[29];
				UndoRec_30 = undoRec[30];
				UndoRec_31 = undoRec[31];
				UndoRec_32 = undoRec[32];
				UndoRec_33 = undoRec[33];
				UndoRec_34 = undoRec[34];
				UndoRec_35 = undoRec[35];
				UndoRec_36 = undoRec[36];
				UndoRec_37 = undoRec[37];
				UndoRec_38 = undoRec[38];
				UndoRec_39 = undoRec[39];
				UndoRec_40 = undoRec[40];
				UndoRec_41 = undoRec[41];
				UndoRec_42 = undoRec[42];
				UndoRec_43 = undoRec[43];
				UndoRec_44 = undoRec[44];
				UndoRec_45 = undoRec[45];
				UndoRec_46 = undoRec[46];
				UndoRec_47 = undoRec[47];
				UndoRec_48 = undoRec[48];
				UndoRec_49 = undoRec[49];
				UndoRec_50 = undoRec[50];
				UndoRec_51 = undoRec[51];
				UndoRec_52 = undoRec[52];
				UndoRec_53 = undoRec[53];
				UndoRec_54 = undoRec[54];
				UndoRec_55 = undoRec[55];
				UndoRec_56 = undoRec[56];
				UndoRec_57 = undoRec[57];
				UndoRec_58 = undoRec[58];
				UndoRec_59 = undoRec[59];
				UndoRec_60 = undoRec[60];
				UndoRec_61 = undoRec[61];
				UndoRec_62 = undoRec[62];
				UndoRec_63 = undoRec[63];
				UndoRec_64 = undoRec[64];
				UndoRec_65 = undoRec[65];
				UndoRec_66 = undoRec[66];
				UndoRec_67 = undoRec[67];
				UndoRec_68 = undoRec[68];
				UndoRec_69 = undoRec[69];
				UndoRec_70 = undoRec[70];
				UndoRec_71 = undoRec[71];
				UndoRec_72 = undoRec[72];
				UndoRec_73 = undoRec[73];
				UndoRec_74 = undoRec[74];
				UndoRec_75 = undoRec[75];
				UndoRec_76 = undoRec[76];
				UndoRec_77 = undoRec[77];
				UndoRec_78 = undoRec[78];
				UndoRec_79 = undoRec[79];
				UndoRec_80 = undoRec[80];
				UndoRec_81 = undoRec[81];
				UndoRec_82 = undoRec[82];
				UndoRec_83 = undoRec[83];
				UndoRec_84 = undoRec[84];
				UndoRec_85 = undoRec[85];
				UndoRec_86 = undoRec[86];
				UndoRec_87 = undoRec[87];
				UndoRec_88 = undoRec[88];
				UndoRec_89 = undoRec[89];
				UndoRec_90 = undoRec[90];
				UndoRec_91 = undoRec[91];
				UndoRec_92 = undoRec[92];
				UndoRec_93 = undoRec[93];
				UndoRec_94 = undoRec[94];
				UndoRec_95 = undoRec[95];
				UndoRec_96 = undoRec[96];
				UndoRec_97 = undoRec[97];
				UndoRec_98 = undoRec[98];
			}
			if (undoChar != default)
			{
				UndoChar_0 = undoChar[0];
				UndoChar_1 = undoChar[1];
				UndoChar_2 = undoChar[2];
				UndoChar_3 = undoChar[3];
				UndoChar_4 = undoChar[4];
				UndoChar_5 = undoChar[5];
				UndoChar_6 = undoChar[6];
				UndoChar_7 = undoChar[7];
				UndoChar_8 = undoChar[8];
				UndoChar_9 = undoChar[9];
				UndoChar_10 = undoChar[10];
				UndoChar_11 = undoChar[11];
				UndoChar_12 = undoChar[12];
				UndoChar_13 = undoChar[13];
				UndoChar_14 = undoChar[14];
				UndoChar_15 = undoChar[15];
				UndoChar_16 = undoChar[16];
				UndoChar_17 = undoChar[17];
				UndoChar_18 = undoChar[18];
				UndoChar_19 = undoChar[19];
				UndoChar_20 = undoChar[20];
				UndoChar_21 = undoChar[21];
				UndoChar_22 = undoChar[22];
				UndoChar_23 = undoChar[23];
				UndoChar_24 = undoChar[24];
				UndoChar_25 = undoChar[25];
				UndoChar_26 = undoChar[26];
				UndoChar_27 = undoChar[27];
				UndoChar_28 = undoChar[28];
				UndoChar_29 = undoChar[29];
				UndoChar_30 = undoChar[30];
				UndoChar_31 = undoChar[31];
				UndoChar_32 = undoChar[32];
				UndoChar_33 = undoChar[33];
				UndoChar_34 = undoChar[34];
				UndoChar_35 = undoChar[35];
				UndoChar_36 = undoChar[36];
				UndoChar_37 = undoChar[37];
				UndoChar_38 = undoChar[38];
				UndoChar_39 = undoChar[39];
				UndoChar_40 = undoChar[40];
				UndoChar_41 = undoChar[41];
				UndoChar_42 = undoChar[42];
				UndoChar_43 = undoChar[43];
				UndoChar_44 = undoChar[44];
				UndoChar_45 = undoChar[45];
				UndoChar_46 = undoChar[46];
				UndoChar_47 = undoChar[47];
				UndoChar_48 = undoChar[48];
				UndoChar_49 = undoChar[49];
				UndoChar_50 = undoChar[50];
				UndoChar_51 = undoChar[51];
				UndoChar_52 = undoChar[52];
				UndoChar_53 = undoChar[53];
				UndoChar_54 = undoChar[54];
				UndoChar_55 = undoChar[55];
				UndoChar_56 = undoChar[56];
				UndoChar_57 = undoChar[57];
				UndoChar_58 = undoChar[58];
				UndoChar_59 = undoChar[59];
				UndoChar_60 = undoChar[60];
				UndoChar_61 = undoChar[61];
				UndoChar_62 = undoChar[62];
				UndoChar_63 = undoChar[63];
				UndoChar_64 = undoChar[64];
				UndoChar_65 = undoChar[65];
				UndoChar_66 = undoChar[66];
				UndoChar_67 = undoChar[67];
				UndoChar_68 = undoChar[68];
				UndoChar_69 = undoChar[69];
				UndoChar_70 = undoChar[70];
				UndoChar_71 = undoChar[71];
				UndoChar_72 = undoChar[72];
				UndoChar_73 = undoChar[73];
				UndoChar_74 = undoChar[74];
				UndoChar_75 = undoChar[75];
				UndoChar_76 = undoChar[76];
				UndoChar_77 = undoChar[77];
				UndoChar_78 = undoChar[78];
				UndoChar_79 = undoChar[79];
				UndoChar_80 = undoChar[80];
				UndoChar_81 = undoChar[81];
				UndoChar_82 = undoChar[82];
				UndoChar_83 = undoChar[83];
				UndoChar_84 = undoChar[84];
				UndoChar_85 = undoChar[85];
				UndoChar_86 = undoChar[86];
				UndoChar_87 = undoChar[87];
				UndoChar_88 = undoChar[88];
				UndoChar_89 = undoChar[89];
				UndoChar_90 = undoChar[90];
				UndoChar_91 = undoChar[91];
				UndoChar_92 = undoChar[92];
				UndoChar_93 = undoChar[93];
				UndoChar_94 = undoChar[94];
				UndoChar_95 = undoChar[95];
				UndoChar_96 = undoChar[96];
				UndoChar_97 = undoChar[97];
				UndoChar_98 = undoChar[98];
				UndoChar_99 = undoChar[99];
				UndoChar_100 = undoChar[100];
				UndoChar_101 = undoChar[101];
				UndoChar_102 = undoChar[102];
				UndoChar_103 = undoChar[103];
				UndoChar_104 = undoChar[104];
				UndoChar_105 = undoChar[105];
				UndoChar_106 = undoChar[106];
				UndoChar_107 = undoChar[107];
				UndoChar_108 = undoChar[108];
				UndoChar_109 = undoChar[109];
				UndoChar_110 = undoChar[110];
				UndoChar_111 = undoChar[111];
				UndoChar_112 = undoChar[112];
				UndoChar_113 = undoChar[113];
				UndoChar_114 = undoChar[114];
				UndoChar_115 = undoChar[115];
				UndoChar_116 = undoChar[116];
				UndoChar_117 = undoChar[117];
				UndoChar_118 = undoChar[118];
				UndoChar_119 = undoChar[119];
				UndoChar_120 = undoChar[120];
				UndoChar_121 = undoChar[121];
				UndoChar_122 = undoChar[122];
				UndoChar_123 = undoChar[123];
				UndoChar_124 = undoChar[124];
				UndoChar_125 = undoChar[125];
				UndoChar_126 = undoChar[126];
				UndoChar_127 = undoChar[127];
				UndoChar_128 = undoChar[128];
				UndoChar_129 = undoChar[129];
				UndoChar_130 = undoChar[130];
				UndoChar_131 = undoChar[131];
				UndoChar_132 = undoChar[132];
				UndoChar_133 = undoChar[133];
				UndoChar_134 = undoChar[134];
				UndoChar_135 = undoChar[135];
				UndoChar_136 = undoChar[136];
				UndoChar_137 = undoChar[137];
				UndoChar_138 = undoChar[138];
				UndoChar_139 = undoChar[139];
				UndoChar_140 = undoChar[140];
				UndoChar_141 = undoChar[141];
				UndoChar_142 = undoChar[142];
				UndoChar_143 = undoChar[143];
				UndoChar_144 = undoChar[144];
				UndoChar_145 = undoChar[145];
				UndoChar_146 = undoChar[146];
				UndoChar_147 = undoChar[147];
				UndoChar_148 = undoChar[148];
				UndoChar_149 = undoChar[149];
				UndoChar_150 = undoChar[150];
				UndoChar_151 = undoChar[151];
				UndoChar_152 = undoChar[152];
				UndoChar_153 = undoChar[153];
				UndoChar_154 = undoChar[154];
				UndoChar_155 = undoChar[155];
				UndoChar_156 = undoChar[156];
				UndoChar_157 = undoChar[157];
				UndoChar_158 = undoChar[158];
				UndoChar_159 = undoChar[159];
				UndoChar_160 = undoChar[160];
				UndoChar_161 = undoChar[161];
				UndoChar_162 = undoChar[162];
				UndoChar_163 = undoChar[163];
				UndoChar_164 = undoChar[164];
				UndoChar_165 = undoChar[165];
				UndoChar_166 = undoChar[166];
				UndoChar_167 = undoChar[167];
				UndoChar_168 = undoChar[168];
				UndoChar_169 = undoChar[169];
				UndoChar_170 = undoChar[170];
				UndoChar_171 = undoChar[171];
				UndoChar_172 = undoChar[172];
				UndoChar_173 = undoChar[173];
				UndoChar_174 = undoChar[174];
				UndoChar_175 = undoChar[175];
				UndoChar_176 = undoChar[176];
				UndoChar_177 = undoChar[177];
				UndoChar_178 = undoChar[178];
				UndoChar_179 = undoChar[179];
				UndoChar_180 = undoChar[180];
				UndoChar_181 = undoChar[181];
				UndoChar_182 = undoChar[182];
				UndoChar_183 = undoChar[183];
				UndoChar_184 = undoChar[184];
				UndoChar_185 = undoChar[185];
				UndoChar_186 = undoChar[186];
				UndoChar_187 = undoChar[187];
				UndoChar_188 = undoChar[188];
				UndoChar_189 = undoChar[189];
				UndoChar_190 = undoChar[190];
				UndoChar_191 = undoChar[191];
				UndoChar_192 = undoChar[192];
				UndoChar_193 = undoChar[193];
				UndoChar_194 = undoChar[194];
				UndoChar_195 = undoChar[195];
				UndoChar_196 = undoChar[196];
				UndoChar_197 = undoChar[197];
				UndoChar_198 = undoChar[198];
				UndoChar_199 = undoChar[199];
				UndoChar_200 = undoChar[200];
				UndoChar_201 = undoChar[201];
				UndoChar_202 = undoChar[202];
				UndoChar_203 = undoChar[203];
				UndoChar_204 = undoChar[204];
				UndoChar_205 = undoChar[205];
				UndoChar_206 = undoChar[206];
				UndoChar_207 = undoChar[207];
				UndoChar_208 = undoChar[208];
				UndoChar_209 = undoChar[209];
				UndoChar_210 = undoChar[210];
				UndoChar_211 = undoChar[211];
				UndoChar_212 = undoChar[212];
				UndoChar_213 = undoChar[213];
				UndoChar_214 = undoChar[214];
				UndoChar_215 = undoChar[215];
				UndoChar_216 = undoChar[216];
				UndoChar_217 = undoChar[217];
				UndoChar_218 = undoChar[218];
				UndoChar_219 = undoChar[219];
				UndoChar_220 = undoChar[220];
				UndoChar_221 = undoChar[221];
				UndoChar_222 = undoChar[222];
				UndoChar_223 = undoChar[223];
				UndoChar_224 = undoChar[224];
				UndoChar_225 = undoChar[225];
				UndoChar_226 = undoChar[226];
				UndoChar_227 = undoChar[227];
				UndoChar_228 = undoChar[228];
				UndoChar_229 = undoChar[229];
				UndoChar_230 = undoChar[230];
				UndoChar_231 = undoChar[231];
				UndoChar_232 = undoChar[232];
				UndoChar_233 = undoChar[233];
				UndoChar_234 = undoChar[234];
				UndoChar_235 = undoChar[235];
				UndoChar_236 = undoChar[236];
				UndoChar_237 = undoChar[237];
				UndoChar_238 = undoChar[238];
				UndoChar_239 = undoChar[239];
				UndoChar_240 = undoChar[240];
				UndoChar_241 = undoChar[241];
				UndoChar_242 = undoChar[242];
				UndoChar_243 = undoChar[243];
				UndoChar_244 = undoChar[244];
				UndoChar_245 = undoChar[245];
				UndoChar_246 = undoChar[246];
				UndoChar_247 = undoChar[247];
				UndoChar_248 = undoChar[248];
				UndoChar_249 = undoChar[249];
				UndoChar_250 = undoChar[250];
				UndoChar_251 = undoChar[251];
				UndoChar_252 = undoChar[252];
				UndoChar_253 = undoChar[253];
				UndoChar_254 = undoChar[254];
				UndoChar_255 = undoChar[255];
				UndoChar_256 = undoChar[256];
				UndoChar_257 = undoChar[257];
				UndoChar_258 = undoChar[258];
				UndoChar_259 = undoChar[259];
				UndoChar_260 = undoChar[260];
				UndoChar_261 = undoChar[261];
				UndoChar_262 = undoChar[262];
				UndoChar_263 = undoChar[263];
				UndoChar_264 = undoChar[264];
				UndoChar_265 = undoChar[265];
				UndoChar_266 = undoChar[266];
				UndoChar_267 = undoChar[267];
				UndoChar_268 = undoChar[268];
				UndoChar_269 = undoChar[269];
				UndoChar_270 = undoChar[270];
				UndoChar_271 = undoChar[271];
				UndoChar_272 = undoChar[272];
				UndoChar_273 = undoChar[273];
				UndoChar_274 = undoChar[274];
				UndoChar_275 = undoChar[275];
				UndoChar_276 = undoChar[276];
				UndoChar_277 = undoChar[277];
				UndoChar_278 = undoChar[278];
				UndoChar_279 = undoChar[279];
				UndoChar_280 = undoChar[280];
				UndoChar_281 = undoChar[281];
				UndoChar_282 = undoChar[282];
				UndoChar_283 = undoChar[283];
				UndoChar_284 = undoChar[284];
				UndoChar_285 = undoChar[285];
				UndoChar_286 = undoChar[286];
				UndoChar_287 = undoChar[287];
				UndoChar_288 = undoChar[288];
				UndoChar_289 = undoChar[289];
				UndoChar_290 = undoChar[290];
				UndoChar_291 = undoChar[291];
				UndoChar_292 = undoChar[292];
				UndoChar_293 = undoChar[293];
				UndoChar_294 = undoChar[294];
				UndoChar_295 = undoChar[295];
				UndoChar_296 = undoChar[296];
				UndoChar_297 = undoChar[297];
				UndoChar_298 = undoChar[298];
				UndoChar_299 = undoChar[299];
				UndoChar_300 = undoChar[300];
				UndoChar_301 = undoChar[301];
				UndoChar_302 = undoChar[302];
				UndoChar_303 = undoChar[303];
				UndoChar_304 = undoChar[304];
				UndoChar_305 = undoChar[305];
				UndoChar_306 = undoChar[306];
				UndoChar_307 = undoChar[307];
				UndoChar_308 = undoChar[308];
				UndoChar_309 = undoChar[309];
				UndoChar_310 = undoChar[310];
				UndoChar_311 = undoChar[311];
				UndoChar_312 = undoChar[312];
				UndoChar_313 = undoChar[313];
				UndoChar_314 = undoChar[314];
				UndoChar_315 = undoChar[315];
				UndoChar_316 = undoChar[316];
				UndoChar_317 = undoChar[317];
				UndoChar_318 = undoChar[318];
				UndoChar_319 = undoChar[319];
				UndoChar_320 = undoChar[320];
				UndoChar_321 = undoChar[321];
				UndoChar_322 = undoChar[322];
				UndoChar_323 = undoChar[323];
				UndoChar_324 = undoChar[324];
				UndoChar_325 = undoChar[325];
				UndoChar_326 = undoChar[326];
				UndoChar_327 = undoChar[327];
				UndoChar_328 = undoChar[328];
				UndoChar_329 = undoChar[329];
				UndoChar_330 = undoChar[330];
				UndoChar_331 = undoChar[331];
				UndoChar_332 = undoChar[332];
				UndoChar_333 = undoChar[333];
				UndoChar_334 = undoChar[334];
				UndoChar_335 = undoChar[335];
				UndoChar_336 = undoChar[336];
				UndoChar_337 = undoChar[337];
				UndoChar_338 = undoChar[338];
				UndoChar_339 = undoChar[339];
				UndoChar_340 = undoChar[340];
				UndoChar_341 = undoChar[341];
				UndoChar_342 = undoChar[342];
				UndoChar_343 = undoChar[343];
				UndoChar_344 = undoChar[344];
				UndoChar_345 = undoChar[345];
				UndoChar_346 = undoChar[346];
				UndoChar_347 = undoChar[347];
				UndoChar_348 = undoChar[348];
				UndoChar_349 = undoChar[349];
				UndoChar_350 = undoChar[350];
				UndoChar_351 = undoChar[351];
				UndoChar_352 = undoChar[352];
				UndoChar_353 = undoChar[353];
				UndoChar_354 = undoChar[354];
				UndoChar_355 = undoChar[355];
				UndoChar_356 = undoChar[356];
				UndoChar_357 = undoChar[357];
				UndoChar_358 = undoChar[358];
				UndoChar_359 = undoChar[359];
				UndoChar_360 = undoChar[360];
				UndoChar_361 = undoChar[361];
				UndoChar_362 = undoChar[362];
				UndoChar_363 = undoChar[363];
				UndoChar_364 = undoChar[364];
				UndoChar_365 = undoChar[365];
				UndoChar_366 = undoChar[366];
				UndoChar_367 = undoChar[367];
				UndoChar_368 = undoChar[368];
				UndoChar_369 = undoChar[369];
				UndoChar_370 = undoChar[370];
				UndoChar_371 = undoChar[371];
				UndoChar_372 = undoChar[372];
				UndoChar_373 = undoChar[373];
				UndoChar_374 = undoChar[374];
				UndoChar_375 = undoChar[375];
				UndoChar_376 = undoChar[376];
				UndoChar_377 = undoChar[377];
				UndoChar_378 = undoChar[378];
				UndoChar_379 = undoChar[379];
				UndoChar_380 = undoChar[380];
				UndoChar_381 = undoChar[381];
				UndoChar_382 = undoChar[382];
				UndoChar_383 = undoChar[383];
				UndoChar_384 = undoChar[384];
				UndoChar_385 = undoChar[385];
				UndoChar_386 = undoChar[386];
				UndoChar_387 = undoChar[387];
				UndoChar_388 = undoChar[388];
				UndoChar_389 = undoChar[389];
				UndoChar_390 = undoChar[390];
				UndoChar_391 = undoChar[391];
				UndoChar_392 = undoChar[392];
				UndoChar_393 = undoChar[393];
				UndoChar_394 = undoChar[394];
				UndoChar_395 = undoChar[395];
				UndoChar_396 = undoChar[396];
				UndoChar_397 = undoChar[397];
				UndoChar_398 = undoChar[398];
				UndoChar_399 = undoChar[399];
				UndoChar_400 = undoChar[400];
				UndoChar_401 = undoChar[401];
				UndoChar_402 = undoChar[402];
				UndoChar_403 = undoChar[403];
				UndoChar_404 = undoChar[404];
				UndoChar_405 = undoChar[405];
				UndoChar_406 = undoChar[406];
				UndoChar_407 = undoChar[407];
				UndoChar_408 = undoChar[408];
				UndoChar_409 = undoChar[409];
				UndoChar_410 = undoChar[410];
				UndoChar_411 = undoChar[411];
				UndoChar_412 = undoChar[412];
				UndoChar_413 = undoChar[413];
				UndoChar_414 = undoChar[414];
				UndoChar_415 = undoChar[415];
				UndoChar_416 = undoChar[416];
				UndoChar_417 = undoChar[417];
				UndoChar_418 = undoChar[418];
				UndoChar_419 = undoChar[419];
				UndoChar_420 = undoChar[420];
				UndoChar_421 = undoChar[421];
				UndoChar_422 = undoChar[422];
				UndoChar_423 = undoChar[423];
				UndoChar_424 = undoChar[424];
				UndoChar_425 = undoChar[425];
				UndoChar_426 = undoChar[426];
				UndoChar_427 = undoChar[427];
				UndoChar_428 = undoChar[428];
				UndoChar_429 = undoChar[429];
				UndoChar_430 = undoChar[430];
				UndoChar_431 = undoChar[431];
				UndoChar_432 = undoChar[432];
				UndoChar_433 = undoChar[433];
				UndoChar_434 = undoChar[434];
				UndoChar_435 = undoChar[435];
				UndoChar_436 = undoChar[436];
				UndoChar_437 = undoChar[437];
				UndoChar_438 = undoChar[438];
				UndoChar_439 = undoChar[439];
				UndoChar_440 = undoChar[440];
				UndoChar_441 = undoChar[441];
				UndoChar_442 = undoChar[442];
				UndoChar_443 = undoChar[443];
				UndoChar_444 = undoChar[444];
				UndoChar_445 = undoChar[445];
				UndoChar_446 = undoChar[446];
				UndoChar_447 = undoChar[447];
				UndoChar_448 = undoChar[448];
				UndoChar_449 = undoChar[449];
				UndoChar_450 = undoChar[450];
				UndoChar_451 = undoChar[451];
				UndoChar_452 = undoChar[452];
				UndoChar_453 = undoChar[453];
				UndoChar_454 = undoChar[454];
				UndoChar_455 = undoChar[455];
				UndoChar_456 = undoChar[456];
				UndoChar_457 = undoChar[457];
				UndoChar_458 = undoChar[458];
				UndoChar_459 = undoChar[459];
				UndoChar_460 = undoChar[460];
				UndoChar_461 = undoChar[461];
				UndoChar_462 = undoChar[462];
				UndoChar_463 = undoChar[463];
				UndoChar_464 = undoChar[464];
				UndoChar_465 = undoChar[465];
				UndoChar_466 = undoChar[466];
				UndoChar_467 = undoChar[467];
				UndoChar_468 = undoChar[468];
				UndoChar_469 = undoChar[469];
				UndoChar_470 = undoChar[470];
				UndoChar_471 = undoChar[471];
				UndoChar_472 = undoChar[472];
				UndoChar_473 = undoChar[473];
				UndoChar_474 = undoChar[474];
				UndoChar_475 = undoChar[475];
				UndoChar_476 = undoChar[476];
				UndoChar_477 = undoChar[477];
				UndoChar_478 = undoChar[478];
				UndoChar_479 = undoChar[479];
				UndoChar_480 = undoChar[480];
				UndoChar_481 = undoChar[481];
				UndoChar_482 = undoChar[482];
				UndoChar_483 = undoChar[483];
				UndoChar_484 = undoChar[484];
				UndoChar_485 = undoChar[485];
				UndoChar_486 = undoChar[486];
				UndoChar_487 = undoChar[487];
				UndoChar_488 = undoChar[488];
				UndoChar_489 = undoChar[489];
				UndoChar_490 = undoChar[490];
				UndoChar_491 = undoChar[491];
				UndoChar_492 = undoChar[492];
				UndoChar_493 = undoChar[493];
				UndoChar_494 = undoChar[494];
				UndoChar_495 = undoChar[495];
				UndoChar_496 = undoChar[496];
				UndoChar_497 = undoChar[497];
				UndoChar_498 = undoChar[498];
				UndoChar_499 = undoChar[499];
				UndoChar_500 = undoChar[500];
				UndoChar_501 = undoChar[501];
				UndoChar_502 = undoChar[502];
				UndoChar_503 = undoChar[503];
				UndoChar_504 = undoChar[504];
				UndoChar_505 = undoChar[505];
				UndoChar_506 = undoChar[506];
				UndoChar_507 = undoChar[507];
				UndoChar_508 = undoChar[508];
				UndoChar_509 = undoChar[509];
				UndoChar_510 = undoChar[510];
				UndoChar_511 = undoChar[511];
				UndoChar_512 = undoChar[512];
				UndoChar_513 = undoChar[513];
				UndoChar_514 = undoChar[514];
				UndoChar_515 = undoChar[515];
				UndoChar_516 = undoChar[516];
				UndoChar_517 = undoChar[517];
				UndoChar_518 = undoChar[518];
				UndoChar_519 = undoChar[519];
				UndoChar_520 = undoChar[520];
				UndoChar_521 = undoChar[521];
				UndoChar_522 = undoChar[522];
				UndoChar_523 = undoChar[523];
				UndoChar_524 = undoChar[524];
				UndoChar_525 = undoChar[525];
				UndoChar_526 = undoChar[526];
				UndoChar_527 = undoChar[527];
				UndoChar_528 = undoChar[528];
				UndoChar_529 = undoChar[529];
				UndoChar_530 = undoChar[530];
				UndoChar_531 = undoChar[531];
				UndoChar_532 = undoChar[532];
				UndoChar_533 = undoChar[533];
				UndoChar_534 = undoChar[534];
				UndoChar_535 = undoChar[535];
				UndoChar_536 = undoChar[536];
				UndoChar_537 = undoChar[537];
				UndoChar_538 = undoChar[538];
				UndoChar_539 = undoChar[539];
				UndoChar_540 = undoChar[540];
				UndoChar_541 = undoChar[541];
				UndoChar_542 = undoChar[542];
				UndoChar_543 = undoChar[543];
				UndoChar_544 = undoChar[544];
				UndoChar_545 = undoChar[545];
				UndoChar_546 = undoChar[546];
				UndoChar_547 = undoChar[547];
				UndoChar_548 = undoChar[548];
				UndoChar_549 = undoChar[549];
				UndoChar_550 = undoChar[550];
				UndoChar_551 = undoChar[551];
				UndoChar_552 = undoChar[552];
				UndoChar_553 = undoChar[553];
				UndoChar_554 = undoChar[554];
				UndoChar_555 = undoChar[555];
				UndoChar_556 = undoChar[556];
				UndoChar_557 = undoChar[557];
				UndoChar_558 = undoChar[558];
				UndoChar_559 = undoChar[559];
				UndoChar_560 = undoChar[560];
				UndoChar_561 = undoChar[561];
				UndoChar_562 = undoChar[562];
				UndoChar_563 = undoChar[563];
				UndoChar_564 = undoChar[564];
				UndoChar_565 = undoChar[565];
				UndoChar_566 = undoChar[566];
				UndoChar_567 = undoChar[567];
				UndoChar_568 = undoChar[568];
				UndoChar_569 = undoChar[569];
				UndoChar_570 = undoChar[570];
				UndoChar_571 = undoChar[571];
				UndoChar_572 = undoChar[572];
				UndoChar_573 = undoChar[573];
				UndoChar_574 = undoChar[574];
				UndoChar_575 = undoChar[575];
				UndoChar_576 = undoChar[576];
				UndoChar_577 = undoChar[577];
				UndoChar_578 = undoChar[578];
				UndoChar_579 = undoChar[579];
				UndoChar_580 = undoChar[580];
				UndoChar_581 = undoChar[581];
				UndoChar_582 = undoChar[582];
				UndoChar_583 = undoChar[583];
				UndoChar_584 = undoChar[584];
				UndoChar_585 = undoChar[585];
				UndoChar_586 = undoChar[586];
				UndoChar_587 = undoChar[587];
				UndoChar_588 = undoChar[588];
				UndoChar_589 = undoChar[589];
				UndoChar_590 = undoChar[590];
				UndoChar_591 = undoChar[591];
				UndoChar_592 = undoChar[592];
				UndoChar_593 = undoChar[593];
				UndoChar_594 = undoChar[594];
				UndoChar_595 = undoChar[595];
				UndoChar_596 = undoChar[596];
				UndoChar_597 = undoChar[597];
				UndoChar_598 = undoChar[598];
				UndoChar_599 = undoChar[599];
				UndoChar_600 = undoChar[600];
				UndoChar_601 = undoChar[601];
				UndoChar_602 = undoChar[602];
				UndoChar_603 = undoChar[603];
				UndoChar_604 = undoChar[604];
				UndoChar_605 = undoChar[605];
				UndoChar_606 = undoChar[606];
				UndoChar_607 = undoChar[607];
				UndoChar_608 = undoChar[608];
				UndoChar_609 = undoChar[609];
				UndoChar_610 = undoChar[610];
				UndoChar_611 = undoChar[611];
				UndoChar_612 = undoChar[612];
				UndoChar_613 = undoChar[613];
				UndoChar_614 = undoChar[614];
				UndoChar_615 = undoChar[615];
				UndoChar_616 = undoChar[616];
				UndoChar_617 = undoChar[617];
				UndoChar_618 = undoChar[618];
				UndoChar_619 = undoChar[619];
				UndoChar_620 = undoChar[620];
				UndoChar_621 = undoChar[621];
				UndoChar_622 = undoChar[622];
				UndoChar_623 = undoChar[623];
				UndoChar_624 = undoChar[624];
				UndoChar_625 = undoChar[625];
				UndoChar_626 = undoChar[626];
				UndoChar_627 = undoChar[627];
				UndoChar_628 = undoChar[628];
				UndoChar_629 = undoChar[629];
				UndoChar_630 = undoChar[630];
				UndoChar_631 = undoChar[631];
				UndoChar_632 = undoChar[632];
				UndoChar_633 = undoChar[633];
				UndoChar_634 = undoChar[634];
				UndoChar_635 = undoChar[635];
				UndoChar_636 = undoChar[636];
				UndoChar_637 = undoChar[637];
				UndoChar_638 = undoChar[638];
				UndoChar_639 = undoChar[639];
				UndoChar_640 = undoChar[640];
				UndoChar_641 = undoChar[641];
				UndoChar_642 = undoChar[642];
				UndoChar_643 = undoChar[643];
				UndoChar_644 = undoChar[644];
				UndoChar_645 = undoChar[645];
				UndoChar_646 = undoChar[646];
				UndoChar_647 = undoChar[647];
				UndoChar_648 = undoChar[648];
				UndoChar_649 = undoChar[649];
				UndoChar_650 = undoChar[650];
				UndoChar_651 = undoChar[651];
				UndoChar_652 = undoChar[652];
				UndoChar_653 = undoChar[653];
				UndoChar_654 = undoChar[654];
				UndoChar_655 = undoChar[655];
				UndoChar_656 = undoChar[656];
				UndoChar_657 = undoChar[657];
				UndoChar_658 = undoChar[658];
				UndoChar_659 = undoChar[659];
				UndoChar_660 = undoChar[660];
				UndoChar_661 = undoChar[661];
				UndoChar_662 = undoChar[662];
				UndoChar_663 = undoChar[663];
				UndoChar_664 = undoChar[664];
				UndoChar_665 = undoChar[665];
				UndoChar_666 = undoChar[666];
				UndoChar_667 = undoChar[667];
				UndoChar_668 = undoChar[668];
				UndoChar_669 = undoChar[669];
				UndoChar_670 = undoChar[670];
				UndoChar_671 = undoChar[671];
				UndoChar_672 = undoChar[672];
				UndoChar_673 = undoChar[673];
				UndoChar_674 = undoChar[674];
				UndoChar_675 = undoChar[675];
				UndoChar_676 = undoChar[676];
				UndoChar_677 = undoChar[677];
				UndoChar_678 = undoChar[678];
				UndoChar_679 = undoChar[679];
				UndoChar_680 = undoChar[680];
				UndoChar_681 = undoChar[681];
				UndoChar_682 = undoChar[682];
				UndoChar_683 = undoChar[683];
				UndoChar_684 = undoChar[684];
				UndoChar_685 = undoChar[685];
				UndoChar_686 = undoChar[686];
				UndoChar_687 = undoChar[687];
				UndoChar_688 = undoChar[688];
				UndoChar_689 = undoChar[689];
				UndoChar_690 = undoChar[690];
				UndoChar_691 = undoChar[691];
				UndoChar_692 = undoChar[692];
				UndoChar_693 = undoChar[693];
				UndoChar_694 = undoChar[694];
				UndoChar_695 = undoChar[695];
				UndoChar_696 = undoChar[696];
				UndoChar_697 = undoChar[697];
				UndoChar_698 = undoChar[698];
				UndoChar_699 = undoChar[699];
				UndoChar_700 = undoChar[700];
				UndoChar_701 = undoChar[701];
				UndoChar_702 = undoChar[702];
				UndoChar_703 = undoChar[703];
				UndoChar_704 = undoChar[704];
				UndoChar_705 = undoChar[705];
				UndoChar_706 = undoChar[706];
				UndoChar_707 = undoChar[707];
				UndoChar_708 = undoChar[708];
				UndoChar_709 = undoChar[709];
				UndoChar_710 = undoChar[710];
				UndoChar_711 = undoChar[711];
				UndoChar_712 = undoChar[712];
				UndoChar_713 = undoChar[713];
				UndoChar_714 = undoChar[714];
				UndoChar_715 = undoChar[715];
				UndoChar_716 = undoChar[716];
				UndoChar_717 = undoChar[717];
				UndoChar_718 = undoChar[718];
				UndoChar_719 = undoChar[719];
				UndoChar_720 = undoChar[720];
				UndoChar_721 = undoChar[721];
				UndoChar_722 = undoChar[722];
				UndoChar_723 = undoChar[723];
				UndoChar_724 = undoChar[724];
				UndoChar_725 = undoChar[725];
				UndoChar_726 = undoChar[726];
				UndoChar_727 = undoChar[727];
				UndoChar_728 = undoChar[728];
				UndoChar_729 = undoChar[729];
				UndoChar_730 = undoChar[730];
				UndoChar_731 = undoChar[731];
				UndoChar_732 = undoChar[732];
				UndoChar_733 = undoChar[733];
				UndoChar_734 = undoChar[734];
				UndoChar_735 = undoChar[735];
				UndoChar_736 = undoChar[736];
				UndoChar_737 = undoChar[737];
				UndoChar_738 = undoChar[738];
				UndoChar_739 = undoChar[739];
				UndoChar_740 = undoChar[740];
				UndoChar_741 = undoChar[741];
				UndoChar_742 = undoChar[742];
				UndoChar_743 = undoChar[743];
				UndoChar_744 = undoChar[744];
				UndoChar_745 = undoChar[745];
				UndoChar_746 = undoChar[746];
				UndoChar_747 = undoChar[747];
				UndoChar_748 = undoChar[748];
				UndoChar_749 = undoChar[749];
				UndoChar_750 = undoChar[750];
				UndoChar_751 = undoChar[751];
				UndoChar_752 = undoChar[752];
				UndoChar_753 = undoChar[753];
				UndoChar_754 = undoChar[754];
				UndoChar_755 = undoChar[755];
				UndoChar_756 = undoChar[756];
				UndoChar_757 = undoChar[757];
				UndoChar_758 = undoChar[758];
				UndoChar_759 = undoChar[759];
				UndoChar_760 = undoChar[760];
				UndoChar_761 = undoChar[761];
				UndoChar_762 = undoChar[762];
				UndoChar_763 = undoChar[763];
				UndoChar_764 = undoChar[764];
				UndoChar_765 = undoChar[765];
				UndoChar_766 = undoChar[766];
				UndoChar_767 = undoChar[767];
				UndoChar_768 = undoChar[768];
				UndoChar_769 = undoChar[769];
				UndoChar_770 = undoChar[770];
				UndoChar_771 = undoChar[771];
				UndoChar_772 = undoChar[772];
				UndoChar_773 = undoChar[773];
				UndoChar_774 = undoChar[774];
				UndoChar_775 = undoChar[775];
				UndoChar_776 = undoChar[776];
				UndoChar_777 = undoChar[777];
				UndoChar_778 = undoChar[778];
				UndoChar_779 = undoChar[779];
				UndoChar_780 = undoChar[780];
				UndoChar_781 = undoChar[781];
				UndoChar_782 = undoChar[782];
				UndoChar_783 = undoChar[783];
				UndoChar_784 = undoChar[784];
				UndoChar_785 = undoChar[785];
				UndoChar_786 = undoChar[786];
				UndoChar_787 = undoChar[787];
				UndoChar_788 = undoChar[788];
				UndoChar_789 = undoChar[789];
				UndoChar_790 = undoChar[790];
				UndoChar_791 = undoChar[791];
				UndoChar_792 = undoChar[792];
				UndoChar_793 = undoChar[793];
				UndoChar_794 = undoChar[794];
				UndoChar_795 = undoChar[795];
				UndoChar_796 = undoChar[796];
				UndoChar_797 = undoChar[797];
				UndoChar_798 = undoChar[798];
				UndoChar_799 = undoChar[799];
				UndoChar_800 = undoChar[800];
				UndoChar_801 = undoChar[801];
				UndoChar_802 = undoChar[802];
				UndoChar_803 = undoChar[803];
				UndoChar_804 = undoChar[804];
				UndoChar_805 = undoChar[805];
				UndoChar_806 = undoChar[806];
				UndoChar_807 = undoChar[807];
				UndoChar_808 = undoChar[808];
				UndoChar_809 = undoChar[809];
				UndoChar_810 = undoChar[810];
				UndoChar_811 = undoChar[811];
				UndoChar_812 = undoChar[812];
				UndoChar_813 = undoChar[813];
				UndoChar_814 = undoChar[814];
				UndoChar_815 = undoChar[815];
				UndoChar_816 = undoChar[816];
				UndoChar_817 = undoChar[817];
				UndoChar_818 = undoChar[818];
				UndoChar_819 = undoChar[819];
				UndoChar_820 = undoChar[820];
				UndoChar_821 = undoChar[821];
				UndoChar_822 = undoChar[822];
				UndoChar_823 = undoChar[823];
				UndoChar_824 = undoChar[824];
				UndoChar_825 = undoChar[825];
				UndoChar_826 = undoChar[826];
				UndoChar_827 = undoChar[827];
				UndoChar_828 = undoChar[828];
				UndoChar_829 = undoChar[829];
				UndoChar_830 = undoChar[830];
				UndoChar_831 = undoChar[831];
				UndoChar_832 = undoChar[832];
				UndoChar_833 = undoChar[833];
				UndoChar_834 = undoChar[834];
				UndoChar_835 = undoChar[835];
				UndoChar_836 = undoChar[836];
				UndoChar_837 = undoChar[837];
				UndoChar_838 = undoChar[838];
				UndoChar_839 = undoChar[839];
				UndoChar_840 = undoChar[840];
				UndoChar_841 = undoChar[841];
				UndoChar_842 = undoChar[842];
				UndoChar_843 = undoChar[843];
				UndoChar_844 = undoChar[844];
				UndoChar_845 = undoChar[845];
				UndoChar_846 = undoChar[846];
				UndoChar_847 = undoChar[847];
				UndoChar_848 = undoChar[848];
				UndoChar_849 = undoChar[849];
				UndoChar_850 = undoChar[850];
				UndoChar_851 = undoChar[851];
				UndoChar_852 = undoChar[852];
				UndoChar_853 = undoChar[853];
				UndoChar_854 = undoChar[854];
				UndoChar_855 = undoChar[855];
				UndoChar_856 = undoChar[856];
				UndoChar_857 = undoChar[857];
				UndoChar_858 = undoChar[858];
				UndoChar_859 = undoChar[859];
				UndoChar_860 = undoChar[860];
				UndoChar_861 = undoChar[861];
				UndoChar_862 = undoChar[862];
				UndoChar_863 = undoChar[863];
				UndoChar_864 = undoChar[864];
				UndoChar_865 = undoChar[865];
				UndoChar_866 = undoChar[866];
				UndoChar_867 = undoChar[867];
				UndoChar_868 = undoChar[868];
				UndoChar_869 = undoChar[869];
				UndoChar_870 = undoChar[870];
				UndoChar_871 = undoChar[871];
				UndoChar_872 = undoChar[872];
				UndoChar_873 = undoChar[873];
				UndoChar_874 = undoChar[874];
				UndoChar_875 = undoChar[875];
				UndoChar_876 = undoChar[876];
				UndoChar_877 = undoChar[877];
				UndoChar_878 = undoChar[878];
				UndoChar_879 = undoChar[879];
				UndoChar_880 = undoChar[880];
				UndoChar_881 = undoChar[881];
				UndoChar_882 = undoChar[882];
				UndoChar_883 = undoChar[883];
				UndoChar_884 = undoChar[884];
				UndoChar_885 = undoChar[885];
				UndoChar_886 = undoChar[886];
				UndoChar_887 = undoChar[887];
				UndoChar_888 = undoChar[888];
				UndoChar_889 = undoChar[889];
				UndoChar_890 = undoChar[890];
				UndoChar_891 = undoChar[891];
				UndoChar_892 = undoChar[892];
				UndoChar_893 = undoChar[893];
				UndoChar_894 = undoChar[894];
				UndoChar_895 = undoChar[895];
				UndoChar_896 = undoChar[896];
				UndoChar_897 = undoChar[897];
				UndoChar_898 = undoChar[898];
				UndoChar_899 = undoChar[899];
				UndoChar_900 = undoChar[900];
				UndoChar_901 = undoChar[901];
				UndoChar_902 = undoChar[902];
				UndoChar_903 = undoChar[903];
				UndoChar_904 = undoChar[904];
				UndoChar_905 = undoChar[905];
				UndoChar_906 = undoChar[906];
				UndoChar_907 = undoChar[907];
				UndoChar_908 = undoChar[908];
				UndoChar_909 = undoChar[909];
				UndoChar_910 = undoChar[910];
				UndoChar_911 = undoChar[911];
				UndoChar_912 = undoChar[912];
				UndoChar_913 = undoChar[913];
				UndoChar_914 = undoChar[914];
				UndoChar_915 = undoChar[915];
				UndoChar_916 = undoChar[916];
				UndoChar_917 = undoChar[917];
				UndoChar_918 = undoChar[918];
				UndoChar_919 = undoChar[919];
				UndoChar_920 = undoChar[920];
				UndoChar_921 = undoChar[921];
				UndoChar_922 = undoChar[922];
				UndoChar_923 = undoChar[923];
				UndoChar_924 = undoChar[924];
				UndoChar_925 = undoChar[925];
				UndoChar_926 = undoChar[926];
				UndoChar_927 = undoChar[927];
				UndoChar_928 = undoChar[928];
				UndoChar_929 = undoChar[929];
				UndoChar_930 = undoChar[930];
				UndoChar_931 = undoChar[931];
				UndoChar_932 = undoChar[932];
				UndoChar_933 = undoChar[933];
				UndoChar_934 = undoChar[934];
				UndoChar_935 = undoChar[935];
				UndoChar_936 = undoChar[936];
				UndoChar_937 = undoChar[937];
				UndoChar_938 = undoChar[938];
				UndoChar_939 = undoChar[939];
				UndoChar_940 = undoChar[940];
				UndoChar_941 = undoChar[941];
				UndoChar_942 = undoChar[942];
				UndoChar_943 = undoChar[943];
				UndoChar_944 = undoChar[944];
				UndoChar_945 = undoChar[945];
				UndoChar_946 = undoChar[946];
				UndoChar_947 = undoChar[947];
				UndoChar_948 = undoChar[948];
				UndoChar_949 = undoChar[949];
				UndoChar_950 = undoChar[950];
				UndoChar_951 = undoChar[951];
				UndoChar_952 = undoChar[952];
				UndoChar_953 = undoChar[953];
				UndoChar_954 = undoChar[954];
				UndoChar_955 = undoChar[955];
				UndoChar_956 = undoChar[956];
				UndoChar_957 = undoChar[957];
				UndoChar_958 = undoChar[958];
				UndoChar_959 = undoChar[959];
				UndoChar_960 = undoChar[960];
				UndoChar_961 = undoChar[961];
				UndoChar_962 = undoChar[962];
				UndoChar_963 = undoChar[963];
				UndoChar_964 = undoChar[964];
				UndoChar_965 = undoChar[965];
				UndoChar_966 = undoChar[966];
				UndoChar_967 = undoChar[967];
				UndoChar_968 = undoChar[968];
				UndoChar_969 = undoChar[969];
				UndoChar_970 = undoChar[970];
				UndoChar_971 = undoChar[971];
				UndoChar_972 = undoChar[972];
				UndoChar_973 = undoChar[973];
				UndoChar_974 = undoChar[974];
				UndoChar_975 = undoChar[975];
				UndoChar_976 = undoChar[976];
				UndoChar_977 = undoChar[977];
				UndoChar_978 = undoChar[978];
				UndoChar_979 = undoChar[979];
				UndoChar_980 = undoChar[980];
				UndoChar_981 = undoChar[981];
				UndoChar_982 = undoChar[982];
				UndoChar_983 = undoChar[983];
				UndoChar_984 = undoChar[984];
				UndoChar_985 = undoChar[985];
				UndoChar_986 = undoChar[986];
				UndoChar_987 = undoChar[987];
				UndoChar_988 = undoChar[988];
				UndoChar_989 = undoChar[989];
				UndoChar_990 = undoChar[990];
				UndoChar_991 = undoChar[991];
				UndoChar_992 = undoChar[992];
				UndoChar_993 = undoChar[993];
				UndoChar_994 = undoChar[994];
				UndoChar_995 = undoChar[995];
				UndoChar_996 = undoChar[996];
				UndoChar_997 = undoChar[997];
				UndoChar_998 = undoChar[998];
			}
			UndoPoint = undoPoint;
			RedoPoint = redoPoint;
			UndoCharPoint = undoCharPoint;
			RedoCharPoint = redoCharPoint;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe StbUndoState(Span<StbUndoRecord> undoRec = default, Span<char> undoChar = default, short undoPoint = default, short redoPoint = default, int undoCharPoint = default, int redoCharPoint = default)
		{
			if (undoRec != default)
			{
				UndoRec_0 = undoRec[0];
				UndoRec_1 = undoRec[1];
				UndoRec_2 = undoRec[2];
				UndoRec_3 = undoRec[3];
				UndoRec_4 = undoRec[4];
				UndoRec_5 = undoRec[5];
				UndoRec_6 = undoRec[6];
				UndoRec_7 = undoRec[7];
				UndoRec_8 = undoRec[8];
				UndoRec_9 = undoRec[9];
				UndoRec_10 = undoRec[10];
				UndoRec_11 = undoRec[11];
				UndoRec_12 = undoRec[12];
				UndoRec_13 = undoRec[13];
				UndoRec_14 = undoRec[14];
				UndoRec_15 = undoRec[15];
				UndoRec_16 = undoRec[16];
				UndoRec_17 = undoRec[17];
				UndoRec_18 = undoRec[18];
				UndoRec_19 = undoRec[19];
				UndoRec_20 = undoRec[20];
				UndoRec_21 = undoRec[21];
				UndoRec_22 = undoRec[22];
				UndoRec_23 = undoRec[23];
				UndoRec_24 = undoRec[24];
				UndoRec_25 = undoRec[25];
				UndoRec_26 = undoRec[26];
				UndoRec_27 = undoRec[27];
				UndoRec_28 = undoRec[28];
				UndoRec_29 = undoRec[29];
				UndoRec_30 = undoRec[30];
				UndoRec_31 = undoRec[31];
				UndoRec_32 = undoRec[32];
				UndoRec_33 = undoRec[33];
				UndoRec_34 = undoRec[34];
				UndoRec_35 = undoRec[35];
				UndoRec_36 = undoRec[36];
				UndoRec_37 = undoRec[37];
				UndoRec_38 = undoRec[38];
				UndoRec_39 = undoRec[39];
				UndoRec_40 = undoRec[40];
				UndoRec_41 = undoRec[41];
				UndoRec_42 = undoRec[42];
				UndoRec_43 = undoRec[43];
				UndoRec_44 = undoRec[44];
				UndoRec_45 = undoRec[45];
				UndoRec_46 = undoRec[46];
				UndoRec_47 = undoRec[47];
				UndoRec_48 = undoRec[48];
				UndoRec_49 = undoRec[49];
				UndoRec_50 = undoRec[50];
				UndoRec_51 = undoRec[51];
				UndoRec_52 = undoRec[52];
				UndoRec_53 = undoRec[53];
				UndoRec_54 = undoRec[54];
				UndoRec_55 = undoRec[55];
				UndoRec_56 = undoRec[56];
				UndoRec_57 = undoRec[57];
				UndoRec_58 = undoRec[58];
				UndoRec_59 = undoRec[59];
				UndoRec_60 = undoRec[60];
				UndoRec_61 = undoRec[61];
				UndoRec_62 = undoRec[62];
				UndoRec_63 = undoRec[63];
				UndoRec_64 = undoRec[64];
				UndoRec_65 = undoRec[65];
				UndoRec_66 = undoRec[66];
				UndoRec_67 = undoRec[67];
				UndoRec_68 = undoRec[68];
				UndoRec_69 = undoRec[69];
				UndoRec_70 = undoRec[70];
				UndoRec_71 = undoRec[71];
				UndoRec_72 = undoRec[72];
				UndoRec_73 = undoRec[73];
				UndoRec_74 = undoRec[74];
				UndoRec_75 = undoRec[75];
				UndoRec_76 = undoRec[76];
				UndoRec_77 = undoRec[77];
				UndoRec_78 = undoRec[78];
				UndoRec_79 = undoRec[79];
				UndoRec_80 = undoRec[80];
				UndoRec_81 = undoRec[81];
				UndoRec_82 = undoRec[82];
				UndoRec_83 = undoRec[83];
				UndoRec_84 = undoRec[84];
				UndoRec_85 = undoRec[85];
				UndoRec_86 = undoRec[86];
				UndoRec_87 = undoRec[87];
				UndoRec_88 = undoRec[88];
				UndoRec_89 = undoRec[89];
				UndoRec_90 = undoRec[90];
				UndoRec_91 = undoRec[91];
				UndoRec_92 = undoRec[92];
				UndoRec_93 = undoRec[93];
				UndoRec_94 = undoRec[94];
				UndoRec_95 = undoRec[95];
				UndoRec_96 = undoRec[96];
				UndoRec_97 = undoRec[97];
				UndoRec_98 = undoRec[98];
			}
			if (undoChar != default)
			{
				UndoChar_0 = undoChar[0];
				UndoChar_1 = undoChar[1];
				UndoChar_2 = undoChar[2];
				UndoChar_3 = undoChar[3];
				UndoChar_4 = undoChar[4];
				UndoChar_5 = undoChar[5];
				UndoChar_6 = undoChar[6];
				UndoChar_7 = undoChar[7];
				UndoChar_8 = undoChar[8];
				UndoChar_9 = undoChar[9];
				UndoChar_10 = undoChar[10];
				UndoChar_11 = undoChar[11];
				UndoChar_12 = undoChar[12];
				UndoChar_13 = undoChar[13];
				UndoChar_14 = undoChar[14];
				UndoChar_15 = undoChar[15];
				UndoChar_16 = undoChar[16];
				UndoChar_17 = undoChar[17];
				UndoChar_18 = undoChar[18];
				UndoChar_19 = undoChar[19];
				UndoChar_20 = undoChar[20];
				UndoChar_21 = undoChar[21];
				UndoChar_22 = undoChar[22];
				UndoChar_23 = undoChar[23];
				UndoChar_24 = undoChar[24];
				UndoChar_25 = undoChar[25];
				UndoChar_26 = undoChar[26];
				UndoChar_27 = undoChar[27];
				UndoChar_28 = undoChar[28];
				UndoChar_29 = undoChar[29];
				UndoChar_30 = undoChar[30];
				UndoChar_31 = undoChar[31];
				UndoChar_32 = undoChar[32];
				UndoChar_33 = undoChar[33];
				UndoChar_34 = undoChar[34];
				UndoChar_35 = undoChar[35];
				UndoChar_36 = undoChar[36];
				UndoChar_37 = undoChar[37];
				UndoChar_38 = undoChar[38];
				UndoChar_39 = undoChar[39];
				UndoChar_40 = undoChar[40];
				UndoChar_41 = undoChar[41];
				UndoChar_42 = undoChar[42];
				UndoChar_43 = undoChar[43];
				UndoChar_44 = undoChar[44];
				UndoChar_45 = undoChar[45];
				UndoChar_46 = undoChar[46];
				UndoChar_47 = undoChar[47];
				UndoChar_48 = undoChar[48];
				UndoChar_49 = undoChar[49];
				UndoChar_50 = undoChar[50];
				UndoChar_51 = undoChar[51];
				UndoChar_52 = undoChar[52];
				UndoChar_53 = undoChar[53];
				UndoChar_54 = undoChar[54];
				UndoChar_55 = undoChar[55];
				UndoChar_56 = undoChar[56];
				UndoChar_57 = undoChar[57];
				UndoChar_58 = undoChar[58];
				UndoChar_59 = undoChar[59];
				UndoChar_60 = undoChar[60];
				UndoChar_61 = undoChar[61];
				UndoChar_62 = undoChar[62];
				UndoChar_63 = undoChar[63];
				UndoChar_64 = undoChar[64];
				UndoChar_65 = undoChar[65];
				UndoChar_66 = undoChar[66];
				UndoChar_67 = undoChar[67];
				UndoChar_68 = undoChar[68];
				UndoChar_69 = undoChar[69];
				UndoChar_70 = undoChar[70];
				UndoChar_71 = undoChar[71];
				UndoChar_72 = undoChar[72];
				UndoChar_73 = undoChar[73];
				UndoChar_74 = undoChar[74];
				UndoChar_75 = undoChar[75];
				UndoChar_76 = undoChar[76];
				UndoChar_77 = undoChar[77];
				UndoChar_78 = undoChar[78];
				UndoChar_79 = undoChar[79];
				UndoChar_80 = undoChar[80];
				UndoChar_81 = undoChar[81];
				UndoChar_82 = undoChar[82];
				UndoChar_83 = undoChar[83];
				UndoChar_84 = undoChar[84];
				UndoChar_85 = undoChar[85];
				UndoChar_86 = undoChar[86];
				UndoChar_87 = undoChar[87];
				UndoChar_88 = undoChar[88];
				UndoChar_89 = undoChar[89];
				UndoChar_90 = undoChar[90];
				UndoChar_91 = undoChar[91];
				UndoChar_92 = undoChar[92];
				UndoChar_93 = undoChar[93];
				UndoChar_94 = undoChar[94];
				UndoChar_95 = undoChar[95];
				UndoChar_96 = undoChar[96];
				UndoChar_97 = undoChar[97];
				UndoChar_98 = undoChar[98];
				UndoChar_99 = undoChar[99];
				UndoChar_100 = undoChar[100];
				UndoChar_101 = undoChar[101];
				UndoChar_102 = undoChar[102];
				UndoChar_103 = undoChar[103];
				UndoChar_104 = undoChar[104];
				UndoChar_105 = undoChar[105];
				UndoChar_106 = undoChar[106];
				UndoChar_107 = undoChar[107];
				UndoChar_108 = undoChar[108];
				UndoChar_109 = undoChar[109];
				UndoChar_110 = undoChar[110];
				UndoChar_111 = undoChar[111];
				UndoChar_112 = undoChar[112];
				UndoChar_113 = undoChar[113];
				UndoChar_114 = undoChar[114];
				UndoChar_115 = undoChar[115];
				UndoChar_116 = undoChar[116];
				UndoChar_117 = undoChar[117];
				UndoChar_118 = undoChar[118];
				UndoChar_119 = undoChar[119];
				UndoChar_120 = undoChar[120];
				UndoChar_121 = undoChar[121];
				UndoChar_122 = undoChar[122];
				UndoChar_123 = undoChar[123];
				UndoChar_124 = undoChar[124];
				UndoChar_125 = undoChar[125];
				UndoChar_126 = undoChar[126];
				UndoChar_127 = undoChar[127];
				UndoChar_128 = undoChar[128];
				UndoChar_129 = undoChar[129];
				UndoChar_130 = undoChar[130];
				UndoChar_131 = undoChar[131];
				UndoChar_132 = undoChar[132];
				UndoChar_133 = undoChar[133];
				UndoChar_134 = undoChar[134];
				UndoChar_135 = undoChar[135];
				UndoChar_136 = undoChar[136];
				UndoChar_137 = undoChar[137];
				UndoChar_138 = undoChar[138];
				UndoChar_139 = undoChar[139];
				UndoChar_140 = undoChar[140];
				UndoChar_141 = undoChar[141];
				UndoChar_142 = undoChar[142];
				UndoChar_143 = undoChar[143];
				UndoChar_144 = undoChar[144];
				UndoChar_145 = undoChar[145];
				UndoChar_146 = undoChar[146];
				UndoChar_147 = undoChar[147];
				UndoChar_148 = undoChar[148];
				UndoChar_149 = undoChar[149];
				UndoChar_150 = undoChar[150];
				UndoChar_151 = undoChar[151];
				UndoChar_152 = undoChar[152];
				UndoChar_153 = undoChar[153];
				UndoChar_154 = undoChar[154];
				UndoChar_155 = undoChar[155];
				UndoChar_156 = undoChar[156];
				UndoChar_157 = undoChar[157];
				UndoChar_158 = undoChar[158];
				UndoChar_159 = undoChar[159];
				UndoChar_160 = undoChar[160];
				UndoChar_161 = undoChar[161];
				UndoChar_162 = undoChar[162];
				UndoChar_163 = undoChar[163];
				UndoChar_164 = undoChar[164];
				UndoChar_165 = undoChar[165];
				UndoChar_166 = undoChar[166];
				UndoChar_167 = undoChar[167];
				UndoChar_168 = undoChar[168];
				UndoChar_169 = undoChar[169];
				UndoChar_170 = undoChar[170];
				UndoChar_171 = undoChar[171];
				UndoChar_172 = undoChar[172];
				UndoChar_173 = undoChar[173];
				UndoChar_174 = undoChar[174];
				UndoChar_175 = undoChar[175];
				UndoChar_176 = undoChar[176];
				UndoChar_177 = undoChar[177];
				UndoChar_178 = undoChar[178];
				UndoChar_179 = undoChar[179];
				UndoChar_180 = undoChar[180];
				UndoChar_181 = undoChar[181];
				UndoChar_182 = undoChar[182];
				UndoChar_183 = undoChar[183];
				UndoChar_184 = undoChar[184];
				UndoChar_185 = undoChar[185];
				UndoChar_186 = undoChar[186];
				UndoChar_187 = undoChar[187];
				UndoChar_188 = undoChar[188];
				UndoChar_189 = undoChar[189];
				UndoChar_190 = undoChar[190];
				UndoChar_191 = undoChar[191];
				UndoChar_192 = undoChar[192];
				UndoChar_193 = undoChar[193];
				UndoChar_194 = undoChar[194];
				UndoChar_195 = undoChar[195];
				UndoChar_196 = undoChar[196];
				UndoChar_197 = undoChar[197];
				UndoChar_198 = undoChar[198];
				UndoChar_199 = undoChar[199];
				UndoChar_200 = undoChar[200];
				UndoChar_201 = undoChar[201];
				UndoChar_202 = undoChar[202];
				UndoChar_203 = undoChar[203];
				UndoChar_204 = undoChar[204];
				UndoChar_205 = undoChar[205];
				UndoChar_206 = undoChar[206];
				UndoChar_207 = undoChar[207];
				UndoChar_208 = undoChar[208];
				UndoChar_209 = undoChar[209];
				UndoChar_210 = undoChar[210];
				UndoChar_211 = undoChar[211];
				UndoChar_212 = undoChar[212];
				UndoChar_213 = undoChar[213];
				UndoChar_214 = undoChar[214];
				UndoChar_215 = undoChar[215];
				UndoChar_216 = undoChar[216];
				UndoChar_217 = undoChar[217];
				UndoChar_218 = undoChar[218];
				UndoChar_219 = undoChar[219];
				UndoChar_220 = undoChar[220];
				UndoChar_221 = undoChar[221];
				UndoChar_222 = undoChar[222];
				UndoChar_223 = undoChar[223];
				UndoChar_224 = undoChar[224];
				UndoChar_225 = undoChar[225];
				UndoChar_226 = undoChar[226];
				UndoChar_227 = undoChar[227];
				UndoChar_228 = undoChar[228];
				UndoChar_229 = undoChar[229];
				UndoChar_230 = undoChar[230];
				UndoChar_231 = undoChar[231];
				UndoChar_232 = undoChar[232];
				UndoChar_233 = undoChar[233];
				UndoChar_234 = undoChar[234];
				UndoChar_235 = undoChar[235];
				UndoChar_236 = undoChar[236];
				UndoChar_237 = undoChar[237];
				UndoChar_238 = undoChar[238];
				UndoChar_239 = undoChar[239];
				UndoChar_240 = undoChar[240];
				UndoChar_241 = undoChar[241];
				UndoChar_242 = undoChar[242];
				UndoChar_243 = undoChar[243];
				UndoChar_244 = undoChar[244];
				UndoChar_245 = undoChar[245];
				UndoChar_246 = undoChar[246];
				UndoChar_247 = undoChar[247];
				UndoChar_248 = undoChar[248];
				UndoChar_249 = undoChar[249];
				UndoChar_250 = undoChar[250];
				UndoChar_251 = undoChar[251];
				UndoChar_252 = undoChar[252];
				UndoChar_253 = undoChar[253];
				UndoChar_254 = undoChar[254];
				UndoChar_255 = undoChar[255];
				UndoChar_256 = undoChar[256];
				UndoChar_257 = undoChar[257];
				UndoChar_258 = undoChar[258];
				UndoChar_259 = undoChar[259];
				UndoChar_260 = undoChar[260];
				UndoChar_261 = undoChar[261];
				UndoChar_262 = undoChar[262];
				UndoChar_263 = undoChar[263];
				UndoChar_264 = undoChar[264];
				UndoChar_265 = undoChar[265];
				UndoChar_266 = undoChar[266];
				UndoChar_267 = undoChar[267];
				UndoChar_268 = undoChar[268];
				UndoChar_269 = undoChar[269];
				UndoChar_270 = undoChar[270];
				UndoChar_271 = undoChar[271];
				UndoChar_272 = undoChar[272];
				UndoChar_273 = undoChar[273];
				UndoChar_274 = undoChar[274];
				UndoChar_275 = undoChar[275];
				UndoChar_276 = undoChar[276];
				UndoChar_277 = undoChar[277];
				UndoChar_278 = undoChar[278];
				UndoChar_279 = undoChar[279];
				UndoChar_280 = undoChar[280];
				UndoChar_281 = undoChar[281];
				UndoChar_282 = undoChar[282];
				UndoChar_283 = undoChar[283];
				UndoChar_284 = undoChar[284];
				UndoChar_285 = undoChar[285];
				UndoChar_286 = undoChar[286];
				UndoChar_287 = undoChar[287];
				UndoChar_288 = undoChar[288];
				UndoChar_289 = undoChar[289];
				UndoChar_290 = undoChar[290];
				UndoChar_291 = undoChar[291];
				UndoChar_292 = undoChar[292];
				UndoChar_293 = undoChar[293];
				UndoChar_294 = undoChar[294];
				UndoChar_295 = undoChar[295];
				UndoChar_296 = undoChar[296];
				UndoChar_297 = undoChar[297];
				UndoChar_298 = undoChar[298];
				UndoChar_299 = undoChar[299];
				UndoChar_300 = undoChar[300];
				UndoChar_301 = undoChar[301];
				UndoChar_302 = undoChar[302];
				UndoChar_303 = undoChar[303];
				UndoChar_304 = undoChar[304];
				UndoChar_305 = undoChar[305];
				UndoChar_306 = undoChar[306];
				UndoChar_307 = undoChar[307];
				UndoChar_308 = undoChar[308];
				UndoChar_309 = undoChar[309];
				UndoChar_310 = undoChar[310];
				UndoChar_311 = undoChar[311];
				UndoChar_312 = undoChar[312];
				UndoChar_313 = undoChar[313];
				UndoChar_314 = undoChar[314];
				UndoChar_315 = undoChar[315];
				UndoChar_316 = undoChar[316];
				UndoChar_317 = undoChar[317];
				UndoChar_318 = undoChar[318];
				UndoChar_319 = undoChar[319];
				UndoChar_320 = undoChar[320];
				UndoChar_321 = undoChar[321];
				UndoChar_322 = undoChar[322];
				UndoChar_323 = undoChar[323];
				UndoChar_324 = undoChar[324];
				UndoChar_325 = undoChar[325];
				UndoChar_326 = undoChar[326];
				UndoChar_327 = undoChar[327];
				UndoChar_328 = undoChar[328];
				UndoChar_329 = undoChar[329];
				UndoChar_330 = undoChar[330];
				UndoChar_331 = undoChar[331];
				UndoChar_332 = undoChar[332];
				UndoChar_333 = undoChar[333];
				UndoChar_334 = undoChar[334];
				UndoChar_335 = undoChar[335];
				UndoChar_336 = undoChar[336];
				UndoChar_337 = undoChar[337];
				UndoChar_338 = undoChar[338];
				UndoChar_339 = undoChar[339];
				UndoChar_340 = undoChar[340];
				UndoChar_341 = undoChar[341];
				UndoChar_342 = undoChar[342];
				UndoChar_343 = undoChar[343];
				UndoChar_344 = undoChar[344];
				UndoChar_345 = undoChar[345];
				UndoChar_346 = undoChar[346];
				UndoChar_347 = undoChar[347];
				UndoChar_348 = undoChar[348];
				UndoChar_349 = undoChar[349];
				UndoChar_350 = undoChar[350];
				UndoChar_351 = undoChar[351];
				UndoChar_352 = undoChar[352];
				UndoChar_353 = undoChar[353];
				UndoChar_354 = undoChar[354];
				UndoChar_355 = undoChar[355];
				UndoChar_356 = undoChar[356];
				UndoChar_357 = undoChar[357];
				UndoChar_358 = undoChar[358];
				UndoChar_359 = undoChar[359];
				UndoChar_360 = undoChar[360];
				UndoChar_361 = undoChar[361];
				UndoChar_362 = undoChar[362];
				UndoChar_363 = undoChar[363];
				UndoChar_364 = undoChar[364];
				UndoChar_365 = undoChar[365];
				UndoChar_366 = undoChar[366];
				UndoChar_367 = undoChar[367];
				UndoChar_368 = undoChar[368];
				UndoChar_369 = undoChar[369];
				UndoChar_370 = undoChar[370];
				UndoChar_371 = undoChar[371];
				UndoChar_372 = undoChar[372];
				UndoChar_373 = undoChar[373];
				UndoChar_374 = undoChar[374];
				UndoChar_375 = undoChar[375];
				UndoChar_376 = undoChar[376];
				UndoChar_377 = undoChar[377];
				UndoChar_378 = undoChar[378];
				UndoChar_379 = undoChar[379];
				UndoChar_380 = undoChar[380];
				UndoChar_381 = undoChar[381];
				UndoChar_382 = undoChar[382];
				UndoChar_383 = undoChar[383];
				UndoChar_384 = undoChar[384];
				UndoChar_385 = undoChar[385];
				UndoChar_386 = undoChar[386];
				UndoChar_387 = undoChar[387];
				UndoChar_388 = undoChar[388];
				UndoChar_389 = undoChar[389];
				UndoChar_390 = undoChar[390];
				UndoChar_391 = undoChar[391];
				UndoChar_392 = undoChar[392];
				UndoChar_393 = undoChar[393];
				UndoChar_394 = undoChar[394];
				UndoChar_395 = undoChar[395];
				UndoChar_396 = undoChar[396];
				UndoChar_397 = undoChar[397];
				UndoChar_398 = undoChar[398];
				UndoChar_399 = undoChar[399];
				UndoChar_400 = undoChar[400];
				UndoChar_401 = undoChar[401];
				UndoChar_402 = undoChar[402];
				UndoChar_403 = undoChar[403];
				UndoChar_404 = undoChar[404];
				UndoChar_405 = undoChar[405];
				UndoChar_406 = undoChar[406];
				UndoChar_407 = undoChar[407];
				UndoChar_408 = undoChar[408];
				UndoChar_409 = undoChar[409];
				UndoChar_410 = undoChar[410];
				UndoChar_411 = undoChar[411];
				UndoChar_412 = undoChar[412];
				UndoChar_413 = undoChar[413];
				UndoChar_414 = undoChar[414];
				UndoChar_415 = undoChar[415];
				UndoChar_416 = undoChar[416];
				UndoChar_417 = undoChar[417];
				UndoChar_418 = undoChar[418];
				UndoChar_419 = undoChar[419];
				UndoChar_420 = undoChar[420];
				UndoChar_421 = undoChar[421];
				UndoChar_422 = undoChar[422];
				UndoChar_423 = undoChar[423];
				UndoChar_424 = undoChar[424];
				UndoChar_425 = undoChar[425];
				UndoChar_426 = undoChar[426];
				UndoChar_427 = undoChar[427];
				UndoChar_428 = undoChar[428];
				UndoChar_429 = undoChar[429];
				UndoChar_430 = undoChar[430];
				UndoChar_431 = undoChar[431];
				UndoChar_432 = undoChar[432];
				UndoChar_433 = undoChar[433];
				UndoChar_434 = undoChar[434];
				UndoChar_435 = undoChar[435];
				UndoChar_436 = undoChar[436];
				UndoChar_437 = undoChar[437];
				UndoChar_438 = undoChar[438];
				UndoChar_439 = undoChar[439];
				UndoChar_440 = undoChar[440];
				UndoChar_441 = undoChar[441];
				UndoChar_442 = undoChar[442];
				UndoChar_443 = undoChar[443];
				UndoChar_444 = undoChar[444];
				UndoChar_445 = undoChar[445];
				UndoChar_446 = undoChar[446];
				UndoChar_447 = undoChar[447];
				UndoChar_448 = undoChar[448];
				UndoChar_449 = undoChar[449];
				UndoChar_450 = undoChar[450];
				UndoChar_451 = undoChar[451];
				UndoChar_452 = undoChar[452];
				UndoChar_453 = undoChar[453];
				UndoChar_454 = undoChar[454];
				UndoChar_455 = undoChar[455];
				UndoChar_456 = undoChar[456];
				UndoChar_457 = undoChar[457];
				UndoChar_458 = undoChar[458];
				UndoChar_459 = undoChar[459];
				UndoChar_460 = undoChar[460];
				UndoChar_461 = undoChar[461];
				UndoChar_462 = undoChar[462];
				UndoChar_463 = undoChar[463];
				UndoChar_464 = undoChar[464];
				UndoChar_465 = undoChar[465];
				UndoChar_466 = undoChar[466];
				UndoChar_467 = undoChar[467];
				UndoChar_468 = undoChar[468];
				UndoChar_469 = undoChar[469];
				UndoChar_470 = undoChar[470];
				UndoChar_471 = undoChar[471];
				UndoChar_472 = undoChar[472];
				UndoChar_473 = undoChar[473];
				UndoChar_474 = undoChar[474];
				UndoChar_475 = undoChar[475];
				UndoChar_476 = undoChar[476];
				UndoChar_477 = undoChar[477];
				UndoChar_478 = undoChar[478];
				UndoChar_479 = undoChar[479];
				UndoChar_480 = undoChar[480];
				UndoChar_481 = undoChar[481];
				UndoChar_482 = undoChar[482];
				UndoChar_483 = undoChar[483];
				UndoChar_484 = undoChar[484];
				UndoChar_485 = undoChar[485];
				UndoChar_486 = undoChar[486];
				UndoChar_487 = undoChar[487];
				UndoChar_488 = undoChar[488];
				UndoChar_489 = undoChar[489];
				UndoChar_490 = undoChar[490];
				UndoChar_491 = undoChar[491];
				UndoChar_492 = undoChar[492];
				UndoChar_493 = undoChar[493];
				UndoChar_494 = undoChar[494];
				UndoChar_495 = undoChar[495];
				UndoChar_496 = undoChar[496];
				UndoChar_497 = undoChar[497];
				UndoChar_498 = undoChar[498];
				UndoChar_499 = undoChar[499];
				UndoChar_500 = undoChar[500];
				UndoChar_501 = undoChar[501];
				UndoChar_502 = undoChar[502];
				UndoChar_503 = undoChar[503];
				UndoChar_504 = undoChar[504];
				UndoChar_505 = undoChar[505];
				UndoChar_506 = undoChar[506];
				UndoChar_507 = undoChar[507];
				UndoChar_508 = undoChar[508];
				UndoChar_509 = undoChar[509];
				UndoChar_510 = undoChar[510];
				UndoChar_511 = undoChar[511];
				UndoChar_512 = undoChar[512];
				UndoChar_513 = undoChar[513];
				UndoChar_514 = undoChar[514];
				UndoChar_515 = undoChar[515];
				UndoChar_516 = undoChar[516];
				UndoChar_517 = undoChar[517];
				UndoChar_518 = undoChar[518];
				UndoChar_519 = undoChar[519];
				UndoChar_520 = undoChar[520];
				UndoChar_521 = undoChar[521];
				UndoChar_522 = undoChar[522];
				UndoChar_523 = undoChar[523];
				UndoChar_524 = undoChar[524];
				UndoChar_525 = undoChar[525];
				UndoChar_526 = undoChar[526];
				UndoChar_527 = undoChar[527];
				UndoChar_528 = undoChar[528];
				UndoChar_529 = undoChar[529];
				UndoChar_530 = undoChar[530];
				UndoChar_531 = undoChar[531];
				UndoChar_532 = undoChar[532];
				UndoChar_533 = undoChar[533];
				UndoChar_534 = undoChar[534];
				UndoChar_535 = undoChar[535];
				UndoChar_536 = undoChar[536];
				UndoChar_537 = undoChar[537];
				UndoChar_538 = undoChar[538];
				UndoChar_539 = undoChar[539];
				UndoChar_540 = undoChar[540];
				UndoChar_541 = undoChar[541];
				UndoChar_542 = undoChar[542];
				UndoChar_543 = undoChar[543];
				UndoChar_544 = undoChar[544];
				UndoChar_545 = undoChar[545];
				UndoChar_546 = undoChar[546];
				UndoChar_547 = undoChar[547];
				UndoChar_548 = undoChar[548];
				UndoChar_549 = undoChar[549];
				UndoChar_550 = undoChar[550];
				UndoChar_551 = undoChar[551];
				UndoChar_552 = undoChar[552];
				UndoChar_553 = undoChar[553];
				UndoChar_554 = undoChar[554];
				UndoChar_555 = undoChar[555];
				UndoChar_556 = undoChar[556];
				UndoChar_557 = undoChar[557];
				UndoChar_558 = undoChar[558];
				UndoChar_559 = undoChar[559];
				UndoChar_560 = undoChar[560];
				UndoChar_561 = undoChar[561];
				UndoChar_562 = undoChar[562];
				UndoChar_563 = undoChar[563];
				UndoChar_564 = undoChar[564];
				UndoChar_565 = undoChar[565];
				UndoChar_566 = undoChar[566];
				UndoChar_567 = undoChar[567];
				UndoChar_568 = undoChar[568];
				UndoChar_569 = undoChar[569];
				UndoChar_570 = undoChar[570];
				UndoChar_571 = undoChar[571];
				UndoChar_572 = undoChar[572];
				UndoChar_573 = undoChar[573];
				UndoChar_574 = undoChar[574];
				UndoChar_575 = undoChar[575];
				UndoChar_576 = undoChar[576];
				UndoChar_577 = undoChar[577];
				UndoChar_578 = undoChar[578];
				UndoChar_579 = undoChar[579];
				UndoChar_580 = undoChar[580];
				UndoChar_581 = undoChar[581];
				UndoChar_582 = undoChar[582];
				UndoChar_583 = undoChar[583];
				UndoChar_584 = undoChar[584];
				UndoChar_585 = undoChar[585];
				UndoChar_586 = undoChar[586];
				UndoChar_587 = undoChar[587];
				UndoChar_588 = undoChar[588];
				UndoChar_589 = undoChar[589];
				UndoChar_590 = undoChar[590];
				UndoChar_591 = undoChar[591];
				UndoChar_592 = undoChar[592];
				UndoChar_593 = undoChar[593];
				UndoChar_594 = undoChar[594];
				UndoChar_595 = undoChar[595];
				UndoChar_596 = undoChar[596];
				UndoChar_597 = undoChar[597];
				UndoChar_598 = undoChar[598];
				UndoChar_599 = undoChar[599];
				UndoChar_600 = undoChar[600];
				UndoChar_601 = undoChar[601];
				UndoChar_602 = undoChar[602];
				UndoChar_603 = undoChar[603];
				UndoChar_604 = undoChar[604];
				UndoChar_605 = undoChar[605];
				UndoChar_606 = undoChar[606];
				UndoChar_607 = undoChar[607];
				UndoChar_608 = undoChar[608];
				UndoChar_609 = undoChar[609];
				UndoChar_610 = undoChar[610];
				UndoChar_611 = undoChar[611];
				UndoChar_612 = undoChar[612];
				UndoChar_613 = undoChar[613];
				UndoChar_614 = undoChar[614];
				UndoChar_615 = undoChar[615];
				UndoChar_616 = undoChar[616];
				UndoChar_617 = undoChar[617];
				UndoChar_618 = undoChar[618];
				UndoChar_619 = undoChar[619];
				UndoChar_620 = undoChar[620];
				UndoChar_621 = undoChar[621];
				UndoChar_622 = undoChar[622];
				UndoChar_623 = undoChar[623];
				UndoChar_624 = undoChar[624];
				UndoChar_625 = undoChar[625];
				UndoChar_626 = undoChar[626];
				UndoChar_627 = undoChar[627];
				UndoChar_628 = undoChar[628];
				UndoChar_629 = undoChar[629];
				UndoChar_630 = undoChar[630];
				UndoChar_631 = undoChar[631];
				UndoChar_632 = undoChar[632];
				UndoChar_633 = undoChar[633];
				UndoChar_634 = undoChar[634];
				UndoChar_635 = undoChar[635];
				UndoChar_636 = undoChar[636];
				UndoChar_637 = undoChar[637];
				UndoChar_638 = undoChar[638];
				UndoChar_639 = undoChar[639];
				UndoChar_640 = undoChar[640];
				UndoChar_641 = undoChar[641];
				UndoChar_642 = undoChar[642];
				UndoChar_643 = undoChar[643];
				UndoChar_644 = undoChar[644];
				UndoChar_645 = undoChar[645];
				UndoChar_646 = undoChar[646];
				UndoChar_647 = undoChar[647];
				UndoChar_648 = undoChar[648];
				UndoChar_649 = undoChar[649];
				UndoChar_650 = undoChar[650];
				UndoChar_651 = undoChar[651];
				UndoChar_652 = undoChar[652];
				UndoChar_653 = undoChar[653];
				UndoChar_654 = undoChar[654];
				UndoChar_655 = undoChar[655];
				UndoChar_656 = undoChar[656];
				UndoChar_657 = undoChar[657];
				UndoChar_658 = undoChar[658];
				UndoChar_659 = undoChar[659];
				UndoChar_660 = undoChar[660];
				UndoChar_661 = undoChar[661];
				UndoChar_662 = undoChar[662];
				UndoChar_663 = undoChar[663];
				UndoChar_664 = undoChar[664];
				UndoChar_665 = undoChar[665];
				UndoChar_666 = undoChar[666];
				UndoChar_667 = undoChar[667];
				UndoChar_668 = undoChar[668];
				UndoChar_669 = undoChar[669];
				UndoChar_670 = undoChar[670];
				UndoChar_671 = undoChar[671];
				UndoChar_672 = undoChar[672];
				UndoChar_673 = undoChar[673];
				UndoChar_674 = undoChar[674];
				UndoChar_675 = undoChar[675];
				UndoChar_676 = undoChar[676];
				UndoChar_677 = undoChar[677];
				UndoChar_678 = undoChar[678];
				UndoChar_679 = undoChar[679];
				UndoChar_680 = undoChar[680];
				UndoChar_681 = undoChar[681];
				UndoChar_682 = undoChar[682];
				UndoChar_683 = undoChar[683];
				UndoChar_684 = undoChar[684];
				UndoChar_685 = undoChar[685];
				UndoChar_686 = undoChar[686];
				UndoChar_687 = undoChar[687];
				UndoChar_688 = undoChar[688];
				UndoChar_689 = undoChar[689];
				UndoChar_690 = undoChar[690];
				UndoChar_691 = undoChar[691];
				UndoChar_692 = undoChar[692];
				UndoChar_693 = undoChar[693];
				UndoChar_694 = undoChar[694];
				UndoChar_695 = undoChar[695];
				UndoChar_696 = undoChar[696];
				UndoChar_697 = undoChar[697];
				UndoChar_698 = undoChar[698];
				UndoChar_699 = undoChar[699];
				UndoChar_700 = undoChar[700];
				UndoChar_701 = undoChar[701];
				UndoChar_702 = undoChar[702];
				UndoChar_703 = undoChar[703];
				UndoChar_704 = undoChar[704];
				UndoChar_705 = undoChar[705];
				UndoChar_706 = undoChar[706];
				UndoChar_707 = undoChar[707];
				UndoChar_708 = undoChar[708];
				UndoChar_709 = undoChar[709];
				UndoChar_710 = undoChar[710];
				UndoChar_711 = undoChar[711];
				UndoChar_712 = undoChar[712];
				UndoChar_713 = undoChar[713];
				UndoChar_714 = undoChar[714];
				UndoChar_715 = undoChar[715];
				UndoChar_716 = undoChar[716];
				UndoChar_717 = undoChar[717];
				UndoChar_718 = undoChar[718];
				UndoChar_719 = undoChar[719];
				UndoChar_720 = undoChar[720];
				UndoChar_721 = undoChar[721];
				UndoChar_722 = undoChar[722];
				UndoChar_723 = undoChar[723];
				UndoChar_724 = undoChar[724];
				UndoChar_725 = undoChar[725];
				UndoChar_726 = undoChar[726];
				UndoChar_727 = undoChar[727];
				UndoChar_728 = undoChar[728];
				UndoChar_729 = undoChar[729];
				UndoChar_730 = undoChar[730];
				UndoChar_731 = undoChar[731];
				UndoChar_732 = undoChar[732];
				UndoChar_733 = undoChar[733];
				UndoChar_734 = undoChar[734];
				UndoChar_735 = undoChar[735];
				UndoChar_736 = undoChar[736];
				UndoChar_737 = undoChar[737];
				UndoChar_738 = undoChar[738];
				UndoChar_739 = undoChar[739];
				UndoChar_740 = undoChar[740];
				UndoChar_741 = undoChar[741];
				UndoChar_742 = undoChar[742];
				UndoChar_743 = undoChar[743];
				UndoChar_744 = undoChar[744];
				UndoChar_745 = undoChar[745];
				UndoChar_746 = undoChar[746];
				UndoChar_747 = undoChar[747];
				UndoChar_748 = undoChar[748];
				UndoChar_749 = undoChar[749];
				UndoChar_750 = undoChar[750];
				UndoChar_751 = undoChar[751];
				UndoChar_752 = undoChar[752];
				UndoChar_753 = undoChar[753];
				UndoChar_754 = undoChar[754];
				UndoChar_755 = undoChar[755];
				UndoChar_756 = undoChar[756];
				UndoChar_757 = undoChar[757];
				UndoChar_758 = undoChar[758];
				UndoChar_759 = undoChar[759];
				UndoChar_760 = undoChar[760];
				UndoChar_761 = undoChar[761];
				UndoChar_762 = undoChar[762];
				UndoChar_763 = undoChar[763];
				UndoChar_764 = undoChar[764];
				UndoChar_765 = undoChar[765];
				UndoChar_766 = undoChar[766];
				UndoChar_767 = undoChar[767];
				UndoChar_768 = undoChar[768];
				UndoChar_769 = undoChar[769];
				UndoChar_770 = undoChar[770];
				UndoChar_771 = undoChar[771];
				UndoChar_772 = undoChar[772];
				UndoChar_773 = undoChar[773];
				UndoChar_774 = undoChar[774];
				UndoChar_775 = undoChar[775];
				UndoChar_776 = undoChar[776];
				UndoChar_777 = undoChar[777];
				UndoChar_778 = undoChar[778];
				UndoChar_779 = undoChar[779];
				UndoChar_780 = undoChar[780];
				UndoChar_781 = undoChar[781];
				UndoChar_782 = undoChar[782];
				UndoChar_783 = undoChar[783];
				UndoChar_784 = undoChar[784];
				UndoChar_785 = undoChar[785];
				UndoChar_786 = undoChar[786];
				UndoChar_787 = undoChar[787];
				UndoChar_788 = undoChar[788];
				UndoChar_789 = undoChar[789];
				UndoChar_790 = undoChar[790];
				UndoChar_791 = undoChar[791];
				UndoChar_792 = undoChar[792];
				UndoChar_793 = undoChar[793];
				UndoChar_794 = undoChar[794];
				UndoChar_795 = undoChar[795];
				UndoChar_796 = undoChar[796];
				UndoChar_797 = undoChar[797];
				UndoChar_798 = undoChar[798];
				UndoChar_799 = undoChar[799];
				UndoChar_800 = undoChar[800];
				UndoChar_801 = undoChar[801];
				UndoChar_802 = undoChar[802];
				UndoChar_803 = undoChar[803];
				UndoChar_804 = undoChar[804];
				UndoChar_805 = undoChar[805];
				UndoChar_806 = undoChar[806];
				UndoChar_807 = undoChar[807];
				UndoChar_808 = undoChar[808];
				UndoChar_809 = undoChar[809];
				UndoChar_810 = undoChar[810];
				UndoChar_811 = undoChar[811];
				UndoChar_812 = undoChar[812];
				UndoChar_813 = undoChar[813];
				UndoChar_814 = undoChar[814];
				UndoChar_815 = undoChar[815];
				UndoChar_816 = undoChar[816];
				UndoChar_817 = undoChar[817];
				UndoChar_818 = undoChar[818];
				UndoChar_819 = undoChar[819];
				UndoChar_820 = undoChar[820];
				UndoChar_821 = undoChar[821];
				UndoChar_822 = undoChar[822];
				UndoChar_823 = undoChar[823];
				UndoChar_824 = undoChar[824];
				UndoChar_825 = undoChar[825];
				UndoChar_826 = undoChar[826];
				UndoChar_827 = undoChar[827];
				UndoChar_828 = undoChar[828];
				UndoChar_829 = undoChar[829];
				UndoChar_830 = undoChar[830];
				UndoChar_831 = undoChar[831];
				UndoChar_832 = undoChar[832];
				UndoChar_833 = undoChar[833];
				UndoChar_834 = undoChar[834];
				UndoChar_835 = undoChar[835];
				UndoChar_836 = undoChar[836];
				UndoChar_837 = undoChar[837];
				UndoChar_838 = undoChar[838];
				UndoChar_839 = undoChar[839];
				UndoChar_840 = undoChar[840];
				UndoChar_841 = undoChar[841];
				UndoChar_842 = undoChar[842];
				UndoChar_843 = undoChar[843];
				UndoChar_844 = undoChar[844];
				UndoChar_845 = undoChar[845];
				UndoChar_846 = undoChar[846];
				UndoChar_847 = undoChar[847];
				UndoChar_848 = undoChar[848];
				UndoChar_849 = undoChar[849];
				UndoChar_850 = undoChar[850];
				UndoChar_851 = undoChar[851];
				UndoChar_852 = undoChar[852];
				UndoChar_853 = undoChar[853];
				UndoChar_854 = undoChar[854];
				UndoChar_855 = undoChar[855];
				UndoChar_856 = undoChar[856];
				UndoChar_857 = undoChar[857];
				UndoChar_858 = undoChar[858];
				UndoChar_859 = undoChar[859];
				UndoChar_860 = undoChar[860];
				UndoChar_861 = undoChar[861];
				UndoChar_862 = undoChar[862];
				UndoChar_863 = undoChar[863];
				UndoChar_864 = undoChar[864];
				UndoChar_865 = undoChar[865];
				UndoChar_866 = undoChar[866];
				UndoChar_867 = undoChar[867];
				UndoChar_868 = undoChar[868];
				UndoChar_869 = undoChar[869];
				UndoChar_870 = undoChar[870];
				UndoChar_871 = undoChar[871];
				UndoChar_872 = undoChar[872];
				UndoChar_873 = undoChar[873];
				UndoChar_874 = undoChar[874];
				UndoChar_875 = undoChar[875];
				UndoChar_876 = undoChar[876];
				UndoChar_877 = undoChar[877];
				UndoChar_878 = undoChar[878];
				UndoChar_879 = undoChar[879];
				UndoChar_880 = undoChar[880];
				UndoChar_881 = undoChar[881];
				UndoChar_882 = undoChar[882];
				UndoChar_883 = undoChar[883];
				UndoChar_884 = undoChar[884];
				UndoChar_885 = undoChar[885];
				UndoChar_886 = undoChar[886];
				UndoChar_887 = undoChar[887];
				UndoChar_888 = undoChar[888];
				UndoChar_889 = undoChar[889];
				UndoChar_890 = undoChar[890];
				UndoChar_891 = undoChar[891];
				UndoChar_892 = undoChar[892];
				UndoChar_893 = undoChar[893];
				UndoChar_894 = undoChar[894];
				UndoChar_895 = undoChar[895];
				UndoChar_896 = undoChar[896];
				UndoChar_897 = undoChar[897];
				UndoChar_898 = undoChar[898];
				UndoChar_899 = undoChar[899];
				UndoChar_900 = undoChar[900];
				UndoChar_901 = undoChar[901];
				UndoChar_902 = undoChar[902];
				UndoChar_903 = undoChar[903];
				UndoChar_904 = undoChar[904];
				UndoChar_905 = undoChar[905];
				UndoChar_906 = undoChar[906];
				UndoChar_907 = undoChar[907];
				UndoChar_908 = undoChar[908];
				UndoChar_909 = undoChar[909];
				UndoChar_910 = undoChar[910];
				UndoChar_911 = undoChar[911];
				UndoChar_912 = undoChar[912];
				UndoChar_913 = undoChar[913];
				UndoChar_914 = undoChar[914];
				UndoChar_915 = undoChar[915];
				UndoChar_916 = undoChar[916];
				UndoChar_917 = undoChar[917];
				UndoChar_918 = undoChar[918];
				UndoChar_919 = undoChar[919];
				UndoChar_920 = undoChar[920];
				UndoChar_921 = undoChar[921];
				UndoChar_922 = undoChar[922];
				UndoChar_923 = undoChar[923];
				UndoChar_924 = undoChar[924];
				UndoChar_925 = undoChar[925];
				UndoChar_926 = undoChar[926];
				UndoChar_927 = undoChar[927];
				UndoChar_928 = undoChar[928];
				UndoChar_929 = undoChar[929];
				UndoChar_930 = undoChar[930];
				UndoChar_931 = undoChar[931];
				UndoChar_932 = undoChar[932];
				UndoChar_933 = undoChar[933];
				UndoChar_934 = undoChar[934];
				UndoChar_935 = undoChar[935];
				UndoChar_936 = undoChar[936];
				UndoChar_937 = undoChar[937];
				UndoChar_938 = undoChar[938];
				UndoChar_939 = undoChar[939];
				UndoChar_940 = undoChar[940];
				UndoChar_941 = undoChar[941];
				UndoChar_942 = undoChar[942];
				UndoChar_943 = undoChar[943];
				UndoChar_944 = undoChar[944];
				UndoChar_945 = undoChar[945];
				UndoChar_946 = undoChar[946];
				UndoChar_947 = undoChar[947];
				UndoChar_948 = undoChar[948];
				UndoChar_949 = undoChar[949];
				UndoChar_950 = undoChar[950];
				UndoChar_951 = undoChar[951];
				UndoChar_952 = undoChar[952];
				UndoChar_953 = undoChar[953];
				UndoChar_954 = undoChar[954];
				UndoChar_955 = undoChar[955];
				UndoChar_956 = undoChar[956];
				UndoChar_957 = undoChar[957];
				UndoChar_958 = undoChar[958];
				UndoChar_959 = undoChar[959];
				UndoChar_960 = undoChar[960];
				UndoChar_961 = undoChar[961];
				UndoChar_962 = undoChar[962];
				UndoChar_963 = undoChar[963];
				UndoChar_964 = undoChar[964];
				UndoChar_965 = undoChar[965];
				UndoChar_966 = undoChar[966];
				UndoChar_967 = undoChar[967];
				UndoChar_968 = undoChar[968];
				UndoChar_969 = undoChar[969];
				UndoChar_970 = undoChar[970];
				UndoChar_971 = undoChar[971];
				UndoChar_972 = undoChar[972];
				UndoChar_973 = undoChar[973];
				UndoChar_974 = undoChar[974];
				UndoChar_975 = undoChar[975];
				UndoChar_976 = undoChar[976];
				UndoChar_977 = undoChar[977];
				UndoChar_978 = undoChar[978];
				UndoChar_979 = undoChar[979];
				UndoChar_980 = undoChar[980];
				UndoChar_981 = undoChar[981];
				UndoChar_982 = undoChar[982];
				UndoChar_983 = undoChar[983];
				UndoChar_984 = undoChar[984];
				UndoChar_985 = undoChar[985];
				UndoChar_986 = undoChar[986];
				UndoChar_987 = undoChar[987];
				UndoChar_988 = undoChar[988];
				UndoChar_989 = undoChar[989];
				UndoChar_990 = undoChar[990];
				UndoChar_991 = undoChar[991];
				UndoChar_992 = undoChar[992];
				UndoChar_993 = undoChar[993];
				UndoChar_994 = undoChar[994];
				UndoChar_995 = undoChar[995];
				UndoChar_996 = undoChar[996];
				UndoChar_997 = undoChar[997];
				UndoChar_998 = undoChar[998];
			}
			UndoPoint = undoPoint;
			RedoPoint = redoPoint;
			UndoCharPoint = undoCharPoint;
			RedoCharPoint = redoCharPoint;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<StbUndoRecord> UndoRec
		
		{
			get
			{
				fixed (StbUndoRecord* p = &this.UndoRec_0)
				{
					return new Span<StbUndoRecord>(p, 99);
				}
			}
		}
		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbUndoRecord
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Where;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int InsertLength;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DeleteLength;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CharStorage;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe StbUndoRecord(int where = default, int insertLength = default, int deleteLength = default, int charStorage = default)
		{
			Where = where;
			InsertLength = insertLength;
			DeleteLength = deleteLength;
			CharStorage = charStorage;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextDeactivatedState
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorChar TextA;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputTextDeactivatedState(uint id = default, ImVectorChar textA = default)
		{
			ID = id;
			TextA = textA;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiComboPreviewData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImRect PreviewRect;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorMaxPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 BackupCursorPosPrevLine;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BackupPrevLineTextBaseOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BackupLayout;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiComboPreviewData(ImRect previewRect = default, Vector2 backupCursorPos = default, Vector2 backupCursorMaxPos = default, Vector2 backupCursorPosPrevLine = default, float backupPrevLineTextBaseOffset = default, int backupLayout = default)
		{
			PreviewRect = previewRect;
			BackupCursorPos = backupCursorPos;
			BackupCursorMaxPos = backupCursorMaxPos;
			BackupCursorPosPrevLine = backupCursorPosPrevLine;
			BackupPrevLineTextBaseOffset = backupPrevLineTextBaseOffset;
			BackupLayout = backupLayout;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTypingSelectState
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiTypingSelectRequest Request;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SearchBuffer_0;
		public byte SearchBuffer_1;
		public byte SearchBuffer_2;
		public byte SearchBuffer_3;
		public byte SearchBuffer_4;
		public byte SearchBuffer_5;
		public byte SearchBuffer_6;
		public byte SearchBuffer_7;
		public byte SearchBuffer_8;
		public byte SearchBuffer_9;
		public byte SearchBuffer_10;
		public byte SearchBuffer_11;
		public byte SearchBuffer_12;
		public byte SearchBuffer_13;
		public byte SearchBuffer_14;
		public byte SearchBuffer_15;
		public byte SearchBuffer_16;
		public byte SearchBuffer_17;
		public byte SearchBuffer_18;
		public byte SearchBuffer_19;
		public byte SearchBuffer_20;
		public byte SearchBuffer_21;
		public byte SearchBuffer_22;
		public byte SearchBuffer_23;
		public byte SearchBuffer_24;
		public byte SearchBuffer_25;
		public byte SearchBuffer_26;
		public byte SearchBuffer_27;
		public byte SearchBuffer_28;
		public byte SearchBuffer_29;
		public byte SearchBuffer_30;
		public byte SearchBuffer_31;
		public byte SearchBuffer_32;
		public byte SearchBuffer_33;
		public byte SearchBuffer_34;
		public byte SearchBuffer_35;
		public byte SearchBuffer_36;
		public byte SearchBuffer_37;
		public byte SearchBuffer_38;
		public byte SearchBuffer_39;
		public byte SearchBuffer_40;
		public byte SearchBuffer_41;
		public byte SearchBuffer_42;
		public byte SearchBuffer_43;
		public byte SearchBuffer_44;
		public byte SearchBuffer_45;
		public byte SearchBuffer_46;
		public byte SearchBuffer_47;
		public byte SearchBuffer_48;
		public byte SearchBuffer_49;
		public byte SearchBuffer_50;
		public byte SearchBuffer_51;
		public byte SearchBuffer_52;
		public byte SearchBuffer_53;
		public byte SearchBuffer_54;
		public byte SearchBuffer_55;
		public byte SearchBuffer_56;
		public byte SearchBuffer_57;
		public byte SearchBuffer_58;
		public byte SearchBuffer_59;
		public byte SearchBuffer_60;
		public byte SearchBuffer_61;
		public byte SearchBuffer_62;
		public byte SearchBuffer_63;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint FocusScope;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastRequestFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float LastRequestTime;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SingleCharModeLock;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTypingSelectState(ImGuiTypingSelectRequest request = default, byte* searchBuffer = default, uint focusScope = default, int lastRequestFrame = default, float lastRequestTime = default, bool singleCharModeLock = default)
		{
			Request = request;
			if (searchBuffer != default)
			{
				SearchBuffer_0 = searchBuffer[0];
				SearchBuffer_1 = searchBuffer[1];
				SearchBuffer_2 = searchBuffer[2];
				SearchBuffer_3 = searchBuffer[3];
				SearchBuffer_4 = searchBuffer[4];
				SearchBuffer_5 = searchBuffer[5];
				SearchBuffer_6 = searchBuffer[6];
				SearchBuffer_7 = searchBuffer[7];
				SearchBuffer_8 = searchBuffer[8];
				SearchBuffer_9 = searchBuffer[9];
				SearchBuffer_10 = searchBuffer[10];
				SearchBuffer_11 = searchBuffer[11];
				SearchBuffer_12 = searchBuffer[12];
				SearchBuffer_13 = searchBuffer[13];
				SearchBuffer_14 = searchBuffer[14];
				SearchBuffer_15 = searchBuffer[15];
				SearchBuffer_16 = searchBuffer[16];
				SearchBuffer_17 = searchBuffer[17];
				SearchBuffer_18 = searchBuffer[18];
				SearchBuffer_19 = searchBuffer[19];
				SearchBuffer_20 = searchBuffer[20];
				SearchBuffer_21 = searchBuffer[21];
				SearchBuffer_22 = searchBuffer[22];
				SearchBuffer_23 = searchBuffer[23];
				SearchBuffer_24 = searchBuffer[24];
				SearchBuffer_25 = searchBuffer[25];
				SearchBuffer_26 = searchBuffer[26];
				SearchBuffer_27 = searchBuffer[27];
				SearchBuffer_28 = searchBuffer[28];
				SearchBuffer_29 = searchBuffer[29];
				SearchBuffer_30 = searchBuffer[30];
				SearchBuffer_31 = searchBuffer[31];
				SearchBuffer_32 = searchBuffer[32];
				SearchBuffer_33 = searchBuffer[33];
				SearchBuffer_34 = searchBuffer[34];
				SearchBuffer_35 = searchBuffer[35];
				SearchBuffer_36 = searchBuffer[36];
				SearchBuffer_37 = searchBuffer[37];
				SearchBuffer_38 = searchBuffer[38];
				SearchBuffer_39 = searchBuffer[39];
				SearchBuffer_40 = searchBuffer[40];
				SearchBuffer_41 = searchBuffer[41];
				SearchBuffer_42 = searchBuffer[42];
				SearchBuffer_43 = searchBuffer[43];
				SearchBuffer_44 = searchBuffer[44];
				SearchBuffer_45 = searchBuffer[45];
				SearchBuffer_46 = searchBuffer[46];
				SearchBuffer_47 = searchBuffer[47];
				SearchBuffer_48 = searchBuffer[48];
				SearchBuffer_49 = searchBuffer[49];
				SearchBuffer_50 = searchBuffer[50];
				SearchBuffer_51 = searchBuffer[51];
				SearchBuffer_52 = searchBuffer[52];
				SearchBuffer_53 = searchBuffer[53];
				SearchBuffer_54 = searchBuffer[54];
				SearchBuffer_55 = searchBuffer[55];
				SearchBuffer_56 = searchBuffer[56];
				SearchBuffer_57 = searchBuffer[57];
				SearchBuffer_58 = searchBuffer[58];
				SearchBuffer_59 = searchBuffer[59];
				SearchBuffer_60 = searchBuffer[60];
				SearchBuffer_61 = searchBuffer[61];
				SearchBuffer_62 = searchBuffer[62];
				SearchBuffer_63 = searchBuffer[63];
			}
			FocusScope = focusScope;
			LastRequestFrame = lastRequestFrame;
			LastRequestTime = lastRequestTime;
			SingleCharModeLock = singleCharModeLock ? (byte)1 : (byte)0;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTypingSelectState(ImGuiTypingSelectRequest request = default, Span<byte> searchBuffer = default, uint focusScope = default, int lastRequestFrame = default, float lastRequestTime = default, bool singleCharModeLock = default)
		{
			Request = request;
			if (searchBuffer != default)
			{
				SearchBuffer_0 = searchBuffer[0];
				SearchBuffer_1 = searchBuffer[1];
				SearchBuffer_2 = searchBuffer[2];
				SearchBuffer_3 = searchBuffer[3];
				SearchBuffer_4 = searchBuffer[4];
				SearchBuffer_5 = searchBuffer[5];
				SearchBuffer_6 = searchBuffer[6];
				SearchBuffer_7 = searchBuffer[7];
				SearchBuffer_8 = searchBuffer[8];
				SearchBuffer_9 = searchBuffer[9];
				SearchBuffer_10 = searchBuffer[10];
				SearchBuffer_11 = searchBuffer[11];
				SearchBuffer_12 = searchBuffer[12];
				SearchBuffer_13 = searchBuffer[13];
				SearchBuffer_14 = searchBuffer[14];
				SearchBuffer_15 = searchBuffer[15];
				SearchBuffer_16 = searchBuffer[16];
				SearchBuffer_17 = searchBuffer[17];
				SearchBuffer_18 = searchBuffer[18];
				SearchBuffer_19 = searchBuffer[19];
				SearchBuffer_20 = searchBuffer[20];
				SearchBuffer_21 = searchBuffer[21];
				SearchBuffer_22 = searchBuffer[22];
				SearchBuffer_23 = searchBuffer[23];
				SearchBuffer_24 = searchBuffer[24];
				SearchBuffer_25 = searchBuffer[25];
				SearchBuffer_26 = searchBuffer[26];
				SearchBuffer_27 = searchBuffer[27];
				SearchBuffer_28 = searchBuffer[28];
				SearchBuffer_29 = searchBuffer[29];
				SearchBuffer_30 = searchBuffer[30];
				SearchBuffer_31 = searchBuffer[31];
				SearchBuffer_32 = searchBuffer[32];
				SearchBuffer_33 = searchBuffer[33];
				SearchBuffer_34 = searchBuffer[34];
				SearchBuffer_35 = searchBuffer[35];
				SearchBuffer_36 = searchBuffer[36];
				SearchBuffer_37 = searchBuffer[37];
				SearchBuffer_38 = searchBuffer[38];
				SearchBuffer_39 = searchBuffer[39];
				SearchBuffer_40 = searchBuffer[40];
				SearchBuffer_41 = searchBuffer[41];
				SearchBuffer_42 = searchBuffer[42];
				SearchBuffer_43 = searchBuffer[43];
				SearchBuffer_44 = searchBuffer[44];
				SearchBuffer_45 = searchBuffer[45];
				SearchBuffer_46 = searchBuffer[46];
				SearchBuffer_47 = searchBuffer[47];
				SearchBuffer_48 = searchBuffer[48];
				SearchBuffer_49 = searchBuffer[49];
				SearchBuffer_50 = searchBuffer[50];
				SearchBuffer_51 = searchBuffer[51];
				SearchBuffer_52 = searchBuffer[52];
				SearchBuffer_53 = searchBuffer[53];
				SearchBuffer_54 = searchBuffer[54];
				SearchBuffer_55 = searchBuffer[55];
				SearchBuffer_56 = searchBuffer[56];
				SearchBuffer_57 = searchBuffer[57];
				SearchBuffer_58 = searchBuffer[58];
				SearchBuffer_59 = searchBuffer[59];
				SearchBuffer_60 = searchBuffer[60];
				SearchBuffer_61 = searchBuffer[61];
				SearchBuffer_62 = searchBuffer[62];
				SearchBuffer_63 = searchBuffer[63];
			}
			FocusScope = focusScope;
			LastRequestFrame = lastRequestFrame;
			LastRequestTime = lastRequestTime;
			SingleCharModeLock = singleCharModeLock ? (byte)1 : (byte)0;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTypingSelectRequest
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SearchBufferLen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* SearchBuffer;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SelectRequest;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SingleCharMode;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SingleCharSize;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTypingSelectRequest(int flags = default, int searchBufferLen = default, byte* searchBuffer = default, bool selectRequest = default, bool singleCharMode = default, byte singleCharSize = default)
		{
			Flags = flags;
			SearchBufferLen = searchBufferLen;
			SearchBuffer = searchBuffer;
			SelectRequest = selectRequest ? (byte)1 : (byte)0;
			SingleCharMode = singleCharMode ? (byte)1 : (byte)0;
			SingleCharSize = singleCharSize;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockContext
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiStorage Nodes;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiDockRequest Requests;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiDockNodeSettings NodesSettings;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantFullRebuild;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDockContext(ImGuiStorage nodes = default, ImVectorImGuiDockRequest requests = default, ImVectorImGuiDockNodeSettings nodesSettings = default, bool wantFullRebuild = default)
		{
			Nodes = nodes;
			Requests = requests;
			NodesSettings = nodesSettings;
			WantFullRebuild = wantFullRebuild ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiDockRequest
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockRequest* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiDockRequest(int size = default, int capacity = default, ImGuiDockRequest* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockRequest
	{


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiDockNodeSettings
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiDockNodeSettings* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiDockNodeSettings(int size = default, int capacity = default, ImGuiDockNodeSettings* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDockNodeSettings
	{


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiSettingsHandler
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiSettingsHandler* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiSettingsHandler(int size = default, int capacity = default, ImGuiSettingsHandler* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiSettingsHandler
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* TypeName;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint TypeHash;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* ClearAllFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* ReadInitFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* ReadOpenFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* ReadLineFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* ApplyAllFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* WriteAllFn;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserData;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiSettingsHandler(byte* typeName = default, uint typeHash = default, delegate*<ImGuiContext*, ImGuiSettingsHandler*, void> clearAllFn = default, delegate*<ImGuiContext*, ImGuiSettingsHandler*, void> readInitFn = default, delegate*<ImGuiContext*, ImGuiSettingsHandler*, byte*, void*> readOpenFn = default, delegate*<ImGuiContext*, ImGuiSettingsHandler*, void*, byte*, void> readLineFn = default, delegate*<ImGuiContext*, ImGuiSettingsHandler*, void> applyAllFn = default, delegate*<ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer*, void> writeAllFn = default, void* userData = default)
		{
			TypeName = typeName;
			TypeHash = typeHash;
			ClearAllFn = (void*)clearAllFn;
			ReadInitFn = (void*)readInitFn;
			ReadOpenFn = (void*)readOpenFn;
			ReadLineFn = (void*)readLineFn;
			ApplyAllFn = (void*)applyAllFn;
			WriteAllFn = (void*)writeAllFn;
			UserData = userData;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImChunkStreamImGuiWindowSettings
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorChar Buf;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImChunkStreamImGuiWindowSettings(ImVectorChar buf = default)
		{
			Buf = buf;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImChunkStreamImGuiTableSettings
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorChar Buf;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImChunkStreamImGuiTableSettings(ImVectorChar buf = default)
		{
			Buf = buf;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiContextHook
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiContextHook* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiContextHook(int size = default, int capacity = default, ImGuiContextHook* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiContextHook
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint HookId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiContextHookType Type;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Owner;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* Callback;
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserData;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiContextHook(uint hookId = default, ImGuiContextHookType type = default, uint owner = default, ImGuiContextHookCallback callback = default, void* userData = default)
		{
			HookId = hookId;
			Type = type;
			Owner = owner;
			Callback = (void*)Marshal.GetFunctionPointerForDelegate(callback);
			UserData = userData;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextIndex
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorInt LineOffsets;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int EndOffset;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTextIndex(ImVectorInt lineOffsets = default, int endOffset = default)
		{
			LineOffsets = lineOffsets;
			EndOffset = endOffset;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorInt
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe int* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorInt(int size = default, int capacity = default, int* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiMetricsConfig
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ShowDebugLog;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ShowIDStackTool;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ShowWindowsRects;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ShowWindowsBeginOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ShowTablesRects;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ShowDrawCmdMesh;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ShowDrawCmdBoundingBoxes;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ShowAtlasTintedWithTextColor;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte ShowDockingNodes;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ShowWindowsRectsType;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int ShowTablesRectsType;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiMetricsConfig(bool showDebugLog = default, bool showIdStackTool = default, bool showWindowsRects = default, bool showWindowsBeginOrder = default, bool showTablesRects = default, bool showDrawCmdMesh = default, bool showDrawCmdBoundingBoxes = default, bool showAtlasTintedWithTextColor = default, bool showDockingNodes = default, int showWindowsRectsType = default, int showTablesRectsType = default)
		{
			ShowDebugLog = showDebugLog ? (byte)1 : (byte)0;
			ShowIDStackTool = showIdStackTool ? (byte)1 : (byte)0;
			ShowWindowsRects = showWindowsRects ? (byte)1 : (byte)0;
			ShowWindowsBeginOrder = showWindowsBeginOrder ? (byte)1 : (byte)0;
			ShowTablesRects = showTablesRects ? (byte)1 : (byte)0;
			ShowDrawCmdMesh = showDrawCmdMesh ? (byte)1 : (byte)0;
			ShowDrawCmdBoundingBoxes = showDrawCmdBoundingBoxes ? (byte)1 : (byte)0;
			ShowAtlasTintedWithTextColor = showAtlasTintedWithTextColor ? (byte)1 : (byte)0;
			ShowDockingNodes = showDockingNodes ? (byte)1 : (byte)0;
			ShowWindowsRectsType = showWindowsRectsType;
			ShowTablesRectsType = showTablesRectsType;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiIDStackTool
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int LastActiveFrame;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int StackLevel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint QueryId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiStackLevelInfo Results;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte CopyToClipboardOnCtrlC;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float CopyToClipboardLastTime;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiIDStackTool(int lastActiveFrame = default, int stackLevel = default, uint queryId = default, ImVectorImGuiStackLevelInfo results = default, bool copyToClipboardOnCtrlC = default, float copyToClipboardLastTime = default)
		{
			LastActiveFrame = lastActiveFrame;
			StackLevel = stackLevel;
			QueryId = queryId;
			Results = results;
			CopyToClipboardOnCtrlC = copyToClipboardOnCtrlC ? (byte)1 : (byte)0;
			CopyToClipboardLastTime = copyToClipboardLastTime;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiStackLevelInfo
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiStackLevelInfo* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiStackLevelInfo(int size = default, int capacity = default, ImGuiStackLevelInfo* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiStackLevelInfo
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte QueryFrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte QuerySuccess;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int DataType;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Desc_0;
		public byte Desc_1;
		public byte Desc_2;
		public byte Desc_3;
		public byte Desc_4;
		public byte Desc_5;
		public byte Desc_6;
		public byte Desc_7;
		public byte Desc_8;
		public byte Desc_9;
		public byte Desc_10;
		public byte Desc_11;
		public byte Desc_12;
		public byte Desc_13;
		public byte Desc_14;
		public byte Desc_15;
		public byte Desc_16;
		public byte Desc_17;
		public byte Desc_18;
		public byte Desc_19;
		public byte Desc_20;
		public byte Desc_21;
		public byte Desc_22;
		public byte Desc_23;
		public byte Desc_24;
		public byte Desc_25;
		public byte Desc_26;
		public byte Desc_27;
		public byte Desc_28;
		public byte Desc_29;
		public byte Desc_30;
		public byte Desc_31;
		public byte Desc_32;
		public byte Desc_33;
		public byte Desc_34;
		public byte Desc_35;
		public byte Desc_36;
		public byte Desc_37;
		public byte Desc_38;
		public byte Desc_39;
		public byte Desc_40;
		public byte Desc_41;
		public byte Desc_42;
		public byte Desc_43;
		public byte Desc_44;
		public byte Desc_45;
		public byte Desc_46;
		public byte Desc_47;
		public byte Desc_48;
		public byte Desc_49;
		public byte Desc_50;
		public byte Desc_51;
		public byte Desc_52;
		public byte Desc_53;
		public byte Desc_54;
		public byte Desc_55;
		public byte Desc_56;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiStackLevelInfo(uint id = default, byte queryFrameCount = default, bool querySuccess = default, int dataType = default, byte* desc = default)
		{
			ID = id;
			QueryFrameCount = queryFrameCount;
			QuerySuccess = querySuccess ? (byte)1 : (byte)0;
			DataType = dataType;
			if (desc != default)
			{
				Desc_0 = desc[0];
				Desc_1 = desc[1];
				Desc_2 = desc[2];
				Desc_3 = desc[3];
				Desc_4 = desc[4];
				Desc_5 = desc[5];
				Desc_6 = desc[6];
				Desc_7 = desc[7];
				Desc_8 = desc[8];
				Desc_9 = desc[9];
				Desc_10 = desc[10];
				Desc_11 = desc[11];
				Desc_12 = desc[12];
				Desc_13 = desc[13];
				Desc_14 = desc[14];
				Desc_15 = desc[15];
				Desc_16 = desc[16];
				Desc_17 = desc[17];
				Desc_18 = desc[18];
				Desc_19 = desc[19];
				Desc_20 = desc[20];
				Desc_21 = desc[21];
				Desc_22 = desc[22];
				Desc_23 = desc[23];
				Desc_24 = desc[24];
				Desc_25 = desc[25];
				Desc_26 = desc[26];
				Desc_27 = desc[27];
				Desc_28 = desc[28];
				Desc_29 = desc[29];
				Desc_30 = desc[30];
				Desc_31 = desc[31];
				Desc_32 = desc[32];
				Desc_33 = desc[33];
				Desc_34 = desc[34];
				Desc_35 = desc[35];
				Desc_36 = desc[36];
				Desc_37 = desc[37];
				Desc_38 = desc[38];
				Desc_39 = desc[39];
				Desc_40 = desc[40];
				Desc_41 = desc[41];
				Desc_42 = desc[42];
				Desc_43 = desc[43];
				Desc_44 = desc[44];
				Desc_45 = desc[45];
				Desc_46 = desc[46];
				Desc_47 = desc[47];
				Desc_48 = desc[48];
				Desc_49 = desc[49];
				Desc_50 = desc[50];
				Desc_51 = desc[51];
				Desc_52 = desc[52];
				Desc_53 = desc[53];
				Desc_54 = desc[54];
				Desc_55 = desc[55];
				Desc_56 = desc[56];
			}
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiStackLevelInfo(uint id = default, byte queryFrameCount = default, bool querySuccess = default, int dataType = default, Span<byte> desc = default)
		{
			ID = id;
			QueryFrameCount = queryFrameCount;
			QuerySuccess = querySuccess ? (byte)1 : (byte)0;
			DataType = dataType;
			if (desc != default)
			{
				Desc_0 = desc[0];
				Desc_1 = desc[1];
				Desc_2 = desc[2];
				Desc_3 = desc[3];
				Desc_4 = desc[4];
				Desc_5 = desc[5];
				Desc_6 = desc[6];
				Desc_7 = desc[7];
				Desc_8 = desc[8];
				Desc_9 = desc[9];
				Desc_10 = desc[10];
				Desc_11 = desc[11];
				Desc_12 = desc[12];
				Desc_13 = desc[13];
				Desc_14 = desc[14];
				Desc_15 = desc[15];
				Desc_16 = desc[16];
				Desc_17 = desc[17];
				Desc_18 = desc[18];
				Desc_19 = desc[19];
				Desc_20 = desc[20];
				Desc_21 = desc[21];
				Desc_22 = desc[22];
				Desc_23 = desc[23];
				Desc_24 = desc[24];
				Desc_25 = desc[25];
				Desc_26 = desc[26];
				Desc_27 = desc[27];
				Desc_28 = desc[28];
				Desc_29 = desc[29];
				Desc_30 = desc[30];
				Desc_31 = desc[31];
				Desc_32 = desc[32];
				Desc_33 = desc[33];
				Desc_34 = desc[34];
				Desc_35 = desc[35];
				Desc_36 = desc[36];
				Desc_37 = desc[37];
				Desc_38 = desc[38];
				Desc_39 = desc[39];
				Desc_40 = desc[40];
				Desc_41 = desc[41];
				Desc_42 = desc[42];
				Desc_43 = desc[43];
				Desc_44 = desc[44];
				Desc_45 = desc[45];
				Desc_46 = desc[46];
				Desc_47 = desc[47];
				Desc_48 = desc[48];
				Desc_49 = desc[49];
				Desc_50 = desc[50];
				Desc_51 = desc[51];
				Desc_52 = desc[52];
				Desc_53 = desc[53];
				Desc_54 = desc[54];
				Desc_55 = desc[55];
				Desc_56 = desc[56];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDebugAllocInfo
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int TotalAllocCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TotalFreeCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short LastEntriesIdx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiDebugAllocEntry LastEntriesBuf_0;
		public ImGuiDebugAllocEntry LastEntriesBuf_1;
		public ImGuiDebugAllocEntry LastEntriesBuf_2;
		public ImGuiDebugAllocEntry LastEntriesBuf_3;
		public ImGuiDebugAllocEntry LastEntriesBuf_4;
		public ImGuiDebugAllocEntry LastEntriesBuf_5;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDebugAllocInfo(int totalAllocCount = default, int totalFreeCount = default, short lastEntriesIdx = default, ImGuiDebugAllocEntry* lastEntriesBuf = default)
		{
			TotalAllocCount = totalAllocCount;
			TotalFreeCount = totalFreeCount;
			LastEntriesIdx = lastEntriesIdx;
			if (lastEntriesBuf != default)
			{
				LastEntriesBuf_0 = lastEntriesBuf[0];
				LastEntriesBuf_1 = lastEntriesBuf[1];
				LastEntriesBuf_2 = lastEntriesBuf[2];
				LastEntriesBuf_3 = lastEntriesBuf[3];
				LastEntriesBuf_4 = lastEntriesBuf[4];
				LastEntriesBuf_5 = lastEntriesBuf[5];
			}
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDebugAllocInfo(int totalAllocCount = default, int totalFreeCount = default, short lastEntriesIdx = default, Span<ImGuiDebugAllocEntry> lastEntriesBuf = default)
		{
			TotalAllocCount = totalAllocCount;
			TotalFreeCount = totalFreeCount;
			LastEntriesIdx = lastEntriesIdx;
			if (lastEntriesBuf != default)
			{
				LastEntriesBuf_0 = lastEntriesBuf[0];
				LastEntriesBuf_1 = lastEntriesBuf[1];
				LastEntriesBuf_2 = lastEntriesBuf[2];
				LastEntriesBuf_3 = lastEntriesBuf[3];
				LastEntriesBuf_4 = lastEntriesBuf[4];
				LastEntriesBuf_5 = lastEntriesBuf[5];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<ImGuiDebugAllocEntry> LastEntriesBuf
		
		{
			get
			{
				fixed (ImGuiDebugAllocEntry* p = &this.LastEntriesBuf_0)
				{
					return new Span<ImGuiDebugAllocEntry>(p, 6);
				}
			}
		}
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDebugAllocEntry
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int FrameCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short AllocCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short FreeCount;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDebugAllocEntry(int frameCount = default, short allocCount = default, short freeCount = default)
		{
			FrameCount = frameCount;
			AllocCount = allocCount;
			FreeCount = freeCount;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextCallbackData
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiContext* Ctx;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int EventFlag;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public char EventChar;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiKey EventKey;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Buf;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BufTextLen;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int BufSize;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte BufDirty;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CursorPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SelectionStart;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SelectionEnd;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiInputTextCallbackData(ImGuiContext* ctx = default, int eventFlag = default, int flags = default, void* userData = default, char eventChar = default, ImGuiKey eventKey = default, byte* buf = default, int bufTextLen = default, int bufSize = default, bool bufDirty = default, int cursorPos = default, int selectionStart = default, int selectionEnd = default)
		{
			Ctx = ctx;
			EventFlag = eventFlag;
			Flags = flags;
			UserData = userData;
			EventChar = eventChar;
			EventKey = eventKey;
			Buf = buf;
			BufTextLen = bufTextLen;
			BufSize = bufSize;
			BufDirty = bufDirty ? (byte)1 : (byte)0;
			CursorPos = cursorPos;
			SelectionStart = selectionStart;
			SelectionEnd = selectionEnd;
		}


		public unsafe void ClearSelection()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.ClearSelectionNative(@this);
			}
		}

		public unsafe void DeleteChars( int pos,  int bytesCount)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.DeleteCharsNative(@this, pos, bytesCount);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool HasSelection()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte ret = ImGui.HasSelectionNative(@this);
				return ret != 0;
			}
		}

		public unsafe void InsertChars( int pos,  byte* text,  byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.InsertCharsNative(@this, pos, text, textEnd);
			}
		}

		public unsafe void InsertChars( int pos,  byte* text)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.InsertCharsNative(@this, pos, text, (byte*)(default));
			}
		}

		public unsafe void InsertChars( int pos,  ref byte text,  byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.InsertCharsNative(@this, pos, (byte*)ptext, textEnd);
				}
			}
		}

		public unsafe void InsertChars( int pos,  ref byte text)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					ImGui.InsertCharsNative(@this, pos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		public unsafe void InsertChars( int pos,  string text,  byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void InsertChars( int pos,  string text)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void InsertChars( int pos,  byte* text,  ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.InsertCharsNative(@this, pos, text, (byte*)ptextEnd);
				}
			}
		}

		public unsafe void InsertChars( int pos,  byte* text,  string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void InsertChars( int pos,  ref byte text,  ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.InsertCharsNative(@this, pos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}

		public unsafe void InsertChars( int pos,  string text,  string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.InsertCharsNative(@this, pos, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void SelectAll()
		{
			fixed (ImGuiInputTextCallbackData* @this = &this)
			{
				ImGui.SelectAllNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiOnceUponAFrame
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int RefFrame;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiOnceUponAFrame(int refFrame = default)
		{
			RefFrame = refFrame;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiOnceUponAFrame* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextFilter
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte InputBuf_0;
		public byte InputBuf_1;
		public byte InputBuf_2;
		public byte InputBuf_3;
		public byte InputBuf_4;
		public byte InputBuf_5;
		public byte InputBuf_6;
		public byte InputBuf_7;
		public byte InputBuf_8;
		public byte InputBuf_9;
		public byte InputBuf_10;
		public byte InputBuf_11;
		public byte InputBuf_12;
		public byte InputBuf_13;
		public byte InputBuf_14;
		public byte InputBuf_15;
		public byte InputBuf_16;
		public byte InputBuf_17;
		public byte InputBuf_18;
		public byte InputBuf_19;
		public byte InputBuf_20;
		public byte InputBuf_21;
		public byte InputBuf_22;
		public byte InputBuf_23;
		public byte InputBuf_24;
		public byte InputBuf_25;
		public byte InputBuf_26;
		public byte InputBuf_27;
		public byte InputBuf_28;
		public byte InputBuf_29;
		public byte InputBuf_30;
		public byte InputBuf_31;
		public byte InputBuf_32;
		public byte InputBuf_33;
		public byte InputBuf_34;
		public byte InputBuf_35;
		public byte InputBuf_36;
		public byte InputBuf_37;
		public byte InputBuf_38;
		public byte InputBuf_39;
		public byte InputBuf_40;
		public byte InputBuf_41;
		public byte InputBuf_42;
		public byte InputBuf_43;
		public byte InputBuf_44;
		public byte InputBuf_45;
		public byte InputBuf_46;
		public byte InputBuf_47;
		public byte InputBuf_48;
		public byte InputBuf_49;
		public byte InputBuf_50;
		public byte InputBuf_51;
		public byte InputBuf_52;
		public byte InputBuf_53;
		public byte InputBuf_54;
		public byte InputBuf_55;
		public byte InputBuf_56;
		public byte InputBuf_57;
		public byte InputBuf_58;
		public byte InputBuf_59;
		public byte InputBuf_60;
		public byte InputBuf_61;
		public byte InputBuf_62;
		public byte InputBuf_63;
		public byte InputBuf_64;
		public byte InputBuf_65;
		public byte InputBuf_66;
		public byte InputBuf_67;
		public byte InputBuf_68;
		public byte InputBuf_69;
		public byte InputBuf_70;
		public byte InputBuf_71;
		public byte InputBuf_72;
		public byte InputBuf_73;
		public byte InputBuf_74;
		public byte InputBuf_75;
		public byte InputBuf_76;
		public byte InputBuf_77;
		public byte InputBuf_78;
		public byte InputBuf_79;
		public byte InputBuf_80;
		public byte InputBuf_81;
		public byte InputBuf_82;
		public byte InputBuf_83;
		public byte InputBuf_84;
		public byte InputBuf_85;
		public byte InputBuf_86;
		public byte InputBuf_87;
		public byte InputBuf_88;
		public byte InputBuf_89;
		public byte InputBuf_90;
		public byte InputBuf_91;
		public byte InputBuf_92;
		public byte InputBuf_93;
		public byte InputBuf_94;
		public byte InputBuf_95;
		public byte InputBuf_96;
		public byte InputBuf_97;
		public byte InputBuf_98;
		public byte InputBuf_99;
		public byte InputBuf_100;
		public byte InputBuf_101;
		public byte InputBuf_102;
		public byte InputBuf_103;
		public byte InputBuf_104;
		public byte InputBuf_105;
		public byte InputBuf_106;
		public byte InputBuf_107;
		public byte InputBuf_108;
		public byte InputBuf_109;
		public byte InputBuf_110;
		public byte InputBuf_111;
		public byte InputBuf_112;
		public byte InputBuf_113;
		public byte InputBuf_114;
		public byte InputBuf_115;
		public byte InputBuf_116;
		public byte InputBuf_117;
		public byte InputBuf_118;
		public byte InputBuf_119;
		public byte InputBuf_120;
		public byte InputBuf_121;
		public byte InputBuf_122;
		public byte InputBuf_123;
		public byte InputBuf_124;
		public byte InputBuf_125;
		public byte InputBuf_126;
		public byte InputBuf_127;
		public byte InputBuf_128;
		public byte InputBuf_129;
		public byte InputBuf_130;
		public byte InputBuf_131;
		public byte InputBuf_132;
		public byte InputBuf_133;
		public byte InputBuf_134;
		public byte InputBuf_135;
		public byte InputBuf_136;
		public byte InputBuf_137;
		public byte InputBuf_138;
		public byte InputBuf_139;
		public byte InputBuf_140;
		public byte InputBuf_141;
		public byte InputBuf_142;
		public byte InputBuf_143;
		public byte InputBuf_144;
		public byte InputBuf_145;
		public byte InputBuf_146;
		public byte InputBuf_147;
		public byte InputBuf_148;
		public byte InputBuf_149;
		public byte InputBuf_150;
		public byte InputBuf_151;
		public byte InputBuf_152;
		public byte InputBuf_153;
		public byte InputBuf_154;
		public byte InputBuf_155;
		public byte InputBuf_156;
		public byte InputBuf_157;
		public byte InputBuf_158;
		public byte InputBuf_159;
		public byte InputBuf_160;
		public byte InputBuf_161;
		public byte InputBuf_162;
		public byte InputBuf_163;
		public byte InputBuf_164;
		public byte InputBuf_165;
		public byte InputBuf_166;
		public byte InputBuf_167;
		public byte InputBuf_168;
		public byte InputBuf_169;
		public byte InputBuf_170;
		public byte InputBuf_171;
		public byte InputBuf_172;
		public byte InputBuf_173;
		public byte InputBuf_174;
		public byte InputBuf_175;
		public byte InputBuf_176;
		public byte InputBuf_177;
		public byte InputBuf_178;
		public byte InputBuf_179;
		public byte InputBuf_180;
		public byte InputBuf_181;
		public byte InputBuf_182;
		public byte InputBuf_183;
		public byte InputBuf_184;
		public byte InputBuf_185;
		public byte InputBuf_186;
		public byte InputBuf_187;
		public byte InputBuf_188;
		public byte InputBuf_189;
		public byte InputBuf_190;
		public byte InputBuf_191;
		public byte InputBuf_192;
		public byte InputBuf_193;
		public byte InputBuf_194;
		public byte InputBuf_195;
		public byte InputBuf_196;
		public byte InputBuf_197;
		public byte InputBuf_198;
		public byte InputBuf_199;
		public byte InputBuf_200;
		public byte InputBuf_201;
		public byte InputBuf_202;
		public byte InputBuf_203;
		public byte InputBuf_204;
		public byte InputBuf_205;
		public byte InputBuf_206;
		public byte InputBuf_207;
		public byte InputBuf_208;
		public byte InputBuf_209;
		public byte InputBuf_210;
		public byte InputBuf_211;
		public byte InputBuf_212;
		public byte InputBuf_213;
		public byte InputBuf_214;
		public byte InputBuf_215;
		public byte InputBuf_216;
		public byte InputBuf_217;
		public byte InputBuf_218;
		public byte InputBuf_219;
		public byte InputBuf_220;
		public byte InputBuf_221;
		public byte InputBuf_222;
		public byte InputBuf_223;
		public byte InputBuf_224;
		public byte InputBuf_225;
		public byte InputBuf_226;
		public byte InputBuf_227;
		public byte InputBuf_228;
		public byte InputBuf_229;
		public byte InputBuf_230;
		public byte InputBuf_231;
		public byte InputBuf_232;
		public byte InputBuf_233;
		public byte InputBuf_234;
		public byte InputBuf_235;
		public byte InputBuf_236;
		public byte InputBuf_237;
		public byte InputBuf_238;
		public byte InputBuf_239;
		public byte InputBuf_240;
		public byte InputBuf_241;
		public byte InputBuf_242;
		public byte InputBuf_243;
		public byte InputBuf_244;
		public byte InputBuf_245;
		public byte InputBuf_246;
		public byte InputBuf_247;
		public byte InputBuf_248;
		public byte InputBuf_249;
		public byte InputBuf_250;
		public byte InputBuf_251;
		public byte InputBuf_252;
		public byte InputBuf_253;
		public byte InputBuf_254;
		public byte InputBuf_255;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImGuiTextRange Filters;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int CountGrep;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTextFilter(byte* inputBuf = default, ImVectorImGuiTextRange filters = default, int countGrep = default)
		{
			if (inputBuf != default)
			{
				InputBuf_0 = inputBuf[0];
				InputBuf_1 = inputBuf[1];
				InputBuf_2 = inputBuf[2];
				InputBuf_3 = inputBuf[3];
				InputBuf_4 = inputBuf[4];
				InputBuf_5 = inputBuf[5];
				InputBuf_6 = inputBuf[6];
				InputBuf_7 = inputBuf[7];
				InputBuf_8 = inputBuf[8];
				InputBuf_9 = inputBuf[9];
				InputBuf_10 = inputBuf[10];
				InputBuf_11 = inputBuf[11];
				InputBuf_12 = inputBuf[12];
				InputBuf_13 = inputBuf[13];
				InputBuf_14 = inputBuf[14];
				InputBuf_15 = inputBuf[15];
				InputBuf_16 = inputBuf[16];
				InputBuf_17 = inputBuf[17];
				InputBuf_18 = inputBuf[18];
				InputBuf_19 = inputBuf[19];
				InputBuf_20 = inputBuf[20];
				InputBuf_21 = inputBuf[21];
				InputBuf_22 = inputBuf[22];
				InputBuf_23 = inputBuf[23];
				InputBuf_24 = inputBuf[24];
				InputBuf_25 = inputBuf[25];
				InputBuf_26 = inputBuf[26];
				InputBuf_27 = inputBuf[27];
				InputBuf_28 = inputBuf[28];
				InputBuf_29 = inputBuf[29];
				InputBuf_30 = inputBuf[30];
				InputBuf_31 = inputBuf[31];
				InputBuf_32 = inputBuf[32];
				InputBuf_33 = inputBuf[33];
				InputBuf_34 = inputBuf[34];
				InputBuf_35 = inputBuf[35];
				InputBuf_36 = inputBuf[36];
				InputBuf_37 = inputBuf[37];
				InputBuf_38 = inputBuf[38];
				InputBuf_39 = inputBuf[39];
				InputBuf_40 = inputBuf[40];
				InputBuf_41 = inputBuf[41];
				InputBuf_42 = inputBuf[42];
				InputBuf_43 = inputBuf[43];
				InputBuf_44 = inputBuf[44];
				InputBuf_45 = inputBuf[45];
				InputBuf_46 = inputBuf[46];
				InputBuf_47 = inputBuf[47];
				InputBuf_48 = inputBuf[48];
				InputBuf_49 = inputBuf[49];
				InputBuf_50 = inputBuf[50];
				InputBuf_51 = inputBuf[51];
				InputBuf_52 = inputBuf[52];
				InputBuf_53 = inputBuf[53];
				InputBuf_54 = inputBuf[54];
				InputBuf_55 = inputBuf[55];
				InputBuf_56 = inputBuf[56];
				InputBuf_57 = inputBuf[57];
				InputBuf_58 = inputBuf[58];
				InputBuf_59 = inputBuf[59];
				InputBuf_60 = inputBuf[60];
				InputBuf_61 = inputBuf[61];
				InputBuf_62 = inputBuf[62];
				InputBuf_63 = inputBuf[63];
				InputBuf_64 = inputBuf[64];
				InputBuf_65 = inputBuf[65];
				InputBuf_66 = inputBuf[66];
				InputBuf_67 = inputBuf[67];
				InputBuf_68 = inputBuf[68];
				InputBuf_69 = inputBuf[69];
				InputBuf_70 = inputBuf[70];
				InputBuf_71 = inputBuf[71];
				InputBuf_72 = inputBuf[72];
				InputBuf_73 = inputBuf[73];
				InputBuf_74 = inputBuf[74];
				InputBuf_75 = inputBuf[75];
				InputBuf_76 = inputBuf[76];
				InputBuf_77 = inputBuf[77];
				InputBuf_78 = inputBuf[78];
				InputBuf_79 = inputBuf[79];
				InputBuf_80 = inputBuf[80];
				InputBuf_81 = inputBuf[81];
				InputBuf_82 = inputBuf[82];
				InputBuf_83 = inputBuf[83];
				InputBuf_84 = inputBuf[84];
				InputBuf_85 = inputBuf[85];
				InputBuf_86 = inputBuf[86];
				InputBuf_87 = inputBuf[87];
				InputBuf_88 = inputBuf[88];
				InputBuf_89 = inputBuf[89];
				InputBuf_90 = inputBuf[90];
				InputBuf_91 = inputBuf[91];
				InputBuf_92 = inputBuf[92];
				InputBuf_93 = inputBuf[93];
				InputBuf_94 = inputBuf[94];
				InputBuf_95 = inputBuf[95];
				InputBuf_96 = inputBuf[96];
				InputBuf_97 = inputBuf[97];
				InputBuf_98 = inputBuf[98];
				InputBuf_99 = inputBuf[99];
				InputBuf_100 = inputBuf[100];
				InputBuf_101 = inputBuf[101];
				InputBuf_102 = inputBuf[102];
				InputBuf_103 = inputBuf[103];
				InputBuf_104 = inputBuf[104];
				InputBuf_105 = inputBuf[105];
				InputBuf_106 = inputBuf[106];
				InputBuf_107 = inputBuf[107];
				InputBuf_108 = inputBuf[108];
				InputBuf_109 = inputBuf[109];
				InputBuf_110 = inputBuf[110];
				InputBuf_111 = inputBuf[111];
				InputBuf_112 = inputBuf[112];
				InputBuf_113 = inputBuf[113];
				InputBuf_114 = inputBuf[114];
				InputBuf_115 = inputBuf[115];
				InputBuf_116 = inputBuf[116];
				InputBuf_117 = inputBuf[117];
				InputBuf_118 = inputBuf[118];
				InputBuf_119 = inputBuf[119];
				InputBuf_120 = inputBuf[120];
				InputBuf_121 = inputBuf[121];
				InputBuf_122 = inputBuf[122];
				InputBuf_123 = inputBuf[123];
				InputBuf_124 = inputBuf[124];
				InputBuf_125 = inputBuf[125];
				InputBuf_126 = inputBuf[126];
				InputBuf_127 = inputBuf[127];
				InputBuf_128 = inputBuf[128];
				InputBuf_129 = inputBuf[129];
				InputBuf_130 = inputBuf[130];
				InputBuf_131 = inputBuf[131];
				InputBuf_132 = inputBuf[132];
				InputBuf_133 = inputBuf[133];
				InputBuf_134 = inputBuf[134];
				InputBuf_135 = inputBuf[135];
				InputBuf_136 = inputBuf[136];
				InputBuf_137 = inputBuf[137];
				InputBuf_138 = inputBuf[138];
				InputBuf_139 = inputBuf[139];
				InputBuf_140 = inputBuf[140];
				InputBuf_141 = inputBuf[141];
				InputBuf_142 = inputBuf[142];
				InputBuf_143 = inputBuf[143];
				InputBuf_144 = inputBuf[144];
				InputBuf_145 = inputBuf[145];
				InputBuf_146 = inputBuf[146];
				InputBuf_147 = inputBuf[147];
				InputBuf_148 = inputBuf[148];
				InputBuf_149 = inputBuf[149];
				InputBuf_150 = inputBuf[150];
				InputBuf_151 = inputBuf[151];
				InputBuf_152 = inputBuf[152];
				InputBuf_153 = inputBuf[153];
				InputBuf_154 = inputBuf[154];
				InputBuf_155 = inputBuf[155];
				InputBuf_156 = inputBuf[156];
				InputBuf_157 = inputBuf[157];
				InputBuf_158 = inputBuf[158];
				InputBuf_159 = inputBuf[159];
				InputBuf_160 = inputBuf[160];
				InputBuf_161 = inputBuf[161];
				InputBuf_162 = inputBuf[162];
				InputBuf_163 = inputBuf[163];
				InputBuf_164 = inputBuf[164];
				InputBuf_165 = inputBuf[165];
				InputBuf_166 = inputBuf[166];
				InputBuf_167 = inputBuf[167];
				InputBuf_168 = inputBuf[168];
				InputBuf_169 = inputBuf[169];
				InputBuf_170 = inputBuf[170];
				InputBuf_171 = inputBuf[171];
				InputBuf_172 = inputBuf[172];
				InputBuf_173 = inputBuf[173];
				InputBuf_174 = inputBuf[174];
				InputBuf_175 = inputBuf[175];
				InputBuf_176 = inputBuf[176];
				InputBuf_177 = inputBuf[177];
				InputBuf_178 = inputBuf[178];
				InputBuf_179 = inputBuf[179];
				InputBuf_180 = inputBuf[180];
				InputBuf_181 = inputBuf[181];
				InputBuf_182 = inputBuf[182];
				InputBuf_183 = inputBuf[183];
				InputBuf_184 = inputBuf[184];
				InputBuf_185 = inputBuf[185];
				InputBuf_186 = inputBuf[186];
				InputBuf_187 = inputBuf[187];
				InputBuf_188 = inputBuf[188];
				InputBuf_189 = inputBuf[189];
				InputBuf_190 = inputBuf[190];
				InputBuf_191 = inputBuf[191];
				InputBuf_192 = inputBuf[192];
				InputBuf_193 = inputBuf[193];
				InputBuf_194 = inputBuf[194];
				InputBuf_195 = inputBuf[195];
				InputBuf_196 = inputBuf[196];
				InputBuf_197 = inputBuf[197];
				InputBuf_198 = inputBuf[198];
				InputBuf_199 = inputBuf[199];
				InputBuf_200 = inputBuf[200];
				InputBuf_201 = inputBuf[201];
				InputBuf_202 = inputBuf[202];
				InputBuf_203 = inputBuf[203];
				InputBuf_204 = inputBuf[204];
				InputBuf_205 = inputBuf[205];
				InputBuf_206 = inputBuf[206];
				InputBuf_207 = inputBuf[207];
				InputBuf_208 = inputBuf[208];
				InputBuf_209 = inputBuf[209];
				InputBuf_210 = inputBuf[210];
				InputBuf_211 = inputBuf[211];
				InputBuf_212 = inputBuf[212];
				InputBuf_213 = inputBuf[213];
				InputBuf_214 = inputBuf[214];
				InputBuf_215 = inputBuf[215];
				InputBuf_216 = inputBuf[216];
				InputBuf_217 = inputBuf[217];
				InputBuf_218 = inputBuf[218];
				InputBuf_219 = inputBuf[219];
				InputBuf_220 = inputBuf[220];
				InputBuf_221 = inputBuf[221];
				InputBuf_222 = inputBuf[222];
				InputBuf_223 = inputBuf[223];
				InputBuf_224 = inputBuf[224];
				InputBuf_225 = inputBuf[225];
				InputBuf_226 = inputBuf[226];
				InputBuf_227 = inputBuf[227];
				InputBuf_228 = inputBuf[228];
				InputBuf_229 = inputBuf[229];
				InputBuf_230 = inputBuf[230];
				InputBuf_231 = inputBuf[231];
				InputBuf_232 = inputBuf[232];
				InputBuf_233 = inputBuf[233];
				InputBuf_234 = inputBuf[234];
				InputBuf_235 = inputBuf[235];
				InputBuf_236 = inputBuf[236];
				InputBuf_237 = inputBuf[237];
				InputBuf_238 = inputBuf[238];
				InputBuf_239 = inputBuf[239];
				InputBuf_240 = inputBuf[240];
				InputBuf_241 = inputBuf[241];
				InputBuf_242 = inputBuf[242];
				InputBuf_243 = inputBuf[243];
				InputBuf_244 = inputBuf[244];
				InputBuf_245 = inputBuf[245];
				InputBuf_246 = inputBuf[246];
				InputBuf_247 = inputBuf[247];
				InputBuf_248 = inputBuf[248];
				InputBuf_249 = inputBuf[249];
				InputBuf_250 = inputBuf[250];
				InputBuf_251 = inputBuf[251];
				InputBuf_252 = inputBuf[252];
				InputBuf_253 = inputBuf[253];
				InputBuf_254 = inputBuf[254];
				InputBuf_255 = inputBuf[255];
			}
			Filters = filters;
			CountGrep = countGrep;
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTextFilter(Span<byte> inputBuf = default, ImVectorImGuiTextRange filters = default, int countGrep = default)
		{
			if (inputBuf != default)
			{
				InputBuf_0 = inputBuf[0];
				InputBuf_1 = inputBuf[1];
				InputBuf_2 = inputBuf[2];
				InputBuf_3 = inputBuf[3];
				InputBuf_4 = inputBuf[4];
				InputBuf_5 = inputBuf[5];
				InputBuf_6 = inputBuf[6];
				InputBuf_7 = inputBuf[7];
				InputBuf_8 = inputBuf[8];
				InputBuf_9 = inputBuf[9];
				InputBuf_10 = inputBuf[10];
				InputBuf_11 = inputBuf[11];
				InputBuf_12 = inputBuf[12];
				InputBuf_13 = inputBuf[13];
				InputBuf_14 = inputBuf[14];
				InputBuf_15 = inputBuf[15];
				InputBuf_16 = inputBuf[16];
				InputBuf_17 = inputBuf[17];
				InputBuf_18 = inputBuf[18];
				InputBuf_19 = inputBuf[19];
				InputBuf_20 = inputBuf[20];
				InputBuf_21 = inputBuf[21];
				InputBuf_22 = inputBuf[22];
				InputBuf_23 = inputBuf[23];
				InputBuf_24 = inputBuf[24];
				InputBuf_25 = inputBuf[25];
				InputBuf_26 = inputBuf[26];
				InputBuf_27 = inputBuf[27];
				InputBuf_28 = inputBuf[28];
				InputBuf_29 = inputBuf[29];
				InputBuf_30 = inputBuf[30];
				InputBuf_31 = inputBuf[31];
				InputBuf_32 = inputBuf[32];
				InputBuf_33 = inputBuf[33];
				InputBuf_34 = inputBuf[34];
				InputBuf_35 = inputBuf[35];
				InputBuf_36 = inputBuf[36];
				InputBuf_37 = inputBuf[37];
				InputBuf_38 = inputBuf[38];
				InputBuf_39 = inputBuf[39];
				InputBuf_40 = inputBuf[40];
				InputBuf_41 = inputBuf[41];
				InputBuf_42 = inputBuf[42];
				InputBuf_43 = inputBuf[43];
				InputBuf_44 = inputBuf[44];
				InputBuf_45 = inputBuf[45];
				InputBuf_46 = inputBuf[46];
				InputBuf_47 = inputBuf[47];
				InputBuf_48 = inputBuf[48];
				InputBuf_49 = inputBuf[49];
				InputBuf_50 = inputBuf[50];
				InputBuf_51 = inputBuf[51];
				InputBuf_52 = inputBuf[52];
				InputBuf_53 = inputBuf[53];
				InputBuf_54 = inputBuf[54];
				InputBuf_55 = inputBuf[55];
				InputBuf_56 = inputBuf[56];
				InputBuf_57 = inputBuf[57];
				InputBuf_58 = inputBuf[58];
				InputBuf_59 = inputBuf[59];
				InputBuf_60 = inputBuf[60];
				InputBuf_61 = inputBuf[61];
				InputBuf_62 = inputBuf[62];
				InputBuf_63 = inputBuf[63];
				InputBuf_64 = inputBuf[64];
				InputBuf_65 = inputBuf[65];
				InputBuf_66 = inputBuf[66];
				InputBuf_67 = inputBuf[67];
				InputBuf_68 = inputBuf[68];
				InputBuf_69 = inputBuf[69];
				InputBuf_70 = inputBuf[70];
				InputBuf_71 = inputBuf[71];
				InputBuf_72 = inputBuf[72];
				InputBuf_73 = inputBuf[73];
				InputBuf_74 = inputBuf[74];
				InputBuf_75 = inputBuf[75];
				InputBuf_76 = inputBuf[76];
				InputBuf_77 = inputBuf[77];
				InputBuf_78 = inputBuf[78];
				InputBuf_79 = inputBuf[79];
				InputBuf_80 = inputBuf[80];
				InputBuf_81 = inputBuf[81];
				InputBuf_82 = inputBuf[82];
				InputBuf_83 = inputBuf[83];
				InputBuf_84 = inputBuf[84];
				InputBuf_85 = inputBuf[85];
				InputBuf_86 = inputBuf[86];
				InputBuf_87 = inputBuf[87];
				InputBuf_88 = inputBuf[88];
				InputBuf_89 = inputBuf[89];
				InputBuf_90 = inputBuf[90];
				InputBuf_91 = inputBuf[91];
				InputBuf_92 = inputBuf[92];
				InputBuf_93 = inputBuf[93];
				InputBuf_94 = inputBuf[94];
				InputBuf_95 = inputBuf[95];
				InputBuf_96 = inputBuf[96];
				InputBuf_97 = inputBuf[97];
				InputBuf_98 = inputBuf[98];
				InputBuf_99 = inputBuf[99];
				InputBuf_100 = inputBuf[100];
				InputBuf_101 = inputBuf[101];
				InputBuf_102 = inputBuf[102];
				InputBuf_103 = inputBuf[103];
				InputBuf_104 = inputBuf[104];
				InputBuf_105 = inputBuf[105];
				InputBuf_106 = inputBuf[106];
				InputBuf_107 = inputBuf[107];
				InputBuf_108 = inputBuf[108];
				InputBuf_109 = inputBuf[109];
				InputBuf_110 = inputBuf[110];
				InputBuf_111 = inputBuf[111];
				InputBuf_112 = inputBuf[112];
				InputBuf_113 = inputBuf[113];
				InputBuf_114 = inputBuf[114];
				InputBuf_115 = inputBuf[115];
				InputBuf_116 = inputBuf[116];
				InputBuf_117 = inputBuf[117];
				InputBuf_118 = inputBuf[118];
				InputBuf_119 = inputBuf[119];
				InputBuf_120 = inputBuf[120];
				InputBuf_121 = inputBuf[121];
				InputBuf_122 = inputBuf[122];
				InputBuf_123 = inputBuf[123];
				InputBuf_124 = inputBuf[124];
				InputBuf_125 = inputBuf[125];
				InputBuf_126 = inputBuf[126];
				InputBuf_127 = inputBuf[127];
				InputBuf_128 = inputBuf[128];
				InputBuf_129 = inputBuf[129];
				InputBuf_130 = inputBuf[130];
				InputBuf_131 = inputBuf[131];
				InputBuf_132 = inputBuf[132];
				InputBuf_133 = inputBuf[133];
				InputBuf_134 = inputBuf[134];
				InputBuf_135 = inputBuf[135];
				InputBuf_136 = inputBuf[136];
				InputBuf_137 = inputBuf[137];
				InputBuf_138 = inputBuf[138];
				InputBuf_139 = inputBuf[139];
				InputBuf_140 = inputBuf[140];
				InputBuf_141 = inputBuf[141];
				InputBuf_142 = inputBuf[142];
				InputBuf_143 = inputBuf[143];
				InputBuf_144 = inputBuf[144];
				InputBuf_145 = inputBuf[145];
				InputBuf_146 = inputBuf[146];
				InputBuf_147 = inputBuf[147];
				InputBuf_148 = inputBuf[148];
				InputBuf_149 = inputBuf[149];
				InputBuf_150 = inputBuf[150];
				InputBuf_151 = inputBuf[151];
				InputBuf_152 = inputBuf[152];
				InputBuf_153 = inputBuf[153];
				InputBuf_154 = inputBuf[154];
				InputBuf_155 = inputBuf[155];
				InputBuf_156 = inputBuf[156];
				InputBuf_157 = inputBuf[157];
				InputBuf_158 = inputBuf[158];
				InputBuf_159 = inputBuf[159];
				InputBuf_160 = inputBuf[160];
				InputBuf_161 = inputBuf[161];
				InputBuf_162 = inputBuf[162];
				InputBuf_163 = inputBuf[163];
				InputBuf_164 = inputBuf[164];
				InputBuf_165 = inputBuf[165];
				InputBuf_166 = inputBuf[166];
				InputBuf_167 = inputBuf[167];
				InputBuf_168 = inputBuf[168];
				InputBuf_169 = inputBuf[169];
				InputBuf_170 = inputBuf[170];
				InputBuf_171 = inputBuf[171];
				InputBuf_172 = inputBuf[172];
				InputBuf_173 = inputBuf[173];
				InputBuf_174 = inputBuf[174];
				InputBuf_175 = inputBuf[175];
				InputBuf_176 = inputBuf[176];
				InputBuf_177 = inputBuf[177];
				InputBuf_178 = inputBuf[178];
				InputBuf_179 = inputBuf[179];
				InputBuf_180 = inputBuf[180];
				InputBuf_181 = inputBuf[181];
				InputBuf_182 = inputBuf[182];
				InputBuf_183 = inputBuf[183];
				InputBuf_184 = inputBuf[184];
				InputBuf_185 = inputBuf[185];
				InputBuf_186 = inputBuf[186];
				InputBuf_187 = inputBuf[187];
				InputBuf_188 = inputBuf[188];
				InputBuf_189 = inputBuf[189];
				InputBuf_190 = inputBuf[190];
				InputBuf_191 = inputBuf[191];
				InputBuf_192 = inputBuf[192];
				InputBuf_193 = inputBuf[193];
				InputBuf_194 = inputBuf[194];
				InputBuf_195 = inputBuf[195];
				InputBuf_196 = inputBuf[196];
				InputBuf_197 = inputBuf[197];
				InputBuf_198 = inputBuf[198];
				InputBuf_199 = inputBuf[199];
				InputBuf_200 = inputBuf[200];
				InputBuf_201 = inputBuf[201];
				InputBuf_202 = inputBuf[202];
				InputBuf_203 = inputBuf[203];
				InputBuf_204 = inputBuf[204];
				InputBuf_205 = inputBuf[205];
				InputBuf_206 = inputBuf[206];
				InputBuf_207 = inputBuf[207];
				InputBuf_208 = inputBuf[208];
				InputBuf_209 = inputBuf[209];
				InputBuf_210 = inputBuf[210];
				InputBuf_211 = inputBuf[211];
				InputBuf_212 = inputBuf[212];
				InputBuf_213 = inputBuf[213];
				InputBuf_214 = inputBuf[214];
				InputBuf_215 = inputBuf[215];
				InputBuf_216 = inputBuf[216];
				InputBuf_217 = inputBuf[217];
				InputBuf_218 = inputBuf[218];
				InputBuf_219 = inputBuf[219];
				InputBuf_220 = inputBuf[220];
				InputBuf_221 = inputBuf[221];
				InputBuf_222 = inputBuf[222];
				InputBuf_223 = inputBuf[223];
				InputBuf_224 = inputBuf[224];
				InputBuf_225 = inputBuf[225];
				InputBuf_226 = inputBuf[226];
				InputBuf_227 = inputBuf[227];
				InputBuf_228 = inputBuf[228];
				InputBuf_229 = inputBuf[229];
				InputBuf_230 = inputBuf[230];
				InputBuf_231 = inputBuf[231];
				InputBuf_232 = inputBuf[232];
				InputBuf_233 = inputBuf[233];
				InputBuf_234 = inputBuf[234];
				InputBuf_235 = inputBuf[235];
				InputBuf_236 = inputBuf[236];
				InputBuf_237 = inputBuf[237];
				InputBuf_238 = inputBuf[238];
				InputBuf_239 = inputBuf[239];
				InputBuf_240 = inputBuf[240];
				InputBuf_241 = inputBuf[241];
				InputBuf_242 = inputBuf[242];
				InputBuf_243 = inputBuf[243];
				InputBuf_244 = inputBuf[244];
				InputBuf_245 = inputBuf[245];
				InputBuf_246 = inputBuf[246];
				InputBuf_247 = inputBuf[247];
				InputBuf_248 = inputBuf[248];
				InputBuf_249 = inputBuf[249];
				InputBuf_250 = inputBuf[250];
				InputBuf_251 = inputBuf[251];
				InputBuf_252 = inputBuf[252];
				InputBuf_253 = inputBuf[253];
				InputBuf_254 = inputBuf[254];
				InputBuf_255 = inputBuf[255];
			}
			Filters = filters;
			CountGrep = countGrep;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void Build()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.BuildNative(@this);
			}
		}

		public unsafe void Clear()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool Draw( byte* label,  float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.DrawNative(@this, label, width);
				return ret != 0;
			}
		}

		public unsafe bool Draw( byte* label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.DrawNative(@this, label, (float)(0.0f));
				return ret != 0;
			}
		}

		public unsafe bool Draw()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.Draw(@this, (string)"Filter(inc,-exc)", (float)(0.0f));
				return ret;
			}
		}

		public unsafe bool Draw( float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				bool ret = ImGui.Draw(@this, (string)"Filter(inc,-exc)", width);
				return ret;
			}
		}

		public unsafe bool Draw( ref byte label,  float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, width);
					return ret != 0;
				}
			}
		}

		public unsafe bool Draw( ref byte label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* plabel = &label)
				{
					byte ret = ImGui.DrawNative(@this, (byte*)plabel, (float)(0.0f));
					return ret != 0;
				}
			}
		}

		public unsafe bool Draw( string label,  float width)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.DrawNative(@this, pStr0, width);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool Draw( string label)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (label != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(label);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.DrawNative(@this, pStr0, (float)(0.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool IsActive()
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.IsActiveNative(@this);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter( byte* text,  byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.PassFilterNative(@this, text, textEnd);
				return ret != 0;
			}
		}

		public unsafe bool PassFilter( byte* text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte ret = ImGui.PassFilterNative(@this, text, (byte*)(default));
				return ret != 0;
			}
		}

		public unsafe bool PassFilter( ref byte text,  byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, textEnd);
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter( ref byte text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)(default));
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter( string text,  byte* textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool PassFilter( string text)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool PassFilter( byte* text,  ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = ImGui.PassFilterNative(@this, text, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		public unsafe bool PassFilter( byte* text,  string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public unsafe bool PassFilter( ref byte text,  ref byte textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte ret = ImGui.PassFilterNative(@this, (byte*)ptext, (byte*)ptextEnd);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool PassFilter( string text,  string textEnd)
		{
			fixed (ImGuiTextFilter* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte ret = ImGui.PassFilterNative(@this, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImGuiTextRange
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImGuiTextRange* Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorImGuiTextRange(int size = default, int capacity = default, ImGuiTextRange* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTextRange
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* B;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* E;



		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTextRange(byte* b = default, byte* e = default)
		{
			B = b;
			E = e;
		}


		public unsafe void Destroy()
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool empty()
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				byte ret = ImGui.emptyNative(@this);
				return ret != 0;
			}
		}

		public unsafe void split( byte separator,  ImVectorImGuiTextRange* output)
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				ImGui.splitNative(@this, separator, output);
			}
		}

		public unsafe void split( byte separator,  ref ImVectorImGuiTextRange output)
		{
			fixed (ImGuiTextRange* @this = &this)
			{
				fixed (ImVectorImGuiTextRange* poutput = &output)
				{
					ImGui.splitNative(@this, separator, (ImVectorImGuiTextRange*)poutput);
				}
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImBitVector
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImU32 Storage;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImBitVector(ImVectorImU32 storage = default)
		{
			Storage = storage;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataVarInfo
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Type;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Count;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Offset;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDataVarInfo(int type = default, uint count = default, uint offset = default)
		{
			Type = type;
			Count = count;
			Offset = offset;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataTypeInfo
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ulong Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Name;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* PrintFmt;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* ScanFmt;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDataTypeInfo(ulong size = default, byte* name = default, byte* printFmt = default, byte* scanFmt = default)
		{
			Size = size;
			Name = name;
			PrintFmt = printFmt;
			ScanFmt = scanFmt;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiInputTextDeactivateData
	{


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiLocEntry
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ImGuiLocKey Key;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* Text;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiLocEntry(ImGuiLocKey key = default, byte* text = default)
		{
			Key = key;
			Text = text;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableSettings
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int SaveFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float RefScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte ColumnsCount;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte ColumnsCountMax;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantApply;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTableSettings(uint id = default, int saveFlags = default, float refScale = default, sbyte columnsCount = default, sbyte columnsCountMax = default, bool wantApply = default)
		{
			ID = id;
			SaveFlags = saveFlags;
			RefScale = refScale;
			ColumnsCount = columnsCount;
			ColumnsCountMax = columnsCountMax;
			WantApply = wantApply ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnsSettings
	{


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiWindowSettings
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec2Ih Pos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec2Ih Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVec2Ih ViewportPos;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ViewportId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint DockId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint ClassId;

		/// <summary>
		/// To be documented.
		/// </summary>
		public short DockOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Collapsed;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantApply;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte WantDelete;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiWindowSettings(uint id = default, ImVec2Ih pos = default, ImVec2Ih size = default, ImVec2Ih viewportPos = default, uint viewportId = default, uint dockId = default, uint classId = default, short dockOrder = default, bool collapsed = default, bool wantApply = default, bool wantDelete = default)
		{
			ID = id;
			Pos = pos;
			Size = size;
			ViewportPos = viewportPos;
			ViewportId = viewportId;
			DockId = dockId;
			ClassId = classId;
			DockOrder = dockOrder;
			Collapsed = collapsed ? (byte)1 : (byte)0;
			WantApply = wantApply ? (byte)1 : (byte)0;
			WantDelete = wantDelete ? (byte)1 : (byte)0;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorConstCharPtr
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte** Data;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImVectorConstCharPtr(int size = default, int capacity = default, byte** data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct StbTexteditRow
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float X0;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float X1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float BaselineYDelta;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Ymin;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Ymax;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int NumChars;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe StbTexteditRow(float x0 = default, float x1 = default, float baselineYDelta = default, float ymin = default, float ymax = default, int numChars = default)
		{
			X0 = x0;
			X1 = x1;
			BaselineYDelta = baselineYDelta;
			Ymin = ymin;
			Ymax = ymax;
			NumChars = numChars;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiDataTypeTempStorage
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Data_0;
		public byte Data_1;
		public byte Data_2;
		public byte Data_3;
		public byte Data_4;
		public byte Data_5;
		public byte Data_6;
		public byte Data_7;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDataTypeTempStorage(byte* data = default)
		{
			if (data != default)
			{
				Data_0 = data[0];
				Data_1 = data[1];
				Data_2 = data[2];
				Data_3 = data[3];
				Data_4 = data[4];
				Data_5 = data[5];
				Data_6 = data[6];
				Data_7 = data[7];
			}
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiDataTypeTempStorage(Span<byte> data = default)
		{
			if (data != default)
			{
				Data_0 = data[0];
				Data_1 = data[1];
				Data_2 = data[2];
				Data_3 = data[3];
				Data_4 = data[4];
				Data_5 = data[5];
				Data_6 = data[6];
				Data_7 = data[7];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImBitArrayImGuiKeyNamedKeyCOUNTLessImGuiKeyNamedKeyBEGIN
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Storage_0;
		public uint Storage_1;
		public uint Storage_2;
		public uint Storage_3;
		public uint Storage_4;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImBitArrayImGuiKeyNamedKeyCOUNTLessImGuiKeyNamedKeyBEGIN(uint* storage = default)
		{
			if (storage != default)
			{
				Storage_0 = storage[0];
				Storage_1 = storage[1];
				Storage_2 = storage[2];
				Storage_3 = storage[3];
				Storage_4 = storage[4];
			}
		}

		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImBitArrayImGuiKeyNamedKeyCOUNTLessImGuiKeyNamedKeyBEGIN(Span<uint> storage = default)
		{
			if (storage != default)
			{
				Storage_0 = storage[0];
				Storage_1 = storage[1];
				Storage_2 = storage[2];
				Storage_3 = storage[3];
				Storage_4 = storage[4];
			}
		}


		/// <summary>
		/// To be documented.
		/// </summary>
	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImGuiTableColumnSettings
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public float WidthOrWeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint UserID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte Index;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte DisplayOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public sbyte SortOrder;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte SortDirection;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsEnabled;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte IsStretch;


		/// <summary>		/// To be documented.		/// </summary>		public unsafe ImGuiTableColumnSettings(float widthOrWeight = default, uint userId = default, sbyte index = default, sbyte displayOrder = default, sbyte sortOrder = default, byte sortDirection = default, byte isEnabled = default, byte isStretch = default)
		{
			WidthOrWeight = widthOrWeight;
			UserID = userId;
			Index = index;
			DisplayOrder = displayOrder;
			SortOrder = sortOrder;
			SortDirection = sortDirection;
			IsEnabled = isEnabled;
			IsStretch = isStretch;
		}


	}

}
