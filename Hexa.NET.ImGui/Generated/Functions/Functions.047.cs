// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "sz")] [NativeName(NativeNameType.Type, "size_t")] nuint sz, [NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "ImGuiCond")] ImGuiCond cond)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, cond);
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "sz")] [NativeName(NativeNameType.Type, "size_t")] nuint sz)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, (ImGuiCond)(0));
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "sz")] [NativeName(NativeNameType.Type, "size_t")] nuint sz, [NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "ImGuiCond")] ImGuiCond cond)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, cond);
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "sz")] [NativeName(NativeNameType.Type, "size_t")] nuint sz)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "sz")] [NativeName(NativeNameType.Type, "size_t")] nuint sz, [NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "ImGuiCond")] ImGuiCond cond)
		{
			fixed (byte* ptype = type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, cond);
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "sz")] [NativeName(NativeNameType.Type, "size_t")] nuint sz)
		{
			fixed (byte* ptype = type)
			{
				byte ret = SetDragDropPayloadNative((byte*)ptype, data, sz, (ImGuiCond)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "sz")] [NativeName(NativeNameType.Type, "size_t")] nuint sz, [NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "ImGuiCond")] ImGuiCond cond)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetDragDropPayloadNative(pStr0, data, sz, cond);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SetDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "sz")] [NativeName(NativeNameType.Type, "size_t")] nuint sz)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SetDragDropPayloadNative(pStr0, data, sz, (ImGuiCond)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// only call EndDragDropSource() if BeginDragDropSource() returns true!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igEndDragDropSource")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void EndDragDropSourceNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[315])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[315])();
			#endif
		}

		/// <summary>
		/// only call EndDragDropSource() if BeginDragDropSource() returns true!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igEndDragDropSource")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndDragDropSource()
		{
			EndDragDropSourceNative();
		}

		/// <summary>
		/// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginDragDropTarget")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte BeginDragDropTargetNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[316])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[316])();
			#endif
		}

		/// <summary>
		/// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginDragDropTarget")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BeginDragDropTarget()
		{
			byte ret = BeginDragDropTargetNative();
			return ret != 0;
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igAcceptDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		internal static ImGuiPayload* AcceptDragDropPayloadNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiDragDropFlags")] ImGuiDragDropFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiDragDropFlags, ImGuiPayload*>)vt[317])(type, flags);
			#else
			return (ImGuiPayload*)((delegate* unmanaged[Cdecl]<nint, ImGuiDragDropFlags, nint>)vt[317])((nint)type, flags);
			#endif
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igAcceptDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		public static ImGuiPayload* AcceptDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiDragDropFlags")] ImGuiDragDropFlags flags)
		{
			ImGuiPayload* ret = AcceptDragDropPayloadNative(type, flags);
			return ret;
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igAcceptDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		public static ImGuiPayload* AcceptDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			ImGuiPayload* ret = AcceptDragDropPayloadNative(type, (ImGuiDragDropFlags)(0));
			return ret;
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igAcceptDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		public static ImGuiPayload* AcceptDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiDragDropFlags")] ImGuiDragDropFlags flags)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayload* ret = AcceptDragDropPayloadNative((byte*)ptype, flags);
				return ret;
			}
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igAcceptDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		public static ImGuiPayload* AcceptDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				ImGuiPayload* ret = AcceptDragDropPayloadNative((byte*)ptype, (ImGuiDragDropFlags)(0));
				return ret;
			}
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igAcceptDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		public static ImGuiPayload* AcceptDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiDragDropFlags")] ImGuiDragDropFlags flags)
		{
			fixed (byte* ptype = type)
			{
				ImGuiPayload* ret = AcceptDragDropPayloadNative((byte*)ptype, flags);
				return ret;
			}
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igAcceptDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		public static ImGuiPayload* AcceptDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				ImGuiPayload* ret = AcceptDragDropPayloadNative((byte*)ptype, (ImGuiDragDropFlags)(0));
				return ret;
			}
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igAcceptDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		public static ImGuiPayload* AcceptDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiDragDropFlags")] ImGuiDragDropFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayload* ret = AcceptDragDropPayloadNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igAcceptDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		public static ImGuiPayload* AcceptDragDropPayload([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiPayload* ret = AcceptDragDropPayloadNative(pStr0, (ImGuiDragDropFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// only call EndDragDropTarget() if BeginDragDropTarget() returns true!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igEndDragDropTarget")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void EndDragDropTargetNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[318])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[318])();
			#endif
		}

		/// <summary>
		/// only call EndDragDropTarget() if BeginDragDropTarget() returns true!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igEndDragDropTarget")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndDragDropTarget()
		{
			EndDragDropTargetNative();
		}

		/// <summary>
		/// peek directly into the current payload from anywhere. returns NULL when drag and drop is finished or inactive. use ImGuiPayload::IsDataType() to test for the payload type.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		internal static ImGuiPayload* GetDragDropPayloadNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiPayload*>)vt[319])();
			#else
			return (ImGuiPayload*)((delegate* unmanaged[Cdecl]<nint>)vt[319])();
			#endif
		}

		/// <summary>
		/// peek directly into the current payload from anywhere. returns NULL when drag and drop is finished or inactive. use ImGuiPayload::IsDataType() to test for the payload type.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetDragDropPayload")]
		[return: NativeName(NativeNameType.Type, "const ImGuiPayload*")]
		public static ImGuiPayload* GetDragDropPayload()
		{
			ImGuiPayload* ret = GetDragDropPayloadNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginDisabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void BeginDisabledNative([NativeName(NativeNameType.Param, "disabled")] [NativeName(NativeNameType.Type, "bool")] byte disabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)vt[320])(disabled);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)vt[320])(disabled);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginDisabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginDisabled([NativeName(NativeNameType.Param, "disabled")] [NativeName(NativeNameType.Type, "bool")] bool disabled)
		{
			BeginDisabledNative(disabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginDisabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BeginDisabled()
		{
			BeginDisabledNative((byte)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igEndDisabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void EndDisabledNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[321])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[321])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igEndDisabled")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndDisabled()
		{
			EndDisabledNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igPushClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void PushClipRectNative([NativeName(NativeNameType.Param, "clip_rect_min")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 clipRectMin, [NativeName(NativeNameType.Param, "clip_rect_max")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 clipRectMax, [NativeName(NativeNameType.Param, "intersect_with_current_clip_rect")] [NativeName(NativeNameType.Type, "bool")] byte intersectWithCurrentClipRect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte, void>)vt[322])(clipRectMin, clipRectMax, intersectWithCurrentClipRect);
			#else
			((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte, void>)vt[322])(clipRectMin, clipRectMax, intersectWithCurrentClipRect);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igPushClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PushClipRect([NativeName(NativeNameType.Param, "clip_rect_min")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 clipRectMin, [NativeName(NativeNameType.Param, "clip_rect_max")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 clipRectMax, [NativeName(NativeNameType.Param, "intersect_with_current_clip_rect")] [NativeName(NativeNameType.Type, "bool")] bool intersectWithCurrentClipRect)
		{
			PushClipRectNative(clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igPopClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void PopClipRectNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[323])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[323])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igPopClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void PopClipRect()
		{
			PopClipRectNative();
		}

		/// <summary>
		/// make last item the default focused item of a window.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetItemDefaultFocus")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetItemDefaultFocusNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[324])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[324])();
			#endif
		}

		/// <summary>
		/// make last item the default focused item of a window.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetItemDefaultFocus")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetItemDefaultFocus()
		{
			SetItemDefaultFocusNative();
		}

		/// <summary>
		/// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetKeyboardFocusHere")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetKeyboardFocusHereNative([NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "int")] int offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[325])(offset);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[325])(offset);
			#endif
		}

		/// <summary>
		/// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetKeyboardFocusHere")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetKeyboardFocusHere([NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "int")] int offset)
		{
			SetKeyboardFocusHereNative(offset);
		}

		/// <summary>
		/// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetKeyboardFocusHere")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetKeyboardFocusHere()
		{
			SetKeyboardFocusHereNative((int)(0));
		}

		/// <summary>
		/// allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemAllowOverlap")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetNextItemAllowOverlapNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[326])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[326])();
			#endif
		}

		/// <summary>
		/// allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemAllowOverlap")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetNextItemAllowOverlap()
		{
			SetNextItemAllowOverlapNative();
		}

		/// <summary>
		/// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemHovered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemHoveredNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiHoveredFlags")] ImGuiHoveredFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)vt[327])(flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiHoveredFlags, byte>)vt[327])(flags);
			#endif
		}

		/// <summary>
		/// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemHovered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemHovered([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiHoveredFlags")] ImGuiHoveredFlags flags)
		{
			byte ret = IsItemHoveredNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemHovered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemHovered()
		{
			byte ret = IsItemHoveredNative((ImGuiHoveredFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemActive")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemActiveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[328])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[328])();
			#endif
		}

		/// <summary>
		/// is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemActive")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemActive()
		{
			byte ret = IsItemActiveNative();
			return ret != 0;
		}

		/// <summary>
		/// is the last item focused for keyboardgamepad navigation?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemFocused")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemFocusedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[329])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[329])();
			#endif
		}

		/// <summary>
		/// is the last item focused for keyboardgamepad navigation?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemFocused")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemFocused()
		{
			byte ret = IsItemFocusedNative();
			return ret != 0;
		}

		/// <summary>
		/// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) &amp;&amp; IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemClicked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemClickedNative([NativeName(NativeNameType.Param, "mouse_button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton mouseButton)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[330])(mouseButton);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[330])(mouseButton);
			#endif
		}

		/// <summary>
		/// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) &amp;&amp; IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemClicked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemClicked([NativeName(NativeNameType.Param, "mouse_button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton mouseButton)
		{
			byte ret = IsItemClickedNative(mouseButton);
			return ret != 0;
		}

		/// <summary>
		/// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) &amp;&amp; IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemClicked")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemClicked()
		{
			byte ret = IsItemClickedNative((ImGuiMouseButton)(0));
			return ret != 0;
		}

		/// <summary>
		/// is the last item visible? (items may be out of sight because of clippingscrolling)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemVisible")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemVisibleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[331])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[331])();
			#endif
		}

		/// <summary>
		/// is the last item visible? (items may be out of sight because of clippingscrolling)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemVisible")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemVisible()
		{
			byte ret = IsItemVisibleNative();
			return ret != 0;
		}

		/// <summary>
		/// did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemEdited")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemEditedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[332])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[332])();
			#endif
		}

		/// <summary>
		/// did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemEdited")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemEdited()
		{
			byte ret = IsItemEditedNative();
			return ret != 0;
		}

		/// <summary>
		/// was the last item just made active (item was previously inactive).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemActivated")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemActivatedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[333])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[333])();
			#endif
		}

		/// <summary>
		/// was the last item just made active (item was previously inactive).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemActivated")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemActivated()
		{
			byte ret = IsItemActivatedNative();
			return ret != 0;
		}

		/// <summary>
		/// was the last item just made inactive (item was previously active). Useful for UndoRedo patterns with widgets that require continuous editing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemDeactivated")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemDeactivatedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[334])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[334])();
			#endif
		}

		/// <summary>
		/// was the last item just made inactive (item was previously active). Useful for UndoRedo patterns with widgets that require continuous editing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemDeactivated")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemDeactivated()
		{
			byte ret = IsItemDeactivatedNative();
			return ret != 0;
		}

		/// <summary>
		/// was the last item just made inactive and made a value change when it was active? (e.g. SliderDrag moved). Useful for UndoRedo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()ListBox()Selectable() will return true even when clicking an already selected item).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemDeactivatedAfterEdit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemDeactivatedAfterEditNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[335])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[335])();
			#endif
		}

		/// <summary>
		/// was the last item just made inactive and made a value change when it was active? (e.g. SliderDrag moved). Useful for UndoRedo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()ListBox()Selectable() will return true even when clicking an already selected item).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemDeactivatedAfterEdit")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemDeactivatedAfterEdit()
		{
			byte ret = IsItemDeactivatedAfterEditNative();
			return ret != 0;
		}

		/// <summary>
		/// was the last item open state toggled? set by TreeNode().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemToggledOpen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemToggledOpenNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[336])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[336])();
			#endif
		}

		/// <summary>
		/// was the last item open state toggled? set by TreeNode().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemToggledOpen")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemToggledOpen()
		{
			byte ret = IsItemToggledOpenNative();
			return ret != 0;
		}

		/// <summary>
		/// is any item hovered?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsAnyItemHovered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsAnyItemHoveredNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[337])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[337])();
			#endif
		}

		/// <summary>
		/// is any item hovered?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsAnyItemHovered")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsAnyItemHovered()
		{
			byte ret = IsAnyItemHoveredNative();
			return ret != 0;
		}

		/// <summary>
		/// is any item active?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsAnyItemActive")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsAnyItemActiveNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[338])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[338])();
			#endif
		}

		/// <summary>
		/// is any item active?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsAnyItemActive")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsAnyItemActive()
		{
			byte ret = IsAnyItemActiveNative();
			return ret != 0;
		}

		/// <summary>
		/// is any item focused?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsAnyItemFocused")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsAnyItemFocusedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[339])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[339])();
			#endif
		}

		/// <summary>
		/// is any item focused?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsAnyItemFocused")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsAnyItemFocused()
		{
			byte ret = IsAnyItemFocusedNative();
			return ret != 0;
		}

		/// <summary>
		/// get ID of last item (~~ often same ImGui::GetID(label) beforehand)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemID")]
		[return: NativeName(NativeNameType.Type, "ImGuiID")]
		internal static uint GetItemIDNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)vt[340])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)vt[340])();
			#endif
		}

		/// <summary>
		/// get ID of last item (~~ often same ImGui::GetID(label) beforehand)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemID")]
		[return: NativeName(NativeNameType.Type, "ImGuiID")]
		public static uint GetItemID()
		{
			uint ret = GetItemIDNative();
			return ret;
		}

		/// <summary>
		/// get upper-left bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemRectMin")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void GetItemRectMinNative([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[341])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[341])((nint)pOut);
			#endif
		}

		/// <summary>
		/// get upper-left bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemRectMin")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetItemRectMin([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			GetItemRectMinNative(pOut);
		}

		/// <summary>
		/// get upper-left bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemRectMin")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetItemRectMin([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetItemRectMinNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// get lower-right bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemRectMax")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void GetItemRectMaxNative([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[342])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[342])((nint)pOut);
			#endif
		}

		/// <summary>
		/// get lower-right bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemRectMax")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetItemRectMax([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			GetItemRectMaxNative(pOut);
		}

		/// <summary>
		/// get lower-right bounding rectangle of the last item (screen space)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemRectMax")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetItemRectMax([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetItemRectMaxNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// get size of last item<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemRectSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void GetItemRectSizeNative([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[343])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[343])((nint)pOut);
			#endif
		}

		/// <summary>
		/// get size of last item<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemRectSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetItemRectSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			GetItemRectSizeNative(pOut);
		}

		/// <summary>
		/// get size of last item<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetItemRectSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetItemRectSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetItemRectSizeNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// return primarydefault viewport. This can never be NULL.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMainViewport")]
		[return: NativeName(NativeNameType.Type, "ImGuiViewport*")]
		internal static ImGuiViewport* GetMainViewportNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*>)vt[344])();
			#else
			return (ImGuiViewport*)((delegate* unmanaged[Cdecl]<nint>)vt[344])();
			#endif
		}

		/// <summary>
		/// return primarydefault viewport. This can never be NULL.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMainViewport")]
		[return: NativeName(NativeNameType.Type, "ImGuiViewport*")]
		public static ImGuiViewport* GetMainViewport()
		{
			ImGuiViewport* ret = GetMainViewportNative();
			return ret;
		}

		/// <summary>
		/// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapestext behind dear imgui contents.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetBackgroundDrawList")]
		[return: NativeName(NativeNameType.Type, "ImDrawList*")]
		internal static ImDrawList* GetBackgroundDrawListNative([NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "ImGuiViewport*")] ImGuiViewport* viewport)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*, ImDrawList*>)vt[345])(viewport);
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[345])((nint)viewport);
			#endif
		}

		/// <summary>
		/// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapestext behind dear imgui contents.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetBackgroundDrawList")]
		[return: NativeName(NativeNameType.Type, "ImDrawList*")]
		public static ImDrawList* GetBackgroundDrawList([NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "ImGuiViewport*")] ImGuiViewport* viewport)
		{
			ImDrawList* ret = GetBackgroundDrawListNative(viewport);
			return ret;
		}

		/// <summary>
		/// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapestext behind dear imgui contents.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetBackgroundDrawList")]
		[return: NativeName(NativeNameType.Type, "ImDrawList*")]
		public static ImDrawList* GetBackgroundDrawList()
		{
			ImDrawList* ret = GetBackgroundDrawListNative((ImGuiViewport*)(default));
			return ret;
		}

		/// <summary>
		/// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapestext behind dear imgui contents.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetBackgroundDrawList")]
		[return: NativeName(NativeNameType.Type, "ImDrawList*")]
		public static ImDrawList* GetBackgroundDrawList([NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "ImGuiViewport*")] ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawList* ret = GetBackgroundDrawListNative((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		/// <summary>
		/// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapestext over dear imgui contents.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetForegroundDrawList_ViewportPtr")]
		[return: NativeName(NativeNameType.Type, "ImDrawList*")]
		internal static ImDrawList* GetForegroundDrawListNative([NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "ImGuiViewport*")] ImGuiViewport* viewport)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiViewport*, ImDrawList*>)vt[346])(viewport);
			#else
			return (ImDrawList*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[346])((nint)viewport);
			#endif
		}

		/// <summary>
		/// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapestext over dear imgui contents.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetForegroundDrawList_ViewportPtr")]
		[return: NativeName(NativeNameType.Type, "ImDrawList*")]
		public static ImDrawList* GetForegroundDrawList([NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "ImGuiViewport*")] ImGuiViewport* viewport)
		{
			ImDrawList* ret = GetForegroundDrawListNative(viewport);
			return ret;
		}

		/// <summary>
		/// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapestext over dear imgui contents.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetForegroundDrawList_ViewportPtr")]
		[return: NativeName(NativeNameType.Type, "ImDrawList*")]
		public static ImDrawList* GetForegroundDrawList()
		{
			ImDrawList* ret = GetForegroundDrawListNative((ImGuiViewport*)(default));
			return ret;
		}

		/// <summary>
		/// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapestext over dear imgui contents.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetForegroundDrawList_ViewportPtr")]
		[return: NativeName(NativeNameType.Type, "ImDrawList*")]
		public static ImDrawList* GetForegroundDrawList([NativeName(NativeNameType.Param, "viewport")] [NativeName(NativeNameType.Type, "ImGuiViewport*")] ref ImGuiViewport viewport)
		{
			fixed (ImGuiViewport* pviewport = &viewport)
			{
				ImDrawList* ret = GetForegroundDrawListNative((ImGuiViewport*)pviewport);
				return ret;
			}
		}

		/// <summary>
		/// test if rectangle (of given size, starting from cursor position) is visible  not clipped.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsRectVisible_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsRectVisibleNative([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, byte>)vt[347])(size);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, byte>)vt[347])(size);
			#endif
		}

		/// <summary>
		/// test if rectangle (of given size, starting from cursor position) is visible  not clipped.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsRectVisible_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsRectVisible([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = IsRectVisibleNative(size);
			return ret != 0;
		}

		/// <summary>
		/// test if rectangle (of given size, starting from cursor position) is visible  not clipped.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsRectVisible_Vec2")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsRectVisibleNative([NativeName(NativeNameType.Param, "rect_min")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rectMin, [NativeName(NativeNameType.Param, "rect_max")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rectMax)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte>)vt[348])(rectMin, rectMax);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte>)vt[348])(rectMin, rectMax);
			#endif
		}

		/// <summary>
		/// test if rectangle (in screen space) is visible  not clipped. to perform coarse clipping on user's side.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsRectVisible_Vec2")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsRectVisible([NativeName(NativeNameType.Param, "rect_min")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rectMin, [NativeName(NativeNameType.Param, "rect_max")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rectMax)
		{
			byte ret = IsRectVisibleNative(rectMin, rectMax);
			return ret != 0;
		}

		/// <summary>
		/// get global imgui time. incremented by io.DeltaTime every frame.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetTime")]
		[return: NativeName(NativeNameType.Type, "double")]
		internal static double GetTimeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double>)vt[349])();
			#else
			return (double)((delegate* unmanaged[Cdecl]<double>)vt[349])();
			#endif
		}

		/// <summary>
		/// get global imgui time. incremented by io.DeltaTime every frame.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetTime")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double GetTime()
		{
			double ret = GetTimeNative();
			return ret;
		}

		/// <summary>
		/// get global imgui frame count. incremented by 1 every frame.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetFrameCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int GetFrameCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[350])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[350])();
			#endif
		}

		/// <summary>
		/// get global imgui frame count. incremented by 1 every frame.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetFrameCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetFrameCount()
		{
			int ret = GetFrameCountNative();
			return ret;
		}

		/// <summary>
		/// you may use this when creating your own ImDrawList instances.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetDrawListSharedData")]
		[return: NativeName(NativeNameType.Type, "ImDrawListSharedData*")]
		internal static ImDrawListSharedData* GetDrawListSharedDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImDrawListSharedData*>)vt[351])();
			#else
			return (ImDrawListSharedData*)((delegate* unmanaged[Cdecl]<nint>)vt[351])();
			#endif
		}

		/// <summary>
		/// you may use this when creating your own ImDrawList instances.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetDrawListSharedData")]
		[return: NativeName(NativeNameType.Type, "ImDrawListSharedData*")]
		public static ImDrawListSharedData* GetDrawListSharedData()
		{
			ImDrawListSharedData* ret = GetDrawListSharedDataNative();
			return ret;
		}

		/// <summary>
		/// get a string corresponding to the enum value (for display, saving, etc.).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetStyleColorName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* GetStyleColorNameNative([NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "ImGuiCol")] ImGuiCol idx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiCol, byte*>)vt[352])(idx);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ImGuiCol, nint>)vt[352])(idx);
			#endif
		}

		/// <summary>
		/// get a string corresponding to the enum value (for display, saving, etc.).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetStyleColorName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetStyleColorName([NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "ImGuiCol")] ImGuiCol idx)
		{
			byte* ret = GetStyleColorNameNative(idx);
			return ret;
		}

		/// <summary>
		/// get a string corresponding to the enum value (for display, saving, etc.).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetStyleColorName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string GetStyleColorNameS([NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "ImGuiCol")] ImGuiCol idx)
		{
			string ret = Utils.DecodeStringUTF8(GetStyleColorNameNative(idx));
			return ret;
		}

		/// <summary>
		/// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetStateStorage")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetStateStorageNative([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "ImGuiStorage*")] ImGuiStorage* storage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStorage*, void>)vt[353])(storage);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[353])((nint)storage);
			#endif
		}

		/// <summary>
		/// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetStateStorage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetStateStorage([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "ImGuiStorage*")] ImGuiStorage* storage)
		{
			SetStateStorageNative(storage);
		}

		/// <summary>
		/// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetStateStorage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetStateStorage([NativeName(NativeNameType.Param, "storage")] [NativeName(NativeNameType.Type, "ImGuiStorage*")] ref ImGuiStorage storage)
		{
			fixed (ImGuiStorage* pstorage = &storage)
			{
				SetStateStorageNative((ImGuiStorage*)pstorage);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetStateStorage")]
		[return: NativeName(NativeNameType.Type, "ImGuiStorage*")]
		internal static ImGuiStorage* GetStateStorageNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStorage*>)vt[354])();
			#else
			return (ImGuiStorage*)((delegate* unmanaged[Cdecl]<nint>)vt[354])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetStateStorage")]
		[return: NativeName(NativeNameType.Type, "ImGuiStorage*")]
		public static ImGuiStorage* GetStateStorage()
		{
			ImGuiStorage* ret = GetStateStorageNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void CalcTextSizeNative([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] byte hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, byte*, byte*, byte, float, void>)vt[355])(pOut, text, textEnd, hideTextAfterDoubleHash, wrapWidth);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, byte, float, void>)vt[355])((nint)pOut, (nint)text, (nint)textEnd, hideTextAfterDoubleHash, wrapWidth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			CalcTextSizeNative(pOut, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			CalcTextSizeNative(pOut, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd)
		{
			CalcTextSizeNative(pOut, text, textEnd, (byte)(0), (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			CalcTextSizeNative(pOut, text, (byte*)(default), (byte)(0), (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			CalcTextSizeNative(pOut, text, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			CalcTextSizeNative(pOut, text, textEnd, (byte)(0), wrapWidth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			CalcTextSizeNative(pOut, text, (byte*)(default), (byte)(0), wrapWidth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			CalcTextSizeNative(pOut, text, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeNative((Vector2*)ppOut, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeNative((Vector2*)ppOut, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeNative((Vector2*)ppOut, text, textEnd, (byte)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeNative((Vector2*)ppOut, text, (byte*)(default), (byte)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeNative((Vector2*)ppOut, text, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeNative((Vector2*)ppOut, text, textEnd, (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeNative((Vector2*)ppOut, text, (byte*)(default), (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				CalcTextSizeNative((Vector2*)ppOut, text, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, (byte)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), (byte)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, (byte)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), (byte)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, (byte)(0), (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, (byte*)(default), (byte)(0), (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, (byte)(0), wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, (byte*)(default), (byte)(0), wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, textEnd, (byte)(0), (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)(default), (byte)(0), (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, textEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)(default), (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, textEnd, (byte)(0), (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)(default), (byte)(0), (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, textEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)(default), (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, textEnd, (byte)(0), (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)(default), (byte)(0), (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] byte* textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, textEnd, (byte)(0), wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)(default), (byte)(0), wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, (byte)(0), (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, (byte)(0), wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, text, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, text, (byte*)ptextEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, text, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, text, (byte*)ptextEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, text, pStr0, (byte)(0), (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, text, pStr0, (byte)(0), wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, (byte)(0), (float)(-1.0f));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, (byte)(0), wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ref byte textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), wrapWidth);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				fixed (byte* ptext = text)
				{
					fixed (byte* ptextEnd = textEnd)
					{
						CalcTextSizeNative((Vector2*)ppOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), wrapWidth);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "hide_text_after_double_hash")] [NativeName(NativeNameType.Type, "bool")] bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, pStr1, (byte)(0), (float)(-1.0f));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igCalcTextSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalcTextSize([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "text_end")] [NativeName(NativeNameType.Type, "const char*")] string textEnd, [NativeName(NativeNameType.Param, "wrap_width")] [NativeName(NativeNameType.Type, "float")] float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				CalcTextSizeNative((Vector2*)ppOut, pStr0, pStr1, (byte)(0), wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertU32ToFloat4")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void ColorConvertU32ToFloat4Native([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec4*")] Vector4* pOut, [NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "ImU32")] uint input)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, uint, void>)vt[356])(pOut, input);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)vt[356])((nint)pOut, input);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertU32ToFloat4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertU32ToFloat4([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec4*")] Vector4* pOut, [NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "ImU32")] uint input)
		{
			ColorConvertU32ToFloat4Native(pOut, input);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertU32ToFloat4")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertU32ToFloat4([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec4*")] ref Vector4 pOut, [NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "ImU32")] uint input)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				ColorConvertU32ToFloat4Native((Vector4*)ppOut, input);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertFloat4ToU32")]
		[return: NativeName(NativeNameType.Type, "ImU32")]
		internal static uint ColorConvertFloat4ToU32Native([NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 input)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4, uint>)vt[357])(input);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<Vector4, uint>)vt[357])(input);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertFloat4ToU32")]
		[return: NativeName(NativeNameType.Type, "ImU32")]
		public static uint ColorConvertFloat4ToU32([NativeName(NativeNameType.Param, "in")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 input)
		{
			uint ret = ColorConvertFloat4ToU32Native(input);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertRGBtoHSV")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void ColorConvertRGBtoHSVNative([NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "out_h")] [NativeName(NativeNameType.Type, "float*")] float* outH, [NativeName(NativeNameType.Param, "out_s")] [NativeName(NativeNameType.Type, "float*")] float* outS, [NativeName(NativeNameType.Param, "out_v")] [NativeName(NativeNameType.Type, "float*")] float* outV)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float*, float*, float*, void>)vt[358])(r, g, b, outH, outS, outV);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, nint, nint, nint, void>)vt[358])(r, g, b, (nint)outH, (nint)outS, (nint)outV);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertRGBtoHSV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertRGBtoHSV([NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "out_h")] [NativeName(NativeNameType.Type, "float*")] float* outH, [NativeName(NativeNameType.Param, "out_s")] [NativeName(NativeNameType.Type, "float*")] float* outS, [NativeName(NativeNameType.Param, "out_v")] [NativeName(NativeNameType.Type, "float*")] float* outV)
		{
			ColorConvertRGBtoHSVNative(r, g, b, outH, outS, outV);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertRGBtoHSV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertRGBtoHSV([NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "out_h")] [NativeName(NativeNameType.Type, "float*")] ref float outH, [NativeName(NativeNameType.Param, "out_s")] [NativeName(NativeNameType.Type, "float*")] float* outS, [NativeName(NativeNameType.Param, "out_v")] [NativeName(NativeNameType.Type, "float*")] float* outV)
		{
			fixed (float* poutH = &outH)
			{
				ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, outS, outV);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertRGBtoHSV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertRGBtoHSV([NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "out_h")] [NativeName(NativeNameType.Type, "float*")] float* outH, [NativeName(NativeNameType.Param, "out_s")] [NativeName(NativeNameType.Type, "float*")] ref float outS, [NativeName(NativeNameType.Param, "out_v")] [NativeName(NativeNameType.Type, "float*")] float* outV)
		{
			fixed (float* poutS = &outS)
			{
				ColorConvertRGBtoHSVNative(r, g, b, outH, (float*)poutS, outV);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertRGBtoHSV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertRGBtoHSV([NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "out_h")] [NativeName(NativeNameType.Type, "float*")] ref float outH, [NativeName(NativeNameType.Param, "out_s")] [NativeName(NativeNameType.Type, "float*")] ref float outS, [NativeName(NativeNameType.Param, "out_v")] [NativeName(NativeNameType.Type, "float*")] float* outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, (float*)poutS, outV);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertRGBtoHSV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertRGBtoHSV([NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "out_h")] [NativeName(NativeNameType.Type, "float*")] float* outH, [NativeName(NativeNameType.Param, "out_s")] [NativeName(NativeNameType.Type, "float*")] float* outS, [NativeName(NativeNameType.Param, "out_v")] [NativeName(NativeNameType.Type, "float*")] ref float outV)
		{
			fixed (float* poutV = &outV)
			{
				ColorConvertRGBtoHSVNative(r, g, b, outH, outS, (float*)poutV);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertRGBtoHSV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertRGBtoHSV([NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "out_h")] [NativeName(NativeNameType.Type, "float*")] ref float outH, [NativeName(NativeNameType.Param, "out_s")] [NativeName(NativeNameType.Type, "float*")] float* outS, [NativeName(NativeNameType.Param, "out_v")] [NativeName(NativeNameType.Type, "float*")] ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, outS, (float*)poutV);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertRGBtoHSV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertRGBtoHSV([NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "out_h")] [NativeName(NativeNameType.Type, "float*")] float* outH, [NativeName(NativeNameType.Param, "out_s")] [NativeName(NativeNameType.Type, "float*")] ref float outS, [NativeName(NativeNameType.Param, "out_v")] [NativeName(NativeNameType.Type, "float*")] ref float outV)
		{
			fixed (float* poutS = &outS)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSVNative(r, g, b, outH, (float*)poutS, (float*)poutV);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertRGBtoHSV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertRGBtoHSV([NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "float")] float r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "float")] float g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "float")] float b, [NativeName(NativeNameType.Param, "out_h")] [NativeName(NativeNameType.Type, "float*")] ref float outH, [NativeName(NativeNameType.Param, "out_s")] [NativeName(NativeNameType.Type, "float*")] ref float outS, [NativeName(NativeNameType.Param, "out_v")] [NativeName(NativeNameType.Type, "float*")] ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					fixed (float* poutV = &outV)
					{
						ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, (float*)poutS, (float*)poutV);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertHSVtoRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void ColorConvertHSVtoRGBNative([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float")] float s, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "float")] float v, [NativeName(NativeNameType.Param, "out_r")] [NativeName(NativeNameType.Type, "float*")] float* outR, [NativeName(NativeNameType.Param, "out_g")] [NativeName(NativeNameType.Type, "float*")] float* outG, [NativeName(NativeNameType.Param, "out_b")] [NativeName(NativeNameType.Type, "float*")] float* outB)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float*, float*, float*, void>)vt[359])(h, s, v, outR, outG, outB);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, nint, nint, nint, void>)vt[359])(h, s, v, (nint)outR, (nint)outG, (nint)outB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertHSVtoRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertHSVtoRGB([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float")] float s, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "float")] float v, [NativeName(NativeNameType.Param, "out_r")] [NativeName(NativeNameType.Type, "float*")] float* outR, [NativeName(NativeNameType.Param, "out_g")] [NativeName(NativeNameType.Type, "float*")] float* outG, [NativeName(NativeNameType.Param, "out_b")] [NativeName(NativeNameType.Type, "float*")] float* outB)
		{
			ColorConvertHSVtoRGBNative(h, s, v, outR, outG, outB);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertHSVtoRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertHSVtoRGB([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float")] float s, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "float")] float v, [NativeName(NativeNameType.Param, "out_r")] [NativeName(NativeNameType.Type, "float*")] ref float outR, [NativeName(NativeNameType.Param, "out_g")] [NativeName(NativeNameType.Type, "float*")] float* outG, [NativeName(NativeNameType.Param, "out_b")] [NativeName(NativeNameType.Type, "float*")] float* outB)
		{
			fixed (float* poutR = &outR)
			{
				ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, outG, outB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertHSVtoRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertHSVtoRGB([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float")] float s, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "float")] float v, [NativeName(NativeNameType.Param, "out_r")] [NativeName(NativeNameType.Type, "float*")] float* outR, [NativeName(NativeNameType.Param, "out_g")] [NativeName(NativeNameType.Type, "float*")] ref float outG, [NativeName(NativeNameType.Param, "out_b")] [NativeName(NativeNameType.Type, "float*")] float* outB)
		{
			fixed (float* poutG = &outG)
			{
				ColorConvertHSVtoRGBNative(h, s, v, outR, (float*)poutG, outB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertHSVtoRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertHSVtoRGB([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float")] float s, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "float")] float v, [NativeName(NativeNameType.Param, "out_r")] [NativeName(NativeNameType.Type, "float*")] ref float outR, [NativeName(NativeNameType.Param, "out_g")] [NativeName(NativeNameType.Type, "float*")] ref float outG, [NativeName(NativeNameType.Param, "out_b")] [NativeName(NativeNameType.Type, "float*")] float* outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, (float*)poutG, outB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertHSVtoRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertHSVtoRGB([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float")] float s, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "float")] float v, [NativeName(NativeNameType.Param, "out_r")] [NativeName(NativeNameType.Type, "float*")] float* outR, [NativeName(NativeNameType.Param, "out_g")] [NativeName(NativeNameType.Type, "float*")] float* outG, [NativeName(NativeNameType.Param, "out_b")] [NativeName(NativeNameType.Type, "float*")] ref float outB)
		{
			fixed (float* poutB = &outB)
			{
				ColorConvertHSVtoRGBNative(h, s, v, outR, outG, (float*)poutB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertHSVtoRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertHSVtoRGB([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float")] float s, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "float")] float v, [NativeName(NativeNameType.Param, "out_r")] [NativeName(NativeNameType.Type, "float*")] ref float outR, [NativeName(NativeNameType.Param, "out_g")] [NativeName(NativeNameType.Type, "float*")] float* outG, [NativeName(NativeNameType.Param, "out_b")] [NativeName(NativeNameType.Type, "float*")] ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, outG, (float*)poutB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertHSVtoRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertHSVtoRGB([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float")] float s, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "float")] float v, [NativeName(NativeNameType.Param, "out_r")] [NativeName(NativeNameType.Type, "float*")] float* outR, [NativeName(NativeNameType.Param, "out_g")] [NativeName(NativeNameType.Type, "float*")] ref float outG, [NativeName(NativeNameType.Param, "out_b")] [NativeName(NativeNameType.Type, "float*")] ref float outB)
		{
			fixed (float* poutG = &outG)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGBNative(h, s, v, outR, (float*)poutG, (float*)poutB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorConvertHSVtoRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ColorConvertHSVtoRGB([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h, [NativeName(NativeNameType.Param, "s")] [NativeName(NativeNameType.Type, "float")] float s, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "float")] float v, [NativeName(NativeNameType.Param, "out_r")] [NativeName(NativeNameType.Type, "float*")] ref float outR, [NativeName(NativeNameType.Param, "out_g")] [NativeName(NativeNameType.Type, "float*")] ref float outG, [NativeName(NativeNameType.Param, "out_b")] [NativeName(NativeNameType.Type, "float*")] ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					fixed (float* poutB = &outB)
					{
						ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, (float*)poutG, (float*)poutB);
					}
				}
			}
		}

		/// <summary>
		/// is key being held.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsKeyDown_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsKeyDownNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[360])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[360])(key);
			#endif
		}

		/// <summary>
		/// is key being held.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsKeyDown_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyDown([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			byte ret = IsKeyDownNative(key);
			return ret != 0;
		}

		/// <summary>
		/// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay  KeyRepeatRate<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsKeyPressed_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsKeyPressedNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key, [NativeName(NativeNameType.Param, "repeat")] [NativeName(NativeNameType.Type, "bool")] byte repeat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte, byte>)vt[361])(key, repeat);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte, byte>)vt[361])(key, repeat);
			#endif
		}

		/// <summary>
		/// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay  KeyRepeatRate<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsKeyPressed_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyPressed([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key, [NativeName(NativeNameType.Param, "repeat")] [NativeName(NativeNameType.Type, "bool")] bool repeat)
		{
			byte ret = IsKeyPressedNative(key, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay  KeyRepeatRate<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsKeyPressed_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyPressed([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			byte ret = IsKeyPressedNative(key, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// was key released (went from Down to !Down)?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsKeyReleased_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsKeyReleasedNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[362])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)vt[362])(key);
			#endif
		}

		/// <summary>
		/// was key released (went from Down to !Down)?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsKeyReleased_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyReleased([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			byte ret = IsKeyReleasedNative(key);
			return ret != 0;
		}

		/// <summary>
		/// was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsKeyChordPressed_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsKeyChordPressedNative([NativeName(NativeNameType.Param, "key_chord")] [NativeName(NativeNameType.Type, "ImGuiKeyChord")] int keyChord)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)vt[363])(keyChord);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)vt[363])(keyChord);
			#endif
		}

		/// <summary>
		/// was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsKeyChordPressed_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsKeyChordPressed([NativeName(NativeNameType.Param, "key_chord")] [NativeName(NativeNameType.Type, "ImGuiKeyChord")] int keyChord)
		{
			byte ret = IsKeyChordPressedNative(keyChord);
			return ret != 0;
		}

		/// <summary>
		/// uses provided repeat ratedelay. return a count, most often 0 or 1 but might be &gt;1 if RepeatRate is small enough that DeltaTime &gt; RepeatRate<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetKeyPressedAmount")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int GetKeyPressedAmountNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key, [NativeName(NativeNameType.Param, "repeat_delay")] [NativeName(NativeNameType.Type, "float")] float repeatDelay, [NativeName(NativeNameType.Param, "rate")] [NativeName(NativeNameType.Type, "float")] float rate)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, float, float, int>)vt[364])(key, repeatDelay, rate);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImGuiKey, float, float, int>)vt[364])(key, repeatDelay, rate);
			#endif
		}

		/// <summary>
		/// uses provided repeat ratedelay. return a count, most often 0 or 1 but might be &gt;1 if RepeatRate is small enough that DeltaTime &gt; RepeatRate<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetKeyPressedAmount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetKeyPressedAmount([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key, [NativeName(NativeNameType.Param, "repeat_delay")] [NativeName(NativeNameType.Type, "float")] float repeatDelay, [NativeName(NativeNameType.Param, "rate")] [NativeName(NativeNameType.Type, "float")] float rate)
		{
			int ret = GetKeyPressedAmountNative(key, repeatDelay, rate);
			return ret;
		}

		/// <summary>
		/// [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetKeyName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* GetKeyNameNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte*>)vt[365])(key);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ImGuiKey, nint>)vt[365])(key);
			#endif
		}

		/// <summary>
		/// [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetKeyName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetKeyName([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			byte* ret = GetKeyNameNative(key);
			return ret;
		}

		/// <summary>
		/// [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetKeyName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string GetKeyNameS([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyNameNative(key));
			return ret;
		}

		/// <summary>
		/// Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextFrameWantCaptureKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetNextFrameWantCaptureKeyboardNative([NativeName(NativeNameType.Param, "want_capture_keyboard")] [NativeName(NativeNameType.Type, "bool")] byte wantCaptureKeyboard)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)vt[366])(wantCaptureKeyboard);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)vt[366])(wantCaptureKeyboard);
			#endif
		}

		/// <summary>
		/// Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextFrameWantCaptureKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetNextFrameWantCaptureKeyboard([NativeName(NativeNameType.Param, "want_capture_keyboard")] [NativeName(NativeNameType.Type, "bool")] bool wantCaptureKeyboard)
		{
			SetNextFrameWantCaptureKeyboardNative(wantCaptureKeyboard ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igShortcut_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte ShortcutNative([NativeName(NativeNameType.Param, "key_chord")] [NativeName(NativeNameType.Type, "ImGuiKeyChord")] int keyChord, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiInputFlags")] ImGuiInputFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, byte>)vt[367])(keyChord, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, byte>)vt[367])(keyChord, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igShortcut_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Shortcut([NativeName(NativeNameType.Param, "key_chord")] [NativeName(NativeNameType.Type, "ImGuiKeyChord")] int keyChord, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiInputFlags")] ImGuiInputFlags flags)
		{
			byte ret = ShortcutNative(keyChord, flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igShortcut_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Shortcut([NativeName(NativeNameType.Param, "key_chord")] [NativeName(NativeNameType.Type, "ImGuiKeyChord")] int keyChord)
		{
			byte ret = ShortcutNative(keyChord, (ImGuiInputFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemShortcut")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetNextItemShortcutNative([NativeName(NativeNameType.Param, "key_chord")] [NativeName(NativeNameType.Type, "ImGuiKeyChord")] int keyChord, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiInputFlags")] ImGuiInputFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, void>)vt[368])(keyChord, flags);
			#else
			((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, void>)vt[368])(keyChord, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemShortcut")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetNextItemShortcut([NativeName(NativeNameType.Param, "key_chord")] [NativeName(NativeNameType.Type, "ImGuiKeyChord")] int keyChord, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiInputFlags")] ImGuiInputFlags flags)
		{
			SetNextItemShortcutNative(keyChord, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemShortcut")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetNextItemShortcut([NativeName(NativeNameType.Param, "key_chord")] [NativeName(NativeNameType.Type, "ImGuiKeyChord")] int keyChord)
		{
			SetNextItemShortcutNative(keyChord, (ImGuiInputFlags)(0));
		}

		/// <summary>
		/// Set key owner to last item ID if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive())  SetKeyOwner(key, GetItemID());'.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetItemKeyOwner_Nil")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetItemKeyOwnerNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKey, void>)vt[369])(key);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiKey, void>)vt[369])(key);
			#endif
		}

		/// <summary>
		/// Set key owner to last item ID if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive())  SetKeyOwner(key, GetItemID());'.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetItemKeyOwner_Nil")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetItemKeyOwner([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "ImGuiKey")] ImGuiKey key)
		{
			SetItemKeyOwnerNative(key);
		}

		/// <summary>
		/// is mouse button held?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseDown_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsMouseDownNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[370])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[370])(button);
			#endif
		}

		/// <summary>
		/// is mouse button held?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseDown_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseDown([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			byte ret = IsMouseDownNative(button);
			return ret != 0;
		}

		/// <summary>
		/// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseClicked_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsMouseClickedNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button, [NativeName(NativeNameType.Param, "repeat")] [NativeName(NativeNameType.Type, "bool")] byte repeat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte, byte>)vt[371])(button, repeat);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte, byte>)vt[371])(button, repeat);
			#endif
		}

		/// <summary>
		/// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseClicked_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseClicked([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button, [NativeName(NativeNameType.Param, "repeat")] [NativeName(NativeNameType.Type, "bool")] bool repeat)
		{
			byte ret = IsMouseClickedNative(button, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseClicked_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseClicked([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			byte ret = IsMouseClickedNative(button, (byte)(0));
			return ret != 0;
		}

		/// <summary>
		/// did mouse button released? (went from Down to !Down)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseReleased_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsMouseReleasedNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[372])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[372])(button);
			#endif
		}

		/// <summary>
		/// did mouse button released? (went from Down to !Down)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseReleased_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseReleased([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			byte ret = IsMouseReleasedNative(button);
			return ret != 0;
		}

		/// <summary>
		/// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseDoubleClicked_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsMouseDoubleClickedNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[373])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)vt[373])(button);
			#endif
		}

		/// <summary>
		/// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseDoubleClicked_Nil")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseDoubleClicked([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			byte ret = IsMouseDoubleClickedNative(button);
			return ret != 0;
		}

		/// <summary>
		/// return the number of successive mouse-clicks at the time where a click happen (otherwise 0).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseClickedCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int GetMouseClickedCountNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int>)vt[374])(button);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int>)vt[374])(button);
			#endif
		}

		/// <summary>
		/// return the number of successive mouse-clicks at the time where a click happen (otherwise 0).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseClickedCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetMouseClickedCount([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			int ret = GetMouseClickedCountNative(button);
			return ret;
		}

		/// <summary>
		/// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focuswindow orderingpopup-block.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseHoveringRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsMouseHoveringRectNative([NativeName(NativeNameType.Param, "r_min")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rMin, [NativeName(NativeNameType.Param, "r_max")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rMax, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "bool")] byte clip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte, byte>)vt[375])(rMin, rMax, clip);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte, byte>)vt[375])(rMin, rMax, clip);
			#endif
		}

		/// <summary>
		/// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focuswindow orderingpopup-block.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseHoveringRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseHoveringRect([NativeName(NativeNameType.Param, "r_min")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rMin, [NativeName(NativeNameType.Param, "r_max")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rMax, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "bool")] bool clip)
		{
			byte ret = IsMouseHoveringRectNative(rMin, rMax, clip ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focuswindow orderingpopup-block.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseHoveringRect")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseHoveringRect([NativeName(NativeNameType.Param, "r_min")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rMin, [NativeName(NativeNameType.Param, "r_max")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 rMax)
		{
			byte ret = IsMouseHoveringRectNative(rMin, rMax, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMousePosValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsMousePosValidNative([NativeName(NativeNameType.Param, "mouse_pos")] [NativeName(NativeNameType.Type, "const ImVec2*")] Vector2* mousePos)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*, byte>)vt[376])(mousePos);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[376])((nint)mousePos);
			#endif
		}

		/// <summary>
		/// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMousePosValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMousePosValid([NativeName(NativeNameType.Param, "mouse_pos")] [NativeName(NativeNameType.Type, "const ImVec2*")] Vector2* mousePos)
		{
			byte ret = IsMousePosValidNative(mousePos);
			return ret != 0;
		}

		/// <summary>
		/// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMousePosValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMousePosValid()
		{
			byte ret = IsMousePosValidNative((Vector2*)(default));
			return ret != 0;
		}

		/// <summary>
		/// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMousePosValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMousePosValid([NativeName(NativeNameType.Param, "mouse_pos")] [NativeName(NativeNameType.Type, "const ImVec2*")] ref Vector2 mousePos)
		{
			fixed (Vector2* pmousePos = &mousePos)
			{
				byte ret = IsMousePosValidNative((Vector2*)pmousePos);
				return ret != 0;
			}
		}

		/// <summary>
		/// [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsAnyMouseDown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsAnyMouseDownNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[377])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[377])();
			#endif
		}

		/// <summary>
		/// [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsAnyMouseDown")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsAnyMouseDown()
		{
			byte ret = IsAnyMouseDownNative();
			return ret != 0;
		}

		/// <summary>
		/// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMousePos")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void GetMousePosNative([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[378])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[378])((nint)pOut);
			#endif
		}

		/// <summary>
		/// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMousePos")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMousePos([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			GetMousePosNative(pOut);
		}

		/// <summary>
		/// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMousePos")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMousePos([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMousePosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMousePosOnOpeningCurrentPopup")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void GetMousePosOnOpeningCurrentPopupNative([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)vt[379])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[379])((nint)pOut);
			#endif
		}

		/// <summary>
		/// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMousePosOnOpeningCurrentPopup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMousePosOnOpeningCurrentPopup([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			GetMousePosOnOpeningCurrentPopupNative(pOut);
		}

		/// <summary>
		/// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMousePosOnOpeningCurrentPopup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMousePosOnOpeningCurrentPopup([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMousePosOnOpeningCurrentPopupNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseDragging")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsMouseDraggingNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button, [NativeName(NativeNameType.Param, "lock_threshold")] [NativeName(NativeNameType.Type, "float")] float lockThreshold)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, float, byte>)vt[380])(button, lockThreshold);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, float, byte>)vt[380])(button, lockThreshold);
			#endif
		}

		/// <summary>
		/// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseDragging")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseDragging([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button, [NativeName(NativeNameType.Param, "lock_threshold")] [NativeName(NativeNameType.Type, "float")] float lockThreshold)
		{
			byte ret = IsMouseDraggingNative(button, lockThreshold);
			return ret != 0;
		}

		/// <summary>
		/// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsMouseDragging")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsMouseDragging([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			byte ret = IsMouseDraggingNative(button, (float)(-1.0f));
			return ret != 0;
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void GetMouseDragDeltaNative([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button, [NativeName(NativeNameType.Param, "lock_threshold")] [NativeName(NativeNameType.Type, "float")] float lockThreshold)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiMouseButton, float, void>)vt[381])(pOut, button, lockThreshold);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiMouseButton, float, void>)vt[381])((nint)pOut, button, lockThreshold);
			#endif
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMouseDragDelta([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button, [NativeName(NativeNameType.Param, "lock_threshold")] [NativeName(NativeNameType.Type, "float")] float lockThreshold)
		{
			GetMouseDragDeltaNative(pOut, button, lockThreshold);
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMouseDragDelta([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			GetMouseDragDeltaNative(pOut, button, (float)(-1.0f));
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMouseDragDelta([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut)
		{
			GetMouseDragDeltaNative(pOut, (ImGuiMouseButton)(0), (float)(-1.0f));
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMouseDragDelta([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] Vector2* pOut, [NativeName(NativeNameType.Param, "lock_threshold")] [NativeName(NativeNameType.Type, "float")] float lockThreshold)
		{
			GetMouseDragDeltaNative(pOut, (ImGuiMouseButton)(0), lockThreshold);
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMouseDragDelta([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button, [NativeName(NativeNameType.Param, "lock_threshold")] [NativeName(NativeNameType.Type, "float")] float lockThreshold)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMouseDragDeltaNative((Vector2*)ppOut, button, lockThreshold);
			}
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMouseDragDelta([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMouseDragDeltaNative((Vector2*)ppOut, button, (float)(-1.0f));
			}
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMouseDragDelta([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMouseDragDeltaNative((Vector2*)ppOut, (ImGuiMouseButton)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMouseDragDelta([NativeName(NativeNameType.Param, "pOut")] [NativeName(NativeNameType.Type, "ImVec2*")] ref Vector2 pOut, [NativeName(NativeNameType.Param, "lock_threshold")] [NativeName(NativeNameType.Type, "float")] float lockThreshold)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMouseDragDeltaNative((Vector2*)ppOut, (ImGuiMouseButton)(0), lockThreshold);
			}
		}

		/// <summary>
		/// </summary>
		[NativeName(NativeNameType.Func, "igResetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void ResetMouseDragDeltaNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMouseButton, void>)vt[382])(button);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiMouseButton, void>)vt[382])(button);
			#endif
		}

		/// <summary>
		/// </summary>
		[NativeName(NativeNameType.Func, "igResetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ResetMouseDragDelta([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "ImGuiMouseButton")] ImGuiMouseButton button)
		{
			ResetMouseDragDeltaNative(button);
		}

		/// <summary>
		/// </summary>
		[NativeName(NativeNameType.Func, "igResetMouseDragDelta")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ResetMouseDragDelta()
		{
			ResetMouseDragDeltaNative((ImGuiMouseButton)(0));
		}

		/// <summary>
		/// get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseCursor")]
		[return: NativeName(NativeNameType.Type, "ImGuiMouseCursor")]
		internal static ImGuiMouseCursor GetMouseCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseCursor>)vt[383])();
			#else
			return (ImGuiMouseCursor)((delegate* unmanaged[Cdecl]<ImGuiMouseCursor>)vt[383])();
			#endif
		}

		/// <summary>
		/// get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetMouseCursor")]
		[return: NativeName(NativeNameType.Type, "ImGuiMouseCursor")]
		public static ImGuiMouseCursor GetMouseCursor()
		{
			ImGuiMouseCursor ret = GetMouseCursorNative();
			return ret;
		}

		/// <summary>
		/// set desired mouse cursor shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetMouseCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetMouseCursorNative([NativeName(NativeNameType.Param, "cursor_type")] [NativeName(NativeNameType.Type, "ImGuiMouseCursor")] ImGuiMouseCursor cursorType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMouseCursor, void>)vt[384])(cursorType);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiMouseCursor, void>)vt[384])(cursorType);
			#endif
		}

		/// <summary>
		/// set desired mouse cursor shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetMouseCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetMouseCursor([NativeName(NativeNameType.Param, "cursor_type")] [NativeName(NativeNameType.Type, "ImGuiMouseCursor")] ImGuiMouseCursor cursorType)
		{
			SetMouseCursorNative(cursorType);
		}

		/// <summary>
		/// Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instucts your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextFrameWantCaptureMouse")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetNextFrameWantCaptureMouseNative([NativeName(NativeNameType.Param, "want_capture_mouse")] [NativeName(NativeNameType.Type, "bool")] byte wantCaptureMouse)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)vt[385])(wantCaptureMouse);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)vt[385])(wantCaptureMouse);
			#endif
		}

		/// <summary>
		/// Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instucts your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextFrameWantCaptureMouse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetNextFrameWantCaptureMouse([NativeName(NativeNameType.Param, "want_capture_mouse")] [NativeName(NativeNameType.Type, "bool")] bool wantCaptureMouse)
		{
			SetNextFrameWantCaptureMouseNative(wantCaptureMouse ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetClipboardText")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		internal static byte* GetClipboardTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)vt[386])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)vt[386])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetClipboardText")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetClipboardText()
		{
			byte* ret = GetClipboardTextNative();
			return ret;
		}
	}
}
