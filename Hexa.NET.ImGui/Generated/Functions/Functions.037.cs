// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = ColorPicker4Native((byte*)plabel, col, (ImGuiColorEditFlags)(0), refCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColorPicker4Native((byte*)plabel, col, flags, refCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColorPicker4Native((byte*)plabel, col, flags, (float*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColorPicker4Native((byte*)plabel, col, (ImGuiColorEditFlags)(0), (float*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (byte* plabel = label)
			{
				byte ret = ColorPicker4Native((byte*)plabel, col, (ImGuiColorEditFlags)(0), refCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorPicker4Native(pStr0, col, flags, refCol);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorPicker4Native(pStr0, col, flags, (float*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorPicker4Native(pStr0, col, (ImGuiColorEditFlags)(0), (float*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorPicker4Native(pStr0, col, (ImGuiColorEditFlags)(0), refCol);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, refCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), refCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (float* pcol = col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, refCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			fixed (float* pcol = col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col)
		{
			fixed (float* pcol = col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (float* pcol = col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), refCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, refCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), refCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, flags, refCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, flags, (float*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0), refCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pcol = col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, flags, refCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pcol = col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, flags, (float*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pcol = col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pcol = col)
				{
					byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0), refCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(pStr0, (float*)pcol, flags, refCol);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(pStr0, (float*)pcol, flags, (float*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] float* refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0), refCol);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (float* prefCol = &refCol)
			{
				byte ret = ColorPicker4Native(label, col, flags, (float*)prefCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (float* prefCol = &refCol)
			{
				byte ret = ColorPicker4Native(label, col, (ImGuiColorEditFlags)(0), (float*)prefCol);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native((byte*)plabel, col, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native((byte*)plabel, col, (ImGuiColorEditFlags)(0), (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native((byte*)plabel, col, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native((byte*)plabel, col, (ImGuiColorEditFlags)(0), (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* prefCol = &refCol)
			{
				byte ret = ColorPicker4Native(pStr0, col, flags, (float*)prefCol);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] float* col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (float* prefCol = &refCol)
			{
				byte ret = ColorPicker4Native(pStr0, col, (ImGuiColorEditFlags)(0), (float*)prefCol);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (float* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (float* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (float* pcol = col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (float* pcol = col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					fixed (float* prefCol = &refCol)
					{
						byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, flags, (float*)prefCol);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref float col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (byte* plabel = &label)
			{
				fixed (float* pcol = &col)
				{
					fixed (float* prefCol = &refCol)
					{
						byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)prefCol);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pcol = col)
				{
					fixed (float* prefCol = &refCol)
					{
						byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, flags, (float*)prefCol);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ReadOnlySpan<float> col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			fixed (byte* plabel = label)
			{
				fixed (float* pcol = col)
				{
					fixed (float* prefCol = &refCol)
					{
						byte ret = ColorPicker4Native((byte*)plabel, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)prefCol);
						return ret != 0;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(pStr0, (float*)pcol, flags, (float*)prefCol);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorPicker4")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorPicker4([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "float[4]")] ref Vector4 col, [NativeName(NativeNameType.Param, "ref_col")] [NativeName(NativeNameType.Type, "const float*")] ref float refCol)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(pStr0, (float*)pcol, (ImGuiColorEditFlags)(0), (float*)prefCol);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte ColorButtonNative([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] byte* descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Vector4, ImGuiColorEditFlags, Vector2, byte>)vt[204])(descId, col, flags, size);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector4, ImGuiColorEditFlags, Vector2, byte>)vt[204])((nint)descId, col, flags, size);
			#endif
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] byte* descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = ColorButtonNative(descId, col, flags, size);
			return ret != 0;
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] byte* descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			byte ret = ColorButtonNative(descId, col, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] byte* descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col)
		{
			byte ret = ColorButtonNative(descId, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] byte* descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = ColorButtonNative(descId, col, (ImGuiColorEditFlags)(0), size);
			return ret != 0;
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, flags, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* pdescId = &descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, (ImGuiColorEditFlags)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* pdescId = descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, flags, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			fixed (byte* pdescId = descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col)
		{
			fixed (byte* pdescId = descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* pdescId = descId)
			{
				byte ret = ColorButtonNative((byte*)pdescId, col, (ImGuiColorEditFlags)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] string descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorButtonNative(pStr0, col, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] string descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorButtonNative(pStr0, col, flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] string descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorButtonNative(pStr0, col, (ImGuiColorEditFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// display a color squarebutton, hover for details, return true when pressed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igColorButton")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ColorButton([NativeName(NativeNameType.Param, "desc_id")] [NativeName(NativeNameType.Type, "const char*")] string descId, [NativeName(NativeNameType.Param, "col")] [NativeName(NativeNameType.Type, "const ImVec4")] Vector4 col, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (descId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(descId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(descId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = ColorButtonNative(pStr0, col, (ImGuiColorEditFlags)(0), size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetColorEditOptions")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetColorEditOptionsNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiColorEditFlags, void>)vt[205])(flags);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiColorEditFlags, void>)vt[205])(flags);
			#endif
		}

		/// <summary>
		/// initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetColorEditOptions")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetColorEditOptions([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiColorEditFlags")] ImGuiColorEditFlags flags)
		{
			SetColorEditOptionsNative(flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeNative([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte>)vt[206])(label);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[206])((nint)label);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label)
		{
			byte ret = TreeNodeNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TreeNodeNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = TreeNodeNative((byte*)plabel);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeNative([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, byte>)vt[207])(strId, fmt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)vt[207])((nint)strId, (nint)fmt);
			#endif
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			byte ret = TreeNodeNative(strId, fmt);
			return ret != 0;
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = TreeNodeNative((byte*)pstrId, fmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = TreeNodeNative((byte*)pstrId, fmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] string strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeNative(pStr0, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeNative(strId, (byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = TreeNodeNative(strId, (byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeNative(strId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					byte ret = TreeNodeNative((byte*)pstrId, (byte*)pfmt);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pstrId = strId)
			{
				fixed (byte* pfmt = fmt)
				{
					byte ret = TreeNodeNative((byte*)pstrId, (byte*)pfmt);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] string strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TreeNodeNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeNative([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, byte*, byte>)vt[208])(ptrId, fmt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)vt[208])((nint)ptrId, (nint)fmt);
			#endif
		}

		/// <summary>
		/// "<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			byte ret = TreeNodeNative(ptrId, fmt);
			return ret != 0;
		}

		/// <summary>
		/// "<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeNative(ptrId, (byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// "<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = TreeNodeNative(ptrId, (byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// "<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNode_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNode([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeNative(ptrId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeVNative([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, nint, byte>)vt[209])(strId, fmt, args);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)vt[209])((nint)strId, (nint)fmt, args);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte ret = TreeNodeVNative(strId, fmt, args);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = TreeNodeVNative((byte*)pstrId, fmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = TreeNodeVNative((byte*)pstrId, fmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] string strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeVNative(pStr0, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeVNative(strId, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = TreeNodeVNative(strId, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeVNative(strId, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					byte ret = TreeNodeVNative((byte*)pstrId, (byte*)pfmt, args);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pstrId = strId)
			{
				fixed (byte* pfmt = fmt)
				{
					byte ret = TreeNodeVNative((byte*)pstrId, (byte*)pfmt, args);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] string strId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TreeNodeVNative(pStr0, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeVNative([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, byte*, nint, byte>)vt[210])(ptrId, fmt, args);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, nint, byte>)vt[210])((nint)ptrId, (nint)fmt, args);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte ret = TreeNodeVNative(ptrId, fmt, args);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeVNative(ptrId, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = TreeNodeVNative(ptrId, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeV([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeVNative(ptrId, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeExNative([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiTreeNodeFlags, byte>)vt[211])(label, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiTreeNodeFlags, byte>)vt[211])((nint)label, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			byte ret = TreeNodeExNative(label, flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label)
		{
			byte ret = TreeNodeExNative(label, (ImGuiTreeNodeFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TreeNodeExNative((byte*)plabel, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = TreeNodeExNative((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = TreeNodeExNative((byte*)plabel, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = TreeNodeExNative((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(pStr0, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeExNative([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiTreeNodeFlags, byte*, byte>)vt[212])(strId, flags, fmt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiTreeNodeFlags, nint, byte>)vt[212])((nint)strId, flags, (nint)fmt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			byte ret = TreeNodeExNative(strId, flags, fmt);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = TreeNodeExNative((byte*)pstrId, flags, fmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = TreeNodeExNative((byte*)pstrId, flags, fmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] string strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(pStr0, flags, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExNative(strId, flags, (byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = TreeNodeExNative(strId, flags, (byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(strId, flags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					byte ret = TreeNodeExNative((byte*)pstrId, flags, (byte*)pfmt);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pstrId = strId)
			{
				fixed (byte* pfmt = fmt)
				{
					byte ret = TreeNodeExNative((byte*)pstrId, flags, (byte*)pfmt);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_StrStr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] string strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TreeNodeExNative(pStr0, flags, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeExNative([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, ImGuiTreeNodeFlags, byte*, byte>)vt[213])(ptrId, flags, fmt);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiTreeNodeFlags, nint, byte>)vt[213])((nint)ptrId, flags, (nint)fmt);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			byte ret = TreeNodeExNative(ptrId, flags, fmt);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExNative(ptrId, flags, (byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = TreeNodeExNative(ptrId, flags, (byte*)pfmt);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeEx_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeEx([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(ptrId, flags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeExVNative([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiTreeNodeFlags, byte*, nint, byte>)vt[214])(strId, flags, fmt, args);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiTreeNodeFlags, nint, nint, byte>)vt[214])((nint)strId, flags, (nint)fmt, args);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte ret = TreeNodeExVNative(strId, flags, fmt, args);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pstrId = &strId)
			{
				byte ret = TreeNodeExVNative((byte*)pstrId, flags, fmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pstrId = strId)
			{
				byte ret = TreeNodeExVNative((byte*)pstrId, flags, fmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] string strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExVNative(pStr0, flags, fmt, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExVNative(strId, flags, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = TreeNodeExVNative(strId, flags, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExVNative(strId, flags, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pstrId = &strId)
			{
				fixed (byte* pfmt = &fmt)
				{
					byte ret = TreeNodeExVNative((byte*)pstrId, flags, (byte*)pfmt, args);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pstrId = strId)
			{
				fixed (byte* pfmt = fmt)
				{
					byte ret = TreeNodeExVNative((byte*)pstrId, flags, (byte*)pfmt, args);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Str")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] string strId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = TreeNodeExVNative(pStr0, flags, pStr1, args);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte TreeNodeExVNative([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, ImGuiTreeNodeFlags, byte*, nint, byte>)vt[215])(ptrId, flags, fmt, args);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiTreeNodeFlags, nint, nint, byte>)vt[215])((nint)ptrId, flags, (nint)fmt, args);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte ret = TreeNodeExVNative(ptrId, flags, fmt, args);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExVNative(ptrId, flags, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			fixed (byte* pfmt = fmt)
			{
				byte ret = TreeNodeExVNative(ptrId, flags, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreeNodeExV_Ptr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool TreeNodeExV([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "va_list")] nint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExVNative(ptrId, flags, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// ~ Indent()+PushID(). Already called by TreeNode() when returning true, but you can call TreePushTreePop yourself if desired.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreePush_Str")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void TreePushNative([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)vt[216])(strId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[216])((nint)strId);
			#endif
		}

		/// <summary>
		/// ~ Indent()+PushID(). Already called by TreeNode() when returning true, but you can call TreePushTreePop yourself if desired.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreePush_Str")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TreePush([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] byte* strId)
		{
			TreePushNative(strId);
		}

		/// <summary>
		/// ~ Indent()+PushID(). Already called by TreeNode() when returning true, but you can call TreePushTreePop yourself if desired.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreePush_Str")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TreePush([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ref byte strId)
		{
			fixed (byte* pstrId = &strId)
			{
				TreePushNative((byte*)pstrId);
			}
		}

		/// <summary>
		/// ~ Indent()+PushID(). Already called by TreeNode() when returning true, but you can call TreePushTreePop yourself if desired.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreePush_Str")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TreePush([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> strId)
		{
			fixed (byte* pstrId = strId)
			{
				TreePushNative((byte*)pstrId);
			}
		}

		/// <summary>
		/// ~ Indent()+PushID(). Already called by TreeNode() when returning true, but you can call TreePushTreePop yourself if desired.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreePush_Str")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TreePush([NativeName(NativeNameType.Param, "str_id")] [NativeName(NativeNameType.Type, "const char*")] string strId)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strId != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strId);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strId, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			TreePushNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// ~ Indent()+PushID(). Already called by TreeNode() when returning true, but you can call TreePushTreePop yourself if desired.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreePush_Ptr")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void TreePushNative([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)vt[217])(ptrId);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[217])((nint)ptrId);
			#endif
		}

		/// <summary>
		/// "<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreePush_Ptr")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TreePush([NativeName(NativeNameType.Param, "ptr_id")] [NativeName(NativeNameType.Type, "const void*")] void* ptrId)
		{
			TreePushNative(ptrId);
		}

		/// <summary>
		/// ~ Unindent()+PopID()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreePop")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void TreePopNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[218])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[218])();
			#endif
		}

		/// <summary>
		/// ~ Unindent()+PopID()<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igTreePop")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void TreePop()
		{
			TreePopNative();
		}

		/// <summary>
		/// horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetTreeNodeToLabelSpacing")]
		[return: NativeName(NativeNameType.Type, "float")]
		internal static float GetTreeNodeToLabelSpacingNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[219])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[219])();
			#endif
		}

		/// <summary>
		/// horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igGetTreeNodeToLabelSpacing")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetTreeNodeToLabelSpacing()
		{
			float ret = GetTreeNodeToLabelSpacingNative();
			return ret;
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_TreeNodeFlags")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte CollapsingHeaderNative([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, ImGuiTreeNodeFlags, byte>)vt[220])(label, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, ImGuiTreeNodeFlags, byte>)vt[220])((nint)label, flags);
			#endif
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_TreeNodeFlags")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			byte ret = CollapsingHeaderNative(label, flags);
			return ret != 0;
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_TreeNodeFlags")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label)
		{
			byte ret = CollapsingHeaderNative(label, (ImGuiTreeNodeFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_TreeNodeFlags")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_TreeNodeFlags")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_TreeNodeFlags")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_TreeNodeFlags")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_TreeNodeFlags")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CollapsingHeaderNative(pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_TreeNodeFlags")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CollapsingHeaderNative(pStr0, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte CollapsingHeaderNative([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] bool* pVisible, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, bool*, ImGuiTreeNodeFlags, byte>)vt[221])(label, pVisible, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ImGuiTreeNodeFlags, byte>)vt[221])((nint)label, (nint)pVisible, flags);
			#endif
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] bool* pVisible, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			byte ret = CollapsingHeaderNative(label, pVisible, flags);
			return ret != 0;
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] bool* pVisible)
		{
			byte ret = CollapsingHeaderNative(label, pVisible, (ImGuiTreeNodeFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] bool* pVisible, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, pVisible, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] bool* pVisible)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, pVisible, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] bool* pVisible, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, pVisible, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] bool* pVisible)
		{
			fixed (byte* plabel = label)
			{
				byte ret = CollapsingHeaderNative((byte*)plabel, pVisible, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] bool* pVisible, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CollapsingHeaderNative(pStr0, pVisible, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] bool* pVisible)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = CollapsingHeaderNative(pStr0, pVisible, (ImGuiTreeNodeFlags)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] ref bool pVisible, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(label, (bool*)ppVisible, flags);
				return ret != 0;
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] ref bool pVisible)
		{
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(label, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] ref bool pVisible, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = CollapsingHeaderNative((byte*)plabel, (bool*)ppVisible, flags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] ref bool pVisible)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = CollapsingHeaderNative((byte*)plabel, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] ref bool pVisible, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = CollapsingHeaderNative((byte*)plabel, (bool*)ppVisible, flags);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] ref bool pVisible)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppVisible = &pVisible)
				{
					byte ret = CollapsingHeaderNative((byte*)plabel, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] ref bool pVisible, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiTreeNodeFlags")] ImGuiTreeNodeFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(pStr0, (bool*)ppVisible, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igCollapsingHeader_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool CollapsingHeader([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_visible")] [NativeName(NativeNameType.Type, "bool*")] ref bool pVisible)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(pStr0, (bool*)ppVisible, (ImGuiTreeNodeFlags)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// set next TreeNodeCollapsingHeader open state.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemOpen")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetNextItemOpenNative([NativeName(NativeNameType.Param, "is_open")] [NativeName(NativeNameType.Type, "bool")] byte isOpen, [NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "ImGuiCond")] ImGuiCond cond)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[222])(isOpen, cond);
			#else
			((delegate* unmanaged[Cdecl]<byte, ImGuiCond, void>)vt[222])(isOpen, cond);
			#endif
		}

		/// <summary>
		/// set next TreeNodeCollapsingHeader open state.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemOpen")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetNextItemOpen([NativeName(NativeNameType.Param, "is_open")] [NativeName(NativeNameType.Type, "bool")] bool isOpen, [NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "ImGuiCond")] ImGuiCond cond)
		{
			SetNextItemOpenNative(isOpen ? (byte)1 : (byte)0, cond);
		}

		/// <summary>
		/// set next TreeNodeCollapsingHeader open state.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemOpen")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetNextItemOpen([NativeName(NativeNameType.Param, "is_open")] [NativeName(NativeNameType.Type, "bool")] bool isOpen)
		{
			SetNextItemOpenNative(isOpen ? (byte)1 : (byte)0, (ImGuiCond)(0));
		}

		/// <summary>
		/// set id to use for openclose storage (default to same as item id).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemStorageID")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetNextItemStorageIDNative([NativeName(NativeNameType.Param, "storage_id")] [NativeName(NativeNameType.Type, "ImGuiID")] uint storageId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)vt[223])(storageId);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)vt[223])(storageId);
			#endif
		}

		/// <summary>
		/// set id to use for openclose storage (default to same as item id).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemStorageID")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetNextItemStorageID([NativeName(NativeNameType.Param, "storage_id")] [NativeName(NativeNameType.Type, "ImGuiID")] uint storageId)
		{
			SetNextItemStorageIDNative(storageId);
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte SelectableNative([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] byte selected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte, ImGuiSelectableFlags, Vector2, byte>)vt[224])(label, selected, flags, size);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte, ImGuiSelectableFlags, Vector2, byte>)vt[224])((nint)label, selected, flags, size);
			#endif
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, flags, size);
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label)
		{
			byte ret = SelectableNative(label, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			byte ret = SelectableNative(label, (byte)(0), flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), size);
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = SelectableNative(label, (byte)(0), (ImGuiSelectableFlags)(0), size);
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = SelectableNative(label, (byte)(0), flags, size);
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, flags, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, (byte)(0), flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, (byte)(0), (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, (byte)(0), flags, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, flags, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, (byte)(0), flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, (byte)(0), (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, (byte)(0), flags, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, selected ? (byte)1 : (byte)0, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, (byte)(0), (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, (byte)(0), flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "selected")] [NativeName(NativeNameType.Type, "bool")] bool selected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, selected ? (byte)1 : (byte)0, (ImGuiSelectableFlags)(0), size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, (byte)(0), (ImGuiSelectableFlags)(0), size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_Bool")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, (byte)(0), flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x&gt;0.0: specify width. size.y==0.0: use label height, size.y&gt;0.0: specify height<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte SelectableNative([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, bool*, ImGuiSelectableFlags, Vector2, byte>)vt[225])(label, pSelected, flags, size);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, ImGuiSelectableFlags, Vector2, byte>)vt[225])((nint)label, (nint)pSelected, flags, size);
			#endif
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = SelectableNative(label, pSelected, flags, size);
			return ret != 0;
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			byte ret = SelectableNative(label, pSelected, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected)
		{
			byte ret = SelectableNative(label, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = SelectableNative(label, pSelected, (ImGuiSelectableFlags)(0), size);
			return ret != 0;
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, flags, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, flags, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = SelectableNative((byte*)plabel, pSelected, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, pSelected, flags, size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, pSelected, flags, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, pSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] bool* pSelected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SelectableNative(pStr0, pSelected, (ImGuiSelectableFlags)(0), size);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (bool*)ppSelected, flags, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (bool*)ppSelected, (ImGuiSelectableFlags)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, flags, size);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), size);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, flags, size);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				fixed (bool* ppSelected = &pSelected)
				{
					byte ret = SelectableNative((byte*)plabel, (bool*)ppSelected, (ImGuiSelectableFlags)(0), size);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(pStr0, (bool*)ppSelected, flags, size);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiSelectableFlags")] ImGuiSelectableFlags flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(pStr0, (bool*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(pStr0, (bool*)ppSelected, (ImGuiSelectableFlags)(0), (Vector2)(new Vector2(0,0)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// "bool* p_selected" point to the selection state (read-write), as a convenient helper.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igSelectable_BoolPtr")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Selectable([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] string label, [NativeName(NativeNameType.Param, "p_selected")] [NativeName(NativeNameType.Type, "bool*")] ref bool pSelected, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (bool* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(pStr0, (bool*)ppSelected, (ImGuiSelectableFlags)(0), size);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginMultiSelect")]
		[return: NativeName(NativeNameType.Type, "ImGuiMultiSelectIO*")]
		internal static ImGuiMultiSelectIO* BeginMultiSelectNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiMultiSelectFlags")] ImGuiMultiSelectFlags flags, [NativeName(NativeNameType.Param, "selection_size")] [NativeName(NativeNameType.Type, "int")] int selectionSize, [NativeName(NativeNameType.Param, "items_count")] [NativeName(NativeNameType.Type, "int")] int itemsCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMultiSelectFlags, int, int, ImGuiMultiSelectIO*>)vt[226])(flags, selectionSize, itemsCount);
			#else
			return (ImGuiMultiSelectIO*)((delegate* unmanaged[Cdecl]<ImGuiMultiSelectFlags, int, int, nint>)vt[226])(flags, selectionSize, itemsCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginMultiSelect")]
		[return: NativeName(NativeNameType.Type, "ImGuiMultiSelectIO*")]
		public static ImGuiMultiSelectIO* BeginMultiSelect([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiMultiSelectFlags")] ImGuiMultiSelectFlags flags, [NativeName(NativeNameType.Param, "selection_size")] [NativeName(NativeNameType.Type, "int")] int selectionSize, [NativeName(NativeNameType.Param, "items_count")] [NativeName(NativeNameType.Type, "int")] int itemsCount)
		{
			ImGuiMultiSelectIO* ret = BeginMultiSelectNative(flags, selectionSize, itemsCount);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginMultiSelect")]
		[return: NativeName(NativeNameType.Type, "ImGuiMultiSelectIO*")]
		public static ImGuiMultiSelectIO* BeginMultiSelect([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiMultiSelectFlags")] ImGuiMultiSelectFlags flags, [NativeName(NativeNameType.Param, "selection_size")] [NativeName(NativeNameType.Type, "int")] int selectionSize)
		{
			ImGuiMultiSelectIO* ret = BeginMultiSelectNative(flags, selectionSize, (int)(-1));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginMultiSelect")]
		[return: NativeName(NativeNameType.Type, "ImGuiMultiSelectIO*")]
		public static ImGuiMultiSelectIO* BeginMultiSelect([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "ImGuiMultiSelectFlags")] ImGuiMultiSelectFlags flags)
		{
			ImGuiMultiSelectIO* ret = BeginMultiSelectNative(flags, (int)(-1), (int)(-1));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igEndMultiSelect")]
		[return: NativeName(NativeNameType.Type, "ImGuiMultiSelectIO*")]
		internal static ImGuiMultiSelectIO* EndMultiSelectNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMultiSelectIO*>)vt[227])();
			#else
			return (ImGuiMultiSelectIO*)((delegate* unmanaged[Cdecl]<nint>)vt[227])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igEndMultiSelect")]
		[return: NativeName(NativeNameType.Type, "ImGuiMultiSelectIO*")]
		public static ImGuiMultiSelectIO* EndMultiSelect()
		{
			ImGuiMultiSelectIO* ret = EndMultiSelectNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemSelectionUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetNextItemSelectionUserDataNative([NativeName(NativeNameType.Param, "selection_user_data")] [NativeName(NativeNameType.Type, "ImGuiSelectionUserData")] long selectionUserData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<long, void>)vt[228])(selectionUserData);
			#else
			((delegate* unmanaged[Cdecl]<long, void>)vt[228])(selectionUserData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[NativeName(NativeNameType.Func, "igSetNextItemSelectionUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetNextItemSelectionUserData([NativeName(NativeNameType.Param, "selection_user_data")] [NativeName(NativeNameType.Type, "ImGuiSelectionUserData")] long selectionUserData)
		{
			SetNextItemSelectionUserDataNative(selectionUserData);
		}

		/// <summary>
		/// Was the last item selection state toggled? Useful if you need the per-item information _before_ reaching EndMultiSelect(). We only returns toggle _event_ in order to handle clipping correctly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemToggledSelection")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsItemToggledSelectionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)vt[229])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)vt[229])();
			#endif
		}

		/// <summary>
		/// Was the last item selection state toggled? Useful if you need the per-item information _before_ reaching EndMultiSelect(). We only returns toggle _event_ in order to handle clipping correctly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igIsItemToggledSelection")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsItemToggledSelection()
		{
			byte ret = IsItemToggledSelectionNative();
			return ret != 0;
		}

		/// <summary>
		/// open a framed scrolling region<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginListBox")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte BeginListBoxNative([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, Vector2, byte>)vt[230])(label, size);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, Vector2, byte>)vt[230])((nint)label, size);
			#endif
		}

		/// <summary>
		/// open a framed scrolling region<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginListBox")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BeginListBox([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			byte ret = BeginListBoxNative(label, size);
			return ret != 0;
		}

		/// <summary>
		/// open a framed scrolling region<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginListBox")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BeginListBox([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] byte* label)
		{
			byte ret = BeginListBoxNative(label, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// open a framed scrolling region<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginListBox")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BeginListBox([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginListBoxNative((byte*)plabel, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// open a framed scrolling region<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginListBox")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BeginListBox([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = BeginListBoxNative((byte*)plabel, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		/// <summary>
		/// open a framed scrolling region<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginListBox")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BeginListBox([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "const ImVec2")] Vector2 size)
		{
			fixed (byte* plabel = label)
			{
				byte ret = BeginListBoxNative((byte*)plabel, size);
				return ret != 0;
			}
		}

		/// <summary>
		/// open a framed scrolling region<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "igBeginListBox")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BeginListBox([NativeName(NativeNameType.Param, "label")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel = label)
			{
				byte ret = BeginListBoxNative((byte*)plabel, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}
	}
}
