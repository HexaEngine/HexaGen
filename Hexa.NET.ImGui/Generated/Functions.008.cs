// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPlotLines_FnFloatPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PlotLinesNative(byte* label, delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize);

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  float scaleMin)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  float scaleMin)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  float scaleMin)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  float scaleMin,  float scaleMax)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  float scaleMin,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize);
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPlotHistogram_FloatPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PlotHistogramNative(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride);

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  float scaleMin)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  float scaleMin,  float scaleMax)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  float scaleMin,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  float scaleMin,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  float scaleMin,  float scaleMax,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			PlotHistogramNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotHistogram( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotHistogramNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPlotHistogram_FnFloatPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PlotHistogramNative(byte* label, delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter, void* data, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize);

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  float scaleMin)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  float scaleMin)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  float scaleMin)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  float scaleMin,  float scaleMax)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  float scaleMin,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize);
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotHistogram( byte* label,  delegate*<byte*, delegate*<void*, int, float>, void*, int, int, byte*, float, float, Vector2, float> valuesGetter,  void* data,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotHistogramNative(label, valuesGetter, data, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igValue_Bool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ValueNative(byte* prefix, byte b);

		public static void Value( byte* prefix,  bool b)
		{
			ValueNative(prefix, b ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igValue_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ValueNative(byte* prefix, int v);

		public static void Value( byte* prefix,  int v)
		{
			ValueNative(prefix, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igValue_Uint")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ValueNative(byte* prefix, uint v);

		public static void Value( byte* prefix,  uint v)
		{
			ValueNative(prefix, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igValue_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ValueNative(byte* prefix, float v, byte* floatFormat);

		public static void Value( byte* prefix,  float v,  byte* floatFormat)
		{
			ValueNative(prefix, v, floatFormat);
		}

		public static void Value( byte* prefix,  float v)
		{
			ValueNative(prefix, v, (byte*)(default));
		}

		public static void Value( byte* prefix,  float v,  ref byte floatFormat)
		{
			fixed (byte* pfloatFormat = &floatFormat)
			{
				ValueNative(prefix, v, (byte*)pfloatFormat);
			}
		}

		public static void Value( byte* prefix,  float v,  string floatFormat)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (floatFormat != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(floatFormat);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(floatFormat, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ValueNative(prefix, v, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginMenuBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginMenuBarNative();

		public static bool BeginMenuBar()
		{
			byte ret = BeginMenuBarNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndMenuBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndMenuBarNative();

		public static void EndMenuBar()
		{
			EndMenuBarNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginMainMenuBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginMainMenuBarNative();

		public static bool BeginMainMenuBar()
		{
			byte ret = BeginMainMenuBarNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndMainMenuBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndMainMenuBarNative();

		public static void EndMainMenuBar()
		{
			EndMainMenuBarNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginMenu")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginMenuNative(byte* label, byte enabled);

		public static bool BeginMenu( byte* label,  bool enabled)
		{
			byte ret = BeginMenuNative(label, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool BeginMenu( byte* label)
		{
			byte ret = BeginMenuNative(label, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndMenu")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndMenuNative();

		public static void EndMenu()
		{
			EndMenuNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igMenuItem_Bool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte MenuItemNative(byte* label, byte* shortcut, byte selected, byte enabled);

		public static bool MenuItem( byte* label,  byte* shortcut,  bool selected,  bool enabled)
		{
			byte ret = MenuItemNative(label, shortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  byte* shortcut,  bool selected)
		{
			byte ret = MenuItemNative(label, shortcut, selected ? (byte)1 : (byte)0, (byte)(1));
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  byte* shortcut)
		{
			byte ret = MenuItemNative(label, shortcut, (byte)(0), (byte)(1));
			return ret != 0;
		}

		public static bool MenuItem( byte* label)
		{
			byte ret = MenuItemNative(label, (byte*)(default), (byte)(0), (byte)(1));
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  bool selected)
		{
			byte ret = MenuItemNative(label, (byte*)(default), selected ? (byte)1 : (byte)0, (byte)(1));
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  bool selected,  bool enabled)
		{
			byte ret = MenuItemNative(label, (byte*)(default), selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  ref byte shortcut,  bool selected,  bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItem( byte* label,  ref byte shortcut,  bool selected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, selected ? (byte)1 : (byte)0, (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem( byte* label,  ref byte shortcut)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, (byte)(0), (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem( byte* label,  string shortcut,  bool selected,  bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, selected ? (byte)1 : (byte)0, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  string shortcut,  bool selected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, selected ? (byte)1 : (byte)0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  string shortcut)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, (byte)(0), (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igMenuItem_BoolPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte MenuItemNative(byte* label, byte* shortcut, byte* pSelected, byte enabled);

		public static bool MenuItem( byte* label,  byte* shortcut,  byte* pSelected,  bool enabled)
		{
			byte ret = MenuItemNative(label, shortcut, pSelected, enabled ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  byte* shortcut,  byte* pSelected)
		{
			byte ret = MenuItemNative(label, shortcut, pSelected, (byte)(1));
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  ref byte shortcut,  byte* pSelected,  bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, pSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItem( byte* label,  ref byte shortcut,  byte* pSelected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				byte ret = MenuItemNative(label, (byte*)pshortcut, pSelected, (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem( byte* label,  string shortcut,  byte* pSelected,  bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, pSelected, enabled ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  string shortcut,  byte* pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = MenuItemNative(label, pStr0, pSelected, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool MenuItem( byte* label,  byte* shortcut,  ref byte pSelected,  bool enabled)
		{
			fixed (byte* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(label, shortcut, (byte*)ppSelected, enabled ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		public static bool MenuItem( byte* label,  byte* shortcut,  ref byte pSelected)
		{
			fixed (byte* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(label, shortcut, (byte*)ppSelected, (byte)(1));
				return ret != 0;
			}
		}

		public static bool MenuItem( byte* label,  ref byte shortcut,  ref byte pSelected,  bool enabled)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (byte* ppSelected = &pSelected)
				{
					byte ret = MenuItemNative(label, (byte*)pshortcut, (byte*)ppSelected, enabled ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		public static bool MenuItem( byte* label,  ref byte shortcut,  ref byte pSelected)
		{
			fixed (byte* pshortcut = &shortcut)
			{
				fixed (byte* ppSelected = &pSelected)
				{
					byte ret = MenuItemNative(label, (byte*)pshortcut, (byte*)ppSelected, (byte)(1));
					return ret != 0;
				}
			}
		}

		public static bool MenuItem( byte* label,  string shortcut,  ref byte pSelected,  bool enabled)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(label, pStr0, (byte*)ppSelected, enabled ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool MenuItem( byte* label,  string shortcut,  ref byte pSelected)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (shortcut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(shortcut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(shortcut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ppSelected = &pSelected)
			{
				byte ret = MenuItemNative(label, pStr0, (byte*)ppSelected, (byte)(1));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginTooltip")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginTooltipNative();

		public static bool BeginTooltip()
		{
			byte ret = BeginTooltipNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndTooltip")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndTooltipNative();

		public static void EndTooltip()
		{
			EndTooltipNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetTooltip")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetTooltipNative(byte* fmt);

		public static void SetTooltip( byte* fmt)
		{
			SetTooltipNative(fmt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetTooltipV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetTooltipVNative(byte* fmt, nuint args);

		public static void SetTooltipV( byte* fmt,  nuint args)
		{
			SetTooltipVNative(fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginItemTooltip")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginItemTooltipNative();

		public static bool BeginItemTooltip()
		{
			byte ret = BeginItemTooltipNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetItemTooltip")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetItemTooltipNative(byte* fmt);

		public static void SetItemTooltip( byte* fmt)
		{
			SetItemTooltipNative(fmt);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetItemTooltipV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetItemTooltipVNative(byte* fmt, nuint args);

		public static void SetItemTooltipV( byte* fmt,  nuint args)
		{
			SetItemTooltipVNative(fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginPopup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginPopupNative(byte* strId, int flags);

		public static bool BeginPopup( byte* strId,  int flags)
		{
			byte ret = BeginPopupNative(strId, flags);
			return ret != 0;
		}

		public static bool BeginPopup( byte* strId)
		{
			byte ret = BeginPopupNative(strId, (int)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginPopupModal")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginPopupModalNative(byte* name, byte* pOpen, int flags);

		public static bool BeginPopupModal( byte* name,  byte* pOpen,  int flags)
		{
			byte ret = BeginPopupModalNative(name, pOpen, flags);
			return ret != 0;
		}

		public static bool BeginPopupModal( byte* name,  byte* pOpen)
		{
			byte ret = BeginPopupModalNative(name, pOpen, (int)(0));
			return ret != 0;
		}

		public static bool BeginPopupModal( byte* name)
		{
			byte ret = BeginPopupModalNative(name, (byte*)(default), (int)(0));
			return ret != 0;
		}

		public static bool BeginPopupModal( byte* name,  int flags)
		{
			byte ret = BeginPopupModalNative(name, (byte*)(default), flags);
			return ret != 0;
		}

		public static bool BeginPopupModal( byte* name,  ref byte pOpen,  int flags)
		{
			fixed (byte* ppOpen = &pOpen)
			{
				byte ret = BeginPopupModalNative(name, (byte*)ppOpen, flags);
				return ret != 0;
			}
		}

		public static bool BeginPopupModal( byte* name,  ref byte pOpen)
		{
			fixed (byte* ppOpen = &pOpen)
			{
				byte ret = BeginPopupModalNative(name, (byte*)ppOpen, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndPopup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndPopupNative();

		public static void EndPopup()
		{
			EndPopupNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igOpenPopup_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void OpenPopupNative(byte* strId, int popupFlags);

		public static void OpenPopup( byte* strId,  int popupFlags)
		{
			OpenPopupNative(strId, popupFlags);
		}

		public static void OpenPopup( byte* strId)
		{
			OpenPopupNative(strId, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igOpenPopup_ID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void OpenPopupNative(uint id, int popupFlags);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igOpenPopupOnItemClick")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void OpenPopupOnItemClickNative(byte* strId, int popupFlags);

		public static void OpenPopupOnItemClick( byte* strId,  int popupFlags)
		{
			OpenPopupOnItemClickNative(strId, popupFlags);
		}

		public static void OpenPopupOnItemClick( byte* strId)
		{
			OpenPopupOnItemClickNative(strId, (int)(1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCloseCurrentPopup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void CloseCurrentPopupNative();

		public static void CloseCurrentPopup()
		{
			CloseCurrentPopupNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginPopupContextItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginPopupContextItemNative(byte* strId, int popupFlags);

		public static bool BeginPopupContextItem( byte* strId,  int popupFlags)
		{
			byte ret = BeginPopupContextItemNative(strId, popupFlags);
			return ret != 0;
		}

		public static bool BeginPopupContextItem( byte* strId)
		{
			byte ret = BeginPopupContextItemNative(strId, (int)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginPopupContextWindow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginPopupContextWindowNative(byte* strId, int popupFlags);

		public static bool BeginPopupContextWindow( byte* strId,  int popupFlags)
		{
			byte ret = BeginPopupContextWindowNative(strId, popupFlags);
			return ret != 0;
		}

		public static bool BeginPopupContextWindow( byte* strId)
		{
			byte ret = BeginPopupContextWindowNative(strId, (int)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginPopupContextVoid")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginPopupContextVoidNative(byte* strId, int popupFlags);

		public static bool BeginPopupContextVoid( byte* strId,  int popupFlags)
		{
			byte ret = BeginPopupContextVoidNative(strId, popupFlags);
			return ret != 0;
		}

		public static bool BeginPopupContextVoid( byte* strId)
		{
			byte ret = BeginPopupContextVoidNative(strId, (int)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsPopupOpen_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsPopupOpenNative(byte* strId, int flags);

		public static bool IsPopupOpen( byte* strId,  int flags)
		{
			byte ret = IsPopupOpenNative(strId, flags);
			return ret != 0;
		}

		public static bool IsPopupOpen( byte* strId)
		{
			byte ret = IsPopupOpenNative(strId, (int)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginTable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginTableNative(byte* strId, int column, int flags, Vector2 outerSize, float innerWidth);

		public static bool BeginTable( byte* strId,  int column,  int flags,  Vector2 outerSize,  float innerWidth)
		{
			byte ret = BeginTableNative(strId, column, flags, outerSize, innerWidth);
			return ret != 0;
		}

		public static bool BeginTable( byte* strId,  int column,  int flags,  Vector2 outerSize)
		{
			byte ret = BeginTableNative(strId, column, flags, outerSize, (float)(0.0f));
			return ret != 0;
		}

		public static bool BeginTable( byte* strId,  int column,  int flags)
		{
			byte ret = BeginTableNative(strId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			return ret != 0;
		}

		public static bool BeginTable( byte* strId,  int column)
		{
			byte ret = BeginTableNative(strId, column, (int)(0), (Vector2)(new Vector2(0.0f,0.0f)), (float)(0.0f));
			return ret != 0;
		}

		public static bool BeginTable( byte* strId,  int column,  Vector2 outerSize)
		{
			byte ret = BeginTableNative(strId, column, (int)(0), outerSize, (float)(0.0f));
			return ret != 0;
		}

		public static bool BeginTable( byte* strId,  int column,  int flags,  float innerWidth)
		{
			byte ret = BeginTableNative(strId, column, flags, (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
			return ret != 0;
		}

		public static bool BeginTable( byte* strId,  int column,  float innerWidth)
		{
			byte ret = BeginTableNative(strId, column, (int)(0), (Vector2)(new Vector2(0.0f,0.0f)), innerWidth);
			return ret != 0;
		}

		public static bool BeginTable( byte* strId,  int column,  Vector2 outerSize,  float innerWidth)
		{
			byte ret = BeginTableNative(strId, column, (int)(0), outerSize, innerWidth);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndTable")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndTableNative();

		public static void EndTable()
		{
			EndTableNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableNextRow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableNextRowNative(int rowFlags, float minRowHeight);

		public static void TableNextRow( int rowFlags,  float minRowHeight)
		{
			TableNextRowNative(rowFlags, minRowHeight);
		}

		public static void TableNextRow( int rowFlags)
		{
			TableNextRowNative(rowFlags, (float)(0.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableNextColumn")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TableNextColumnNative();

		public static bool TableNextColumn()
		{
			byte ret = TableNextColumnNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableSetColumnIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TableSetColumnIndexNative(int columnN);

		public static bool TableSetColumnIndex( int columnN)
		{
			byte ret = TableSetColumnIndexNative(columnN);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableSetupColumn")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSetupColumnNative(byte* label, int flags, float initWidthOrWeight, uint userId);

		public static void TableSetupColumn( byte* label,  int flags,  float initWidthOrWeight,  uint userId)
		{
			TableSetupColumnNative(label, flags, initWidthOrWeight, userId);
		}

		public static void TableSetupColumn( byte* label,  int flags,  float initWidthOrWeight)
		{
			TableSetupColumnNative(label, flags, initWidthOrWeight, (uint)(0));
		}

		public static void TableSetupColumn( byte* label,  int flags)
		{
			TableSetupColumnNative(label, flags, (float)(0.0f), (uint)(0));
		}

		public static void TableSetupColumn( byte* label)
		{
			TableSetupColumnNative(label, (int)(0), (float)(0.0f), (uint)(0));
		}

		public static void TableSetupColumn( byte* label,  float initWidthOrWeight)
		{
			TableSetupColumnNative(label, (int)(0), initWidthOrWeight, (uint)(0));
		}

		public static void TableSetupColumn( byte* label,  int flags,  uint userId)
		{
			TableSetupColumnNative(label, flags, (float)(0.0f), userId);
		}

		public static void TableSetupColumn( byte* label,  uint userId)
		{
			TableSetupColumnNative(label, (int)(0), (float)(0.0f), userId);
		}

		public static void TableSetupColumn( byte* label,  float initWidthOrWeight,  uint userId)
		{
			TableSetupColumnNative(label, (int)(0), initWidthOrWeight, userId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableSetupScrollFreeze")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSetupScrollFreezeNative(int cols, int rows);

		public static void TableSetupScrollFreeze( int cols,  int rows)
		{
			TableSetupScrollFreezeNative(cols, rows);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableHeader")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableHeaderNative(byte* label);

		public static void TableHeader( byte* label)
		{
			TableHeaderNative(label);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableHeadersRow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableHeadersRowNative();

		public static void TableHeadersRow()
		{
			TableHeadersRowNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableAngledHeadersRow")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableAngledHeadersRowNative();

		public static void TableAngledHeadersRow()
		{
			TableAngledHeadersRowNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableGetSortSpecs")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTableSortSpecs* TableGetSortSpecsNative();

		public static ImGuiTableSortSpecs* TableGetSortSpecs()
		{
			ImGuiTableSortSpecs* ret = TableGetSortSpecsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableGetColumnCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TableGetColumnCountNative();

		public static int TableGetColumnCount()
		{
			int ret = TableGetColumnCountNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableGetColumnIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TableGetColumnIndexNative();

		public static int TableGetColumnIndex()
		{
			int ret = TableGetColumnIndexNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableGetRowIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TableGetRowIndexNative();

		public static int TableGetRowIndex()
		{
			int ret = TableGetRowIndexNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableGetColumnName_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* TableGetColumnNameNative(int columnN);

		public static byte* TableGetColumnName( int columnN)
		{
			byte* ret = TableGetColumnNameNative(columnN);
			return ret;
		}

		public static string TableGetColumnNameS()
		{
			string ret = Utils.DecodeStringUTF8(TableGetColumnNameNative((int)(-1)));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableGetColumnFlags")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int TableGetColumnFlagsNative(int columnN);

		public static int TableGetColumnFlags( int columnN)
		{
			int ret = TableGetColumnFlagsNative(columnN);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableSetColumnEnabled")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSetColumnEnabledNative(int columnN, byte v);

		public static void TableSetColumnEnabled( int columnN,  bool v)
		{
			TableSetColumnEnabledNative(columnN, v ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTableSetBgColor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TableSetBgColorNative(int target, uint color, int columnN);

		public static void TableSetBgColor( int target,  uint color,  int columnN)
		{
			TableSetBgColorNative(target, color, columnN);
		}

		public static void TableSetBgColor( int target,  uint color)
		{
			TableSetBgColorNative(target, color, (int)(-1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColumns")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ColumnsNative(int count, byte* id, byte border);

		public static void Columns( int count,  byte* id,  bool border)
		{
			ColumnsNative(count, id, border ? (byte)1 : (byte)0);
		}

		public static void Columns( int count,  byte* id)
		{
			ColumnsNative(count, id, (byte)(1));
		}

		public static void Columns( int count)
		{
			ColumnsNative(count, (byte*)(default), (byte)(1));
		}

		public static void Columns( int count,  bool border)
		{
			ColumnsNative(count, (byte*)(default), border ? (byte)1 : (byte)0);
		}

		public static void Columns( int count,  ref byte id,  bool border)
		{
			fixed (byte* pid = &id)
			{
				ColumnsNative(count, (byte*)pid, border ? (byte)1 : (byte)0);
			}
		}

		public static void Columns( int count,  ref byte id)
		{
			fixed (byte* pid = &id)
			{
				ColumnsNative(count, (byte*)pid, (byte)(1));
			}
		}

		public static void Columns( int count,  string id,  bool border)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColumnsNative(count, pStr0, border ? (byte)1 : (byte)0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Columns( int count,  string id)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (id != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(id);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(id, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ColumnsNative(count, pStr0, (byte)(1));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igNextColumn")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void NextColumnNative();

		public static void NextColumn()
		{
			NextColumnNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetColumnIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetColumnIndexNative();

		public static int GetColumnIndex()
		{
			int ret = GetColumnIndexNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetColumnWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetColumnWidthNative(int columnIndex);

		public static float GetColumnWidth( int columnIndex)
		{
			float ret = GetColumnWidthNative(columnIndex);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetColumnWidth")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetColumnWidthNative(int columnIndex, float width);

		public static void SetColumnWidth( int columnIndex,  float width)
		{
			SetColumnWidthNative(columnIndex, width);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetColumnOffset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetColumnOffsetNative(int columnIndex);

		public static float GetColumnOffset( int columnIndex)
		{
			float ret = GetColumnOffsetNative(columnIndex);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetColumnOffset")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetColumnOffsetNative(int columnIndex, float offsetX);

		public static void SetColumnOffset( int columnIndex,  float offsetX)
		{
			SetColumnOffsetNative(columnIndex, offsetX);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetColumnsCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetColumnsCountNative();

		public static int GetColumnsCount()
		{
			int ret = GetColumnsCountNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginTabBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginTabBarNative(byte* strId, int flags);

		public static bool BeginTabBar( byte* strId,  int flags)
		{
			byte ret = BeginTabBarNative(strId, flags);
			return ret != 0;
		}

		public static bool BeginTabBar( byte* strId)
		{
			byte ret = BeginTabBarNative(strId, (int)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndTabBar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndTabBarNative();

		public static void EndTabBar()
		{
			EndTabBarNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginTabItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginTabItemNative(byte* label, byte* pOpen, int flags);

		public static bool BeginTabItem( byte* label,  byte* pOpen,  int flags)
		{
			byte ret = BeginTabItemNative(label, pOpen, flags);
			return ret != 0;
		}

		public static bool BeginTabItem( byte* label,  byte* pOpen)
		{
			byte ret = BeginTabItemNative(label, pOpen, (int)(0));
			return ret != 0;
		}

		public static bool BeginTabItem( byte* label)
		{
			byte ret = BeginTabItemNative(label, (byte*)(default), (int)(0));
			return ret != 0;
		}

		public static bool BeginTabItem( byte* label,  int flags)
		{
			byte ret = BeginTabItemNative(label, (byte*)(default), flags);
			return ret != 0;
		}

		public static bool BeginTabItem( byte* label,  ref byte pOpen,  int flags)
		{
			fixed (byte* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(label, (byte*)ppOpen, flags);
				return ret != 0;
			}
		}

		public static bool BeginTabItem( byte* label,  ref byte pOpen)
		{
			fixed (byte* ppOpen = &pOpen)
			{
				byte ret = BeginTabItemNative(label, (byte*)ppOpen, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndTabItem")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndTabItemNative();

		public static void EndTabItem()
		{
			EndTabItemNative();
		}
	}
}
