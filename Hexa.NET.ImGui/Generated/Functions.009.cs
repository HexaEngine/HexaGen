// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTabItemButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TabItemButtonNative(byte* label, int flags);

		public static bool TabItemButton( byte* label,  int flags)
		{
			byte ret = TabItemButtonNative(label, flags);
			return ret != 0;
		}

		public static bool TabItemButton( byte* label)
		{
			byte ret = TabItemButtonNative(label, (int)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetTabItemClosed")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetTabItemClosedNative(byte* tabOrDockedWindowLabel);

		public static void SetTabItemClosed( byte* tabOrDockedWindowLabel)
		{
			SetTabItemClosedNative(tabOrDockedWindowLabel);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDockSpace")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint DockSpaceNative(uint id, Vector2 size, int flags, ImGuiWindowClass* windowClass);

		public static uint DockSpace( uint id,  Vector2 size,  int flags,  ImGuiWindowClass* windowClass)
		{
			uint ret = DockSpaceNative(id, size, flags, windowClass);
			return ret;
		}

		public static uint DockSpace( uint id,  Vector2 size,  int flags)
		{
			uint ret = DockSpaceNative(id, size, flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		public static uint DockSpace( uint id,  Vector2 size)
		{
			uint ret = DockSpaceNative(id, size, (int)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		public static uint DockSpace( uint id)
		{
			uint ret = DockSpaceNative(id, (Vector2)(new Vector2(0,0)), (int)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		public static uint DockSpace( uint id,  int flags)
		{
			uint ret = DockSpaceNative(id, (Vector2)(new Vector2(0,0)), flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		public static uint DockSpace( uint id,  Vector2 size,  ImGuiWindowClass* windowClass)
		{
			uint ret = DockSpaceNative(id, size, (int)(0), windowClass);
			return ret;
		}

		public static uint DockSpace( uint id,  ImGuiWindowClass* windowClass)
		{
			uint ret = DockSpaceNative(id, (Vector2)(new Vector2(0,0)), (int)(0), windowClass);
			return ret;
		}

		public static uint DockSpace( uint id,  int flags,  ImGuiWindowClass* windowClass)
		{
			uint ret = DockSpaceNative(id, (Vector2)(new Vector2(0,0)), flags, windowClass);
			return ret;
		}

		public static uint DockSpace( uint id,  Vector2 size,  int flags,  ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceNative(id, size, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		public static uint DockSpace( uint id,  Vector2 size,  ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceNative(id, size, (int)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		public static uint DockSpace( uint id,  ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceNative(id, (Vector2)(new Vector2(0,0)), (int)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		public static uint DockSpace( uint id,  int flags,  ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceNative(id, (Vector2)(new Vector2(0,0)), flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDockSpaceOverViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint DockSpaceOverViewportNative(ImGuiViewport* viewport, int flags, ImGuiWindowClass* windowClass);

		public static uint DockSpaceOverViewport( ImGuiViewport* viewport,  int flags,  ImGuiWindowClass* windowClass)
		{
			uint ret = DockSpaceOverViewportNative(viewport, flags, windowClass);
			return ret;
		}

		public static uint DockSpaceOverViewport( ImGuiViewport* viewport,  int flags)
		{
			uint ret = DockSpaceOverViewportNative(viewport, flags, (ImGuiWindowClass*)(default));
			return ret;
		}

		public static uint DockSpaceOverViewport( ImGuiViewport* viewport)
		{
			uint ret = DockSpaceOverViewportNative(viewport, (int)(0), (ImGuiWindowClass*)(default));
			return ret;
		}

		public static uint DockSpaceOverViewport( ImGuiViewport* viewport,  ImGuiWindowClass* windowClass)
		{
			uint ret = DockSpaceOverViewportNative(viewport, (int)(0), windowClass);
			return ret;
		}

		public static uint DockSpaceOverViewport( ImGuiViewport* viewport,  int flags,  ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative(viewport, flags, (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		public static uint DockSpaceOverViewport( ImGuiViewport* viewport,  ref ImGuiWindowClass windowClass)
		{
			fixed (ImGuiWindowClass* pwindowClass = &windowClass)
			{
				uint ret = DockSpaceOverViewportNative(viewport, (int)(0), (ImGuiWindowClass*)pwindowClass);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowDockID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowDockIDNative(uint dockId, int cond);

		public static void SetNextWindowDockID( uint dockId,  int cond)
		{
			SetNextWindowDockIDNative(dockId, cond);
		}

		public static void SetNextWindowDockID( uint dockId)
		{
			SetNextWindowDockIDNative(dockId, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextWindowClass")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextWindowClassNative(ImGuiWindowClass* windowClass);

		public static void SetNextWindowClass( ImGuiWindowClass* windowClass)
		{
			SetNextWindowClassNative(windowClass);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetWindowDockID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetWindowDockIDNative();

		public static uint GetWindowDockID()
		{
			uint ret = GetWindowDockIDNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsWindowDocked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsWindowDockedNative();

		public static bool IsWindowDocked()
		{
			byte ret = IsWindowDockedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLogToTTY")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogToTTYNative(int autoOpenDepth);

		public static void LogToTTY( int autoOpenDepth)
		{
			LogToTTYNative(autoOpenDepth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLogToFile")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogToFileNative(int autoOpenDepth, byte* filename);

		public static void LogToFile( int autoOpenDepth,  byte* filename)
		{
			LogToFileNative(autoOpenDepth, filename);
		}

		public static void LogToFile( int autoOpenDepth)
		{
			LogToFileNative(autoOpenDepth, (byte*)(default));
		}

		public static void LogToFile( int autoOpenDepth,  ref byte filename)
		{
			fixed (byte* pfilename = &filename)
			{
				LogToFileNative(autoOpenDepth, (byte*)pfilename);
			}
		}

		public static void LogToFile( int autoOpenDepth,  string filename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LogToFileNative(autoOpenDepth, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLogToClipboard")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogToClipboardNative(int autoOpenDepth);

		public static void LogToClipboard( int autoOpenDepth)
		{
			LogToClipboardNative(autoOpenDepth);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLogFinish")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogFinishNative();

		public static void LogFinish()
		{
			LogFinishNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLogButtons")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogButtonsNative();

		public static void LogButtons()
		{
			LogButtonsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLogTextV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LogTextVNative(byte* fmt, nuint args);

		public static void LogTextV( byte* fmt,  nuint args)
		{
			LogTextVNative(fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginDragDropSource")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginDragDropSourceNative(int flags);

		public static bool BeginDragDropSource( int flags)
		{
			byte ret = BeginDragDropSourceNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetDragDropPayload")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte SetDragDropPayloadNative(byte* type, void* data, ulong sz, int cond);

		public static bool SetDragDropPayload( byte* type,  void* data,  ulong sz,  int cond)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, cond);
			return ret != 0;
		}

		public static bool SetDragDropPayload( byte* type,  void* data,  ulong sz)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, (int)(0));
			return ret != 0;
		}

		public static bool SetDragDropPayload( byte* type,  void* data,  nuint sz,  int cond)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, cond);
			return ret != 0;
		}

		public static bool SetDragDropPayload( byte* type,  void* data,  nuint sz)
		{
			byte ret = SetDragDropPayloadNative(type, data, sz, (int)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndDragDropSource")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndDragDropSourceNative();

		public static void EndDragDropSource()
		{
			EndDragDropSourceNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginDragDropTarget")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginDragDropTargetNative();

		public static bool BeginDragDropTarget()
		{
			byte ret = BeginDragDropTargetNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igAcceptDragDropPayload")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPayload* AcceptDragDropPayloadNative(byte* type, int flags);

		public static ImGuiPayload* AcceptDragDropPayload( byte* type,  int flags)
		{
			ImGuiPayload* ret = AcceptDragDropPayloadNative(type, flags);
			return ret;
		}

		public static ImGuiPayload* AcceptDragDropPayload( byte* type)
		{
			ImGuiPayload* ret = AcceptDragDropPayloadNative(type, (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndDragDropTarget")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndDragDropTargetNative();

		public static void EndDragDropTarget()
		{
			EndDragDropTargetNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetDragDropPayload")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPayload* GetDragDropPayloadNative();

		public static ImGuiPayload* GetDragDropPayload()
		{
			ImGuiPayload* ret = GetDragDropPayloadNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginDisabled")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BeginDisabledNative(byte disabled);

		public static void BeginDisabled( bool disabled)
		{
			BeginDisabledNative(disabled ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndDisabled")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndDisabledNative();

		public static void EndDisabled()
		{
			EndDisabledNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPushClipRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushClipRectNative(Vector2 clipRectMin, Vector2 clipRectMax, byte intersectWithCurrentClipRect);

		public static void PushClipRect( Vector2 clipRectMin,  Vector2 clipRectMax,  bool intersectWithCurrentClipRect)
		{
			PushClipRectNative(clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPopClipRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopClipRectNative();

		public static void PopClipRect()
		{
			PopClipRectNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetItemDefaultFocus")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetItemDefaultFocusNative();

		public static void SetItemDefaultFocus()
		{
			SetItemDefaultFocusNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetKeyboardFocusHere")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetKeyboardFocusHereNative(int offset);

		public static void SetKeyboardFocusHere( int offset)
		{
			SetKeyboardFocusHereNative(offset);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextItemAllowOverlap")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextItemAllowOverlapNative();

		public static void SetNextItemAllowOverlap()
		{
			SetNextItemAllowOverlapNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemHovered")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemHoveredNative(int flags);

		public static bool IsItemHovered( int flags)
		{
			byte ret = IsItemHoveredNative(flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemActive")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemActiveNative();

		public static bool IsItemActive()
		{
			byte ret = IsItemActiveNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemFocused")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemFocusedNative();

		public static bool IsItemFocused()
		{
			byte ret = IsItemFocusedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemClicked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemClickedNative(int mouseButton);

		public static bool IsItemClicked( int mouseButton)
		{
			byte ret = IsItemClickedNative(mouseButton);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemVisible")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemVisibleNative();

		public static bool IsItemVisible()
		{
			byte ret = IsItemVisibleNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemEdited")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemEditedNative();

		public static bool IsItemEdited()
		{
			byte ret = IsItemEditedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemActivated")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemActivatedNative();

		public static bool IsItemActivated()
		{
			byte ret = IsItemActivatedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemDeactivated")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemDeactivatedNative();

		public static bool IsItemDeactivated()
		{
			byte ret = IsItemDeactivatedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemDeactivatedAfterEdit")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemDeactivatedAfterEditNative();

		public static bool IsItemDeactivatedAfterEdit()
		{
			byte ret = IsItemDeactivatedAfterEditNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsItemToggledOpen")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsItemToggledOpenNative();

		public static bool IsItemToggledOpen()
		{
			byte ret = IsItemToggledOpenNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsAnyItemHovered")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsAnyItemHoveredNative();

		public static bool IsAnyItemHovered()
		{
			byte ret = IsAnyItemHoveredNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsAnyItemActive")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsAnyItemActiveNative();

		public static bool IsAnyItemActive()
		{
			byte ret = IsAnyItemActiveNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsAnyItemFocused")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsAnyItemFocusedNative();

		public static bool IsAnyItemFocused()
		{
			byte ret = IsAnyItemFocusedNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetItemID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint GetItemIDNative();

		public static uint GetItemID()
		{
			uint ret = GetItemIDNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetItemRectMin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetItemRectMinNative(Vector2* pOut);

		public static void GetItemRectMin( Vector2* pOut)
		{
			GetItemRectMinNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetItemRectMax")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetItemRectMaxNative(Vector2* pOut);

		public static void GetItemRectMax( Vector2* pOut)
		{
			GetItemRectMaxNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetItemRectSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetItemRectSizeNative(Vector2* pOut);

		public static void GetItemRectSize( Vector2* pOut)
		{
			GetItemRectSizeNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetMainViewport")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiViewport* GetMainViewportNative();

		public static ImGuiViewport* GetMainViewport()
		{
			ImGuiViewport* ret = GetMainViewportNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetBackgroundDrawList_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawList* GetBackgroundDrawListNative();

		public static ImDrawList* GetBackgroundDrawList()
		{
			ImDrawList* ret = GetBackgroundDrawListNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetForegroundDrawList_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawList* GetForegroundDrawListNative();

		public static ImDrawList* GetForegroundDrawList()
		{
			ImDrawList* ret = GetForegroundDrawListNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetBackgroundDrawList_ViewportPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawList* GetBackgroundDrawListNative(ImGuiViewport* viewport);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetForegroundDrawList_ViewportPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawList* GetForegroundDrawListNative(ImGuiViewport* viewport);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsRectVisible_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsRectVisibleNative(Vector2 size);

		public static bool IsRectVisible( Vector2 size)
		{
			byte ret = IsRectVisibleNative(size);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsRectVisible_Vec2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsRectVisibleNative(Vector2 rectMin, Vector2 rectMax);

		public static bool IsRectVisible( Vector2 rectMin,  Vector2 rectMax)
		{
			byte ret = IsRectVisibleNative(rectMin, rectMax);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetTime")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial double GetTimeNative();

		public static double GetTime()
		{
			double ret = GetTimeNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetFrameCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetFrameCountNative();

		public static int GetFrameCount()
		{
			int ret = GetFrameCountNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetDrawListSharedData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawListSharedData* GetDrawListSharedDataNative();

		public static ImDrawListSharedData* GetDrawListSharedData()
		{
			ImDrawListSharedData* ret = GetDrawListSharedDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetStyleColorName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* GetStyleColorNameNative(int idx);

		public static byte* GetStyleColorName( int idx)
		{
			byte* ret = GetStyleColorNameNative(idx);
			return ret;
		}

		public static string GetStyleColorNameS( int idx)
		{
			string ret = Utils.DecodeStringUTF8(GetStyleColorNameNative(idx));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetStateStorage")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetStateStorageNative(ImGuiStorage* storage);

		public static void SetStateStorage( ImGuiStorage* storage)
		{
			SetStateStorageNative(storage);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetStateStorage")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStorage* GetStateStorageNative();

		public static ImGuiStorage* GetStateStorage()
		{
			ImGuiStorage* ret = GetStateStorageNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginChildFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginChildFrameNative(uint id, Vector2 size, int flags);

		public static bool BeginChildFrame( uint id,  Vector2 size,  int flags)
		{
			byte ret = BeginChildFrameNative(id, size, flags);
			return ret != 0;
		}

		public static bool BeginChildFrame( uint id,  Vector2 size)
		{
			byte ret = BeginChildFrameNative(id, size, (int)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndChildFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndChildFrameNative();

		public static void EndChildFrame()
		{
			EndChildFrameNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCalcTextSize")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void CalcTextSizeNative(Vector2* pOut, byte* text, byte* textEnd, byte hideTextAfterDoubleHash, float wrapWidth);

		public static void CalcTextSize( Vector2* pOut,  byte* text,  byte* textEnd,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			CalcTextSizeNative(pOut, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  byte* textEnd,  bool hideTextAfterDoubleHash)
		{
			CalcTextSizeNative(pOut, text, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  byte* textEnd)
		{
			CalcTextSizeNative(pOut, text, textEnd, (byte)(0), (float)(-1.0f));
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text)
		{
			CalcTextSizeNative(pOut, text, (byte*)(default), (byte)(0), (float)(-1.0f));
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  bool hideTextAfterDoubleHash)
		{
			CalcTextSizeNative(pOut, text, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  byte* textEnd,  float wrapWidth)
		{
			CalcTextSizeNative(pOut, text, textEnd, (byte)(0), wrapWidth);
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  float wrapWidth)
		{
			CalcTextSizeNative(pOut, text, (byte*)(default), (byte)(0), wrapWidth);
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			CalcTextSizeNative(pOut, text, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  byte* textEnd,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  byte* textEnd,  bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, (byte)(0), (float)(-1.0f));
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), (byte)(0), (float)(-1.0f));
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  byte* textEnd,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, (byte)(0), wrapWidth);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), (byte)(0), wrapWidth);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  byte* textEnd,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  byte* textEnd,  bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, (byte)(0), (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, (byte*)(default), (byte)(0), (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  byte* textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, (byte)(0), wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, (byte*)(default), (byte)(0), wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  ref byte textEnd,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  ref byte textEnd,  bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
			}
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, (byte)(0), wrapWidth);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  string textEnd,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  string textEnd,  bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, (byte)(0), (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  byte* text,  string textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, (byte)(0), wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  ref byte textEnd,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  ref byte textEnd,  bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
				}
			}
		}

		public static void CalcTextSize( Vector2* pOut,  ref byte text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), wrapWidth);
				}
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  string textEnd,  bool hideTextAfterDoubleHash,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  string textEnd,  bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, (byte)(0), (float)(-1.0f));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void CalcTextSize( Vector2* pOut,  string text,  string textEnd,  float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, (byte)(0), wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColorConvertU32ToFloat4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ColorConvertU32ToFloat4Native(Vector4* pOut, uint input);

		public static void ColorConvertU32ToFloat4( Vector4* pOut,  uint input)
		{
			ColorConvertU32ToFloat4Native(pOut, input);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColorConvertFloat4ToU32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint ColorConvertFloat4ToU32Native(Vector4 input);

		public static uint ColorConvertFloat4ToU32( Vector4 input)
		{
			uint ret = ColorConvertFloat4ToU32Native(input);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColorConvertRGBtoHSV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ColorConvertRGBtoHSVNative(float r, float g, float b, float* outH, float* outS, float* outV);

		public static void ColorConvertRGBtoHSV( float r,  float g,  float b,  float* outH,  float* outS,  float* outV)
		{
			ColorConvertRGBtoHSVNative(r, g, b, outH, outS, outV);
		}

		public static void ColorConvertRGBtoHSV( float r,  float g,  float b,  ref float outH,  float* outS,  float* outV)
		{
			fixed (float* poutH = &outH)
			{
				ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, outS, outV);
			}
		}

		public static void ColorConvertRGBtoHSV( float r,  float g,  float b,  float* outH,  ref float outS,  float* outV)
		{
			fixed (float* poutS = &outS)
			{
				ColorConvertRGBtoHSVNative(r, g, b, outH, (float*)poutS, outV);
			}
		}

		public static void ColorConvertRGBtoHSV( float r,  float g,  float b,  ref float outH,  ref float outS,  float* outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, (float*)poutS, outV);
				}
			}
		}

		public static void ColorConvertRGBtoHSV( float r,  float g,  float b,  float* outH,  float* outS,  ref float outV)
		{
			fixed (float* poutV = &outV)
			{
				ColorConvertRGBtoHSVNative(r, g, b, outH, outS, (float*)poutV);
			}
		}

		public static void ColorConvertRGBtoHSV( float r,  float g,  float b,  ref float outH,  float* outS,  ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, outS, (float*)poutV);
				}
			}
		}

		public static void ColorConvertRGBtoHSV( float r,  float g,  float b,  float* outH,  ref float outS,  ref float outV)
		{
			fixed (float* poutS = &outS)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSVNative(r, g, b, outH, (float*)poutS, (float*)poutV);
				}
			}
		}

		public static void ColorConvertRGBtoHSV( float r,  float g,  float b,  ref float outH,  ref float outS,  ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					fixed (float* poutV = &outV)
					{
						ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, (float*)poutS, (float*)poutV);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColorConvertHSVtoRGB")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ColorConvertHSVtoRGBNative(float h, float s, float v, float* outR, float* outG, float* outB);

		public static void ColorConvertHSVtoRGB( float h,  float s,  float v,  float* outR,  float* outG,  float* outB)
		{
			ColorConvertHSVtoRGBNative(h, s, v, outR, outG, outB);
		}

		public static void ColorConvertHSVtoRGB( float h,  float s,  float v,  ref float outR,  float* outG,  float* outB)
		{
			fixed (float* poutR = &outR)
			{
				ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, outG, outB);
			}
		}

		public static void ColorConvertHSVtoRGB( float h,  float s,  float v,  float* outR,  ref float outG,  float* outB)
		{
			fixed (float* poutG = &outG)
			{
				ColorConvertHSVtoRGBNative(h, s, v, outR, (float*)poutG, outB);
			}
		}

		public static void ColorConvertHSVtoRGB( float h,  float s,  float v,  ref float outR,  ref float outG,  float* outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, (float*)poutG, outB);
				}
			}
		}

		public static void ColorConvertHSVtoRGB( float h,  float s,  float v,  float* outR,  float* outG,  ref float outB)
		{
			fixed (float* poutB = &outB)
			{
				ColorConvertHSVtoRGBNative(h, s, v, outR, outG, (float*)poutB);
			}
		}

		public static void ColorConvertHSVtoRGB( float h,  float s,  float v,  ref float outR,  float* outG,  ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, outG, (float*)poutB);
				}
			}
		}

		public static void ColorConvertHSVtoRGB( float h,  float s,  float v,  float* outR,  ref float outG,  ref float outB)
		{
			fixed (float* poutG = &outG)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGBNative(h, s, v, outR, (float*)poutG, (float*)poutB);
				}
			}
		}

		public static void ColorConvertHSVtoRGB( float h,  float s,  float v,  ref float outR,  ref float outG,  ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					fixed (float* poutB = &outB)
					{
						ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, (float*)poutG, (float*)poutB);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsKeyDown_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsKeyDownNative(ImGuiKey key);

		public static bool IsKeyDown( ImGuiKey key)
		{
			byte ret = IsKeyDownNative(key);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsKeyPressed_Bool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsKeyPressedNative(ImGuiKey key, byte repeat);

		public static bool IsKeyPressed( ImGuiKey key,  bool repeat)
		{
			byte ret = IsKeyPressedNative(key, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool IsKeyPressed( ImGuiKey key)
		{
			byte ret = IsKeyPressedNative(key, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsKeyReleased_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsKeyReleasedNative(ImGuiKey key);

		public static bool IsKeyReleased( ImGuiKey key)
		{
			byte ret = IsKeyReleasedNative(key);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetKeyPressedAmount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetKeyPressedAmountNative(ImGuiKey key, float repeatDelay, float rate);

		public static int GetKeyPressedAmount( ImGuiKey key,  float repeatDelay,  float rate)
		{
			int ret = GetKeyPressedAmountNative(key, repeatDelay, rate);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetKeyName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* GetKeyNameNative(ImGuiKey key);

		public static byte* GetKeyName( ImGuiKey key)
		{
			byte* ret = GetKeyNameNative(key);
			return ret;
		}

		public static string GetKeyNameS( ImGuiKey key)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyNameNative(key));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextFrameWantCaptureKeyboard")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextFrameWantCaptureKeyboardNative(byte wantCaptureKeyboard);

		public static void SetNextFrameWantCaptureKeyboard( bool wantCaptureKeyboard)
		{
			SetNextFrameWantCaptureKeyboardNative(wantCaptureKeyboard ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsMouseDown_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseDownNative(int button);

		public static bool IsMouseDown( int button)
		{
			byte ret = IsMouseDownNative(button);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsMouseClicked_Bool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseClickedNative(int button, byte repeat);

		public static bool IsMouseClicked( int button,  bool repeat)
		{
			byte ret = IsMouseClickedNative(button, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool IsMouseClicked( int button)
		{
			byte ret = IsMouseClickedNative(button, (byte)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsMouseReleased_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseReleasedNative(int button);

		public static bool IsMouseReleased( int button)
		{
			byte ret = IsMouseReleasedNative(button);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsMouseDoubleClicked")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseDoubleClickedNative(int button);

		public static bool IsMouseDoubleClicked( int button)
		{
			byte ret = IsMouseDoubleClickedNative(button);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetMouseClickedCount")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetMouseClickedCountNative(int button);

		public static int GetMouseClickedCount( int button)
		{
			int ret = GetMouseClickedCountNative(button);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsMouseHoveringRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseHoveringRectNative(Vector2 rMin, Vector2 rMax, byte clip);

		public static bool IsMouseHoveringRect( Vector2 rMin,  Vector2 rMax,  bool clip)
		{
			byte ret = IsMouseHoveringRectNative(rMin, rMax, clip ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool IsMouseHoveringRect( Vector2 rMin,  Vector2 rMax)
		{
			byte ret = IsMouseHoveringRectNative(rMin, rMax, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsMousePosValid")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMousePosValidNative(Vector2* mousePos);

		public static bool IsMousePosValid( Vector2* mousePos)
		{
			byte ret = IsMousePosValidNative(mousePos);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsAnyMouseDown")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsAnyMouseDownNative();

		public static bool IsAnyMouseDown()
		{
			byte ret = IsAnyMouseDownNative();
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetMousePos")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetMousePosNative(Vector2* pOut);

		public static void GetMousePos( Vector2* pOut)
		{
			GetMousePosNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetMousePosOnOpeningCurrentPopup")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetMousePosOnOpeningCurrentPopupNative(Vector2* pOut);

		public static void GetMousePosOnOpeningCurrentPopup( Vector2* pOut)
		{
			GetMousePosOnOpeningCurrentPopupNative(pOut);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igIsMouseDragging")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsMouseDraggingNative(int button, float lockThreshold);

		public static bool IsMouseDragging( int button,  float lockThreshold)
		{
			byte ret = IsMouseDraggingNative(button, lockThreshold);
			return ret != 0;
		}

		public static bool IsMouseDragging( int button)
		{
			byte ret = IsMouseDraggingNative(button, (float)(-1.0f));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetMouseDragDelta")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetMouseDragDeltaNative(Vector2* pOut, int button, float lockThreshold);

		public static void GetMouseDragDelta( Vector2* pOut,  int button,  float lockThreshold)
		{
			GetMouseDragDeltaNative(pOut, button, lockThreshold);
		}

		public static void GetMouseDragDelta( Vector2* pOut,  int button)
		{
			GetMouseDragDeltaNative(pOut, button, (float)(-1.0f));
		}

		public static void GetMouseDragDelta( Vector2* pOut)
		{
			GetMouseDragDeltaNative(pOut, (int)(0), (float)(-1.0f));
		}

		public static void GetMouseDragDelta( Vector2* pOut,  float lockThreshold)
		{
			GetMouseDragDeltaNative(pOut, (int)(0), lockThreshold);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igResetMouseDragDelta")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ResetMouseDragDeltaNative(int button);

		public static void ResetMouseDragDelta( int button)
		{
			ResetMouseDragDeltaNative(button);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetMouseCursor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetMouseCursorNative();

		public static int GetMouseCursor()
		{
			int ret = GetMouseCursorNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetMouseCursor")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetMouseCursorNative(int cursorType);

		public static void SetMouseCursor( int cursorType)
		{
			SetMouseCursorNative(cursorType);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextFrameWantCaptureMouse")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextFrameWantCaptureMouseNative(byte wantCaptureMouse);

		public static void SetNextFrameWantCaptureMouse( bool wantCaptureMouse)
		{
			SetNextFrameWantCaptureMouseNative(wantCaptureMouse ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetClipboardText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* GetClipboardTextNative();

		public static byte* GetClipboardText()
		{
			byte* ret = GetClipboardTextNative();
			return ret;
		}

		public static string GetClipboardTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetClipboardTextNative());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetClipboardText")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetClipboardTextNative(byte* text);

		public static void SetClipboardText( byte* text)
		{
			SetClipboardTextNative(text);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLoadIniSettingsFromDisk")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LoadIniSettingsFromDiskNative(byte* iniFilename);

		public static void LoadIniSettingsFromDisk( byte* iniFilename)
		{
			LoadIniSettingsFromDiskNative(iniFilename);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igLoadIniSettingsFromMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void LoadIniSettingsFromMemoryNative(byte* iniData, ulong iniSize);

		public static void LoadIniSettingsFromMemory( byte* iniData,  ulong iniSize)
		{
			LoadIniSettingsFromMemoryNative(iniData, iniSize);
		}

		public static void LoadIniSettingsFromMemory( byte* iniData)
		{
			LoadIniSettingsFromMemoryNative(iniData, (ulong)(0));
		}

		public static void LoadIniSettingsFromMemory( byte* iniData,  nuint iniSize)
		{
			LoadIniSettingsFromMemoryNative(iniData, iniSize);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSaveIniSettingsToDisk")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SaveIniSettingsToDiskNative(byte* iniFilename);

		public static void SaveIniSettingsToDisk( byte* iniFilename)
		{
			SaveIniSettingsToDiskNative(iniFilename);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSaveIniSettingsToMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* SaveIniSettingsToMemoryNative(ulong* outIniSize);

		public static byte* SaveIniSettingsToMemory( ulong* outIniSize)
		{
			byte* ret = SaveIniSettingsToMemoryNative(outIniSize);
			return ret;
		}

		public static string SaveIniSettingsToMemoryS()
		{
			string ret = Utils.DecodeStringUTF8(SaveIniSettingsToMemoryNative((ulong*)(default)));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDebugTextEncoding")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DebugTextEncodingNative(byte* text);

		public static void DebugTextEncoding( byte* text)
		{
			DebugTextEncodingNative(text);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDebugCheckVersionAndDataLayout")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte DebugCheckVersionAndDataLayoutNative(byte* versionStr, ulong szIo, ulong szStyle, ulong szvec2, ulong szvec4, ulong szDrawvert, ulong szDrawidx);

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  ulong szvec2,  ulong szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  ulong szvec2,  ulong szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  ulong szvec2,  ulong szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  ulong szvec2,  ulong szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  nuint szvec2,  ulong szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  nuint szvec2,  ulong szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  nuint szvec2,  ulong szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  nuint szvec2,  ulong szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  ulong szvec2,  nuint szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  ulong szvec2,  nuint szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  ulong szvec2,  nuint szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  ulong szvec2,  nuint szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  nuint szvec2,  nuint szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  nuint szvec2,  nuint szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  nuint szvec2,  nuint szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  nuint szvec2,  nuint szvec4,  ulong szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  ulong szvec2,  ulong szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  ulong szvec2,  ulong szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  ulong szvec2,  ulong szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  ulong szvec2,  ulong szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  nuint szvec2,  ulong szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  nuint szvec2,  ulong szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  nuint szvec2,  ulong szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  nuint szvec2,  ulong szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  ulong szvec2,  nuint szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  ulong szvec2,  nuint szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  ulong szvec2,  nuint szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  ulong szvec2,  nuint szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  nuint szvec2,  nuint szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  nuint szvec2,  nuint szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  nuint szvec2,  nuint szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  nuint szvec2,  nuint szvec4,  nuint szDrawvert,  ulong szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  ulong szvec2,  ulong szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  ulong szvec2,  ulong szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  ulong szvec2,  ulong szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  ulong szvec2,  ulong szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  nuint szvec2,  ulong szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  nuint szvec2,  ulong szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  nuint szvec2,  ulong szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  nuint szvec2,  ulong szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  ulong szvec2,  nuint szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  ulong szvec2,  nuint szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  ulong szvec2,  nuint szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  ulong szvec2,  nuint szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  nuint szvec2,  nuint szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  nuint szvec2,  nuint szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  nuint szvec2,  nuint szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  nuint szvec2,  nuint szvec4,  ulong szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  ulong szvec2,  ulong szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  ulong szvec2,  ulong szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  ulong szvec2,  ulong szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  ulong szvec2,  ulong szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  nuint szvec2,  ulong szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  nuint szvec2,  ulong szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  nuint szvec2,  ulong szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  nuint szvec2,  ulong szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  ulong szvec2,  nuint szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  ulong szvec2,  nuint szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  ulong szvec2,  nuint szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  ulong szvec2,  nuint szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  ulong szStyle,  nuint szvec2,  nuint szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  ulong szStyle,  nuint szvec2,  nuint szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  ulong szIo,  nuint szStyle,  nuint szvec2,  nuint szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		public static bool DebugCheckVersionAndDataLayout( byte* versionStr,  nuint szIo,  nuint szStyle,  nuint szvec2,  nuint szvec4,  nuint szDrawvert,  nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetAllocatorFunctions")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetAllocatorFunctionsNative(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc, void* userData);

		public static void SetAllocatorFunctions( ImGuiMemAllocFunc allocFunc,  ImGuiMemFreeFunc freeFunc,  void* userData)
		{
			SetAllocatorFunctionsNative(allocFunc, freeFunc, userData);
		}

		public static void SetAllocatorFunctions( ImGuiMemAllocFunc allocFunc,  ImGuiMemFreeFunc freeFunc)
		{
			SetAllocatorFunctionsNative(allocFunc, freeFunc, (void*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetAllocatorFunctions")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetAllocatorFunctionsNative(ImGuiMemAllocFunc pAllocFunc, ImGuiMemFreeFunc pFreeFunc, void** pUserData);

		public static void GetAllocatorFunctions( ImGuiMemAllocFunc pAllocFunc,  ImGuiMemFreeFunc pFreeFunc,  void** pUserData)
		{
			GetAllocatorFunctionsNative(pAllocFunc, pFreeFunc, pUserData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igMemAlloc")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* MemAllocNative(ulong size);

		public static void* MemAlloc( ulong size)
		{
			void* ret = MemAllocNative(size);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igMemFree")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void MemFreeNative(void* ptr);

		public static void MemFree( void* ptr)
		{
			MemFreeNative(ptr);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetPlatformIO")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPlatformIO* GetPlatformIONative();

		public static ImGuiPlatformIO* GetPlatformIO()
		{
			ImGuiPlatformIO* ret = GetPlatformIONative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igUpdatePlatformWindows")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void UpdatePlatformWindowsNative();

		public static void UpdatePlatformWindows()
		{
			UpdatePlatformWindowsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igRenderPlatformWindowsDefault")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void RenderPlatformWindowsDefaultNative(void* platformRenderArg, void* rendererRenderArg);

		public static void RenderPlatformWindowsDefault( void* platformRenderArg,  void* rendererRenderArg)
		{
			RenderPlatformWindowsDefaultNative(platformRenderArg, rendererRenderArg);
		}

		public static void RenderPlatformWindowsDefault( void* platformRenderArg)
		{
			RenderPlatformWindowsDefaultNative(platformRenderArg, (void*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igDestroyPlatformWindows")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyPlatformWindowsNative();

		public static void DestroyPlatformWindows()
		{
			DestroyPlatformWindowsNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igFindViewportByID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiViewport* FindViewportByIDNative(uint id);

		public static ImGuiViewport* FindViewportByID( uint id)
		{
			ImGuiViewport* ret = FindViewportByIDNative(id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igFindViewportByPlatformHandle")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiViewport* FindViewportByPlatformHandleNative(void* platformHandle);

		public static ImGuiViewport* FindViewportByPlatformHandle( void* platformHandle)
		{
			ImGuiViewport* ret = FindViewportByPlatformHandleNative(platformHandle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStyle_ImGuiStyle")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStyle* ImGuiStyleNative();

		public static ImGuiStyle* ImGuiStyle()
		{
			ImGuiStyle* ret = ImGuiStyleNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStyle_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiStyle* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStyle_ScaleAllSizes")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ScaleAllSizesNative(ImGuiStyle* self, float scaleFactor);

		public static void ScaleAllSizes( ImGuiStyle* self,  float scaleFactor)
		{
			ScaleAllSizesNative(self, scaleFactor);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddKeyEvent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddKeyEventNative(ImGuiIO* self, ImGuiKey key, byte down);

		public static void AddKeyEvent( ImGuiIO* self,  ImGuiKey key,  bool down)
		{
			AddKeyEventNative(self, key, down ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddKeyAnalogEvent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddKeyAnalogEventNative(ImGuiIO* self, ImGuiKey key, byte down, float v);

		public static void AddKeyAnalogEvent( ImGuiIO* self,  ImGuiKey key,  bool down,  float v)
		{
			AddKeyAnalogEventNative(self, key, down ? (byte)1 : (byte)0, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddMousePosEvent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddMousePosEventNative(ImGuiIO* self, float x, float y);

		public static void AddMousePosEvent( ImGuiIO* self,  float x,  float y)
		{
			AddMousePosEventNative(self, x, y);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddMouseButtonEvent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddMouseButtonEventNative(ImGuiIO* self, int button, byte down);

		public static void AddMouseButtonEvent( ImGuiIO* self,  int button,  bool down)
		{
			AddMouseButtonEventNative(self, button, down ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddMouseWheelEvent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddMouseWheelEventNative(ImGuiIO* self, float wheelX, float wheelY);

		public static void AddMouseWheelEvent( ImGuiIO* self,  float wheelX,  float wheelY)
		{
			AddMouseWheelEventNative(self, wheelX, wheelY);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddMouseSourceEvent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddMouseSourceEventNative(ImGuiIO* self, ImGuiMouseSource source);

		public static void AddMouseSourceEvent( ImGuiIO* self,  ImGuiMouseSource source)
		{
			AddMouseSourceEventNative(self, source);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddMouseViewportEvent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddMouseViewportEventNative(ImGuiIO* self, uint id);

		public static void AddMouseViewportEvent( ImGuiIO* self,  uint id)
		{
			AddMouseViewportEventNative(self, id);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddFocusEvent")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddFocusEventNative(ImGuiIO* self, byte focused);

		public static void AddFocusEvent( ImGuiIO* self,  bool focused)
		{
			AddFocusEventNative(self, focused ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddInputCharacter")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddInputCharacterNative(ImGuiIO* self, uint c);

		public static void AddInputCharacter( ImGuiIO* self,  uint c)
		{
			AddInputCharacterNative(self, c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddInputCharacterUTF16")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddInputCharacterUTF16Native(ImGuiIO* self, ushort c);

		public static void AddInputCharacterUTF16( ImGuiIO* self,  ushort c)
		{
			AddInputCharacterUTF16Native(self, c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_AddInputCharactersUTF8")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddInputCharactersUTF8Native(ImGuiIO* self, byte* str);

		public static void AddInputCharactersUTF8( ImGuiIO* self,  byte* str)
		{
			AddInputCharactersUTF8Native(self, str);
		}

		public static void AddInputCharactersUTF8( ImGuiIO* self,  ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				AddInputCharactersUTF8Native(self, (byte*)pstr);
			}
		}

		public static void AddInputCharactersUTF8( ImGuiIO* self,  string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddInputCharactersUTF8Native(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_SetKeyEventNativeData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetKeyEventNativeDataNative(ImGuiIO* self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex);

		public static void SetKeyEventNativeData( ImGuiIO* self,  ImGuiKey key,  int nativeKeycode,  int nativeScancode,  int nativeLegacyIndex)
		{
			SetKeyEventNativeDataNative(self, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
		}

		public static void SetKeyEventNativeData( ImGuiIO* self,  ImGuiKey key,  int nativeKeycode,  int nativeScancode)
		{
			SetKeyEventNativeDataNative(self, key, nativeKeycode, nativeScancode, (int)(-1));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_SetAppAcceptingEvents")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetAppAcceptingEventsNative(ImGuiIO* self, byte acceptingEvents);

		public static void SetAppAcceptingEvents( ImGuiIO* self,  bool acceptingEvents)
		{
			SetAppAcceptingEventsNative(self, acceptingEvents ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_ClearEventsQueue")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearEventsQueueNative(ImGuiIO* self);

		public static void ClearEventsQueue( ImGuiIO* self)
		{
			ClearEventsQueueNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_ClearInputKeys")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearInputKeysNative(ImGuiIO* self);

		public static void ClearInputKeys( ImGuiIO* self)
		{
			ClearInputKeysNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_ImGuiIO")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiIO* ImGuiIONative();

		public static ImGuiIO* ImGuiIO()
		{
			ImGuiIO* ret = ImGuiIONative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiIO_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiIO* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextCallbackData_ImGuiInputTextCallbackData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiInputTextCallbackData* ImGuiInputTextCallbackDataNative();

		public static ImGuiInputTextCallbackData* ImGuiInputTextCallbackData()
		{
			ImGuiInputTextCallbackData* ret = ImGuiInputTextCallbackDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextCallbackData_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiInputTextCallbackData* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextCallbackData_DeleteChars")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DeleteCharsNative(ImGuiInputTextCallbackData* self, int pos, int bytesCount);

		public static void DeleteChars( ImGuiInputTextCallbackData* self,  int pos,  int bytesCount)
		{
			DeleteCharsNative(self, pos, bytesCount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextCallbackData_InsertChars")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void InsertCharsNative(ImGuiInputTextCallbackData* self, int pos, byte* text, byte* textEnd);

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  byte* text,  byte* textEnd)
		{
			InsertCharsNative(self, pos, text, textEnd);
		}

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  byte* text)
		{
			InsertCharsNative(self, pos, text, (byte*)(default));
		}

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  ref byte text,  byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				InsertCharsNative(self, pos, (byte*)ptext, textEnd);
			}
		}

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				InsertCharsNative(self, pos, (byte*)ptext, (byte*)(default));
			}
		}

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  string text,  byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertCharsNative(self, pos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertCharsNative(self, pos, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  byte* text,  ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				InsertCharsNative(self, pos, text, (byte*)ptextEnd);
			}
		}

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  byte* text,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertCharsNative(self, pos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  ref byte text,  ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					InsertCharsNative(self, pos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		public static void InsertChars( ImGuiInputTextCallbackData* self,  int pos,  string text,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			InsertCharsNative(self, pos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextCallbackData_SelectAll")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SelectAllNative(ImGuiInputTextCallbackData* self);

		public static void SelectAll( ImGuiInputTextCallbackData* self)
		{
			SelectAllNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextCallbackData_ClearSelection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearSelectionNative(ImGuiInputTextCallbackData* self);

		public static void ClearSelection( ImGuiInputTextCallbackData* self)
		{
			ClearSelectionNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiInputTextCallbackData_HasSelection")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte HasSelectionNative(ImGuiInputTextCallbackData* self);

		public static bool HasSelection( ImGuiInputTextCallbackData* self)
		{
			byte ret = HasSelectionNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiWindowClass_ImGuiWindowClass")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiWindowClass* ImGuiWindowClassNative();

		public static ImGuiWindowClass* ImGuiWindowClass()
		{
			ImGuiWindowClass* ret = ImGuiWindowClassNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiWindowClass_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiWindowClass* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPayload_ImGuiPayload")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiPayload* ImGuiPayloadNative();

		public static ImGuiPayload* ImGuiPayload()
		{
			ImGuiPayload* ret = ImGuiPayloadNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPayload_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiPayload* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPayload_Clear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearNative(ImGuiPayload* self);

		public static void Clear( ImGuiPayload* self)
		{
			ClearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPayload_IsDataType")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsDataTypeNative(ImGuiPayload* self, byte* type);

		public static bool IsDataType( ImGuiPayload* self,  byte* type)
		{
			byte ret = IsDataTypeNative(self, type);
			return ret != 0;
		}

		public static bool IsDataType( ImGuiPayload* self,  ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				byte ret = IsDataTypeNative(self, (byte*)ptype);
				return ret != 0;
			}
		}

		public static bool IsDataType( ImGuiPayload* self,  string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = IsDataTypeNative(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPayload_IsPreview")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsPreviewNative(ImGuiPayload* self);

		public static bool IsPreview( ImGuiPayload* self)
		{
			byte ret = IsPreviewNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiPayload_IsDelivery")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsDeliveryNative(ImGuiPayload* self);

		public static bool IsDelivery( ImGuiPayload* self)
		{
			byte ret = IsDeliveryNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTableColumnSortSpecs* ImGuiTableColumnSortSpecsNative();

		public static ImGuiTableColumnSortSpecs* ImGuiTableColumnSortSpecs()
		{
			ImGuiTableColumnSortSpecs* ret = ImGuiTableColumnSortSpecsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTableColumnSortSpecs_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiTableColumnSortSpecs* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTableSortSpecs_ImGuiTableSortSpecs")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTableSortSpecs* ImGuiTableSortSpecsNative();

		public static ImGuiTableSortSpecs* ImGuiTableSortSpecs()
		{
			ImGuiTableSortSpecs* ret = ImGuiTableSortSpecsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTableSortSpecs_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiTableSortSpecs* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiOnceUponAFrame_ImGuiOnceUponAFrame")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiOnceUponAFrame* ImGuiOnceUponAFrameNative();

		public static ImGuiOnceUponAFrame* ImGuiOnceUponAFrame()
		{
			ImGuiOnceUponAFrame* ret = ImGuiOnceUponAFrameNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiOnceUponAFrame_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiOnceUponAFrame* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextFilter_ImGuiTextFilter")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTextFilter* ImGuiTextFilterNative(byte* defaultFilter);

		public static ImGuiTextFilter* ImGuiTextFilter( byte* defaultFilter)
		{
			ImGuiTextFilter* ret = ImGuiTextFilterNative(defaultFilter);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextFilter_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiTextFilter* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextFilter_Draw")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte DrawNative(ImGuiTextFilter* self, byte* label, float width);

		public static bool Draw( ImGuiTextFilter* self,  byte* label,  float width)
		{
			byte ret = DrawNative(self, label, width);
			return ret != 0;
		}

		public static bool Draw( ImGuiTextFilter* self,  byte* label)
		{
			byte ret = DrawNative(self, label, (float)(0.0f));
			return ret != 0;
		}

		public static bool Draw( ImGuiTextFilter* self)
		{
			bool ret = Draw(self, (string)"Filter(inc,-exc)", (float)(0.0f));
			return ret;
		}

		public static bool Draw( ImGuiTextFilter* self,  float width)
		{
			bool ret = Draw(self, (string)"Filter(inc,-exc)", width);
			return ret;
		}

		public static bool Draw( ImGuiTextFilter* self,  ref byte label,  float width)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DrawNative(self, (byte*)plabel, width);
				return ret != 0;
			}
		}

		public static bool Draw( ImGuiTextFilter* self,  ref byte label)
		{
			fixed (byte* plabel = &label)
			{
				byte ret = DrawNative(self, (byte*)plabel, (float)(0.0f));
				return ret != 0;
			}
		}

		public static bool Draw( ImGuiTextFilter* self,  string label,  float width)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DrawNative(self, pStr0, width);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool Draw( ImGuiTextFilter* self,  string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DrawNative(self, pStr0, (float)(0.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextFilter_PassFilter")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte PassFilterNative(ImGuiTextFilter* self, byte* text, byte* textEnd);

		public static bool PassFilter( ImGuiTextFilter* self,  byte* text,  byte* textEnd)
		{
			byte ret = PassFilterNative(self, text, textEnd);
			return ret != 0;
		}

		public static bool PassFilter( ImGuiTextFilter* self,  byte* text)
		{
			byte ret = PassFilterNative(self, text, (byte*)(default));
			return ret != 0;
		}

		public static bool PassFilter( ImGuiTextFilter* self,  ref byte text,  byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = PassFilterNative(self, (byte*)ptext, textEnd);
				return ret != 0;
			}
		}

		public static bool PassFilter( ImGuiTextFilter* self,  ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				byte ret = PassFilterNative(self, (byte*)ptext, (byte*)(default));
				return ret != 0;
			}
		}

		public static bool PassFilter( ImGuiTextFilter* self,  string text,  byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = PassFilterNative(self, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool PassFilter( ImGuiTextFilter* self,  string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = PassFilterNative(self, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool PassFilter( ImGuiTextFilter* self,  byte* text,  ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				byte ret = PassFilterNative(self, text, (byte*)ptextEnd);
				return ret != 0;
			}
		}

		public static bool PassFilter( ImGuiTextFilter* self,  byte* text,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = PassFilterNative(self, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool PassFilter( ImGuiTextFilter* self,  ref byte text,  ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte ret = PassFilterNative(self, (byte*)ptext, (byte*)ptextEnd);
					return ret != 0;
				}
			}
		}

		public static bool PassFilter( ImGuiTextFilter* self,  string text,  string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte ret = PassFilterNative(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextFilter_Build")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BuildNative(ImGuiTextFilter* self);

		public static void Build( ImGuiTextFilter* self)
		{
			BuildNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextFilter_Clear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearNative(ImGuiTextFilter* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextFilter_IsActive")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte IsActiveNative(ImGuiTextFilter* self);

		public static bool IsActive( ImGuiTextFilter* self)
		{
			byte ret = IsActiveNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextRange_ImGuiTextRange_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTextRange* ImGuiTextRangeNative();

		public static ImGuiTextRange* ImGuiTextRange()
		{
			ImGuiTextRange* ret = ImGuiTextRangeNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextRange_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiTextRange* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextRange_ImGuiTextRange_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTextRange* ImGuiTextRangeNative(byte* B, byte* E);

		public static ImGuiTextRange* ImGuiTextRange( byte* B,  byte* E)
		{
			ImGuiTextRange* ret = ImGuiTextRangeNative(B, E);
			return ret;
		}

		public static ImGuiTextRange* ImGuiTextRange( byte* B,  ref byte E)
		{
			fixed (byte* pE = &E)
			{
				ImGuiTextRange* ret = ImGuiTextRangeNative(B, (byte*)pE);
				return ret;
			}
		}

		public static ImGuiTextRange* ImGuiTextRange( byte* B,  string E)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (E != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(E);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(E, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImGuiTextRange* ret = ImGuiTextRangeNative(B, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextRange_empty")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte emptyNative(ImGuiTextRange* self);

		public static bool empty( ImGuiTextRange* self)
		{
			byte ret = emptyNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextRange_split")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void splitNative(ImGuiTextRange* self, byte separator, ImVectorImGuiTextRange* output);

		public static void split( ImGuiTextRange* self,  byte separator,  ImVectorImGuiTextRange* output)
		{
			splitNative(self, separator, output);
		}

		public static void split( ImGuiTextRange* self,  byte separator,  ref ImVectorImGuiTextRange output)
		{
			fixed (ImVectorImGuiTextRange* poutput = &output)
			{
				splitNative(self, separator, (ImVectorImGuiTextRange*)poutput);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_ImGuiTextBuffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiTextBuffer* ImGuiTextBufferNative();

		public static ImGuiTextBuffer* ImGuiTextBuffer()
		{
			ImGuiTextBuffer* ret = ImGuiTextBufferNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiTextBuffer* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_begin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* beginNative(ImGuiTextBuffer* self);

		public static byte* begin( ImGuiTextBuffer* self)
		{
			byte* ret = beginNative(self);
			return ret;
		}

		public static string beginS( ImGuiTextBuffer* self)
		{
			string ret = Utils.DecodeStringUTF8(beginNative(self));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_end")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* endNative(ImGuiTextBuffer* self);

		public static byte* end( ImGuiTextBuffer* self)
		{
			byte* ret = endNative(self);
			return ret;
		}

		public static string endS( ImGuiTextBuffer* self)
		{
			string ret = Utils.DecodeStringUTF8(endNative(self));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_size")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int sizeNative(ImGuiTextBuffer* self);

		public static int size( ImGuiTextBuffer* self)
		{
			int ret = sizeNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_empty")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte emptyNative(ImGuiTextBuffer* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_clear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void clearNative(ImGuiTextBuffer* self);

		public static void clear( ImGuiTextBuffer* self)
		{
			clearNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_reserve")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void reserveNative(ImGuiTextBuffer* self, int capacity);

		public static void reserve( ImGuiTextBuffer* self,  int capacity)
		{
			reserveNative(self, capacity);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_c_str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* c_strNative(ImGuiTextBuffer* self);

		public static byte* c_str( ImGuiTextBuffer* self)
		{
			byte* ret = c_strNative(self);
			return ret;
		}

		public static string c_strS( ImGuiTextBuffer* self)
		{
			string ret = Utils.DecodeStringUTF8(c_strNative(self));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_append")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void appendNative(ImGuiTextBuffer* self, byte* str, byte* strEnd);

		public static void append( ImGuiTextBuffer* self,  byte* str,  byte* strEnd)
		{
			appendNative(self, str, strEnd);
		}

		public static void append( ImGuiTextBuffer* self,  byte* str)
		{
			appendNative(self, str, (byte*)(default));
		}

		public static void append( ImGuiTextBuffer* self,  ref byte str,  byte* strEnd)
		{
			fixed (byte* pstr = &str)
			{
				appendNative(self, (byte*)pstr, strEnd);
			}
		}

		public static void append( ImGuiTextBuffer* self,  ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				appendNative(self, (byte*)pstr, (byte*)(default));
			}
		}

		public static void append( ImGuiTextBuffer* self,  string str,  byte* strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendNative(self, pStr0, strEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append( ImGuiTextBuffer* self,  string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendNative(self, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append( ImGuiTextBuffer* self,  byte* str,  ref byte strEnd)
		{
			fixed (byte* pstrEnd = &strEnd)
			{
				appendNative(self, str, (byte*)pstrEnd);
			}
		}

		public static void append( ImGuiTextBuffer* self,  byte* str,  string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (strEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(strEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendNative(self, str, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void append( ImGuiTextBuffer* self,  ref byte str,  ref byte strEnd)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte* pstrEnd = &strEnd)
				{
					appendNative(self, (byte*)pstr, (byte*)pstrEnd);
				}
			}
		}

		public static void append( ImGuiTextBuffer* self,  string str,  string strEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (strEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(strEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(strEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			appendNative(self, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiTextBuffer_appendfv")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void appendfvNative(ImGuiTextBuffer* self, byte* fmt, nuint args);

		public static void appendfv( ImGuiTextBuffer* self,  byte* fmt,  nuint args)
		{
			appendfvNative(self, fmt, args);
		}

		public static void appendfv( ImGuiTextBuffer* self,  ref byte fmt,  nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				appendfvNative(self, (byte*)pfmt, args);
			}
		}

		public static void appendfv( ImGuiTextBuffer* self,  string fmt,  nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			appendfvNative(self, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStoragePair* ImGuiStoragePairNative(uint Key, int Val);

		public static ImGuiStoragePair* ImGuiStoragePair( uint Key,  int Val)
		{
			ImGuiStoragePair* ret = ImGuiStoragePairNative(Key, Val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStoragePair_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiStoragePair* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStoragePair* ImGuiStoragePairNative(uint Key, float Val);

		public static ImGuiStoragePair* ImGuiStoragePair( uint Key,  float Val)
		{
			ImGuiStoragePair* ret = ImGuiStoragePairNative(Key, Val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiStoragePair* ImGuiStoragePairNative(uint Key, void* Val);

		public static ImGuiStoragePair* ImGuiStoragePair( uint Key,  void* Val)
		{
			ImGuiStoragePair* ret = ImGuiStoragePairNative(Key, Val);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_Clear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearNative(ImGuiStorage* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_GetInt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int GetIntNative(ImGuiStorage* self, uint key, int defaultVal);

		public static int GetInt( ImGuiStorage* self,  uint key,  int defaultVal)
		{
			int ret = GetIntNative(self, key, defaultVal);
			return ret;
		}

		public static int GetInt( ImGuiStorage* self,  uint key)
		{
			int ret = GetIntNative(self, key, (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_SetInt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetIntNative(ImGuiStorage* self, uint key, int val);

		public static void SetInt( ImGuiStorage* self,  uint key,  int val)
		{
			SetIntNative(self, key, val);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_GetBool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte GetBoolNative(ImGuiStorage* self, uint key, byte defaultVal);

		public static bool GetBool( ImGuiStorage* self,  uint key,  bool defaultVal)
		{
			byte ret = GetBoolNative(self, key, defaultVal ? (byte)1 : (byte)0);
			return ret != 0;
		}

		public static bool GetBool( ImGuiStorage* self,  uint key)
		{
			byte ret = GetBoolNative(self, key, (byte)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_SetBool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetBoolNative(ImGuiStorage* self, uint key, byte val);

		public static void SetBool( ImGuiStorage* self,  uint key,  bool val)
		{
			SetBoolNative(self, key, val ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_GetFloat")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetFloatNative(ImGuiStorage* self, uint key, float defaultVal);

		public static float GetFloat( ImGuiStorage* self,  uint key,  float defaultVal)
		{
			float ret = GetFloatNative(self, key, defaultVal);
			return ret;
		}

		public static float GetFloat( ImGuiStorage* self,  uint key)
		{
			float ret = GetFloatNative(self, key, (float)(0.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_SetFloat")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetFloatNative(ImGuiStorage* self, uint key, float val);

		public static void SetFloat( ImGuiStorage* self,  uint key,  float val)
		{
			SetFloatNative(self, key, val);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_GetVoidPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void* GetVoidPtrNative(ImGuiStorage* self, uint key);

		public static void* GetVoidPtr( ImGuiStorage* self,  uint key)
		{
			void* ret = GetVoidPtrNative(self, key);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_SetVoidPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetVoidPtrNative(ImGuiStorage* self, uint key, void* val);

		public static void SetVoidPtr( ImGuiStorage* self,  uint key,  void* val)
		{
			SetVoidPtrNative(self, key, val);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_GetIntRef")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial int* GetIntRefNative(ImGuiStorage* self, uint key, int defaultVal);

		public static int* GetIntRef( ImGuiStorage* self,  uint key,  int defaultVal)
		{
			int* ret = GetIntRefNative(self, key, defaultVal);
			return ret;
		}

		public static int* GetIntRef( ImGuiStorage* self,  uint key)
		{
			int* ret = GetIntRefNative(self, key, (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_GetBoolRef")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte* GetBoolRefNative(ImGuiStorage* self, uint key, byte defaultVal);

		public static byte* GetBoolRef( ImGuiStorage* self,  uint key,  bool defaultVal)
		{
			byte* ret = GetBoolRefNative(self, key, defaultVal ? (byte)1 : (byte)0);
			return ret;
		}

		public static byte* GetBoolRef( ImGuiStorage* self,  uint key)
		{
			byte* ret = GetBoolRefNative(self, key, (byte)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_GetFloatRef")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float* GetFloatRefNative(ImGuiStorage* self, uint key, float defaultVal);

		public static float* GetFloatRef( ImGuiStorage* self,  uint key,  float defaultVal)
		{
			float* ret = GetFloatRefNative(self, key, defaultVal);
			return ret;
		}

		public static float* GetFloatRef( ImGuiStorage* self,  uint key)
		{
			float* ret = GetFloatRefNative(self, key, (float)(0.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_GetVoidPtrRef")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void** GetVoidPtrRefNative(ImGuiStorage* self, uint key, void* defaultVal);

		public static void** GetVoidPtrRef( ImGuiStorage* self,  uint key,  void* defaultVal)
		{
			void** ret = GetVoidPtrRefNative(self, key, defaultVal);
			return ret;
		}

		public static void** GetVoidPtrRef( ImGuiStorage* self,  uint key)
		{
			void** ret = GetVoidPtrRefNative(self, key, (void*)(default));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_BuildSortByKey")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BuildSortByKeyNative(ImGuiStorage* self);

		public static void BuildSortByKey( ImGuiStorage* self)
		{
			BuildSortByKeyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiStorage_SetAllInt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetAllIntNative(ImGuiStorage* self, int val);

		public static void SetAllInt( ImGuiStorage* self,  int val)
		{
			SetAllIntNative(self, val);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipper_ImGuiListClipper")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImGuiListClipper* ImGuiListClipperNative();

		public static ImGuiListClipper* ImGuiListClipper()
		{
			ImGuiListClipper* ret = ImGuiListClipperNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipper_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImGuiListClipper* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipper_Begin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void BeginNative(ImGuiListClipper* self, int itemsCount, float itemsHeight);

		public static void Begin( ImGuiListClipper* self,  int itemsCount,  float itemsHeight)
		{
			BeginNative(self, itemsCount, itemsHeight);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipper_End")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndNative(ImGuiListClipper* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipper_Step")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte StepNative(ImGuiListClipper* self);

		public static bool Step( ImGuiListClipper* self)
		{
			byte ret = StepNative(self);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipper_IncludeItemByIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void IncludeItemByIndexNative(ImGuiListClipper* self, int itemIndex);

		public static void IncludeItemByIndex( ImGuiListClipper* self,  int itemIndex)
		{
			IncludeItemByIndexNative(self, itemIndex);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImGuiListClipper_IncludeItemsByIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void IncludeItemsByIndexNative(ImGuiListClipper* self, int itemBegin, int itemEnd);

		public static void IncludeItemsByIndex( ImGuiListClipper* self,  int itemBegin,  int itemEnd)
		{
			IncludeItemsByIndexNative(self, itemBegin, itemEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImColor_ImColor_Nil")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImColor* ImColorNative();

		public static ImColor* ImColor()
		{
			ImColor* ret = ImColorNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImColor_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImColor* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImColor_ImColor_Float")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImColor* ImColorNative(float r, float g, float b, float a);

		public static ImColor* ImColor( float r,  float g,  float b,  float a)
		{
			ImColor* ret = ImColorNative(r, g, b, a);
			return ret;
		}

		public static ImColor* ImColor( float r,  float g,  float b)
		{
			ImColor* ret = ImColorNative(r, g, b, (float)(1.0f));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImColor_ImColor_Vec4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImColor* ImColorNative(Vector4 col);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImColor_ImColor_Int")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImColor* ImColorNative(int r, int g, int b, int a);

		public static ImColor* ImColor( int r,  int g,  int b,  int a)
		{
			ImColor* ret = ImColorNative(r, g, b, a);
			return ret;
		}

		public static ImColor* ImColor( int r,  int g,  int b)
		{
			ImColor* ret = ImColorNative(r, g, b, (int)(255));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImColor_ImColor_U32")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImColor* ImColorNative(uint rgba);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImColor_SetHSV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetHSVNative(ImColor* self, float h, float s, float v, float a);

		public static void SetHSV( ImColor* self,  float h,  float s,  float v,  float a)
		{
			SetHSVNative(self, h, s, v, a);
		}

		public static void SetHSV( ImColor* self,  float h,  float s,  float v)
		{
			SetHSVNative(self, h, s, v, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImColor_HSV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void HSVNative(ImColor* pOut, float h, float s, float v, float a);

		public static void HSV( ImColor* pOut,  float h,  float s,  float v,  float a)
		{
			HSVNative(pOut, h, s, v, a);
		}

		public static void HSV( ImColor* pOut,  float h,  float s,  float v)
		{
			HSVNative(pOut, h, s, v, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawCmd_ImDrawCmd")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawCmd* ImDrawCmdNative();

		public static ImDrawCmd* ImDrawCmd()
		{
			ImDrawCmd* ret = ImDrawCmdNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawCmd_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImDrawCmd* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawCmd_GetTexID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImTextureID GetTexIDNative(ImDrawCmd* self);

		public static ImTextureID GetTexID( ImDrawCmd* self)
		{
			ImTextureID ret = GetTexIDNative(self);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSplitter_ImDrawListSplitter")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawListSplitter* ImDrawListSplitterNative();

		public static ImDrawListSplitter* ImDrawListSplitter()
		{
			ImDrawListSplitter* ret = ImDrawListSplitterNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSplitter_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImDrawListSplitter* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSplitter_Clear")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearNative(ImDrawListSplitter* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSplitter_ClearFreeMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void ClearFreeMemoryNative(ImDrawListSplitter* self);

		public static void ClearFreeMemory( ImDrawListSplitter* self)
		{
			ClearFreeMemoryNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSplitter_Split")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SplitNative(ImDrawListSplitter* self, ImDrawList* drawList, int count);

		public static void Split( ImDrawListSplitter* self,  ImDrawList* drawList,  int count)
		{
			SplitNative(self, drawList, count);
		}

		public static void Split( ImDrawListSplitter* self,  ref ImDrawList drawList,  int count)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				SplitNative(self, (ImDrawList*)pdrawList, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSplitter_Merge")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void MergeNative(ImDrawListSplitter* self, ImDrawList* drawList);

		public static void Merge( ImDrawListSplitter* self,  ImDrawList* drawList)
		{
			MergeNative(self, drawList);
		}

		public static void Merge( ImDrawListSplitter* self,  ref ImDrawList drawList)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				MergeNative(self, (ImDrawList*)pdrawList);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawListSplitter_SetCurrentChannel")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetCurrentChannelNative(ImDrawListSplitter* self, ImDrawList* drawList, int channelIdx);

		public static void SetCurrentChannel( ImDrawListSplitter* self,  ImDrawList* drawList,  int channelIdx)
		{
			SetCurrentChannelNative(self, drawList, channelIdx);
		}

		public static void SetCurrentChannel( ImDrawListSplitter* self,  ref ImDrawList drawList,  int channelIdx)
		{
			fixed (ImDrawList* pdrawList = &drawList)
			{
				SetCurrentChannelNative(self, (ImDrawList*)pdrawList, channelIdx);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_ImDrawList")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ImDrawList* ImDrawListNative(ImDrawListSharedData* sharedData);

		public static ImDrawList* ImDrawList( ImDrawListSharedData* sharedData)
		{
			ImDrawList* ret = ImDrawListNative(sharedData);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_destroy")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void DestroyNative(ImDrawList* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_PushClipRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushClipRectNative(ImDrawList* self, Vector2 clipRectMin, Vector2 clipRectMax, byte intersectWithCurrentClipRect);

		public static void PushClipRect( ImDrawList* self,  Vector2 clipRectMin,  Vector2 clipRectMax,  bool intersectWithCurrentClipRect)
		{
			PushClipRectNative(self, clipRectMin, clipRectMax, intersectWithCurrentClipRect ? (byte)1 : (byte)0);
		}

		public static void PushClipRect( ImDrawList* self,  Vector2 clipRectMin,  Vector2 clipRectMax)
		{
			PushClipRectNative(self, clipRectMin, clipRectMax, (byte)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_PushClipRectFullScreen")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushClipRectFullScreenNative(ImDrawList* self);

		public static void PushClipRectFullScreen( ImDrawList* self)
		{
			PushClipRectFullScreenNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_PopClipRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopClipRectNative(ImDrawList* self);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_PushTextureID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PushTextureIDNative(ImDrawList* self, ImTextureID textureId);

		public static void PushTextureID( ImDrawList* self,  ImTextureID textureId)
		{
			PushTextureIDNative(self, textureId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_PopTextureID")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PopTextureIDNative(ImDrawList* self);

		public static void PopTextureID( ImDrawList* self)
		{
			PopTextureIDNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_GetClipRectMin")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetClipRectMinNative(Vector2* pOut, ImDrawList* self);

		public static void GetClipRectMin( Vector2* pOut,  ImDrawList* self)
		{
			GetClipRectMinNative(pOut, self);
		}

		public static void GetClipRectMin( Vector2* pOut,  ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				GetClipRectMinNative(pOut, (ImDrawList*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_GetClipRectMax")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void GetClipRectMaxNative(Vector2* pOut, ImDrawList* self);

		public static void GetClipRectMax( Vector2* pOut,  ImDrawList* self)
		{
			GetClipRectMaxNative(pOut, self);
		}

		public static void GetClipRectMax( Vector2* pOut,  ref ImDrawList self)
		{
			fixed (ImDrawList* pself = &self)
			{
				GetClipRectMaxNative(pOut, (ImDrawList*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_AddLine")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddLineNative(ImDrawList* self, Vector2 p1, Vector2 p2, uint col, float thickness);

		public static void AddLine( ImDrawList* self,  Vector2 p1,  Vector2 p2,  uint col,  float thickness)
		{
			AddLineNative(self, p1, p2, col, thickness);
		}

		public static void AddLine( ImDrawList* self,  Vector2 p1,  Vector2 p2,  uint col)
		{
			AddLineNative(self, p1, p2, col, (float)(1.0f));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "ImDrawList_AddRect")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void AddRectNative(ImDrawList* self, Vector2 pMin, Vector2 pMax, uint col, float rounding, int flags, float thickness);

		public static void AddRect( ImDrawList* self,  Vector2 pMin,  Vector2 pMax,  uint col,  float rounding,  int flags,  float thickness)
		{
			AddRectNative(self, pMin, pMax, col, rounding, flags, thickness);
		}
	}
}
