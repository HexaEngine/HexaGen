// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		public static bool InputFloat4( byte* label,  ref float v,  int flags)
		{
			fixed (float* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool InputFloat4( byte* label,  ref Vector4 v,  byte* format,  int flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte ret = InputFloat4Native(label, (float*)pv, format, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat4( byte* label,  ref Vector4 v,  byte* format)
		{
			fixed (Vector4* pv = &v)
			{
				byte ret = InputFloat4Native(label, (float*)pv, format, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat4( byte* label,  ref Vector4 v)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, (string)"%.3f", (int)(0));
				return ret;
			}
		}

		public static bool InputFloat4( byte* label,  ref Vector4 v,  int flags)
		{
			fixed (Vector4* pv = &v)
			{
				bool ret = InputFloat4(label, (float*)pv, (string)"%.3f", flags);
				return ret;
			}
		}

		public static bool InputFloat4( byte* label,  float* v,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloat4Native(label, v, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputFloat4( byte* label,  float* v,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputFloat4Native(label, v, (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputFloat4( byte* label,  float* v,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat4Native(label, v, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat4( byte* label,  float* v,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputFloat4Native(label, v, pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputFloat4( byte* label,  ref float v,  ref byte format,  int flags)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat4Native(label, (float*)pv, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputFloat4( byte* label,  ref float v,  ref byte format)
		{
			fixed (float* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputFloat4Native(label, (float*)pv, (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputFloat4( byte* label,  ref Vector4 v,  string format,  int flags)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloat4Native(label, (float*)pv, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputFloat4( byte* label,  ref Vector4 v,  string format)
		{
			fixed (Vector4* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputFloat4Native(label, (float*)pv, pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igInputInt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte InputIntNative(byte* label, int* v, int step, int stepFast, int flags);

		public static bool InputInt( byte* label,  int* v,  int step,  int stepFast,  int flags)
		{
			byte ret = InputIntNative(label, v, step, stepFast, flags);
			return ret != 0;
		}

		public static bool InputInt( byte* label,  int* v,  int step,  int stepFast)
		{
			byte ret = InputIntNative(label, v, step, stepFast, (int)(0));
			return ret != 0;
		}

		public static bool InputInt( byte* label,  int* v,  int step)
		{
			byte ret = InputIntNative(label, v, step, (int)(100), (int)(0));
			return ret != 0;
		}

		public static bool InputInt( byte* label,  int* v)
		{
			byte ret = InputIntNative(label, v, (int)(1), (int)(100), (int)(0));
			return ret != 0;
		}

		public static bool InputInt( byte* label,  ref int v,  int step,  int stepFast,  int flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(label, (int*)pv, step, stepFast, flags);
				return ret != 0;
			}
		}

		public static bool InputInt( byte* label,  ref int v,  int step,  int stepFast)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(label, (int*)pv, step, stepFast, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputInt( byte* label,  ref int v,  int step)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(label, (int*)pv, step, (int)(100), (int)(0));
				return ret != 0;
			}
		}

		public static bool InputInt( byte* label,  ref int v)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputIntNative(label, (int*)pv, (int)(1), (int)(100), (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igInputInt2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte InputInt2Native(byte* label, int* v, int flags);

		public static bool InputInt2( byte* label,  int* v,  int flags)
		{
			byte ret = InputInt2Native(label, v, flags);
			return ret != 0;
		}

		public static bool InputInt2( byte* label,  int* v)
		{
			byte ret = InputInt2Native(label, v, (int)(0));
			return ret != 0;
		}

		public static bool InputInt2( byte* label,  ref int v,  int flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt2Native(label, (int*)pv, flags);
				return ret != 0;
			}
		}

		public static bool InputInt2( byte* label,  ref int v)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt2Native(label, (int*)pv, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igInputInt3")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte InputInt3Native(byte* label, int* v, int flags);

		public static bool InputInt3( byte* label,  int* v,  int flags)
		{
			byte ret = InputInt3Native(label, v, flags);
			return ret != 0;
		}

		public static bool InputInt3( byte* label,  int* v)
		{
			byte ret = InputInt3Native(label, v, (int)(0));
			return ret != 0;
		}

		public static bool InputInt3( byte* label,  ref int v,  int flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt3Native(label, (int*)pv, flags);
				return ret != 0;
			}
		}

		public static bool InputInt3( byte* label,  ref int v)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt3Native(label, (int*)pv, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igInputInt4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte InputInt4Native(byte* label, int* v, int flags);

		public static bool InputInt4( byte* label,  int* v,  int flags)
		{
			byte ret = InputInt4Native(label, v, flags);
			return ret != 0;
		}

		public static bool InputInt4( byte* label,  int* v)
		{
			byte ret = InputInt4Native(label, v, (int)(0));
			return ret != 0;
		}

		public static bool InputInt4( byte* label,  ref int v,  int flags)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt4Native(label, (int*)pv, flags);
				return ret != 0;
			}
		}

		public static bool InputInt4( byte* label,  ref int v)
		{
			fixed (int* pv = &v)
			{
				byte ret = InputInt4Native(label, (int*)pv, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igInputDouble")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte InputDoubleNative(byte* label, double* v, double step, double stepFast, byte* format, int flags);

		public static bool InputDouble( byte* label,  double* v,  double step,  double stepFast,  byte* format,  int flags)
		{
			byte ret = InputDoubleNative(label, v, step, stepFast, format, flags);
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  double stepFast,  byte* format)
		{
			byte ret = InputDoubleNative(label, v, step, stepFast, format, (int)(0));
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  double stepFast)
		{
			bool ret = InputDouble(label, v, step, stepFast, (string)"%.6f", (int)(0));
			return ret;
		}

		public static bool InputDouble( byte* label,  double* v,  double step)
		{
			bool ret = InputDouble(label, v, step, (double)(0.0), (string)"%.6f", (int)(0));
			return ret;
		}

		public static bool InputDouble( byte* label,  double* v)
		{
			bool ret = InputDouble(label, v, (double)(0.0), (double)(0.0), (string)"%.6f", (int)(0));
			return ret;
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  byte* format)
		{
			byte ret = InputDoubleNative(label, v, step, (double)(0.0), format, (int)(0));
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  byte* format)
		{
			byte ret = InputDoubleNative(label, v, (double)(0.0), (double)(0.0), format, (int)(0));
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  double stepFast,  int flags)
		{
			bool ret = InputDouble(label, v, step, stepFast, (string)"%.6f", flags);
			return ret;
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  int flags)
		{
			bool ret = InputDouble(label, v, step, (double)(0.0), (string)"%.6f", flags);
			return ret;
		}

		public static bool InputDouble( byte* label,  double* v,  int flags)
		{
			bool ret = InputDouble(label, v, (double)(0.0), (double)(0.0), (string)"%.6f", flags);
			return ret;
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  byte* format,  int flags)
		{
			byte ret = InputDoubleNative(label, v, step, (double)(0.0), format, flags);
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  byte* format,  int flags)
		{
			byte ret = InputDoubleNative(label, v, (double)(0.0), (double)(0.0), format, flags);
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  double stepFast,  byte* format,  int flags)
		{
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, format, flags);
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  double stepFast,  byte* format)
		{
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, format, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  double stepFast)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, stepFast, (string)"%.6f", (int)(0));
				return ret;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, (double)(0.0), (string)"%.6f", (int)(0));
				return ret;
			}
		}

		public static bool InputDouble( byte* label,  ref double v)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, (double)(0.0), (double)(0.0), (string)"%.6f", (int)(0));
				return ret;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  byte* format)
		{
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(label, (double*)pv, step, (double)(0.0), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  byte* format)
		{
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(label, (double*)pv, (double)(0.0), (double)(0.0), format, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  double stepFast,  int flags)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, stepFast, (string)"%.6f", flags);
				return ret;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  int flags)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, step, (double)(0.0), (string)"%.6f", flags);
				return ret;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  int flags)
		{
			fixed (double* pv = &v)
			{
				bool ret = InputDouble(label, (double*)pv, (double)(0.0), (double)(0.0), (string)"%.6f", flags);
				return ret;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  byte* format,  int flags)
		{
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(label, (double*)pv, step, (double)(0.0), format, flags);
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  byte* format,  int flags)
		{
			fixed (double* pv = &v)
			{
				byte ret = InputDoubleNative(label, (double*)pv, (double)(0.0), (double)(0.0), format, flags);
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  double stepFast,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputDoubleNative(label, v, step, stepFast, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  double stepFast,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputDoubleNative(label, v, step, stepFast, (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputDoubleNative(label, v, step, (double)(0.0), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  double* v,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputDoubleNative(label, v, (double)(0.0), (double)(0.0), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputDoubleNative(label, v, step, (double)(0.0), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  double* v,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputDoubleNative(label, v, (double)(0.0), (double)(0.0), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  double stepFast,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(label, v, step, stepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  double stepFast,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(label, v, step, stepFast, pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(label, v, step, (double)(0.0), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(label, v, (double)(0.0), (double)(0.0), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  double step,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(label, v, step, (double)(0.0), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  double* v,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputDoubleNative(label, v, (double)(0.0), (double)(0.0), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  double stepFast,  ref byte format,  int flags)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  double stepFast,  ref byte format)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  ref byte format)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative(label, (double*)pv, step, (double)(0.0), (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  ref byte format)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative(label, (double*)pv, (double)(0.0), (double)(0.0), (byte*)pformat, (int)(0));
					return ret != 0;
				}
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  ref byte format,  int flags)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative(label, (double*)pv, step, (double)(0.0), (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  ref byte format,  int flags)
		{
			fixed (double* pv = &v)
			{
				fixed (byte* pformat = &format)
				{
					byte ret = InputDoubleNative(label, (double*)pv, (double)(0.0), (double)(0.0), (byte*)pformat, flags);
					return ret != 0;
				}
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  double stepFast,  string format,  int flags)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  double stepFast,  string format)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputDoubleNative(label, (double*)pv, step, stepFast, pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  string format)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputDoubleNative(label, (double*)pv, step, (double)(0.0), pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  string format)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputDoubleNative(label, (double*)pv, (double)(0.0), (double)(0.0), pStr0, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  double step,  string format,  int flags)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputDoubleNative(label, (double*)pv, step, (double)(0.0), pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		public static bool InputDouble( byte* label,  ref double v,  string format,  int flags)
		{
			fixed (double* pv = &v)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (format != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(format);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = InputDoubleNative(label, (double*)pv, (double)(0.0), (double)(0.0), pStr0, flags);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igInputScalar")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte InputScalarNative(byte* label, int dataType, void* pData, void* pStep, void* pStepFast, byte* format, int flags);

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  void* pStepFast,  byte* format,  int flags)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, format, flags);
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  void* pStepFast,  byte* format)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, format, (int)(0));
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  void* pStepFast)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, (byte*)(default), (int)(0));
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, (void*)(default), (byte*)(default), (int)(0));
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData)
		{
			byte ret = InputScalarNative(label, dataType, pData, (void*)(default), (void*)(default), (byte*)(default), (int)(0));
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  byte* format)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, (void*)(default), format, (int)(0));
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  byte* format)
		{
			byte ret = InputScalarNative(label, dataType, pData, (void*)(default), (void*)(default), format, (int)(0));
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  void* pStepFast,  int flags)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, (byte*)(default), flags);
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  int flags)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, (void*)(default), (byte*)(default), flags);
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  int flags)
		{
			byte ret = InputScalarNative(label, dataType, pData, (void*)(default), (void*)(default), (byte*)(default), flags);
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  byte* format,  int flags)
		{
			byte ret = InputScalarNative(label, dataType, pData, pStep, (void*)(default), format, flags);
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  byte* format,  int flags)
		{
			byte ret = InputScalarNative(label, dataType, pData, (void*)(default), (void*)(default), format, flags);
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  void* pStepFast,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  void* pStepFast,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNative(label, dataType, pData, pStep, (void*)(default), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNative(label, dataType, pData, (void*)(default), (void*)(default), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNative(label, dataType, pData, pStep, (void*)(default), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNative(label, dataType, pData, (void*)(default), (void*)(default), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  void* pStepFast,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  void* pStepFast,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(label, dataType, pData, pStep, pStepFast, pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(label, dataType, pData, pStep, (void*)(default), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(label, dataType, pData, (void*)(default), (void*)(default), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  void* pStep,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(label, dataType, pData, pStep, (void*)(default), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalar( byte* label,  int dataType,  void* pData,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNative(label, dataType, pData, (void*)(default), (void*)(default), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igInputScalarN")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte InputScalarNNative(byte* label, int dataType, void* pData, int components, void* pStep, void* pStepFast, byte* format, int flags);

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  void* pStepFast,  byte* format,  int flags)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, format, flags);
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  void* pStepFast,  byte* format)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, format, (int)(0));
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  void* pStepFast)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, (byte*)(default), (int)(0));
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, (void*)(default), (byte*)(default), (int)(0));
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, (void*)(default), (void*)(default), (byte*)(default), (int)(0));
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  byte* format)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, (void*)(default), format, (int)(0));
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  byte* format)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, (void*)(default), (void*)(default), format, (int)(0));
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  void* pStepFast,  int flags)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, (byte*)(default), flags);
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  int flags)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, (void*)(default), (byte*)(default), flags);
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  int flags)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, (void*)(default), (void*)(default), (byte*)(default), flags);
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  byte* format,  int flags)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, (void*)(default), format, flags);
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  byte* format,  int flags)
		{
			byte ret = InputScalarNNative(label, dataType, pData, components, (void*)(default), (void*)(default), format, flags);
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  void* pStepFast,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  void* pStepFast,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNNative(label, dataType, pData, components, pStep, (void*)(default), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNNative(label, dataType, pData, components, (void*)(default), (void*)(default), (byte*)pformat, (int)(0));
				return ret != 0;
			}
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNNative(label, dataType, pData, components, pStep, (void*)(default), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  ref byte format,  int flags)
		{
			fixed (byte* pformat = &format)
			{
				byte ret = InputScalarNNative(label, dataType, pData, components, (void*)(default), (void*)(default), (byte*)pformat, flags);
				return ret != 0;
			}
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  void* pStepFast,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  void* pStepFast,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, pStepFast, pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, (void*)(default), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(label, dataType, pData, components, (void*)(default), (void*)(default), pStr0, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  void* pStep,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(label, dataType, pData, components, pStep, (void*)(default), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool InputScalarN( byte* label,  int dataType,  void* pData,  int components,  string format,  int flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = InputScalarNNative(label, dataType, pData, components, (void*)(default), (void*)(default), pStr0, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColorEdit3")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ColorEdit3Native(byte* label, float* col, int flags);

		public static bool ColorEdit3( byte* label,  float* col,  int flags)
		{
			byte ret = ColorEdit3Native(label, col, flags);
			return ret != 0;
		}

		public static bool ColorEdit3( byte* label,  float* col)
		{
			byte ret = ColorEdit3Native(label, col, (int)(0));
			return ret != 0;
		}

		public static bool ColorEdit3( byte* label,  ref float col,  int flags)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorEdit3Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit3( byte* label,  ref float col)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorEdit3Native(label, (float*)pcol, (int)(0));
				return ret != 0;
			}
		}

		public static bool ColorEdit3( byte* label,  ref Vector3 col,  int flags)
		{
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorEdit3Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit3( byte* label,  ref Vector3 col)
		{
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorEdit3Native(label, (float*)pcol, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColorEdit4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ColorEdit4Native(byte* label, float* col, int flags);

		public static bool ColorEdit4( byte* label,  float* col,  int flags)
		{
			byte ret = ColorEdit4Native(label, col, flags);
			return ret != 0;
		}

		public static bool ColorEdit4( byte* label,  float* col)
		{
			byte ret = ColorEdit4Native(label, col, (int)(0));
			return ret != 0;
		}

		public static bool ColorEdit4( byte* label,  ref float col,  int flags)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorEdit4Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit4( byte* label,  ref float col)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorEdit4Native(label, (float*)pcol, (int)(0));
				return ret != 0;
			}
		}

		public static bool ColorEdit4( byte* label,  ref Vector4 col,  int flags)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorEdit4Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorEdit4( byte* label,  ref Vector4 col)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorEdit4Native(label, (float*)pcol, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColorPicker3")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ColorPicker3Native(byte* label, float* col, int flags);

		public static bool ColorPicker3( byte* label,  float* col,  int flags)
		{
			byte ret = ColorPicker3Native(label, col, flags);
			return ret != 0;
		}

		public static bool ColorPicker3( byte* label,  float* col)
		{
			byte ret = ColorPicker3Native(label, col, (int)(0));
			return ret != 0;
		}

		public static bool ColorPicker3( byte* label,  ref float col,  int flags)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker3Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorPicker3( byte* label,  ref float col)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker3Native(label, (float*)pcol, (int)(0));
				return ret != 0;
			}
		}

		public static bool ColorPicker3( byte* label,  ref Vector3 col,  int flags)
		{
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorPicker3Native(label, (float*)pcol, flags);
				return ret != 0;
			}
		}

		public static bool ColorPicker3( byte* label,  ref Vector3 col)
		{
			fixed (Vector3* pcol = &col)
			{
				byte ret = ColorPicker3Native(label, (float*)pcol, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColorPicker4")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ColorPicker4Native(byte* label, float* col, int flags, float* refCol);

		public static bool ColorPicker4( byte* label,  float* col,  int flags,  float* refCol)
		{
			byte ret = ColorPicker4Native(label, col, flags, refCol);
			return ret != 0;
		}

		public static bool ColorPicker4( byte* label,  float* col,  int flags)
		{
			byte ret = ColorPicker4Native(label, col, flags, (float*)(default));
			return ret != 0;
		}

		public static bool ColorPicker4( byte* label,  float* col)
		{
			byte ret = ColorPicker4Native(label, col, (int)(0), (float*)(default));
			return ret != 0;
		}

		public static bool ColorPicker4( byte* label,  float* col,  float* refCol)
		{
			byte ret = ColorPicker4Native(label, col, (int)(0), refCol);
			return ret != 0;
		}

		public static bool ColorPicker4( byte* label,  ref float col,  int flags,  float* refCol)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, refCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  ref float col,  int flags)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  ref float col)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (int)(0), (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  ref float col,  float* refCol)
		{
			fixed (float* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (int)(0), refCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  ref Vector4 col,  int flags,  float* refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, refCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  ref Vector4 col,  int flags)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  ref Vector4 col)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (int)(0), (float*)(default));
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  ref Vector4 col,  float* refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				byte ret = ColorPicker4Native(label, (float*)pcol, (int)(0), refCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  float* col,  int flags,  ref float refCol)
		{
			fixed (float* prefCol = &refCol)
			{
				byte ret = ColorPicker4Native(label, col, flags, (float*)prefCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  float* col,  ref float refCol)
		{
			fixed (float* prefCol = &refCol)
			{
				byte ret = ColorPicker4Native(label, col, (int)(0), (float*)prefCol);
				return ret != 0;
			}
		}

		public static bool ColorPicker4( byte* label,  ref float col,  int flags,  ref float refCol)
		{
			fixed (float* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker4( byte* label,  ref float col,  ref float refCol)
		{
			fixed (float* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, (int)(0), (float*)prefCol);
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker4( byte* label,  ref Vector4 col,  int flags,  ref float refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, flags, (float*)prefCol);
					return ret != 0;
				}
			}
		}

		public static bool ColorPicker4( byte* label,  ref Vector4 col,  ref float refCol)
		{
			fixed (Vector4* pcol = &col)
			{
				fixed (float* prefCol = &refCol)
				{
					byte ret = ColorPicker4Native(label, (float*)pcol, (int)(0), (float*)prefCol);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igColorButton")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ColorButtonNative(byte* descId, Vector4 col, int flags, Vector2 size);

		public static bool ColorButton( byte* descId,  Vector4 col,  int flags,  Vector2 size)
		{
			byte ret = ColorButtonNative(descId, col, flags, size);
			return ret != 0;
		}

		public static bool ColorButton( byte* descId,  Vector4 col,  int flags)
		{
			byte ret = ColorButtonNative(descId, col, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool ColorButton( byte* descId,  Vector4 col)
		{
			byte ret = ColorButtonNative(descId, col, (int)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool ColorButton( byte* descId,  Vector4 col,  Vector2 size)
		{
			byte ret = ColorButtonNative(descId, col, (int)(0), size);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetColorEditOptions")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetColorEditOptionsNative(int flags);

		public static void SetColorEditOptions( int flags)
		{
			SetColorEditOptionsNative(flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNode_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeNative(byte* label);

		public static bool TreeNode( byte* label)
		{
			byte ret = TreeNodeNative(label);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNode_StrStr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeNative(byte* strId, byte* fmt);

		public static bool TreeNode( byte* strId,  byte* fmt)
		{
			byte ret = TreeNodeNative(strId, fmt);
			return ret != 0;
		}

		public static bool TreeNode( byte* strId,  ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeNative(strId, (byte*)pfmt);
				return ret != 0;
			}
		}

		public static bool TreeNode( byte* strId,  string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeNative(strId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNode_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeNative(void* ptrId, byte* fmt);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNodeV_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeVNative(byte* strId, byte* fmt, nuint args);

		public static bool TreeNodeV( byte* strId,  byte* fmt,  nuint args)
		{
			byte ret = TreeNodeVNative(strId, fmt, args);
			return ret != 0;
		}

		public static bool TreeNodeV( byte* strId,  ref byte fmt,  nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeVNative(strId, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		public static bool TreeNodeV( byte* strId,  string fmt,  nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeVNative(strId, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNodeV_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeVNative(void* ptrId, byte* fmt, nuint args);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNodeEx_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeExNative(byte* label, int flags);

		public static bool TreeNodeEx( byte* label,  int flags)
		{
			byte ret = TreeNodeExNative(label, flags);
			return ret != 0;
		}

		public static bool TreeNodeEx( byte* label)
		{
			byte ret = TreeNodeExNative(label, (int)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNodeEx_StrStr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeExNative(byte* strId, int flags, byte* fmt);

		public static bool TreeNodeEx( byte* strId,  int flags,  byte* fmt)
		{
			byte ret = TreeNodeExNative(strId, flags, fmt);
			return ret != 0;
		}

		public static bool TreeNodeEx( byte* strId,  int flags,  ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExNative(strId, flags, (byte*)pfmt);
				return ret != 0;
			}
		}

		public static bool TreeNodeEx( byte* strId,  int flags,  string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExNative(strId, flags, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNodeEx_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeExNative(void* ptrId, int flags, byte* fmt);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNodeExV_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeExVNative(byte* strId, int flags, byte* fmt, nuint args);

		public static bool TreeNodeExV( byte* strId,  int flags,  byte* fmt,  nuint args)
		{
			byte ret = TreeNodeExVNative(strId, flags, fmt, args);
			return ret != 0;
		}

		public static bool TreeNodeExV( byte* strId,  int flags,  ref byte fmt,  nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				byte ret = TreeNodeExVNative(strId, flags, (byte*)pfmt, args);
				return ret != 0;
			}
		}

		public static bool TreeNodeExV( byte* strId,  int flags,  string fmt,  nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = TreeNodeExVNative(strId, flags, pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreeNodeExV_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte TreeNodeExVNative(void* ptrId, int flags, byte* fmt, nuint args);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreePush_Str")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TreePushNative(byte* strId);

		public static void TreePush( byte* strId)
		{
			TreePushNative(strId);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreePush_Ptr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TreePushNative(void* ptrId);

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igTreePop")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void TreePopNative();

		public static void TreePop()
		{
			TreePopNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igGetTreeNodeToLabelSpacing")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial float GetTreeNodeToLabelSpacingNative();

		public static float GetTreeNodeToLabelSpacing()
		{
			float ret = GetTreeNodeToLabelSpacingNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCollapsingHeader_TreeNodeFlags")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte CollapsingHeaderNative(byte* label, int flags);

		public static bool CollapsingHeader( byte* label,  int flags)
		{
			byte ret = CollapsingHeaderNative(label, flags);
			return ret != 0;
		}

		public static bool CollapsingHeader( byte* label)
		{
			byte ret = CollapsingHeaderNative(label, (int)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igCollapsingHeader_BoolPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte CollapsingHeaderNative(byte* label, byte* pVisible, int flags);

		public static bool CollapsingHeader( byte* label,  byte* pVisible,  int flags)
		{
			byte ret = CollapsingHeaderNative(label, pVisible, flags);
			return ret != 0;
		}

		public static bool CollapsingHeader( byte* label,  byte* pVisible)
		{
			byte ret = CollapsingHeaderNative(label, pVisible, (int)(0));
			return ret != 0;
		}

		public static bool CollapsingHeader( byte* label,  ref byte pVisible,  int flags)
		{
			fixed (byte* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(label, (byte*)ppVisible, flags);
				return ret != 0;
			}
		}

		public static bool CollapsingHeader( byte* label,  ref byte pVisible)
		{
			fixed (byte* ppVisible = &pVisible)
			{
				byte ret = CollapsingHeaderNative(label, (byte*)ppVisible, (int)(0));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSetNextItemOpen")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void SetNextItemOpenNative(byte isOpen, int cond);

		public static void SetNextItemOpen( bool isOpen,  int cond)
		{
			SetNextItemOpenNative(isOpen ? (byte)1 : (byte)0, cond);
		}

		public static void SetNextItemOpen( bool isOpen)
		{
			SetNextItemOpenNative(isOpen ? (byte)1 : (byte)0, (int)(0));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSelectable_Bool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte SelectableNative(byte* label, byte selected, int flags, Vector2 size);

		public static bool Selectable( byte* label,  bool selected,  int flags,  Vector2 size)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, flags, size);
			return ret != 0;
		}

		public static bool Selectable( byte* label,  bool selected,  int flags)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable( byte* label,  bool selected)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, (int)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable( byte* label)
		{
			byte ret = SelectableNative(label, (byte)(0), (int)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable( byte* label,  int flags)
		{
			byte ret = SelectableNative(label, (byte)(0), flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable( byte* label,  bool selected,  Vector2 size)
		{
			byte ret = SelectableNative(label, selected ? (byte)1 : (byte)0, (int)(0), size);
			return ret != 0;
		}

		public static bool Selectable( byte* label,  Vector2 size)
		{
			byte ret = SelectableNative(label, (byte)(0), (int)(0), size);
			return ret != 0;
		}

		public static bool Selectable( byte* label,  int flags,  Vector2 size)
		{
			byte ret = SelectableNative(label, (byte)(0), flags, size);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igSelectable_BoolPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte SelectableNative(byte* label, byte* pSelected, int flags, Vector2 size);

		public static bool Selectable( byte* label,  byte* pSelected,  int flags,  Vector2 size)
		{
			byte ret = SelectableNative(label, pSelected, flags, size);
			return ret != 0;
		}

		public static bool Selectable( byte* label,  byte* pSelected,  int flags)
		{
			byte ret = SelectableNative(label, pSelected, flags, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable( byte* label,  byte* pSelected)
		{
			byte ret = SelectableNative(label, pSelected, (int)(0), (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		public static bool Selectable( byte* label,  byte* pSelected,  Vector2 size)
		{
			byte ret = SelectableNative(label, pSelected, (int)(0), size);
			return ret != 0;
		}

		public static bool Selectable( byte* label,  ref byte pSelected,  int flags,  Vector2 size)
		{
			fixed (byte* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (byte*)ppSelected, flags, size);
				return ret != 0;
			}
		}

		public static bool Selectable( byte* label,  ref byte pSelected,  int flags)
		{
			fixed (byte* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (byte*)ppSelected, flags, (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Selectable( byte* label,  ref byte pSelected)
		{
			fixed (byte* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (byte*)ppSelected, (int)(0), (Vector2)(new Vector2(0,0)));
				return ret != 0;
			}
		}

		public static bool Selectable( byte* label,  ref byte pSelected,  Vector2 size)
		{
			fixed (byte* ppSelected = &pSelected)
			{
				byte ret = SelectableNative(label, (byte*)ppSelected, (int)(0), size);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igBeginListBox")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte BeginListBoxNative(byte* label, Vector2 size);

		public static bool BeginListBox( byte* label,  Vector2 size)
		{
			byte ret = BeginListBoxNative(label, size);
			return ret != 0;
		}

		public static bool BeginListBox( byte* label)
		{
			byte ret = BeginListBoxNative(label, (Vector2)(new Vector2(0,0)));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igEndListBox")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void EndListBoxNative();

		public static void EndListBox()
		{
			EndListBoxNative();
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igListBox_Str_arr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ListBoxNative(byte* label, int* currentItem, byte** items, int itemsCount, int heightInItems);

		public static bool ListBox( byte* label,  int* currentItem,  byte** items,  int itemsCount,  int heightInItems)
		{
			byte ret = ListBoxNative(label, currentItem, items, itemsCount, heightInItems);
			return ret != 0;
		}

		public static bool ListBox( byte* label,  int* currentItem,  byte** items,  int itemsCount)
		{
			byte ret = ListBoxNative(label, currentItem, items, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool ListBox( byte* label,  ref int currentItem,  byte** items,  int itemsCount,  int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, items, itemsCount, heightInItems);
				return ret != 0;
			}
		}

		public static bool ListBox( byte* label,  ref int currentItem,  byte** items,  int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, items, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool ListBox( byte* label,  int* currentItem,  string[] items,  int itemsCount,  int heightInItems)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ListBoxNative(label, currentItem, pStrArray0, itemsCount, heightInItems);
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}

		public static bool ListBox( byte* label,  int* currentItem,  string[] items,  int itemsCount)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(items);
			if (items != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < items.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
			}
			byte ret = ListBoxNative(label, currentItem, pStrArray0, itemsCount, (int)(-1));
			for (int i = 0; i < items.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret != 0;
		}

		public static bool ListBox( byte* label,  ref int currentItem,  string[] items,  int itemsCount,  int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ListBoxNative(label, (int*)pcurrentItem, pStrArray0, itemsCount, heightInItems);
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}

		public static bool ListBox( byte* label,  ref int currentItem,  string[] items,  int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte** pStrArray0 = null;
				int pStrArraySize0 = Utils.GetByteCountArray(items);
				if (items != null)
				{
					if (pStrArraySize0 > Utils.MaxStackallocSize)
					{
						pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
					}
					else
					{
						byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
						pStrArray0 = (byte**)pStrArrayStack0;
					}
				}
				for (int i = 0; i < items.Length; i++)
				{
					pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(items[i]);
				}
				byte ret = ListBoxNative(label, (int*)pcurrentItem, pStrArray0, itemsCount, (int)(-1));
				for (int i = 0; i < items.Length; i++)
				{
					Utils.Free(pStrArray0[i]);
				}
				if (pStrArraySize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStrArray0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igListBox_FnStrPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial byte ListBoxNative(byte* label, int* currentItem, delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter, void* userData, int itemsCount, int heightInItems);

		public static bool ListBox( byte* label,  int* currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter,  void* userData,  int itemsCount,  int heightInItems)
		{
			byte ret = ListBoxNative(label, currentItem, getter, userData, itemsCount, heightInItems);
			return ret != 0;
		}

		public static bool ListBox( byte* label,  int* currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter,  void* userData,  int itemsCount)
		{
			byte ret = ListBoxNative(label, currentItem, getter, userData, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool ListBox( byte* label,  ref int currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter,  void* userData,  int itemsCount,  int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, getter, userData, itemsCount, heightInItems);
				return ret != 0;
			}
		}

		public static bool ListBox( byte* label,  ref int currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, byte*> getter,  void* userData,  int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, getter, userData, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		public static bool ListBox( byte* label,  int* currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, ref byte> getter,  void* userData,  int itemsCount,  int heightInItems)
		{
			byte ret = ListBoxNative(label, currentItem, getter, userData, itemsCount, heightInItems);
			return ret != 0;
		}

		public static bool ListBox( byte* label,  int* currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, ref byte> getter,  void* userData,  int itemsCount)
		{
			byte ret = ListBoxNative(label, currentItem, getter, userData, itemsCount, (int)(-1));
			return ret != 0;
		}

		public static bool ListBox( byte* label,  ref int currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, ref byte> getter,  void* userData,  int itemsCount,  int heightInItems)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, getter, userData, itemsCount, heightInItems);
				return ret != 0;
			}
		}

		public static bool ListBox( byte* label,  ref int currentItem,  delegate*<byte*, int*, delegate*<void*, int, byte*>, void*, int, int, ref byte> getter,  void* userData,  int itemsCount)
		{
			fixed (int* pcurrentItem = &currentItem)
			{
				byte ret = ListBoxNative(label, (int*)pcurrentItem, getter, userData, itemsCount, (int)(-1));
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[LibraryImport(LibName, EntryPoint = "igPlotLines_FloatPtr")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void PlotLinesNative(byte* label, float* values, int valuesCount, int valuesOffset, byte* overlayText, float scaleMin, float scaleMax, Vector2 graphSize, int stride);

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  float scaleMin)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  float scaleMin,  float scaleMax)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  float scaleMin,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  float scaleMin,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  float scaleMin,  float scaleMax,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			PlotLinesNative(label, values, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize, stride);
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  byte* overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)(default), scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)(default), scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  byte* overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), overlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (byte* poverlayText = &overlayText)
			{
				PlotLinesNative(label, values, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  float* values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (overlayText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(overlayText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PlotLinesNative(label, values, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize, stride);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  ref byte overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, (float)(float.MaxValue), graphSize, stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  ref byte overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				fixed (byte* poverlayText = &overlayText)
				{
					PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), (byte*)poverlayText, scaleMin, scaleMax, graphSize, stride);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  Vector2 graphSize)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, graphSize, (int)(sizeof(float)));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  int valuesOffset,  string overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, valuesOffset, pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, (float)(float.MaxValue), (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, (float)(float.MaxValue), (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public static void PlotLines( byte* label,  ref float values,  int valuesCount,  string overlayText,  float scaleMin,  float scaleMax,  int stride)
		{
			fixed (float* pvalues = &values)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (overlayText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(overlayText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(overlayText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				PlotLinesNative(label, (float*)pvalues, valuesCount, (int)(0), pStr0, scaleMin, scaleMax, (Vector2)(new Vector2(0,0)), stride);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}
	}
}
