// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImDrawChannel
	{


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void AddGlyph( ImFontConfig* srcCfg,  char c,  float x0,  float y0,  float x1,  float y1,  float u0,  float v0,  float u1,  float v1,  float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddGlyphNative(@this, srcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
			}
		}

		public unsafe void AddGlyph( ref ImFontConfig srcCfg,  char c,  float x0,  float y0,  float x1,  float y1,  float u0,  float v0,  float u1,  float v1,  float advanceX)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImFontConfig* psrcCfg = &srcCfg)
				{
					ImGui.AddGlyphNative(@this, (ImFontConfig*)psrcCfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advanceX);
				}
			}
		}

		public unsafe void AddRemapChar( char dst,  char src,  bool overwriteDst)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddRemapCharNative(@this, dst, src, overwriteDst ? (byte)1 : (byte)0);
			}
		}

		public unsafe void AddRemapChar( char dst,  char src)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.AddRemapCharNative(@this, dst, src, (byte)(1));
			}
		}

		public unsafe void BuildLookupTable()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.BuildLookupTableNative(@this);
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  byte* text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, textEnd, wrapWidth);
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  byte* text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, textEnd, wrapWidth));
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  ref byte text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, textEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  ref byte text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, textEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  string text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, textEnd, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  string text,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, textEnd, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  byte* text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, (byte*)ptextEnd, wrapWidth);
					return ret;
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  byte* text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, (byte*)ptextEnd, wrapWidth));
					return ret;
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  byte* text,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, text, pStr0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  byte* text,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, text, pStr0, wrapWidth));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  ref byte text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth);
						return ret;
					}
				}
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  ref byte text,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, (byte*)ptext, (byte*)ptextEnd, wrapWidth));
						return ret;
					}
				}
			}
		}

		public unsafe byte* CalcWordWrapPositionA( float scale,  string text,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				byte* ret = ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, pStr1, wrapWidth);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe string CalcWordWrapPositionAS( float scale,  string text,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImGui.CalcWordWrapPositionANative(@this, scale, pStr0, pStr1, wrapWidth));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe void ClearOutputData()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.ClearOutputDataNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImFontGlyph* FindGlyph( char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyphNative(@this, c);
				return ret;
			}
		}

		public unsafe ImFontGlyph* FindGlyphNoFallback( char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImFontGlyph* ret = ImGui.FindGlyphNoFallbackNative(@this, c);
				return ret;
			}
		}

		public unsafe float GetCharAdvance( char c)
		{
			fixed (ImFont* @this = &this)
			{
				float ret = ImGui.GetCharAdvanceNative(@this, c);
				return ret;
			}
		}

		public unsafe byte* GetDebugName()
		{
			fixed (ImFont* @this = &this)
			{
				byte* ret = ImGui.GetDebugNameNative(@this);
				return ret;
			}
		}

		public unsafe string GetDebugNameS()
		{
			fixed (ImFont* @this = &this)
			{
				string ret = Utils.DecodeStringUTF8(ImGui.GetDebugNameNative(@this));
				return ret;
			}
		}

		public unsafe void GrowIndex( int newSize)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.GrowIndexNative(@this, newSize);
			}
		}

		public unsafe bool IsGlyphRangeUnused( uint cBegin,  uint cLast)
		{
			fixed (ImFont* @this = &this)
			{
				byte ret = ImGui.IsGlyphRangeUnusedNative(@this, cBegin, cLast);
				return ret != 0;
			}
		}

		public unsafe bool IsLoaded()
		{
			fixed (ImFont* @this = &this)
			{
				byte ret = ImGui.IsLoadedNative(@this);
				return ret != 0;
			}
		}

		public unsafe void RenderChar( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  char c)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderCharNative(@this, drawList, size, pos, col, c);
			}
		}

		public unsafe void RenderChar( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  char c)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderCharNative(@this, (ImDrawList*)pdrawList, size, pos, col, c);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  byte* textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, textEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, wrapWidth, (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), (byte)(0));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  byte* textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, textBegin, pStr0, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (byte* ptextBegin = &textBegin)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					}
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ImDrawList* drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textBegin != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textBegin);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (textEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				ImGui.RenderTextNative(@this, drawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, wrapWidth, (byte)(0));
						}
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), (byte)(0));
						}
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  ref byte textBegin,  ref byte textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					fixed (byte* ptextBegin = &textBegin)
					{
						fixed (byte* ptextEnd = &textEnd)
						{
							ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, (byte*)ptextBegin, (byte*)ptextEnd, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
						}
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  float wrapWidth)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, wrapWidth, (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), (byte)(0));
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void RenderText( ref ImDrawList drawList,  float size,  Vector2 pos,  uint col,  Vector4 clipRect,  string textBegin,  string textEnd,  bool cpuFineClip)
		{
			fixed (ImFont* @this = &this)
			{
				fixed (ImDrawList* pdrawList = &drawList)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (textBegin != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(textBegin);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(textBegin, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					byte* pStr1 = null;
					int pStrSize1 = 0;
					if (textEnd != null)
					{
						pStrSize1 = Utils.GetByteCountUTF8(textEnd);
						if (pStrSize1 >= Utils.MaxStackallocSize)
						{
							pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
						}
						else
						{
							byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
							pStr1 = pStrStack1;
						}
						int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
						pStr1[pStrOffset1] = 0;
					}
					ImGui.RenderTextNative(@this, (ImDrawList*)pdrawList, size, pos, col, clipRect, pStr0, pStr1, (float)(0.0f), cpuFineClip ? (byte)1 : (byte)0);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr1);
					}
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		public unsafe void SetGlyphVisible( char c,  bool visible)
		{
			fixed (ImFont* @this = &this)
			{
				ImGui.SetGlyphVisibleNative(@this, c, visible ? (byte)1 : (byte)0);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorFloat
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe float* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorFloat(int size = default, int capacity = default, float* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImWchar
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ushort* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImWchar(int size = default, int capacity = default, ushort* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontGlyph
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontGlyph* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImFontGlyph(int size = default, int capacity = default, ImFontGlyph* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontGlyph
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Colored;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Visible;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint Codepoint;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float AdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float X0;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Y0;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float X1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float Y1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float U0;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float V0;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float U1;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float V1;


		/// <summary>/// To be documented./// </summary>		public unsafe ImFontGlyph(uint colored = default, uint visible = default, uint codepoint = default, float advanceX = default, float x0 = default, float y0 = default, float x1 = default, float y1 = default, float u0 = default, float v0 = default, float u1 = default, float v1 = default)
		{
			Colored = colored;
			Visible = visible;
			Codepoint = codepoint;
			AdvanceX = advanceX;
			X0 = x0;
			Y0 = y0;
			X1 = x1;
			Y1 = y1;
			U0 = u0;
			V0 = v0;
			U1 = u1;
			V1 = v1;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlas
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Flags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* TexID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TexDesiredWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TexGlyphPadding;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte Locked;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe void* UserData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte TexReady;

		/// <summary>
		/// To be documented.
		/// </summary>
		public byte TexPixelsUseColors;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe byte* TexPixelsAlpha8;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe uint* TexPixelsRGBA32;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TexWidth;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int TexHeight;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 TexUvScale;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 TexUvWhitePixel;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImFontPtr Fonts;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImFontAtlasCustomRect CustomRects;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ImVectorImFontConfig ConfigData;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector4 TexUvLines_0;
		public Vector4 TexUvLines_1;
		public Vector4 TexUvLines_2;
		public Vector4 TexUvLines_3;
		public Vector4 TexUvLines_4;
		public Vector4 TexUvLines_5;
		public Vector4 TexUvLines_6;
		public Vector4 TexUvLines_7;
		public Vector4 TexUvLines_8;
		public Vector4 TexUvLines_9;
		public Vector4 TexUvLines_10;
		public Vector4 TexUvLines_11;
		public Vector4 TexUvLines_12;
		public Vector4 TexUvLines_13;
		public Vector4 TexUvLines_14;
		public Vector4 TexUvLines_15;
		public Vector4 TexUvLines_16;
		public Vector4 TexUvLines_17;
		public Vector4 TexUvLines_18;
		public Vector4 TexUvLines_19;
		public Vector4 TexUvLines_20;
		public Vector4 TexUvLines_21;
		public Vector4 TexUvLines_22;
		public Vector4 TexUvLines_23;
		public Vector4 TexUvLines_24;
		public Vector4 TexUvLines_25;
		public Vector4 TexUvLines_26;
		public Vector4 TexUvLines_27;
		public Vector4 TexUvLines_28;
		public Vector4 TexUvLines_29;
		public Vector4 TexUvLines_30;
		public Vector4 TexUvLines_31;
		public Vector4 TexUvLines_32;
		public Vector4 TexUvLines_33;
		public Vector4 TexUvLines_34;
		public Vector4 TexUvLines_35;
		public Vector4 TexUvLines_36;
		public Vector4 TexUvLines_37;
		public Vector4 TexUvLines_38;
		public Vector4 TexUvLines_39;
		public Vector4 TexUvLines_40;
		public Vector4 TexUvLines_41;
		public Vector4 TexUvLines_42;
		public Vector4 TexUvLines_43;
		public Vector4 TexUvLines_44;
		public Vector4 TexUvLines_45;
		public Vector4 TexUvLines_46;
		public Vector4 TexUvLines_47;
		public Vector4 TexUvLines_48;
		public Vector4 TexUvLines_49;
		public Vector4 TexUvLines_50;
		public Vector4 TexUvLines_51;
		public Vector4 TexUvLines_52;
		public Vector4 TexUvLines_53;
		public Vector4 TexUvLines_54;
		public Vector4 TexUvLines_55;
		public Vector4 TexUvLines_56;
		public Vector4 TexUvLines_57;
		public Vector4 TexUvLines_58;
		public Vector4 TexUvLines_59;
		public Vector4 TexUvLines_60;
		public Vector4 TexUvLines_61;
		public Vector4 TexUvLines_62;
		public Vector4 TexUvLines_63;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontBuilderIO* FontBuilderIO;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint FontBuilderFlags;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int PackIdMouseCursors;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int PackIdLines;



		/// <summary>/// To be documented./// </summary>		public unsafe ImFontAtlas(int flags = default, void* texId = default, int texDesiredWidth = default, int texGlyphPadding = default, bool locked = default, void* userData = default, bool texReady = default, bool texPixelsUseColors = default, byte* texPixelsAlpha8 = default, uint* texPixelsRgba32 = default, int texWidth = default, int texHeight = default, Vector2 texUvScale = default, Vector2 texUvWhitePixel = default, ImVectorImFontPtr fonts = default, ImVectorImFontAtlasCustomRect customRects = default, ImVectorImFontConfig configData = default, Vector4* texUvLines = default, ImFontBuilderIO* fontBuilderIo = default, uint fontBuilderFlags = default, int packIdMouseCursors = default, int packIdLines = default)
		{
			Flags = flags;
			TexID = texId;
			TexDesiredWidth = texDesiredWidth;
			TexGlyphPadding = texGlyphPadding;
			Locked = locked ? (byte)1 : (byte)0;
			UserData = userData;
			TexReady = texReady ? (byte)1 : (byte)0;
			TexPixelsUseColors = texPixelsUseColors ? (byte)1 : (byte)0;
			TexPixelsAlpha8 = texPixelsAlpha8;
			TexPixelsRGBA32 = texPixelsRgba32;
			TexWidth = texWidth;
			TexHeight = texHeight;
			TexUvScale = texUvScale;
			TexUvWhitePixel = texUvWhitePixel;
			Fonts = fonts;
			CustomRects = customRects;
			ConfigData = configData;
			if (texUvLines != default)
			{
				TexUvLines_0 = texUvLines[0];
				TexUvLines_1 = texUvLines[1];
				TexUvLines_2 = texUvLines[2];
				TexUvLines_3 = texUvLines[3];
				TexUvLines_4 = texUvLines[4];
				TexUvLines_5 = texUvLines[5];
				TexUvLines_6 = texUvLines[6];
				TexUvLines_7 = texUvLines[7];
				TexUvLines_8 = texUvLines[8];
				TexUvLines_9 = texUvLines[9];
				TexUvLines_10 = texUvLines[10];
				TexUvLines_11 = texUvLines[11];
				TexUvLines_12 = texUvLines[12];
				TexUvLines_13 = texUvLines[13];
				TexUvLines_14 = texUvLines[14];
				TexUvLines_15 = texUvLines[15];
				TexUvLines_16 = texUvLines[16];
				TexUvLines_17 = texUvLines[17];
				TexUvLines_18 = texUvLines[18];
				TexUvLines_19 = texUvLines[19];
				TexUvLines_20 = texUvLines[20];
				TexUvLines_21 = texUvLines[21];
				TexUvLines_22 = texUvLines[22];
				TexUvLines_23 = texUvLines[23];
				TexUvLines_24 = texUvLines[24];
				TexUvLines_25 = texUvLines[25];
				TexUvLines_26 = texUvLines[26];
				TexUvLines_27 = texUvLines[27];
				TexUvLines_28 = texUvLines[28];
				TexUvLines_29 = texUvLines[29];
				TexUvLines_30 = texUvLines[30];
				TexUvLines_31 = texUvLines[31];
				TexUvLines_32 = texUvLines[32];
				TexUvLines_33 = texUvLines[33];
				TexUvLines_34 = texUvLines[34];
				TexUvLines_35 = texUvLines[35];
				TexUvLines_36 = texUvLines[36];
				TexUvLines_37 = texUvLines[37];
				TexUvLines_38 = texUvLines[38];
				TexUvLines_39 = texUvLines[39];
				TexUvLines_40 = texUvLines[40];
				TexUvLines_41 = texUvLines[41];
				TexUvLines_42 = texUvLines[42];
				TexUvLines_43 = texUvLines[43];
				TexUvLines_44 = texUvLines[44];
				TexUvLines_45 = texUvLines[45];
				TexUvLines_46 = texUvLines[46];
				TexUvLines_47 = texUvLines[47];
				TexUvLines_48 = texUvLines[48];
				TexUvLines_49 = texUvLines[49];
				TexUvLines_50 = texUvLines[50];
				TexUvLines_51 = texUvLines[51];
				TexUvLines_52 = texUvLines[52];
				TexUvLines_53 = texUvLines[53];
				TexUvLines_54 = texUvLines[54];
				TexUvLines_55 = texUvLines[55];
				TexUvLines_56 = texUvLines[56];
				TexUvLines_57 = texUvLines[57];
				TexUvLines_58 = texUvLines[58];
				TexUvLines_59 = texUvLines[59];
				TexUvLines_60 = texUvLines[60];
				TexUvLines_61 = texUvLines[61];
				TexUvLines_62 = texUvLines[62];
				TexUvLines_63 = texUvLines[63];
			}
			FontBuilderIO = fontBuilderIo;
			FontBuilderFlags = fontBuilderFlags;
			PackIdMouseCursors = packIdMouseCursors;
			PackIdLines = packIdLines;
		}

		/// <summary>/// To be documented./// </summary>		public unsafe ImFontAtlas(int flags = default, void* texId = default, int texDesiredWidth = default, int texGlyphPadding = default, bool locked = default, void* userData = default, bool texReady = default, bool texPixelsUseColors = default, byte* texPixelsAlpha8 = default, uint* texPixelsRgba32 = default, int texWidth = default, int texHeight = default, Vector2 texUvScale = default, Vector2 texUvWhitePixel = default, ImVectorImFontPtr fonts = default, ImVectorImFontAtlasCustomRect customRects = default, ImVectorImFontConfig configData = default, Span<Vector4> texUvLines = default, ImFontBuilderIO* fontBuilderIo = default, uint fontBuilderFlags = default, int packIdMouseCursors = default, int packIdLines = default)
		{
			Flags = flags;
			TexID = texId;
			TexDesiredWidth = texDesiredWidth;
			TexGlyphPadding = texGlyphPadding;
			Locked = locked ? (byte)1 : (byte)0;
			UserData = userData;
			TexReady = texReady ? (byte)1 : (byte)0;
			TexPixelsUseColors = texPixelsUseColors ? (byte)1 : (byte)0;
			TexPixelsAlpha8 = texPixelsAlpha8;
			TexPixelsRGBA32 = texPixelsRgba32;
			TexWidth = texWidth;
			TexHeight = texHeight;
			TexUvScale = texUvScale;
			TexUvWhitePixel = texUvWhitePixel;
			Fonts = fonts;
			CustomRects = customRects;
			ConfigData = configData;
			if (texUvLines != default)
			{
				TexUvLines_0 = texUvLines[0];
				TexUvLines_1 = texUvLines[1];
				TexUvLines_2 = texUvLines[2];
				TexUvLines_3 = texUvLines[3];
				TexUvLines_4 = texUvLines[4];
				TexUvLines_5 = texUvLines[5];
				TexUvLines_6 = texUvLines[6];
				TexUvLines_7 = texUvLines[7];
				TexUvLines_8 = texUvLines[8];
				TexUvLines_9 = texUvLines[9];
				TexUvLines_10 = texUvLines[10];
				TexUvLines_11 = texUvLines[11];
				TexUvLines_12 = texUvLines[12];
				TexUvLines_13 = texUvLines[13];
				TexUvLines_14 = texUvLines[14];
				TexUvLines_15 = texUvLines[15];
				TexUvLines_16 = texUvLines[16];
				TexUvLines_17 = texUvLines[17];
				TexUvLines_18 = texUvLines[18];
				TexUvLines_19 = texUvLines[19];
				TexUvLines_20 = texUvLines[20];
				TexUvLines_21 = texUvLines[21];
				TexUvLines_22 = texUvLines[22];
				TexUvLines_23 = texUvLines[23];
				TexUvLines_24 = texUvLines[24];
				TexUvLines_25 = texUvLines[25];
				TexUvLines_26 = texUvLines[26];
				TexUvLines_27 = texUvLines[27];
				TexUvLines_28 = texUvLines[28];
				TexUvLines_29 = texUvLines[29];
				TexUvLines_30 = texUvLines[30];
				TexUvLines_31 = texUvLines[31];
				TexUvLines_32 = texUvLines[32];
				TexUvLines_33 = texUvLines[33];
				TexUvLines_34 = texUvLines[34];
				TexUvLines_35 = texUvLines[35];
				TexUvLines_36 = texUvLines[36];
				TexUvLines_37 = texUvLines[37];
				TexUvLines_38 = texUvLines[38];
				TexUvLines_39 = texUvLines[39];
				TexUvLines_40 = texUvLines[40];
				TexUvLines_41 = texUvLines[41];
				TexUvLines_42 = texUvLines[42];
				TexUvLines_43 = texUvLines[43];
				TexUvLines_44 = texUvLines[44];
				TexUvLines_45 = texUvLines[45];
				TexUvLines_46 = texUvLines[46];
				TexUvLines_47 = texUvLines[47];
				TexUvLines_48 = texUvLines[48];
				TexUvLines_49 = texUvLines[49];
				TexUvLines_50 = texUvLines[50];
				TexUvLines_51 = texUvLines[51];
				TexUvLines_52 = texUvLines[52];
				TexUvLines_53 = texUvLines[53];
				TexUvLines_54 = texUvLines[54];
				TexUvLines_55 = texUvLines[55];
				TexUvLines_56 = texUvLines[56];
				TexUvLines_57 = texUvLines[57];
				TexUvLines_58 = texUvLines[58];
				TexUvLines_59 = texUvLines[59];
				TexUvLines_60 = texUvLines[60];
				TexUvLines_61 = texUvLines[61];
				TexUvLines_62 = texUvLines[62];
				TexUvLines_63 = texUvLines[63];
			}
			FontBuilderIO = fontBuilderIo;
			FontBuilderFlags = fontBuilderFlags;
			PackIdMouseCursors = packIdMouseCursors;
			PackIdLines = packIdLines;
		}


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe Span<Vector4> TexUvLines
		
		{
			get
			{
				fixed (Vector4* p = &this.TexUvLines_0)
				{
					return new Span<Vector4>(p, 64);
				}
			}
		}
		public unsafe int AddCustomRectFontGlyph( ImFont* font,  char id,  int width,  int height,  float advanceX,  Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(@this, font, id, width, height, advanceX, offset);
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph( ImFont* font,  char id,  int width,  int height,  float advanceX)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectFontGlyphNative(@this, font, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
				return ret;
			}
		}

		public unsafe int AddCustomRectFontGlyph( ref ImFont font,  char id,  int width,  int height,  float advanceX,  Vector2 offset)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGui.AddCustomRectFontGlyphNative(@this, (ImFont*)pfont, id, width, height, advanceX, offset);
					return ret;
				}
			}
		}

		public unsafe int AddCustomRectFontGlyph( ref ImFont font,  char id,  int width,  int height,  float advanceX)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFont* pfont = &font)
				{
					int ret = ImGui.AddCustomRectFontGlyphNative(@this, (ImFont*)pfont, id, width, height, advanceX, (Vector2)(new Vector2(0,0)));
					return ret;
				}
			}
		}

		public unsafe int AddCustomRectRegular( int width,  int height)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				int ret = ImGui.AddCustomRectRegularNative(@this, width, height);
				return ret;
			}
		}

		public unsafe ImFont* AddFont( ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontNative(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFont* AddFont( ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontNative(@this, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontDefault( ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontDefaultNative(@this, fontCfg);
				return ret;
			}
		}

		public unsafe ImFont* AddFontDefault()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontDefaultNative(@this, (ImFontConfig*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontDefault( ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontDefaultNative(@this, (ImFontConfig*)pfontCfg);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( byte* filename,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, filename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( ref byte filename,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pfilename = &filename)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, (byte*)pfilename, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromFileTTF( string filename,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (filename != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(filename);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromFileTTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, fontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, fontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)(default), (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)(default), glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), glyphRanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, fontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, fontCfg, (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( byte* compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, compressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( ref byte compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte* pcompressedFontDatabase85 = &compressedFontDatabase85)
				{
					fixed (ImFontConfig* pfontCfg = &fontCfg)
					{
						fixed (char* pglyphRanges = &glyphRanges)
						{
							ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, (byte*)pcompressedFontDatabase85, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
							return ret;
						}
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedBase85TTF( string compressedFontDatabase85,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (compressedFontDatabase85 != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(compressedFontDatabase85);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(compressedFontDatabase85, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedBase85TTFNative(@this, pStr0, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							Utils.Free(pStr0);
						}
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryCompressedTTF( void* compressedFontData,  int compressedFontDataSize,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryCompressedTTFNative(@this, compressedFontData, compressedFontDataSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ImFontConfig* fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, fontCfg, glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ImFontConfig* fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, fontCfg, (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)(default), (char*)(default));
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)(default), glyphRanges);
				return ret;
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ref ImFontConfig fontCfg,  char* glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)pfontCfg, glyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ref ImFontConfig fontCfg)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)(default));
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ImFontConfig* fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, fontCfg, (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (char* pglyphRanges = &glyphRanges)
				{
					ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)(default), (char*)pglyphRanges);
					return ret;
				}
			}
		}

		public unsafe ImFont* AddFontFromMemoryTTF( void* fontData,  int fontDataSize,  float sizePixels,  ref ImFontConfig fontCfg,  ref char glyphRanges)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontConfig* pfontCfg = &fontCfg)
				{
					fixed (char* pglyphRanges = &glyphRanges)
					{
						ImFont* ret = ImGui.AddFontFromMemoryTTFNative(@this, fontData, fontDataSize, sizePixels, (ImFontConfig*)pfontCfg, (char*)pglyphRanges);
						return ret;
					}
				}
			}
		}

		public unsafe bool Build()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.BuildNative(@this);
				return ret != 0;
			}
		}

		public unsafe void CalcCustomRectUV( ImFontAtlasCustomRect* rect,  Vector2* outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.CalcCustomRectUVNative(@this, rect, outUvMin, outUvMax);
			}
		}

		public unsafe void CalcCustomRectUV( ref ImFontAtlasCustomRect rect,  Vector2* outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, outUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV( ImFontAtlasCustomRect* rect,  ref Vector2 outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					ImGui.CalcCustomRectUVNative(@this, rect, (Vector2*)poutUvMin, outUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV( ref ImFontAtlasCustomRect rect,  ref Vector2 outUvMin,  Vector2* outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, outUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV( ImFontAtlasCustomRect* rect,  Vector2* outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMax = &outUvMax)
				{
					ImGui.CalcCustomRectUVNative(@this, rect, outUvMin, (Vector2*)poutUvMax);
				}
			}
		}

		public unsafe void CalcCustomRectUV( ref ImFontAtlasCustomRect rect,  Vector2* outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, outUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV( ImFontAtlasCustomRect* rect,  ref Vector2 outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvMin = &outUvMin)
				{
					fixed (Vector2* poutUvMax = &outUvMax)
					{
						ImGui.CalcCustomRectUVNative(@this, rect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
					}
				}
			}
		}

		public unsafe void CalcCustomRectUV( ref ImFontAtlasCustomRect rect,  ref Vector2 outUvMin,  ref Vector2 outUvMax)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (ImFontAtlasCustomRect* prect = &rect)
				{
					fixed (Vector2* poutUvMin = &outUvMin)
					{
						fixed (Vector2* poutUvMax = &outUvMax)
						{
							ImGui.CalcCustomRectUVNative(@this, (ImFontAtlasCustomRect*)prect, (Vector2*)poutUvMin, (Vector2*)poutUvMax);
						}
					}
				}
			}
		}

		public unsafe void Clear()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearNative(@this);
			}
		}

		public unsafe void ClearFonts()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearFontsNative(@this);
			}
		}

		public unsafe void ClearInputData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearInputDataNative(@this);
			}
		}

		public unsafe void ClearTexData()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.ClearTexDataNative(@this);
			}
		}

		public unsafe void Destroy()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe ImFontAtlasCustomRect* GetCustomRectByIndex( int index)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImFontAtlasCustomRect* ret = ImGui.GetCustomRectByIndexNative(@this, index);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesChineseFull()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseFullNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesChineseSimplifiedCommon()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesChineseSimplifiedCommonNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesCyrillic()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesCyrillicNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesDefault()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesDefaultNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesGreek()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesGreekNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesJapanese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesJapaneseNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesKorean()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesKoreanNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesThai()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesThaiNative(@this);
				return ret;
			}
		}

		public unsafe char* GetGlyphRangesVietnamese()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				char* ret = ImGui.GetGlyphRangesVietnameseNative(@this);
				return ret;
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  Vector2* outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, outUvBorder, outUvFill);
				return ret != 0;
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  Vector2* outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  Vector2* outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, outUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  Vector2* outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvFill = &outUvFill)
				{
					byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
					return ret != 0;
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  Vector2* outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  Vector2* outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, outUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutUvBorder = &outUvBorder)
				{
					fixed (Vector2* poutUvFill = &outUvFill)
					{
						byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
						return ret != 0;
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  Vector2* outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, outSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  Vector2* outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutSize = &outSize)
				{
					fixed (Vector2* poutUvBorder = &outUvBorder)
					{
						fixed (Vector2* poutUvFill = &outUvFill)
						{
							byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, outOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
							return ret != 0;
						}
					}
				}
			}
		}

		public unsafe bool GetMouseCursorTexData( int cursor,  ref Vector2 outOffset,  ref Vector2 outSize,  ref Vector2 outUvBorder,  ref Vector2 outUvFill)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (Vector2* poutOffset = &outOffset)
				{
					fixed (Vector2* poutSize = &outSize)
					{
						fixed (Vector2* poutUvBorder = &outUvBorder)
						{
							fixed (Vector2* poutUvFill = &outUvFill)
							{
								byte ret = ImGui.GetMouseCursorTexDataNative(@this, cursor, (Vector2*)poutOffset, (Vector2*)poutSize, (Vector2*)poutUvBorder, (Vector2*)poutUvFill);
								return ret != 0;
							}
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsAlpha8Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( byte** outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsAlpha8Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsAlpha8( ref byte* outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsAlpha8Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, outBytesPerPixel);
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, (int*)(default));
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  int* outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  int* outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)(default));
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  ref int outHeight,  int* outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, outBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  ref int outHeight)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)(default));
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutBytesPerPixel = &outBytesPerPixel)
				{
					ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  int* outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, outHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutHeight = &outHeight)
				{
					fixed (int* poutBytesPerPixel = &outBytesPerPixel)
					{
						ImGui.GetTexDataAsRGBA32Native(@this, outPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  int* outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, outWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( byte** outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (int* poutWidth = &outWidth)
				{
					fixed (int* poutHeight = &outHeight)
					{
						fixed (int* poutBytesPerPixel = &outBytesPerPixel)
						{
							ImGui.GetTexDataAsRGBA32Native(@this, outPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
						}
					}
				}
			}
		}

		public unsafe void GetTexDataAsRGBA32( ref byte* outPixels,  ref int outWidth,  ref int outHeight,  ref int outBytesPerPixel)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				fixed (byte** poutPixels = &outPixels)
				{
					fixed (int* poutWidth = &outWidth)
					{
						fixed (int* poutHeight = &outHeight)
						{
							fixed (int* poutBytesPerPixel = &outBytesPerPixel)
							{
								ImGui.GetTexDataAsRGBA32Native(@this, (byte**)poutPixels, (int*)poutWidth, (int*)poutHeight, (int*)poutBytesPerPixel);
							}
						}
					}
				}
			}
		}

		public unsafe bool IsBuilt()
		{
			fixed (ImFontAtlas* @this = &this)
			{
				byte ret = ImGui.IsBuiltNative(@this);
				return ret != 0;
			}
		}

		public unsafe void SetTexID( ImTextureID id)
		{
			fixed (ImFontAtlas* @this = &this)
			{
				ImGui.SetTexIDNative(@this, id);
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontPtr
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFont** Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImFontPtr(int size = default, int capacity = default, ImFont** data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontAtlasCustomRect
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontAtlasCustomRect* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImFontAtlasCustomRect(int size = default, int capacity = default, ImFontAtlasCustomRect* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}


	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImFontAtlasCustomRect
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Width;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Height;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort X;

		/// <summary>
		/// To be documented.
		/// </summary>
		public ushort Y;

		/// <summary>
		/// To be documented.
		/// </summary>
		public uint GlyphID;

		/// <summary>
		/// To be documented.
		/// </summary>
		public float GlyphAdvanceX;

		/// <summary>
		/// To be documented.
		/// </summary>
		public Vector2 GlyphOffset;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFont* Font;



		/// <summary>/// To be documented./// </summary>		public unsafe ImFontAtlasCustomRect(ushort width = default, ushort height = default, ushort x = default, ushort y = default, uint glyphId = default, float glyphAdvanceX = default, Vector2 glyphOffset = default, ImFont* font = default)
		{
			Width = width;
			Height = height;
			X = x;
			Y = y;
			GlyphID = glyphId;
			GlyphAdvanceX = glyphAdvanceX;
			GlyphOffset = glyphOffset;
			Font = font;
		}


		public unsafe void Destroy()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				ImGui.DestroyNative(@this);
			}
		}

		public unsafe bool IsPacked()
		{
			fixed (ImFontAtlasCustomRect* @this = &this)
			{
				byte ret = ImGui.IsPackedNative(@this);
				return ret != 0;
			}
		}

	}

	/// <summary>
	/// To be documented.
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct ImVectorImFontConfig
	{
		/// <summary>
		/// To be documented.
		/// </summary>
		public int Size;

		/// <summary>
		/// To be documented.
		/// </summary>
		public int Capacity;

		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe ImFontConfig* Data;


		/// <summary>/// To be documented./// </summary>		public unsafe ImVectorImFontConfig(int size = default, int capacity = default, ImFontConfig* data = default)
		{
			Size = size;
			Capacity = capacity;
			Data = data;
		}
	}
}
