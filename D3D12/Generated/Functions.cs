// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using HexaGen.Runtime.COM;
using HexaEngine.DXGI;
using HexaEngine.D3DCommon;

namespace HexaEngine.D3D12
{
	public unsafe partial class D3D12
	{
		internal const string LibName = "d3d12";

		[NativeName("D3D12SerializeRootSignature")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "D3D12SerializeRootSignature")]
		internal static extern HResult D3D12SerializeRootSignatureNative(D3D12RootSignatureDesc* pRootSignature, D3DRootSignatureVersion version, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob);

		public static HResult D3D12SerializeRootSignature(D3D12RootSignatureDesc* pRootSignature, D3DRootSignatureVersion version, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			HResult ret = D3D12SerializeRootSignatureNative(pRootSignature, version, ppBlob, ppErrorBlob);
			return ret;
		}

		public static HResult D3D12SerializeRootSignature(ref D3D12RootSignatureDesc pRootSignature, D3DRootSignatureVersion version, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (D3D12RootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				HResult ret = D3D12SerializeRootSignatureNative((D3D12RootSignatureDesc*)ppRootSignature, version, ppBlob, ppErrorBlob);
				return ret;
			}
		}

		public static HResult D3D12SerializeRootSignature(D3D12RootSignatureDesc* pRootSignature, D3DRootSignatureVersion version, ref ID3D10Blob* ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (ID3D10Blob** pppBlob = &ppBlob)
			{
				HResult ret = D3D12SerializeRootSignatureNative(pRootSignature, version, (ID3D10Blob**)pppBlob, ppErrorBlob);
				return ret;
			}
		}

		public static HResult D3D12SerializeRootSignature(ref D3D12RootSignatureDesc pRootSignature, D3DRootSignatureVersion version, ref ID3D10Blob* ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (D3D12RootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppBlob = &ppBlob)
				{
					HResult ret = D3D12SerializeRootSignatureNative((D3D12RootSignatureDesc*)ppRootSignature, version, (ID3D10Blob**)pppBlob, ppErrorBlob);
					return ret;
				}
			}
		}

		public static HResult D3D12SerializeRootSignature(D3D12RootSignatureDesc* pRootSignature, D3DRootSignatureVersion version, ID3D10Blob** ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
			{
				HResult ret = D3D12SerializeRootSignatureNative(pRootSignature, version, ppBlob, (ID3D10Blob**)pppErrorBlob);
				return ret;
			}
		}

		public static HResult D3D12SerializeRootSignature(ref D3D12RootSignatureDesc pRootSignature, D3DRootSignatureVersion version, ID3D10Blob** ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (D3D12RootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
				{
					HResult ret = D3D12SerializeRootSignatureNative((D3D12RootSignatureDesc*)ppRootSignature, version, ppBlob, (ID3D10Blob**)pppErrorBlob);
					return ret;
				}
			}
		}

		public static HResult D3D12SerializeRootSignature(D3D12RootSignatureDesc* pRootSignature, D3DRootSignatureVersion version, ref ID3D10Blob* ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (ID3D10Blob** pppBlob = &ppBlob)
			{
				fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
				{
					HResult ret = D3D12SerializeRootSignatureNative(pRootSignature, version, (ID3D10Blob**)pppBlob, (ID3D10Blob**)pppErrorBlob);
					return ret;
				}
			}
		}

		public static HResult D3D12SerializeRootSignature(ref D3D12RootSignatureDesc pRootSignature, D3DRootSignatureVersion version, ref ID3D10Blob* ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (D3D12RootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppBlob = &ppBlob)
				{
					fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
					{
						HResult ret = D3D12SerializeRootSignatureNative((D3D12RootSignatureDesc*)ppRootSignature, version, (ID3D10Blob**)pppBlob, (ID3D10Blob**)pppErrorBlob);
						return ret;
					}
				}
			}
		}

		[NativeName("D3D12CreateRootSignatureDeserializer")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "D3D12CreateRootSignatureDeserializer")]
		internal static extern HResult D3D12CreateRootSignatureDeserializerNative(void* pSrcData, nuint srcDataSizeInBytes, Guid* pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer);

		public static HResult D3D12CreateRootSignatureDeserializer(void* pSrcData, nuint srcDataSizeInBytes, Guid* pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			HResult ret = D3D12CreateRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, pRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
			return ret;
		}

		public static HResult D3D12CreateRootSignatureDeserializer(void* pSrcData, nuint srcDataSizeInBytes, ref Guid pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			fixed (Guid* ppRootSignatureDeserializerInterface = &pRootSignatureDeserializerInterface)
			{
				HResult ret = D3D12CreateRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, (Guid*)ppRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
				return ret;
			}
		}

		[NativeName("D3D12SerializeVersionedRootSignature")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "D3D12SerializeVersionedRootSignature")]
		internal static extern HResult D3D12SerializeVersionedRootSignatureNative(D3D12VersionedRootSignatureDesc* pRootSignature, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob);

		public static HResult D3D12SerializeVersionedRootSignature(D3D12VersionedRootSignatureDesc* pRootSignature, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			HResult ret = D3D12SerializeVersionedRootSignatureNative(pRootSignature, ppBlob, ppErrorBlob);
			return ret;
		}

		public static HResult D3D12SerializeVersionedRootSignature(ref D3D12VersionedRootSignatureDesc pRootSignature, ID3D10Blob** ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (D3D12VersionedRootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				HResult ret = D3D12SerializeVersionedRootSignatureNative((D3D12VersionedRootSignatureDesc*)ppRootSignature, ppBlob, ppErrorBlob);
				return ret;
			}
		}

		public static HResult D3D12SerializeVersionedRootSignature(D3D12VersionedRootSignatureDesc* pRootSignature, ref ID3D10Blob* ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (ID3D10Blob** pppBlob = &ppBlob)
			{
				HResult ret = D3D12SerializeVersionedRootSignatureNative(pRootSignature, (ID3D10Blob**)pppBlob, ppErrorBlob);
				return ret;
			}
		}

		public static HResult D3D12SerializeVersionedRootSignature(ref D3D12VersionedRootSignatureDesc pRootSignature, ref ID3D10Blob* ppBlob, ID3D10Blob** ppErrorBlob)
		{
			fixed (D3D12VersionedRootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppBlob = &ppBlob)
				{
					HResult ret = D3D12SerializeVersionedRootSignatureNative((D3D12VersionedRootSignatureDesc*)ppRootSignature, (ID3D10Blob**)pppBlob, ppErrorBlob);
					return ret;
				}
			}
		}

		public static HResult D3D12SerializeVersionedRootSignature(D3D12VersionedRootSignatureDesc* pRootSignature, ID3D10Blob** ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
			{
				HResult ret = D3D12SerializeVersionedRootSignatureNative(pRootSignature, ppBlob, (ID3D10Blob**)pppErrorBlob);
				return ret;
			}
		}

		public static HResult D3D12SerializeVersionedRootSignature(ref D3D12VersionedRootSignatureDesc pRootSignature, ID3D10Blob** ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (D3D12VersionedRootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
				{
					HResult ret = D3D12SerializeVersionedRootSignatureNative((D3D12VersionedRootSignatureDesc*)ppRootSignature, ppBlob, (ID3D10Blob**)pppErrorBlob);
					return ret;
				}
			}
		}

		public static HResult D3D12SerializeVersionedRootSignature(D3D12VersionedRootSignatureDesc* pRootSignature, ref ID3D10Blob* ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (ID3D10Blob** pppBlob = &ppBlob)
			{
				fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
				{
					HResult ret = D3D12SerializeVersionedRootSignatureNative(pRootSignature, (ID3D10Blob**)pppBlob, (ID3D10Blob**)pppErrorBlob);
					return ret;
				}
			}
		}

		public static HResult D3D12SerializeVersionedRootSignature(ref D3D12VersionedRootSignatureDesc pRootSignature, ref ID3D10Blob* ppBlob, ref ID3D10Blob* ppErrorBlob)
		{
			fixed (D3D12VersionedRootSignatureDesc* ppRootSignature = &pRootSignature)
			{
				fixed (ID3D10Blob** pppBlob = &ppBlob)
				{
					fixed (ID3D10Blob** pppErrorBlob = &ppErrorBlob)
					{
						HResult ret = D3D12SerializeVersionedRootSignatureNative((D3D12VersionedRootSignatureDesc*)ppRootSignature, (ID3D10Blob**)pppBlob, (ID3D10Blob**)pppErrorBlob);
						return ret;
					}
				}
			}
		}

		[NativeName("D3D12CreateVersionedRootSignatureDeserializer")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "D3D12CreateVersionedRootSignatureDeserializer")]
		internal static extern HResult D3D12CreateVersionedRootSignatureDeserializerNative(void* pSrcData, nuint srcDataSizeInBytes, Guid* pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer);

		public static HResult D3D12CreateVersionedRootSignatureDeserializer(void* pSrcData, nuint srcDataSizeInBytes, Guid* pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			HResult ret = D3D12CreateVersionedRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, pRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
			return ret;
		}

		public static HResult D3D12CreateVersionedRootSignatureDeserializer(void* pSrcData, nuint srcDataSizeInBytes, ref Guid pRootSignatureDeserializerInterface, void** ppRootSignatureDeserializer)
		{
			fixed (Guid* ppRootSignatureDeserializerInterface = &pRootSignatureDeserializerInterface)
			{
				HResult ret = D3D12CreateVersionedRootSignatureDeserializerNative(pSrcData, srcDataSizeInBytes, (Guid*)ppRootSignatureDeserializerInterface, ppRootSignatureDeserializer);
				return ret;
			}
		}

		[NativeName("D3D12CreateDevice")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "D3D12CreateDevice")]
		internal static extern HResult D3D12CreateDeviceNative(IUnknown* pAdapter, D3DFeatureLevel minimumFeatureLevel, Guid* riid, void** ppDevice);

		public static HResult D3D12CreateDevice(IUnknown* pAdapter, D3DFeatureLevel minimumFeatureLevel, Guid* riid, void** ppDevice)
		{
			HResult ret = D3D12CreateDeviceNative(pAdapter, minimumFeatureLevel, riid, ppDevice);
			return ret;
		}

		public static HResult D3D12CreateDevice(ref IUnknown pAdapter, D3DFeatureLevel minimumFeatureLevel, Guid* riid, void** ppDevice)
		{
			fixed (IUnknown* ppAdapter = &pAdapter)
			{
				HResult ret = D3D12CreateDeviceNative((IUnknown*)ppAdapter, minimumFeatureLevel, riid, ppDevice);
				return ret;
			}
		}

		public static HResult D3D12CreateDevice(IUnknown* pAdapter, D3DFeatureLevel minimumFeatureLevel, ref Guid riid, void** ppDevice)
		{
			fixed (Guid* priid = &riid)
			{
				HResult ret = D3D12CreateDeviceNative(pAdapter, minimumFeatureLevel, (Guid*)priid, ppDevice);
				return ret;
			}
		}

		public static HResult D3D12CreateDevice(ref IUnknown pAdapter, D3DFeatureLevel minimumFeatureLevel, ref Guid riid, void** ppDevice)
		{
			fixed (IUnknown* ppAdapter = &pAdapter)
			{
				fixed (Guid* priid = &riid)
				{
					HResult ret = D3D12CreateDeviceNative((IUnknown*)ppAdapter, minimumFeatureLevel, (Guid*)priid, ppDevice);
					return ret;
				}
			}
		}

		[NativeName("D3D12GetDebugInterface")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "D3D12GetDebugInterface")]
		internal static extern HResult D3D12GetDebugInterfaceNative(Guid* riid, void** ppvDebug);

		public static HResult D3D12GetDebugInterface(Guid* riid, void** ppvDebug)
		{
			HResult ret = D3D12GetDebugInterfaceNative(riid, ppvDebug);
			return ret;
		}

		public static HResult D3D12GetDebugInterface(ref Guid riid, void** ppvDebug)
		{
			fixed (Guid* priid = &riid)
			{
				HResult ret = D3D12GetDebugInterfaceNative((Guid*)priid, ppvDebug);
				return ret;
			}
		}

		/// <summary>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// D3D12EnableExperimentalFeatures<br/>
		/// Pass in a list of feature GUIDs to be enabled together.<br/>
		/// If a particular feature requires some configuration information on enablement, it will have<br/>
		/// a configuration struct that can be passed alongside the GUID.<br/>
		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>
		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>
		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>
		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>
		/// If this method is called and a change to existing feature enablement is made, <br/>
		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>
		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>
		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>
		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>
		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>
		/// in are known to be incompatible with each other, or other errors.<br/>
		/// Returns S_OK otherwise.<br/>
		/// --------------------------------------------------------------------------------------------------------------------------------<br/>
		/// </summary>
		[NativeName("D3D12EnableExperimentalFeatures")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "D3D12EnableExperimentalFeatures")]
		internal static extern HResult D3D12EnableExperimentalFeaturesNative(uint numFeatures, Guid* pIIDs, void* pConfigurationStructs, uint* pConfigurationStructSizes);

		/// <summary>		/// --------------------------------------------------------------------------------------------------------------------------------<br/>		/// D3D12EnableExperimentalFeatures<br/>		/// Pass in a list of feature GUIDs to be enabled together.<br/>		/// If a particular feature requires some configuration information on enablement, it will have<br/>		/// a configuration struct that can be passed alongside the GUID.<br/>		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>		/// If this method is called and a change to existing feature enablement is made, <br/>		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>		/// in are known to be incompatible with each other, or other errors.<br/>		/// Returns S_OK otherwise.<br/>		/// --------------------------------------------------------------------------------------------------------------------------------<br/>		/// </summary>		public static HResult D3D12EnableExperimentalFeatures(uint numFeatures, Guid* pIIDs, void* pConfigurationStructs, uint* pConfigurationStructSizes)
		{
			HResult ret = D3D12EnableExperimentalFeaturesNative(numFeatures, pIIDs, pConfigurationStructs, pConfigurationStructSizes);
			return ret;
		}

		/// <summary>		/// --------------------------------------------------------------------------------------------------------------------------------<br/>		/// D3D12EnableExperimentalFeatures<br/>		/// Pass in a list of feature GUIDs to be enabled together.<br/>		/// If a particular feature requires some configuration information on enablement, it will have<br/>		/// a configuration struct that can be passed alongside the GUID.<br/>		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>		/// If this method is called and a change to existing feature enablement is made, <br/>		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>		/// in are known to be incompatible with each other, or other errors.<br/>		/// Returns S_OK otherwise.<br/>		/// --------------------------------------------------------------------------------------------------------------------------------<br/>		/// </summary>		public static HResult D3D12EnableExperimentalFeatures(uint numFeatures, ref Guid pIIDs, void* pConfigurationStructs, uint* pConfigurationStructSizes)
		{
			fixed (Guid* ppIIDs = &pIIDs)
			{
				HResult ret = D3D12EnableExperimentalFeaturesNative(numFeatures, (Guid*)ppIIDs, pConfigurationStructs, pConfigurationStructSizes);
				return ret;
			}
		}

		/// <summary>		/// --------------------------------------------------------------------------------------------------------------------------------<br/>		/// D3D12EnableExperimentalFeatures<br/>		/// Pass in a list of feature GUIDs to be enabled together.<br/>		/// If a particular feature requires some configuration information on enablement, it will have<br/>		/// a configuration struct that can be passed alongside the GUID.<br/>		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>		/// If this method is called and a change to existing feature enablement is made, <br/>		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>		/// in are known to be incompatible with each other, or other errors.<br/>		/// Returns S_OK otherwise.<br/>		/// --------------------------------------------------------------------------------------------------------------------------------<br/>		/// </summary>		public static HResult D3D12EnableExperimentalFeatures(uint numFeatures, Guid* pIIDs, void* pConfigurationStructs, ref uint pConfigurationStructSizes)
		{
			fixed (uint* ppConfigurationStructSizes = &pConfigurationStructSizes)
			{
				HResult ret = D3D12EnableExperimentalFeaturesNative(numFeatures, pIIDs, pConfigurationStructs, (uint*)ppConfigurationStructSizes);
				return ret;
			}
		}

		/// <summary>		/// --------------------------------------------------------------------------------------------------------------------------------<br/>		/// D3D12EnableExperimentalFeatures<br/>		/// Pass in a list of feature GUIDs to be enabled together.<br/>		/// If a particular feature requires some configuration information on enablement, it will have<br/>		/// a configuration struct that can be passed alongside the GUID.<br/>		/// Some features might use an interface IID as the GUID.  For these, once the feature is enabled via<br/>		/// D3D12EnableExperimentalFeatures, D3D12GetDebugInterface can then be called with the IID to retrieve the interface<br/>		/// for manipulating the feature.  This allows for control that might not cleanly be expressed by just <br/>		/// the configuration struct that D3D12EnableExperimentalFeatures provides.<br/>		/// If this method is called and a change to existing feature enablement is made, <br/>		/// all current D3D12 devices are set to DEVICE_REMOVED state, since under the covers there is really only one<br/>		/// singleton device for a process.  Removing the devices when configuration changes prevents<br/>		/// mismatched expectations of how a device is supposed to work after it has been created from the app's point of view.<br/>		/// The call returns E_NOINTERFACE if an unrecognized feature is passed in or Windows Developer mode is not on.<br/>		/// The call returns E_INVALIDARG if the configuration of a feature is incorrect, the set of features passed<br/>		/// in are known to be incompatible with each other, or other errors.<br/>		/// Returns S_OK otherwise.<br/>		/// --------------------------------------------------------------------------------------------------------------------------------<br/>		/// </summary>		public static HResult D3D12EnableExperimentalFeatures(uint numFeatures, ref Guid pIIDs, void* pConfigurationStructs, ref uint pConfigurationStructSizes)
		{
			fixed (Guid* ppIIDs = &pIIDs)
			{
				fixed (uint* ppConfigurationStructSizes = &pConfigurationStructSizes)
				{
					HResult ret = D3D12EnableExperimentalFeaturesNative(numFeatures, (Guid*)ppIIDs, pConfigurationStructs, (uint*)ppConfigurationStructSizes);
					return ret;
				}
			}
		}

		[NativeName("D3D12GetInterface")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "D3D12GetInterface")]
		internal static extern HResult D3D12GetInterfaceNative(Guid* rclsid, Guid* riid, void** ppvDebug);

		public static HResult D3D12GetInterface(Guid* rclsid, Guid* riid, void** ppvDebug)
		{
			HResult ret = D3D12GetInterfaceNative(rclsid, riid, ppvDebug);
			return ret;
		}

		public static HResult D3D12GetInterface(ref Guid rclsid, Guid* riid, void** ppvDebug)
		{
			fixed (Guid* prclsid = &rclsid)
			{
				HResult ret = D3D12GetInterfaceNative((Guid*)prclsid, riid, ppvDebug);
				return ret;
			}
		}

		public static HResult D3D12GetInterface(Guid* rclsid, ref Guid riid, void** ppvDebug)
		{
			fixed (Guid* priid = &riid)
			{
				HResult ret = D3D12GetInterfaceNative(rclsid, (Guid*)priid, ppvDebug);
				return ret;
			}
		}

		public static HResult D3D12GetInterface(ref Guid rclsid, ref Guid riid, void** ppvDebug)
		{
			fixed (Guid* prclsid = &rclsid)
			{
				fixed (Guid* priid = &riid)
				{
					HResult ret = D3D12GetInterfaceNative((Guid*)prclsid, (Guid*)priid, ppvDebug);
					return ret;
				}
			}
		}

	}
}
