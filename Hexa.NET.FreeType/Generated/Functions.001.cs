// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	public unsafe partial class FreeType
	{

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* pparg2 = &parg2)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					int ret = FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_SubGlyph_Info<br/>/// <br/>/// :<br/>/// Retrieve a description of a given subglyph.  Only use it if<br/>/// `glyph->format` is <br/>/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>/// otherwise.<br/>/// <br/>/// :<br/>/// glyph ::<br/>/// The source glyph slot.<br/>/// sub_index ::<br/>/// The index of the subglyph.  Must be less than<br/>/// `glyph->num_subglyphs`.<br/>/// <br/>/// :<br/>/// p_index ::<br/>/// The glyph index of the subglyph.<br/>/// p_flags ::<br/>/// The subglyph flags, see <br/>/// _SUBGLYPH_FLAG_XXX.<br/>/// p_arg1 ::<br/>/// The subglyph's first argument (if any).<br/>/// p_arg2 ::<br/>/// The subglyph's second argument (if any).<br/>/// p_transform ::<br/>/// The subglyph transformation (if any).<br/>/// <br/>/// <br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (int* pparg2 = &parg2)
						{
							fixed (FTMatrix* ppTransform = &pTransform)
							{
								int ret = FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_FSType_Flags<br/>
		/// <br/>
		/// :<br/>
		/// Return the `fsType` flags for a font.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_FSType_Flags")]
		[return: NativeName(NativeNameType.Type, "FT_UShort")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_FSType_Flags")]
		internal static extern ushort FTGetFSTypeFlagsNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_FSType_Flags<br/>/// <br/>/// :<br/>/// Return the `fsType` flags for a font.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face object.<br/>/// <br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_FSType_Flags")]
		[return: NativeName(NativeNameType.Type, "FT_UShort")]
		public static ushort FTGetFSTypeFlags([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			ushort ret = FTGetFSTypeFlagsNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharVariantIndex<br/>
		/// <br/>
		/// :<br/>
		/// Return the glyph index of a given character code as modified by the<br/>
		/// variation selector.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character code point in Unicode.<br/>
		/// variantSelector ::<br/>
		/// The Unicode code point of the variation selector.<br/>
		/// <br/>
		/// <br/>
		/// This function is only meaningful if<br/>
		/// a) the font has a variation selector cmap sub table, and<br/>
		/// b) the current charmap has a Unicode encoding.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIndex")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Face_GetCharVariantIndex")]
		internal static extern uint FTFaceGetCharVariantIndexNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Face_GetCharVariantIndex<br/>/// <br/>/// :<br/>/// Return the glyph index of a given character code as modified by the<br/>/// variation selector.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face object.<br/>/// charcode ::<br/>/// The character code point in Unicode.<br/>/// variantSelector ::<br/>/// The Unicode code point of the variation selector.<br/>/// <br/>/// <br/>/// This function is only meaningful if<br/>/// a) the font has a variation selector cmap sub table, and<br/>/// b) the current charmap has a Unicode encoding.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIndex")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint FTFaceGetCharVariantIndex([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint ret = FTFaceGetCharVariantIndexNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharVariantIsDefault<br/>
		/// <br/>
		/// :<br/>
		/// Check whether this variation of this Unicode character is the one to<br/>
		/// be found in the charmap.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character codepoint in Unicode.<br/>
		/// variantSelector ::<br/>
		/// The Unicode codepoint of the variation selector.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIsDefault")]
		[return: NativeName(NativeNameType.Type, "FT_Int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Face_GetCharVariantIsDefault")]
		internal static extern int FTFaceGetCharVariantIsDefaultNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Face_GetCharVariantIsDefault<br/>/// <br/>/// :<br/>/// Check whether this variation of this Unicode character is the one to<br/>/// be found in the charmap.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face object.<br/>/// charcode ::<br/>/// The character codepoint in Unicode.<br/>/// variantSelector ::<br/>/// The Unicode codepoint of the variation selector.<br/>/// <br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIsDefault")]
		[return: NativeName(NativeNameType.Type, "FT_Int")]
		public static int FTFaceGetCharVariantIsDefault([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			int ret = FTFaceGetCharVariantIsDefaultNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetVariantSelectors<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode variation selectors found in<br/>
		/// the font.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetVariantSelectors")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Face_GetVariantSelectors")]
		internal static extern uint* FTFaceGetVariantSelectorsNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Face_GetVariantSelectors<br/>/// <br/>/// :<br/>/// Return a zero-terminated list of Unicode variation selectors found in<br/>/// the font.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face object.<br/>/// <br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetVariantSelectors")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		public static uint* FTFaceGetVariantSelectors([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			uint* ret = FTFaceGetVariantSelectorsNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetVariantsOfChar<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode variation selectors found for<br/>
		/// the specified character code.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character codepoint in Unicode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetVariantsOfChar")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Face_GetVariantsOfChar")]
		internal static extern uint* FTFaceGetVariantsOfCharNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Face_GetVariantsOfChar<br/>/// <br/>/// :<br/>/// Return a zero-terminated list of Unicode variation selectors found for<br/>/// the specified character code.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face object.<br/>/// charcode ::<br/>/// The character codepoint in Unicode.<br/>/// <br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetVariantsOfChar")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		public static uint* FTFaceGetVariantsOfChar([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode)
		{
			uint* ret = FTFaceGetVariantsOfCharNative(face, charcode);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharsOfVariant<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode character codes found for the<br/>
		/// specified variation selector.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// variantSelector ::<br/>
		/// The variation selector code point in Unicode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharsOfVariant")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Face_GetCharsOfVariant")]
		internal static extern uint* FTFaceGetCharsOfVariantNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Face_GetCharsOfVariant<br/>/// <br/>/// :<br/>/// Return a zero-terminated list of Unicode character codes found for the<br/>/// specified variation selector.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face object.<br/>/// variantSelector ::<br/>/// The variation selector code point in Unicode.<br/>/// <br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetCharsOfVariant")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		public static uint* FTFaceGetCharsOfVariant([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint* ret = FTFaceGetCharsOfVariantNative(face, variantSelector);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_MulDiv<br/>
		/// <br/>
		/// :<br/>
		/// Compute `(a*b)/c` with maximum accuracy, using a 64-bit intermediate<br/>
		/// integer whenever necessary.<br/>
		/// This function isn't necessarily as fast as some processor-specific<br/>
		/// operations, but is at least completely portable.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The first multiplier.<br/>
		/// b ::<br/>
		/// The second multiplier.<br/>
		/// c ::<br/>
		/// The divisor.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_MulDiv")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_MulDiv")]
		internal static extern int FTMulDivNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "FT_Long")] int c);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_MulDiv<br/>/// <br/>/// :<br/>/// Compute `(a*b)/c` with maximum accuracy, using a 64-bit intermediate<br/>/// integer whenever necessary.<br/>/// This function isn't necessarily as fast as some processor-specific<br/>/// operations, but is at least completely portable.<br/>/// <br/>/// :<br/>/// a ::<br/>/// The first multiplier.<br/>/// b ::<br/>/// The second multiplier.<br/>/// c ::<br/>/// The divisor.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_MulDiv")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		public static int FTMulDiv([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "FT_Long")] int c)
		{
			int ret = FTMulDivNative(a, b, c);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_MulFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute `(a*b)/0x10000` with maximum accuracy.  Its main use is to<br/>
		/// multiply a given value by a 16.16 fixed-point factor.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The first multiplier.<br/>
		/// b ::<br/>
		/// The second multiplier.  Use a 16.16 factor here whenever possible<br/>
		/// (see note below).<br/>
		/// <br/>
		/// <br/>
		/// As a conclusion, always try to place a 16.16 factor as the _second_<br/>
		/// argument of this function; this can make a great difference.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_MulFix")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_MulFix")]
		internal static extern int FTMulFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_MulFix<br/>/// <br/>/// :<br/>/// Compute `(a*b)/0x10000` with maximum accuracy.  Its main use is to<br/>/// multiply a given value by a 16.16 fixed-point factor.<br/>/// <br/>/// :<br/>/// a ::<br/>/// The first multiplier.<br/>/// b ::<br/>/// The second multiplier.  Use a 16.16 factor here whenever possible<br/>/// (see note below).<br/>/// <br/>/// <br/>/// As a conclusion, always try to place a 16.16 factor as the _second_<br/>/// argument of this function; this can make a great difference.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_MulFix")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		public static int FTMulFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b)
		{
			int ret = FTMulFixNative(a, b);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_DivFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute `(a*0x10000)/b` with maximum accuracy.  Its main use is to<br/>
		/// divide a given value by a 16.16 fixed-point factor.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The numerator.<br/>
		/// b ::<br/>
		/// The denominator.  Use a 16.16 factor here.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_DivFix")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_DivFix")]
		internal static extern int FTDivFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_DivFix<br/>/// <br/>/// :<br/>/// Compute `(a*0x10000)/b` with maximum accuracy.  Its main use is to<br/>/// divide a given value by a 16.16 fixed-point factor.<br/>/// <br/>/// :<br/>/// a ::<br/>/// The numerator.<br/>/// b ::<br/>/// The denominator.  Use a 16.16 factor here.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_DivFix")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		public static int FTDivFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b)
		{
			int ret = FTDivFixNative(a, b);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_RoundFix<br/>
		/// <br/>
		/// :<br/>
		/// Round a 16.16 fixed number.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The number to be rounded.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_RoundFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_RoundFix")]
		internal static extern int FTRoundFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_RoundFix<br/>/// <br/>/// :<br/>/// Round a 16.16 fixed number.<br/>/// <br/>/// :<br/>/// a ::<br/>/// The number to be rounded.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_RoundFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int FTRoundFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a)
		{
			int ret = FTRoundFixNative(a);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_CeilFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute the smallest following integer of a 16.16 fixed number.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The number for which the ceiling function is to be computed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_CeilFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_CeilFix")]
		internal static extern int FTCeilFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_CeilFix<br/>/// <br/>/// :<br/>/// Compute the smallest following integer of a 16.16 fixed number.<br/>/// <br/>/// :<br/>/// a ::<br/>/// The number for which the ceiling function is to be computed.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_CeilFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int FTCeilFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a)
		{
			int ret = FTCeilFixNative(a);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_FloorFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute the largest previous integer of a 16.16 fixed number.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The number for which the floor function is to be computed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_FloorFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_FloorFix")]
		internal static extern int FTFloorFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_FloorFix<br/>/// <br/>/// :<br/>/// Compute the largest previous integer of a 16.16 fixed number.<br/>/// <br/>/// :<br/>/// a ::<br/>/// The number for which the floor function is to be computed.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_FloorFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int FTFloorFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a)
		{
			int ret = FTFloorFixNative(a);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a single vector through a 2x2 matrix.<br/>
		/// <br/>
		/// :<br/>
		/// vector ::<br/>
		/// The target vector to transform.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the source 2x2 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Vector_Transform")]
		internal static extern void FTVectorTransformNative([NativeName(NativeNameType.Param, "vector")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* vector, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "const FT_Matrix*")] FTMatrix* matrix);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Vector_Transform<br/>/// <br/>/// :<br/>/// Transform a single vector through a 2x2 matrix.<br/>/// <br/>/// :<br/>/// vector ::<br/>/// The target vector to transform.<br/>/// <br/>/// :<br/>/// matrix ::<br/>/// A pointer to the source 2x2 matrix.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Vector_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTVectorTransform([NativeName(NativeNameType.Param, "vector")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* vector, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "const FT_Matrix*")] FTMatrix* matrix)
		{
			FTVectorTransformNative(vector, matrix);
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Vector_Transform<br/>/// <br/>/// :<br/>/// Transform a single vector through a 2x2 matrix.<br/>/// <br/>/// :<br/>/// vector ::<br/>/// The target vector to transform.<br/>/// <br/>/// :<br/>/// matrix ::<br/>/// A pointer to the source 2x2 matrix.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Vector_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTVectorTransform([NativeName(NativeNameType.Param, "vector")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* vector, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "const FT_Matrix*")] ref FTMatrix matrix)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				FTVectorTransformNative(vector, (FTMatrix*)pmatrix);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Library_Version")]
		internal static extern void FTLibraryVersionNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Library_Version<br/>/// <br/>/// :<br/>/// Return the version of the FreeType library being used.  This is useful<br/>/// when dynamically linking to the library, since one cannot use the<br/>/// macros <br/>/// _MAJOR, <br/>/// _MINOR, and <br/>/// _PATCH.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A source library handle.<br/>/// <br/>/// :<br/>/// amajor ::<br/>/// The major version number.<br/>/// aminor ::<br/>/// The minor version number.<br/>/// apatch ::<br/>/// The patch version number.<br/>/// <br/>/// In such cases, the library version might not be available before the<br/>/// library object has been created.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTLibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			FTLibraryVersionNative(library, amajor, aminor, apatch);
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Library_Version<br/>/// <br/>/// :<br/>/// Return the version of the FreeType library being used.  This is useful<br/>/// when dynamically linking to the library, since one cannot use the<br/>/// macros <br/>/// _MAJOR, <br/>/// _MINOR, and <br/>/// _PATCH.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A source library handle.<br/>/// <br/>/// :<br/>/// amajor ::<br/>/// The major version number.<br/>/// aminor ::<br/>/// The minor version number.<br/>/// apatch ::<br/>/// The patch version number.<br/>/// <br/>/// In such cases, the library version might not be available before the<br/>/// library object has been created.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTLibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				FTLibraryVersionNative(library, (int*)pamajor, aminor, apatch);
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Library_Version<br/>/// <br/>/// :<br/>/// Return the version of the FreeType library being used.  This is useful<br/>/// when dynamically linking to the library, since one cannot use the<br/>/// macros <br/>/// _MAJOR, <br/>/// _MINOR, and <br/>/// _PATCH.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A source library handle.<br/>/// <br/>/// :<br/>/// amajor ::<br/>/// The major version number.<br/>/// aminor ::<br/>/// The minor version number.<br/>/// apatch ::<br/>/// The patch version number.<br/>/// <br/>/// In such cases, the library version might not be available before the<br/>/// library object has been created.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTLibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			fixed (int* paminor = &aminor)
			{
				FTLibraryVersionNative(library, amajor, (int*)paminor, apatch);
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Library_Version<br/>/// <br/>/// :<br/>/// Return the version of the FreeType library being used.  This is useful<br/>/// when dynamically linking to the library, since one cannot use the<br/>/// macros <br/>/// _MAJOR, <br/>/// _MINOR, and <br/>/// _PATCH.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A source library handle.<br/>/// <br/>/// :<br/>/// amajor ::<br/>/// The major version number.<br/>/// aminor ::<br/>/// The minor version number.<br/>/// apatch ::<br/>/// The patch version number.<br/>/// <br/>/// In such cases, the library version might not be available before the<br/>/// library object has been created.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTLibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					FTLibraryVersionNative(library, (int*)pamajor, (int*)paminor, apatch);
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Library_Version<br/>/// <br/>/// :<br/>/// Return the version of the FreeType library being used.  This is useful<br/>/// when dynamically linking to the library, since one cannot use the<br/>/// macros <br/>/// _MAJOR, <br/>/// _MINOR, and <br/>/// _PATCH.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A source library handle.<br/>/// <br/>/// :<br/>/// amajor ::<br/>/// The major version number.<br/>/// aminor ::<br/>/// The minor version number.<br/>/// apatch ::<br/>/// The patch version number.<br/>/// <br/>/// In such cases, the library version might not be available before the<br/>/// library object has been created.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTLibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* papatch = &apatch)
			{
				FTLibraryVersionNative(library, amajor, aminor, (int*)papatch);
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Library_Version<br/>/// <br/>/// :<br/>/// Return the version of the FreeType library being used.  This is useful<br/>/// when dynamically linking to the library, since one cannot use the<br/>/// macros <br/>/// _MAJOR, <br/>/// _MINOR, and <br/>/// _PATCH.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A source library handle.<br/>/// <br/>/// :<br/>/// amajor ::<br/>/// The major version number.<br/>/// aminor ::<br/>/// The minor version number.<br/>/// apatch ::<br/>/// The patch version number.<br/>/// <br/>/// In such cases, the library version might not be available before the<br/>/// library object has been created.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTLibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* papatch = &apatch)
				{
					FTLibraryVersionNative(library, (int*)pamajor, aminor, (int*)papatch);
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Library_Version<br/>/// <br/>/// :<br/>/// Return the version of the FreeType library being used.  This is useful<br/>/// when dynamically linking to the library, since one cannot use the<br/>/// macros <br/>/// _MAJOR, <br/>/// _MINOR, and <br/>/// _PATCH.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A source library handle.<br/>/// <br/>/// :<br/>/// amajor ::<br/>/// The major version number.<br/>/// aminor ::<br/>/// The minor version number.<br/>/// apatch ::<br/>/// The patch version number.<br/>/// <br/>/// In such cases, the library version might not be available before the<br/>/// library object has been created.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTLibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* paminor = &aminor)
			{
				fixed (int* papatch = &apatch)
				{
					FTLibraryVersionNative(library, amajor, (int*)paminor, (int*)papatch);
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Library_Version<br/>/// <br/>/// :<br/>/// Return the version of the FreeType library being used.  This is useful<br/>/// when dynamically linking to the library, since one cannot use the<br/>/// macros <br/>/// _MAJOR, <br/>/// _MINOR, and <br/>/// _PATCH.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A source library handle.<br/>/// <br/>/// :<br/>/// amajor ::<br/>/// The major version number.<br/>/// aminor ::<br/>/// The minor version number.<br/>/// apatch ::<br/>/// The patch version number.<br/>/// <br/>/// In such cases, the library version might not be available before the<br/>/// library object has been created.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTLibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					fixed (int* papatch = &apatch)
					{
						FTLibraryVersionNative(library, (int*)pamajor, (int*)paminor, (int*)papatch);
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_CheckTrueTypePatents<br/>
		/// <br/>
		/// :<br/>
		/// Deprecated, does nothing.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A face handle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_CheckTrueTypePatents")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Face_CheckTrueTypePatents")]
		internal static extern byte FTFaceCheckTrueTypePatentsNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Face_CheckTrueTypePatents<br/>/// <br/>/// :<br/>/// Deprecated, does nothing.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A face handle.<br/>/// <br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_CheckTrueTypePatents")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTFaceCheckTrueTypePatents([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			byte ret = FTFaceCheckTrueTypePatentsNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_SetUnpatentedHinting<br/>
		/// <br/>
		/// :<br/>
		/// Deprecated, does nothing.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A face handle.<br/>
		/// value ::<br/>
		/// New boolean setting.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_SetUnpatentedHinting")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Face_SetUnpatentedHinting")]
		internal static extern byte FTFaceSetUnpatentedHintingNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "FT_Bool")] byte value);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Face_SetUnpatentedHinting<br/>/// <br/>/// :<br/>/// Deprecated, does nothing.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A face handle.<br/>/// value ::<br/>/// New boolean setting.<br/>/// <br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_SetUnpatentedHinting")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTFaceSetUnpatentedHinting([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "FT_Bool")] byte value)
		{
			byte ret = FTFaceSetUnpatentedHintingNative(face, value);
			return ret;
		}

	}
}
