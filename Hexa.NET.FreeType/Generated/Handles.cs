// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Memory<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a given memory manager object, defined with an<br/>
	/// <br/>
	/// _MemoryRec structure.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Memory")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTMemory : IEquatable<FTMemory>
	{
		public FTMemory(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTMemory Null => new FTMemory(0);
		public static implicit operator FTMemory(nint handle) => new FTMemory(handle);
		public static bool operator ==(FTMemory left, FTMemory right) => left.Handle == right.Handle;
		public static bool operator !=(FTMemory left, FTMemory right) => left.Handle != right.Handle;
		public static bool operator ==(FTMemory left, nint right) => left.Handle == right;
		public static bool operator !=(FTMemory left, nint right) => left.Handle != right;
		public bool Equals(FTMemory other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTMemory handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTMemory [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Stream<br/>
	/// <br/>
	/// :<br/>
	/// A handle to an input stream.<br/>
	/// <br/>
	/// :<br/>
	/// See <br/>
	/// _StreamRec for the publicly accessible fields of a given stream<br/>
	/// object.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Stream")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTStream : IEquatable<FTStream>
	{
		public FTStream(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTStream Null => new FTStream(0);
		public static implicit operator FTStream(nint handle) => new FTStream(handle);
		public static bool operator ==(FTStream left, FTStream right) => left.Handle == right.Handle;
		public static bool operator !=(FTStream left, FTStream right) => left.Handle != right.Handle;
		public static bool operator ==(FTStream left, nint right) => left.Handle == right;
		public static bool operator !=(FTStream left, nint right) => left.Handle != right;
		public bool Equals(FTStream other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTStream handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTStream [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Raster<br/>
	/// <br/>
	/// :<br/>
	/// An opaque handle (pointer) to a raster object.  Each object can be<br/>
	/// used independently to convert an outline into a bitmap or pixmap.<br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Raster")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTRaster : IEquatable<FTRaster>
	{
		public FTRaster(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTRaster Null => new FTRaster(0);
		public static implicit operator FTRaster(nint handle) => new FTRaster(handle);
		public static bool operator ==(FTRaster left, FTRaster right) => left.Handle == right.Handle;
		public static bool operator !=(FTRaster left, FTRaster right) => left.Handle != right.Handle;
		public static bool operator ==(FTRaster left, nint right) => left.Handle == right;
		public static bool operator !=(FTRaster left, nint right) => left.Handle != right;
		public bool Equals(FTRaster other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTRaster handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTRaster [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Bytes<br/>
	/// <br/>
	/// :<br/>
	/// A typedef for constant memory areas.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Bytes")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTBytes : IEquatable<FTBytes>
	{
		public FTBytes(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTBytes Null => new FTBytes(0);
		public static implicit operator FTBytes(nint handle) => new FTBytes(handle);
		public static bool operator ==(FTBytes left, FTBytes right) => left.Handle == right.Handle;
		public static bool operator !=(FTBytes left, FTBytes right) => left.Handle != right.Handle;
		public static bool operator ==(FTBytes left, nint right) => left.Handle == right;
		public static bool operator !=(FTBytes left, nint right) => left.Handle != right;
		public bool Equals(FTBytes other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTBytes handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTBytes [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Pointer<br/>
	/// <br/>
	/// :<br/>
	/// A simple typedef for a typeless pointer.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Pointer")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTPointer : IEquatable<FTPointer>
	{
		public FTPointer(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTPointer Null => new FTPointer(0);
		public static implicit operator FTPointer(nint handle) => new FTPointer(handle);
		public static bool operator ==(FTPointer left, FTPointer right) => left.Handle == right.Handle;
		public static bool operator !=(FTPointer left, FTPointer right) => left.Handle != right.Handle;
		public static bool operator ==(FTPointer left, nint right) => left.Handle == right;
		public static bool operator !=(FTPointer left, nint right) => left.Handle != right;
		public bool Equals(FTPointer other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTPointer handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTPointer [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_ListNode<br/>
	/// <br/>
	/// :<br/>
	/// Many elements and objects in FreeType are listed through an <br/>
	/// _List<br/>
	/// record (see <br/>
	/// _ListRec).  As its name suggests, an FT_ListNode is a<br/>
	/// handle to a single list element.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_ListNode")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTListNode : IEquatable<FTListNode>
	{
		public FTListNode(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTListNode Null => new FTListNode(0);
		public static implicit operator FTListNode(nint handle) => new FTListNode(handle);
		public static bool operator ==(FTListNode left, FTListNode right) => left.Handle == right.Handle;
		public static bool operator !=(FTListNode left, FTListNode right) => left.Handle != right.Handle;
		public static bool operator ==(FTListNode left, nint right) => left.Handle == right;
		public static bool operator !=(FTListNode left, nint right) => left.Handle != right;
		public bool Equals(FTListNode other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTListNode handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTListNode [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_List<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a list record (see <br/>
	/// _ListRec).<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_List")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTList : IEquatable<FTList>
	{
		public FTList(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTList Null => new FTList(0);
		public static implicit operator FTList(nint handle) => new FTList(handle);
		public static bool operator ==(FTList left, FTList right) => left.Handle == right.Handle;
		public static bool operator !=(FTList left, FTList right) => left.Handle != right.Handle;
		public static bool operator ==(FTList left, nint right) => left.Handle == right;
		public static bool operator !=(FTList left, nint right) => left.Handle != right;
		public bool Equals(FTList other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTList handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTList [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Library<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a FreeType library instance.  Each 'library' is completely<br/>
	/// independent from the others; it is the 'root' of a set of objects like<br/>
	/// fonts, faces, sizes, etc.<br/>
	/// It also embeds a memory manager (see <br/>
	/// _Memory), as well as a<br/>
	/// scan-line converter object (see <br/>
	/// _Raster).<br/>
	/// [Since 2.5.6] In multi-threaded applications it is easiest to use one<br/>
	/// `FT_Library` object per thread.  In case this is too cumbersome, a<br/>
	/// single `FT_Library` object across threads is possible also, as long as<br/>
	/// a mutex lock is used around <br/>
	/// _New_Face and <br/>
	/// _Done_Face.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Library")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTLibrary : IEquatable<FTLibrary>
	{
		public FTLibrary(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTLibrary Null => new FTLibrary(0);
		public static implicit operator FTLibrary(nint handle) => new FTLibrary(handle);
		public static bool operator ==(FTLibrary left, FTLibrary right) => left.Handle == right.Handle;
		public static bool operator !=(FTLibrary left, FTLibrary right) => left.Handle != right.Handle;
		public static bool operator ==(FTLibrary left, nint right) => left.Handle == right;
		public static bool operator !=(FTLibrary left, nint right) => left.Handle != right;
		public bool Equals(FTLibrary other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTLibrary handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTLibrary [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Module<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a given FreeType module object.  A module can be a font<br/>
	/// driver, a renderer, or anything else that provides services to the<br/>
	/// former.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Module")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTModule : IEquatable<FTModule>
	{
		public FTModule(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTModule Null => new FTModule(0);
		public static implicit operator FTModule(nint handle) => new FTModule(handle);
		public static bool operator ==(FTModule left, FTModule right) => left.Handle == right.Handle;
		public static bool operator !=(FTModule left, FTModule right) => left.Handle != right.Handle;
		public static bool operator ==(FTModule left, nint right) => left.Handle == right;
		public static bool operator !=(FTModule left, nint right) => left.Handle != right;
		public bool Equals(FTModule other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTModule handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTModule [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Driver<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a given FreeType font driver object.  A font driver is a<br/>
	/// module capable of creating faces from font files.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Driver")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTDriver : IEquatable<FTDriver>
	{
		public FTDriver(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTDriver Null => new FTDriver(0);
		public static implicit operator FTDriver(nint handle) => new FTDriver(handle);
		public static bool operator ==(FTDriver left, FTDriver right) => left.Handle == right.Handle;
		public static bool operator !=(FTDriver left, FTDriver right) => left.Handle != right.Handle;
		public static bool operator ==(FTDriver left, nint right) => left.Handle == right;
		public static bool operator !=(FTDriver left, nint right) => left.Handle != right;
		public bool Equals(FTDriver other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTDriver handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTDriver [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Renderer<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a given FreeType renderer.  A renderer is a module in<br/>
	/// charge of converting a glyph's outline image to a bitmap.  It supports<br/>
	/// a single glyph image format, and one or more target surface depths.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Renderer")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTRenderer : IEquatable<FTRenderer>
	{
		public FTRenderer(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTRenderer Null => new FTRenderer(0);
		public static implicit operator FTRenderer(nint handle) => new FTRenderer(handle);
		public static bool operator ==(FTRenderer left, FTRenderer right) => left.Handle == right.Handle;
		public static bool operator !=(FTRenderer left, FTRenderer right) => left.Handle != right.Handle;
		public static bool operator ==(FTRenderer left, nint right) => left.Handle == right;
		public static bool operator !=(FTRenderer left, nint right) => left.Handle != right;
		public bool Equals(FTRenderer other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTRenderer handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTRenderer [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Face<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a typographic face object.  A face object models a given<br/>
	/// typeface, in a given style.<br/>
	/// <br/>
	/// Use <br/>
	/// _New_Face or <br/>
	/// _Open_Face to create a new face object from a<br/>
	/// given filepath or a custom input stream.<br/>
	/// Use <br/>
	/// _Done_Face to destroy it (along with its slot and sizes).<br/>
	/// An `FT_Face` object can only be safely used from one thread at a time.<br/>
	/// Similarly, creation and destruction of `FT_Face` with the same<br/>
	/// <br/>
	/// _Library object can only be done from one thread at a time.  On the<br/>
	/// other hand, functions like <br/>
	/// _Load_Glyph and its siblings are<br/>
	/// thread-safe and do not need the lock to be held as long as the same<br/>
	/// `FT_Face` object is not used from multiple threads at the same time.<br/>
	/// <br/>
	/// :<br/>
	/// See <br/>
	/// _FaceRec for the publicly accessible fields of a given face<br/>
	/// object.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Face")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTFace : IEquatable<FTFace>
	{
		public FTFace(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTFace Null => new FTFace(0);
		public static implicit operator FTFace(nint handle) => new FTFace(handle);
		public static bool operator ==(FTFace left, FTFace right) => left.Handle == right.Handle;
		public static bool operator !=(FTFace left, FTFace right) => left.Handle != right.Handle;
		public static bool operator ==(FTFace left, nint right) => left.Handle == right;
		public static bool operator !=(FTFace left, nint right) => left.Handle != right;
		public bool Equals(FTFace other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTFace handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTFace [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Size<br/>
	/// <br/>
	/// :<br/>
	/// A handle to an object that models a face scaled to a given character<br/>
	/// size.<br/>
	/// <br/>
	/// A newly created `FT_Size` object contains only meaningless zero values.<br/>
	/// You must use <br/>
	/// _Set_Char_Size, <br/>
	/// _Set_Pixel_Sizes, <br/>
	/// _Request_Size<br/>
	/// or even <br/>
	/// _Select_Size to change the content (i.e., the scaling<br/>
	/// values) of the active `FT_Size`.  Otherwise, the scaling and hinting<br/>
	/// will not be performed.<br/>
	/// You can use <br/>
	/// _New_Size to create additional size objects for a given<br/>
	/// <br/>
	/// _Face, but they won't be used by other functions until you activate<br/>
	/// it through <br/>
	/// _Activate_Size.  Only one size can be activated at any<br/>
	/// given time per face.<br/>
	/// <br/>
	/// :<br/>
	/// See <br/>
	/// _SizeRec for the publicly accessible fields of a given size<br/>
	/// object.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Size")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTSize : IEquatable<FTSize>
	{
		public FTSize(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTSize Null => new FTSize(0);
		public static implicit operator FTSize(nint handle) => new FTSize(handle);
		public static bool operator ==(FTSize left, FTSize right) => left.Handle == right.Handle;
		public static bool operator !=(FTSize left, FTSize right) => left.Handle != right.Handle;
		public static bool operator ==(FTSize left, nint right) => left.Handle == right;
		public static bool operator !=(FTSize left, nint right) => left.Handle != right;
		public bool Equals(FTSize other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTSize handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTSize [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_GlyphSlot<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a given 'glyph slot'.  A slot is a container that can hold<br/>
	/// any of the glyphs contained in its parent face.<br/>
	/// In other words, each time you call <br/>
	/// _Load_Glyph or <br/>
	/// _Load_Char,<br/>
	/// the slot's content is erased by the new glyph data, i.e., the glyph's<br/>
	/// metrics, its image (bitmap or outline), and other control information.<br/>
	/// <br/>
	/// :<br/>
	/// See <br/>
	/// _GlyphSlotRec for the publicly accessible glyph fields.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_GlyphSlot")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTGlyphSlot : IEquatable<FTGlyphSlot>
	{
		public FTGlyphSlot(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTGlyphSlot Null => new FTGlyphSlot(0);
		public static implicit operator FTGlyphSlot(nint handle) => new FTGlyphSlot(handle);
		public static bool operator ==(FTGlyphSlot left, FTGlyphSlot right) => left.Handle == right.Handle;
		public static bool operator !=(FTGlyphSlot left, FTGlyphSlot right) => left.Handle != right.Handle;
		public static bool operator ==(FTGlyphSlot left, nint right) => left.Handle == right;
		public static bool operator !=(FTGlyphSlot left, nint right) => left.Handle != right;
		public bool Equals(FTGlyphSlot other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTGlyphSlot handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTGlyphSlot [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_CharMap<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a character map (usually abbreviated to 'charmap').  A<br/>
	/// charmap is used to translate character codes in a given encoding into<br/>
	/// glyph indexes for its parent's face.  Some font formats may provide<br/>
	/// several charmaps per font.<br/>
	/// Each face object owns zero or more charmaps, but only one of them can<br/>
	/// be 'active', providing the data used by <br/>
	/// _Get_Char_Index or<br/>
	/// <br/>
	/// _Load_Char.<br/>
	/// The list of available charmaps in a face is available through the<br/>
	/// `face->num_charmaps` and `face->charmaps` fields of <br/>
	/// _FaceRec.<br/>
	/// The currently active charmap is available as `face->charmap`.  You<br/>
	/// should call <br/>
	/// _Set_Charmap to change it.<br/>
	/// <br/>
	/// <br/>
	/// :<br/>
	/// See <br/>
	/// _CharMapRec for the publicly accessible fields of a given<br/>
	/// character map.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_CharMap")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTCharMap : IEquatable<FTCharMap>
	{
		public FTCharMap(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTCharMap Null => new FTCharMap(0);
		public static implicit operator FTCharMap(nint handle) => new FTCharMap(handle);
		public static bool operator ==(FTCharMap left, FTCharMap right) => left.Handle == right.Handle;
		public static bool operator !=(FTCharMap left, FTCharMap right) => left.Handle != right.Handle;
		public static bool operator ==(FTCharMap left, nint right) => left.Handle == right;
		public static bool operator !=(FTCharMap left, nint right) => left.Handle != right;
		public bool Equals(FTCharMap other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTCharMap handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTCharMap [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Face_Internal<br/>
	/// <br/>
	/// :<br/>
	/// An opaque handle to an `FT_Face_InternalRec` structure that models the<br/>
	/// private data of a given <br/>
	/// _Face object.<br/>
	/// This structure might change between releases of FreeType~2 and is not<br/>
	/// generally available to client applications.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Face_Internal")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTFaceInternal : IEquatable<FTFaceInternal>
	{
		public FTFaceInternal(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTFaceInternal Null => new FTFaceInternal(0);
		public static implicit operator FTFaceInternal(nint handle) => new FTFaceInternal(handle);
		public static bool operator ==(FTFaceInternal left, FTFaceInternal right) => left.Handle == right.Handle;
		public static bool operator !=(FTFaceInternal left, FTFaceInternal right) => left.Handle != right.Handle;
		public static bool operator ==(FTFaceInternal left, nint right) => left.Handle == right;
		public static bool operator !=(FTFaceInternal left, nint right) => left.Handle != right;
		public bool Equals(FTFaceInternal other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTFaceInternal handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTFaceInternal [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Size_Internal<br/>
	/// <br/>
	/// :<br/>
	/// An opaque handle to an `FT_Size_InternalRec` structure, used to model<br/>
	/// private data of a given <br/>
	/// _Size object.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Size_Internal")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTSizeInternal : IEquatable<FTSizeInternal>
	{
		public FTSizeInternal(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTSizeInternal Null => new FTSizeInternal(0);
		public static implicit operator FTSizeInternal(nint handle) => new FTSizeInternal(handle);
		public static bool operator ==(FTSizeInternal left, FTSizeInternal right) => left.Handle == right.Handle;
		public static bool operator !=(FTSizeInternal left, FTSizeInternal right) => left.Handle != right.Handle;
		public static bool operator ==(FTSizeInternal left, nint right) => left.Handle == right;
		public static bool operator !=(FTSizeInternal left, nint right) => left.Handle != right;
		public bool Equals(FTSizeInternal other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTSizeInternal handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTSizeInternal [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_SubGlyph<br/>
	/// <br/>
	/// :<br/>
	/// The subglyph structure is an internal object used to describe<br/>
	/// subglyphs (for example, in the case of composites).<br/>
	/// <br/>
	/// You can however retrieve subglyph information with<br/>
	/// <br/>
	/// _Get_SubGlyph_Info.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_SubGlyph")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTSubGlyph : IEquatable<FTSubGlyph>
	{
		public FTSubGlyph(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTSubGlyph Null => new FTSubGlyph(0);
		public static implicit operator FTSubGlyph(nint handle) => new FTSubGlyph(handle);
		public static bool operator ==(FTSubGlyph left, FTSubGlyph right) => left.Handle == right.Handle;
		public static bool operator !=(FTSubGlyph left, FTSubGlyph right) => left.Handle != right.Handle;
		public static bool operator ==(FTSubGlyph left, nint right) => left.Handle == right;
		public static bool operator !=(FTSubGlyph left, nint right) => left.Handle != right;
		public bool Equals(FTSubGlyph other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTSubGlyph handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTSubGlyph [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// :<br/>
	/// FT_Slot_Internal<br/>
	/// <br/>
	/// :<br/>
	/// An opaque handle to an `FT_Slot_InternalRec` structure, used to model<br/>
	/// private data of a given <br/>
	/// _GlyphSlot object.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Slot_Internal")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTSlotInternal : IEquatable<FTSlotInternal>
	{
		public FTSlotInternal(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTSlotInternal Null => new FTSlotInternal(0);
		public static implicit operator FTSlotInternal(nint handle) => new FTSlotInternal(handle);
		public static bool operator ==(FTSlotInternal left, FTSlotInternal right) => left.Handle == right.Handle;
		public static bool operator !=(FTSlotInternal left, FTSlotInternal right) => left.Handle != right.Handle;
		public static bool operator ==(FTSlotInternal left, nint right) => left.Handle == right;
		public static bool operator !=(FTSlotInternal left, nint right) => left.Handle != right;
		public bool Equals(FTSlotInternal other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTSlotInternal handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTSlotInternal [0x{0}]", Handle.ToString("X"));
	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Size_Request<br/>
	/// <br/>
	/// :<br/>
	/// A handle to a size request structure.<br/>
	/// </summary>
	[NativeName(NativeNameType.Typedef, "FT_Size_Request")]
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	public readonly partial struct FTSizeRequest : IEquatable<FTSizeRequest>
	{
		public FTSizeRequest(nint handle) { Handle = handle; }
		public nint Handle { get; }
		public bool IsNull => Handle == 0;
		public static FTSizeRequest Null => new FTSizeRequest(0);
		public static implicit operator FTSizeRequest(nint handle) => new FTSizeRequest(handle);
		public static bool operator ==(FTSizeRequest left, FTSizeRequest right) => left.Handle == right.Handle;
		public static bool operator !=(FTSizeRequest left, FTSizeRequest right) => left.Handle != right.Handle;
		public static bool operator ==(FTSizeRequest left, nint right) => left.Handle == right;
		public static bool operator !=(FTSizeRequest left, nint right) => left.Handle != right;
		public bool Equals(FTSizeRequest other) => Handle == other.Handle;
		/// <inheritdoc/>
		public override bool Equals(object obj) => obj is FTSizeRequest handle && Equals(handle);
		/// <inheritdoc/>
		public override int GetHashCode() => Handle.GetHashCode();
		private string DebuggerDisplay => string.Format("FTSizeRequest [0x{0}]", Handle.ToString("X"));
	}

}
