// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	public unsafe partial class FreeType
	{

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Color_Glyph_Layer<br/>/// <br/>/// :<br/>/// This is an interface to the 'COLR' table in OpenType fonts to<br/>/// iteratively retrieve the colored glyph layers associated with the<br/>/// current glyph slot.<br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>/// The glyph layer data for a given glyph index, if present, provides an<br/>/// alternative, multi-color glyph representation: Instead of rendering<br/>/// the outline or bitmap with the given glyph index, glyphs with the<br/>/// indices and colors returned by this function are rendered layer by<br/>/// layer.<br/>/// The returned elements are ordered in the z~direction from bottom to<br/>/// top; the 'n'th element should be rendered with the associated palette<br/>/// color and blended on top of the already rendered layers (elements 0,<br/>/// 1, ..., n-1).<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// base_glyph ::<br/>/// The glyph index the colored glyph layers are associated with.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// An <br/>/// _LayerIterator object.  For the first call you should set<br/>/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>/// same object again.<br/>/// <br/>/// :<br/>/// aglyph_index ::<br/>/// The glyph index of the current layer.<br/>/// acolor_index ::<br/>/// The color index into the font face's color palette of the current<br/>/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>/// entry but indicates that the text foreground color should be used<br/>/// instead (to be set up by the application outside of FreeType).<br/>/// The color palette can be retrieved with <br/>/// _Palette_Select.<br/>/// <br/>/// <br/>/// Note that <br/>/// _Render_Glyph is able to handle colored glyph layers<br/>/// automatically if the <br/>/// _LOAD_COLOR flag is passed to a previous call<br/>/// to <br/>/// _Load_Glyph.  [This is an experimental feature.]<br/>/// <br/>/// ```<br/>/// FT_Color*         palette;<br/>/// FT_LayerIterator  iterator;<br/>/// FT_Bool  have_layers;<br/>/// FT_UInt  layer_glyph_index;<br/>/// FT_UInt  layer_color_index;<br/>/// error = FT_Palette_Select( face, palette_index, <br/>/// &palette<br/>/// );<br/>/// if ( error )<br/>/// palette = NULL;<br/>/// iterator.p  = NULL;<br/>/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>/// glyph_index,<br/>/// <br/>/// &layer<br/>/// _glyph_index,<br/>/// <br/>/// &layer<br/>/// _color_index,<br/>/// <br/>/// &iterator<br/>/// );<br/>/// if ( palette <br/>/// &<br/>/// &<br/>/// have_layers )<br/>/// {<br/>/// do<br/>/// {<br/>/// FT_Color  layer_color;<br/>/// if ( layer_color_index == 0xFFFF )<br/>/// layer_color = text_foreground_color;<br/>/// else<br/>/// layer_color = palette[layer_color_index];<br/>/// // Load and render glyph `layer_glyph_index', then<br/>/// // blend resulting pixmap (using color `layer_color')<br/>/// // with previously created pixmaps.<br/>/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>/// glyph_index,<br/>/// <br/>/// &layer<br/>/// _glyph_index,<br/>/// <br/>/// &layer<br/>/// _color_index,<br/>/// <br/>/// &iterator<br/>/// ) );<br/>/// }<br/>/// ```<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator)
		{
			fixed (uint* pacolorIndex = &acolorIndex)
			{
				fixed (FTLayerIterator* piterator = &iterator)
				{
					byte ret = FTGetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, (uint*)pacolorIndex, (FTLayerIterator*)piterator);
					return ret;
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Color_Glyph_Layer<br/>/// <br/>/// :<br/>/// This is an interface to the 'COLR' table in OpenType fonts to<br/>/// iteratively retrieve the colored glyph layers associated with the<br/>/// current glyph slot.<br/>/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>/// The glyph layer data for a given glyph index, if present, provides an<br/>/// alternative, multi-color glyph representation: Instead of rendering<br/>/// the outline or bitmap with the given glyph index, glyphs with the<br/>/// indices and colors returned by this function are rendered layer by<br/>/// layer.<br/>/// The returned elements are ordered in the z~direction from bottom to<br/>/// top; the 'n'th element should be rendered with the associated palette<br/>/// color and blended on top of the already rendered layers (elements 0,<br/>/// 1, ..., n-1).<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// base_glyph ::<br/>/// The glyph index the colored glyph layers are associated with.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// An <br/>/// _LayerIterator object.  For the first call you should set<br/>/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>/// same object again.<br/>/// <br/>/// :<br/>/// aglyph_index ::<br/>/// The glyph index of the current layer.<br/>/// acolor_index ::<br/>/// The color index into the font face's color palette of the current<br/>/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>/// entry but indicates that the text foreground color should be used<br/>/// instead (to be set up by the application outside of FreeType).<br/>/// The color palette can be retrieved with <br/>/// _Palette_Select.<br/>/// <br/>/// <br/>/// Note that <br/>/// _Render_Glyph is able to handle colored glyph layers<br/>/// automatically if the <br/>/// _LOAD_COLOR flag is passed to a previous call<br/>/// to <br/>/// _Load_Glyph.  [This is an experimental feature.]<br/>/// <br/>/// ```<br/>/// FT_Color*         palette;<br/>/// FT_LayerIterator  iterator;<br/>/// FT_Bool  have_layers;<br/>/// FT_UInt  layer_glyph_index;<br/>/// FT_UInt  layer_color_index;<br/>/// error = FT_Palette_Select( face, palette_index, <br/>/// &palette<br/>/// );<br/>/// if ( error )<br/>/// palette = NULL;<br/>/// iterator.p  = NULL;<br/>/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>/// glyph_index,<br/>/// <br/>/// &layer<br/>/// _glyph_index,<br/>/// <br/>/// &layer<br/>/// _color_index,<br/>/// <br/>/// &iterator<br/>/// );<br/>/// if ( palette <br/>/// &<br/>/// &<br/>/// have_layers )<br/>/// {<br/>/// do<br/>/// {<br/>/// FT_Color  layer_color;<br/>/// if ( layer_color_index == 0xFFFF )<br/>/// layer_color = text_foreground_color;<br/>/// else<br/>/// layer_color = palette[layer_color_index];<br/>/// // Load and render glyph `layer_glyph_index', then<br/>/// // blend resulting pixmap (using color `layer_color')<br/>/// // with previously created pixmaps.<br/>/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>/// glyph_index,<br/>/// <br/>/// &layer<br/>/// _glyph_index,<br/>/// <br/>/// &layer<br/>/// _color_index,<br/>/// <br/>/// &iterator<br/>/// ) );<br/>/// }<br/>/// ```<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator)
		{
			fixed (uint* paglyphIndex = &aglyphIndex)
			{
				fixed (uint* pacolorIndex = &acolorIndex)
				{
					fixed (FTLayerIterator* piterator = &iterator)
					{
						byte ret = FTGetColorGlyphLayerNative(face, baseGlyph, (uint*)paglyphIndex, (uint*)pacolorIndex, (FTLayerIterator*)piterator);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Paint<br/>
		/// <br/>
		/// :<br/>
		/// This is the starting point and interface to color gradient<br/>
		/// information in a 'COLR' v1 table in OpenType fonts to recursively<br/>
		/// retrieve the paint tables for the directed acyclic graph of a colored<br/>
		/// glyph, given a glyph ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// In a 'COLR' v1 font, each color glyph defines a directed acyclic<br/>
		/// graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,<br/>
		/// `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this<br/>
		/// function and specifying a glyph ID, one retrieves the root paint<br/>
		/// table for this glyph ID.<br/>
		/// This function allows control whether an initial root transform is<br/>
		/// returned to configure scaling, transform, and translation correctly<br/>
		/// on the client's graphics context.  The initial root transform is<br/>
		/// computed and returned according to the values configured for <br/>
		/// _Size<br/>
		/// and <br/>
		/// _Set_Transform on the <br/>
		/// _Face object, see below for details<br/>
		/// of the `root_transform` parameter.  This has implications for a<br/>
		/// client 'COLR' v1 implementation: When this function returns an<br/>
		/// initially computed root transform, at the time of executing the<br/>
		/// <br/>
		/// _PaintGlyph operation, the contours should be retrieved using<br/>
		/// <br/>
		/// _Load_Glyph at unscaled, untransformed size.  This is because the<br/>
		/// root transform applied to the graphics context will take care of<br/>
		/// correct scaling.<br/>
		/// Alternatively, to allow hinting of contours, at the time of executing<br/>
		/// <br/>
		/// _Load_Glyph, the current graphics context transformation matrix<br/>
		/// can be decomposed into a scaling matrix and a remainder, and<br/>
		/// <br/>
		/// _Load_Glyph can be used to retrieve the contours at scaled size.<br/>
		/// Care must then be taken to blit or clip to the graphics context with<br/>
		/// taking this remainder transformation into account.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index for which to retrieve the root paint table.<br/>
		/// root_transform ::<br/>
		/// Specifies whether an initially computed root is returned by the<br/>
		/// <br/>
		/// _PaintTransform operation to account for the activated size<br/>
		/// (see <br/>
		/// _Activate_Size) and the configured transform and translate<br/>
		/// (see <br/>
		/// _Set_Transform).<br/>
		/// This root transform is returned before nodes of the glyph graph of<br/>
		/// the font are returned.  Subsequent <br/>
		/// _COLR_Paint structures<br/>
		/// contain unscaled and untransformed values.  The inserted root<br/>
		/// transform enables the client application to apply an initial<br/>
		/// transform to its graphics context.  When executing subsequent<br/>
		/// FT_COLR_Paint operations, values from <br/>
		/// _COLR_Paint operations<br/>
		/// will ultimately be correctly scaled because of the root transform<br/>
		/// applied to the graphics context.  Use<br/>
		/// <br/>
		/// _COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use<br/>
		/// <br/>
		/// _COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be<br/>
		/// useful when traversing the 'COLR' v1 glyph graph and reaching a<br/>
		/// <br/>
		/// _PaintColrGlyph.  When recursing into <br/>
		/// _PaintColrGlyph and<br/>
		/// painting that inline, no additional root transform is needed as it<br/>
		/// has already been applied to the graphics context at the beginning<br/>
		/// of drawing this glyph.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_Color_Glyph_Paint")]
		internal static extern byte FTGetColorGlyphPaintNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "root_transform")] [NativeName(NativeNameType.Type, "FT_Color_Root_Transform")] FTColorRootTransform rootTransform, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] FTOpaquePaint* paint);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Color_Glyph_Paint<br/>/// <br/>/// :<br/>/// This is the starting point and interface to color gradient<br/>/// information in a 'COLR' v1 table in OpenType fonts to recursively<br/>/// retrieve the paint tables for the directed acyclic graph of a colored<br/>/// glyph, given a glyph ID.<br/>/// https://github.com/googlefonts/colr-gradients-spec<br/>/// In a 'COLR' v1 font, each color glyph defines a directed acyclic<br/>/// graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,<br/>/// `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this<br/>/// function and specifying a glyph ID, one retrieves the root paint<br/>/// table for this glyph ID.<br/>/// This function allows control whether an initial root transform is<br/>/// returned to configure scaling, transform, and translation correctly<br/>/// on the client's graphics context.  The initial root transform is<br/>/// computed and returned according to the values configured for <br/>/// _Size<br/>/// and <br/>/// _Set_Transform on the <br/>/// _Face object, see below for details<br/>/// of the `root_transform` parameter.  This has implications for a<br/>/// client 'COLR' v1 implementation: When this function returns an<br/>/// initially computed root transform, at the time of executing the<br/>/// <br/>/// _PaintGlyph operation, the contours should be retrieved using<br/>/// <br/>/// _Load_Glyph at unscaled, untransformed size.  This is because the<br/>/// root transform applied to the graphics context will take care of<br/>/// correct scaling.<br/>/// Alternatively, to allow hinting of contours, at the time of executing<br/>/// <br/>/// _Load_Glyph, the current graphics context transformation matrix<br/>/// can be decomposed into a scaling matrix and a remainder, and<br/>/// <br/>/// _Load_Glyph can be used to retrieve the contours at scaled size.<br/>/// Care must then be taken to blit or clip to the graphics context with<br/>/// taking this remainder transformation into account.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// base_glyph ::<br/>/// The glyph index for which to retrieve the root paint table.<br/>/// root_transform ::<br/>/// Specifies whether an initially computed root is returned by the<br/>/// <br/>/// _PaintTransform operation to account for the activated size<br/>/// (see <br/>/// _Activate_Size) and the configured transform and translate<br/>/// (see <br/>/// _Set_Transform).<br/>/// This root transform is returned before nodes of the glyph graph of<br/>/// the font are returned.  Subsequent <br/>/// _COLR_Paint structures<br/>/// contain unscaled and untransformed values.  The inserted root<br/>/// transform enables the client application to apply an initial<br/>/// transform to its graphics context.  When executing subsequent<br/>/// FT_COLR_Paint operations, values from <br/>/// _COLR_Paint operations<br/>/// will ultimately be correctly scaled because of the root transform<br/>/// applied to the graphics context.  Use<br/>/// <br/>/// _COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use<br/>/// <br/>/// _COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be<br/>/// useful when traversing the 'COLR' v1 glyph graph and reaching a<br/>/// <br/>/// _PaintColrGlyph.  When recursing into <br/>/// _PaintColrGlyph and<br/>/// painting that inline, no additional root transform is needed as it<br/>/// has already been applied to the graphics context at the beginning<br/>/// of drawing this glyph.<br/>/// <br/>/// :<br/>/// paint ::<br/>/// The <br/>/// _OpaquePaint object that references the actual paint table.<br/>/// The respective actual <br/>/// _COLR_Paint object is retrieved via<br/>/// <br/>/// _Get_Paint.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorGlyphPaint([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "root_transform")] [NativeName(NativeNameType.Type, "FT_Color_Root_Transform")] FTColorRootTransform rootTransform, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] FTOpaquePaint* paint)
		{
			byte ret = FTGetColorGlyphPaintNative(face, baseGlyph, rootTransform, paint);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Color_Glyph_Paint<br/>/// <br/>/// :<br/>/// This is the starting point and interface to color gradient<br/>/// information in a 'COLR' v1 table in OpenType fonts to recursively<br/>/// retrieve the paint tables for the directed acyclic graph of a colored<br/>/// glyph, given a glyph ID.<br/>/// https://github.com/googlefonts/colr-gradients-spec<br/>/// In a 'COLR' v1 font, each color glyph defines a directed acyclic<br/>/// graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,<br/>/// `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this<br/>/// function and specifying a glyph ID, one retrieves the root paint<br/>/// table for this glyph ID.<br/>/// This function allows control whether an initial root transform is<br/>/// returned to configure scaling, transform, and translation correctly<br/>/// on the client's graphics context.  The initial root transform is<br/>/// computed and returned according to the values configured for <br/>/// _Size<br/>/// and <br/>/// _Set_Transform on the <br/>/// _Face object, see below for details<br/>/// of the `root_transform` parameter.  This has implications for a<br/>/// client 'COLR' v1 implementation: When this function returns an<br/>/// initially computed root transform, at the time of executing the<br/>/// <br/>/// _PaintGlyph operation, the contours should be retrieved using<br/>/// <br/>/// _Load_Glyph at unscaled, untransformed size.  This is because the<br/>/// root transform applied to the graphics context will take care of<br/>/// correct scaling.<br/>/// Alternatively, to allow hinting of contours, at the time of executing<br/>/// <br/>/// _Load_Glyph, the current graphics context transformation matrix<br/>/// can be decomposed into a scaling matrix and a remainder, and<br/>/// <br/>/// _Load_Glyph can be used to retrieve the contours at scaled size.<br/>/// Care must then be taken to blit or clip to the graphics context with<br/>/// taking this remainder transformation into account.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// base_glyph ::<br/>/// The glyph index for which to retrieve the root paint table.<br/>/// root_transform ::<br/>/// Specifies whether an initially computed root is returned by the<br/>/// <br/>/// _PaintTransform operation to account for the activated size<br/>/// (see <br/>/// _Activate_Size) and the configured transform and translate<br/>/// (see <br/>/// _Set_Transform).<br/>/// This root transform is returned before nodes of the glyph graph of<br/>/// the font are returned.  Subsequent <br/>/// _COLR_Paint structures<br/>/// contain unscaled and untransformed values.  The inserted root<br/>/// transform enables the client application to apply an initial<br/>/// transform to its graphics context.  When executing subsequent<br/>/// FT_COLR_Paint operations, values from <br/>/// _COLR_Paint operations<br/>/// will ultimately be correctly scaled because of the root transform<br/>/// applied to the graphics context.  Use<br/>/// <br/>/// _COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use<br/>/// <br/>/// _COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be<br/>/// useful when traversing the 'COLR' v1 glyph graph and reaching a<br/>/// <br/>/// _PaintColrGlyph.  When recursing into <br/>/// _PaintColrGlyph and<br/>/// painting that inline, no additional root transform is needed as it<br/>/// has already been applied to the graphics context at the beginning<br/>/// of drawing this glyph.<br/>/// <br/>/// :<br/>/// paint ::<br/>/// The <br/>/// _OpaquePaint object that references the actual paint table.<br/>/// The respective actual <br/>/// _COLR_Paint object is retrieved via<br/>/// <br/>/// _Get_Paint.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorGlyphPaint([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "root_transform")] [NativeName(NativeNameType.Type, "FT_Color_Root_Transform")] FTColorRootTransform rootTransform, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] ref FTOpaquePaint paint)
		{
			fixed (FTOpaquePaint* ppaint = &paint)
			{
				byte ret = FTGetColorGlyphPaintNative(face, baseGlyph, rootTransform, (FTOpaquePaint*)ppaint);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_ClipBox<br/>
		/// <br/>
		/// :<br/>
		/// Search for a 'COLR' v1 clip box for the specified `base_glyph` and<br/>
		/// fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information<br/>
		/// if one is found.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index for which to retrieve the clip box.<br/>
		/// <br/>
		/// :<br/>
		/// clip_box ::<br/>
		/// The clip box for the requested `base_glyph` if one is found.  The<br/>
		/// clip box is computed taking scale and transformations configured on<br/>
		/// the <br/>
		/// _Face into account.  <br/>
		/// _ClipBox contains <br/>
		/// _Vector values<br/>
		/// in 26.6 format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_ClipBox")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_Color_Glyph_ClipBox")]
		internal static extern byte FTGetColorGlyphClipBoxNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "clip_box")] [NativeName(NativeNameType.Type, "FT_ClipBox*")] FTClipBox* clipBox);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Color_Glyph_ClipBox<br/>/// <br/>/// :<br/>/// Search for a 'COLR' v1 clip box for the specified `base_glyph` and<br/>/// fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information<br/>/// if one is found.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// base_glyph ::<br/>/// The glyph index for which to retrieve the clip box.<br/>/// <br/>/// :<br/>/// clip_box ::<br/>/// The clip box for the requested `base_glyph` if one is found.  The<br/>/// clip box is computed taking scale and transformations configured on<br/>/// the <br/>/// _Face into account.  <br/>/// _ClipBox contains <br/>/// _Vector values<br/>/// in 26.6 format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_ClipBox")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorGlyphClipBox([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "clip_box")] [NativeName(NativeNameType.Type, "FT_ClipBox*")] FTClipBox* clipBox)
		{
			byte ret = FTGetColorGlyphClipBoxNative(face, baseGlyph, clipBox);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Color_Glyph_ClipBox<br/>/// <br/>/// :<br/>/// Search for a 'COLR' v1 clip box for the specified `base_glyph` and<br/>/// fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information<br/>/// if one is found.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// base_glyph ::<br/>/// The glyph index for which to retrieve the clip box.<br/>/// <br/>/// :<br/>/// clip_box ::<br/>/// The clip box for the requested `base_glyph` if one is found.  The<br/>/// clip box is computed taking scale and transformations configured on<br/>/// the <br/>/// _Face into account.  <br/>/// _ClipBox contains <br/>/// _Vector values<br/>/// in 26.6 format.<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_ClipBox")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorGlyphClipBox([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "clip_box")] [NativeName(NativeNameType.Type, "FT_ClipBox*")] ref FTClipBox clipBox)
		{
			fixed (FTClipBox* pclipBox = &clipBox)
			{
				byte ret = FTGetColorGlyphClipBoxNative(face, baseGlyph, (FTClipBox*)pclipBox);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint_Layers<br/>
		/// <br/>
		/// :<br/>
		/// Access the layers of a `PaintColrLayers` table.<br/>
		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>
		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>
		/// layers of the `PaintColrLayers` table.<br/>
		/// The <br/>
		/// _PaintColrLayers object contains an <br/>
		/// _LayerIterator, which<br/>
		/// is used here to iterate over the layers.  Each layer is returned as<br/>
		/// an <br/>
		/// _OpaquePaint object, which then can be used with <br/>
		/// _Get_Paint<br/>
		/// to retrieve the actual paint object.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The <br/>
		/// _LayerIterator from an <br/>
		/// _PaintColrLayers object, for which<br/>
		/// the layers are to be retrieved.  The internal state of the iterator<br/>
		/// is incremented after one call to this function for retrieving one<br/>
		/// layer.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_Paint_Layers")]
		internal static extern byte FTGetPaintLayersNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] FTLayerIterator* iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] FTOpaquePaint* paint);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Paint_Layers<br/>/// <br/>/// :<br/>/// Access the layers of a `PaintColrLayers` table.<br/>/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>/// layers of the `PaintColrLayers` table.<br/>/// The <br/>/// _PaintColrLayers object contains an <br/>/// _LayerIterator, which<br/>/// is used here to iterate over the layers.  Each layer is returned as<br/>/// an <br/>/// _OpaquePaint object, which then can be used with <br/>/// _Get_Paint<br/>/// to retrieve the actual paint object.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// The <br/>/// _LayerIterator from an <br/>/// _PaintColrLayers object, for which<br/>/// the layers are to be retrieved.  The internal state of the iterator<br/>/// is incremented after one call to this function for retrieving one<br/>/// layer.<br/>/// <br/>/// :<br/>/// paint ::<br/>/// The <br/>/// _OpaquePaint object that references the actual paint table.<br/>/// The respective actual <br/>/// _COLR_Paint object is retrieved via<br/>/// <br/>/// _Get_Paint.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetPaintLayers([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] FTLayerIterator* iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] FTOpaquePaint* paint)
		{
			byte ret = FTGetPaintLayersNative(face, iterator, paint);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Paint_Layers<br/>/// <br/>/// :<br/>/// Access the layers of a `PaintColrLayers` table.<br/>/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>/// layers of the `PaintColrLayers` table.<br/>/// The <br/>/// _PaintColrLayers object contains an <br/>/// _LayerIterator, which<br/>/// is used here to iterate over the layers.  Each layer is returned as<br/>/// an <br/>/// _OpaquePaint object, which then can be used with <br/>/// _Get_Paint<br/>/// to retrieve the actual paint object.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// The <br/>/// _LayerIterator from an <br/>/// _PaintColrLayers object, for which<br/>/// the layers are to be retrieved.  The internal state of the iterator<br/>/// is incremented after one call to this function for retrieving one<br/>/// layer.<br/>/// <br/>/// :<br/>/// paint ::<br/>/// The <br/>/// _OpaquePaint object that references the actual paint table.<br/>/// The respective actual <br/>/// _COLR_Paint object is retrieved via<br/>/// <br/>/// _Get_Paint.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetPaintLayers([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] FTOpaquePaint* paint)
		{
			fixed (FTLayerIterator* piterator = &iterator)
			{
				byte ret = FTGetPaintLayersNative(face, (FTLayerIterator*)piterator, paint);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Paint_Layers<br/>/// <br/>/// :<br/>/// Access the layers of a `PaintColrLayers` table.<br/>/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>/// layers of the `PaintColrLayers` table.<br/>/// The <br/>/// _PaintColrLayers object contains an <br/>/// _LayerIterator, which<br/>/// is used here to iterate over the layers.  Each layer is returned as<br/>/// an <br/>/// _OpaquePaint object, which then can be used with <br/>/// _Get_Paint<br/>/// to retrieve the actual paint object.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// The <br/>/// _LayerIterator from an <br/>/// _PaintColrLayers object, for which<br/>/// the layers are to be retrieved.  The internal state of the iterator<br/>/// is incremented after one call to this function for retrieving one<br/>/// layer.<br/>/// <br/>/// :<br/>/// paint ::<br/>/// The <br/>/// _OpaquePaint object that references the actual paint table.<br/>/// The respective actual <br/>/// _COLR_Paint object is retrieved via<br/>/// <br/>/// _Get_Paint.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetPaintLayers([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] FTLayerIterator* iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] ref FTOpaquePaint paint)
		{
			fixed (FTOpaquePaint* ppaint = &paint)
			{
				byte ret = FTGetPaintLayersNative(face, iterator, (FTOpaquePaint*)ppaint);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Paint_Layers<br/>/// <br/>/// :<br/>/// Access the layers of a `PaintColrLayers` table.<br/>/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>/// layers of the `PaintColrLayers` table.<br/>/// The <br/>/// _PaintColrLayers object contains an <br/>/// _LayerIterator, which<br/>/// is used here to iterate over the layers.  Each layer is returned as<br/>/// an <br/>/// _OpaquePaint object, which then can be used with <br/>/// _Get_Paint<br/>/// to retrieve the actual paint object.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// The <br/>/// _LayerIterator from an <br/>/// _PaintColrLayers object, for which<br/>/// the layers are to be retrieved.  The internal state of the iterator<br/>/// is incremented after one call to this function for retrieving one<br/>/// layer.<br/>/// <br/>/// :<br/>/// paint ::<br/>/// The <br/>/// _OpaquePaint object that references the actual paint table.<br/>/// The respective actual <br/>/// _COLR_Paint object is retrieved via<br/>/// <br/>/// _Get_Paint.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetPaintLayers([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] ref FTOpaquePaint paint)
		{
			fixed (FTLayerIterator* piterator = &iterator)
			{
				fixed (FTOpaquePaint* ppaint = &paint)
				{
					byte ret = FTGetPaintLayersNative(face, (FTLayerIterator*)piterator, (FTOpaquePaint*)ppaint);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Colorline_Stops<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to color gradient information in a 'COLR' v1<br/>
		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>
		/// solid fill information for colored glyph layers for a specified glyph<br/>
		/// ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The retrieved <br/>
		/// _ColorStopIterator, configured on an <br/>
		/// _ColorLine,<br/>
		/// which in turn got retrieved via paint information in<br/>
		/// <br/>
		/// _PaintLinearGradient or <br/>
		/// _PaintRadialGradient.<br/>
		/// <br/>
		/// :<br/>
		/// color_stop ::<br/>
		/// Color index and alpha value for the retrieved color stop.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_Colorline_Stops")]
		internal static extern byte FTGetColorlineStopsNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop*")] FTColorStop* colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator*")] FTColorStopIterator* iterator);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Colorline_Stops<br/>/// <br/>/// :<br/>/// This is an interface to color gradient information in a 'COLR' v1<br/>/// table in OpenType fonts to iteratively retrieve the gradient and<br/>/// solid fill information for colored glyph layers for a specified glyph<br/>/// ID.<br/>/// https://github.com/googlefonts/colr-gradients-spec<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// The retrieved <br/>/// _ColorStopIterator, configured on an <br/>/// _ColorLine,<br/>/// which in turn got retrieved via paint information in<br/>/// <br/>/// _PaintLinearGradient or <br/>/// _PaintRadialGradient.<br/>/// <br/>/// :<br/>/// color_stop ::<br/>/// Color index and alpha value for the retrieved color stop.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorlineStops([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop*")] FTColorStop* colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator*")] FTColorStopIterator* iterator)
		{
			byte ret = FTGetColorlineStopsNative(face, colorStop, iterator);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Colorline_Stops<br/>/// <br/>/// :<br/>/// This is an interface to color gradient information in a 'COLR' v1<br/>/// table in OpenType fonts to iteratively retrieve the gradient and<br/>/// solid fill information for colored glyph layers for a specified glyph<br/>/// ID.<br/>/// https://github.com/googlefonts/colr-gradients-spec<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// The retrieved <br/>/// _ColorStopIterator, configured on an <br/>/// _ColorLine,<br/>/// which in turn got retrieved via paint information in<br/>/// <br/>/// _PaintLinearGradient or <br/>/// _PaintRadialGradient.<br/>/// <br/>/// :<br/>/// color_stop ::<br/>/// Color index and alpha value for the retrieved color stop.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorlineStops([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop*")] ref FTColorStop colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator*")] FTColorStopIterator* iterator)
		{
			fixed (FTColorStop* pcolorStop = &colorStop)
			{
				byte ret = FTGetColorlineStopsNative(face, (FTColorStop*)pcolorStop, iterator);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Colorline_Stops<br/>/// <br/>/// :<br/>/// This is an interface to color gradient information in a 'COLR' v1<br/>/// table in OpenType fonts to iteratively retrieve the gradient and<br/>/// solid fill information for colored glyph layers for a specified glyph<br/>/// ID.<br/>/// https://github.com/googlefonts/colr-gradients-spec<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// The retrieved <br/>/// _ColorStopIterator, configured on an <br/>/// _ColorLine,<br/>/// which in turn got retrieved via paint information in<br/>/// <br/>/// _PaintLinearGradient or <br/>/// _PaintRadialGradient.<br/>/// <br/>/// :<br/>/// color_stop ::<br/>/// Color index and alpha value for the retrieved color stop.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorlineStops([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop*")] FTColorStop* colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator*")] ref FTColorStopIterator iterator)
		{
			fixed (FTColorStopIterator* piterator = &iterator)
			{
				byte ret = FTGetColorlineStopsNative(face, colorStop, (FTColorStopIterator*)piterator);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Colorline_Stops<br/>/// <br/>/// :<br/>/// This is an interface to color gradient information in a 'COLR' v1<br/>/// table in OpenType fonts to iteratively retrieve the gradient and<br/>/// solid fill information for colored glyph layers for a specified glyph<br/>/// ID.<br/>/// https://github.com/googlefonts/colr-gradients-spec<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// <br/>/// :<br/>/// iterator ::<br/>/// The retrieved <br/>/// _ColorStopIterator, configured on an <br/>/// _ColorLine,<br/>/// which in turn got retrieved via paint information in<br/>/// <br/>/// _PaintLinearGradient or <br/>/// _PaintRadialGradient.<br/>/// <br/>/// :<br/>/// color_stop ::<br/>/// Color index and alpha value for the retrieved color stop.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetColorlineStops([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop*")] ref FTColorStop colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator*")] ref FTColorStopIterator iterator)
		{
			fixed (FTColorStop* pcolorStop = &colorStop)
			{
				fixed (FTColorStopIterator* piterator = &iterator)
				{
					byte ret = FTGetColorlineStopsNative(face, (FTColorStop*)pcolorStop, (FTColorStopIterator*)piterator);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint<br/>
		/// <br/>
		/// :<br/>
		/// Access the details of a paint using an <br/>
		/// _OpaquePaint opaque paint<br/>
		/// object, which internally stores the offset to the respective `Paint`<br/>
		/// object in the 'COLR' table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// opaque_paint ::<br/>
		/// The opaque paint object for which the underlying <br/>
		/// _COLR_Paint<br/>
		/// data is to be retrieved.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The specific <br/>
		/// _COLR_Paint object containing information coming<br/>
		/// from one of the font's `Paint*` tables.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_Paint")]
		internal static extern byte FTGetPaintNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "opaque_paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint")] FTOpaquePaint opaquePaint, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_COLR_Paint*")] FTCOLRPaint* paint);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Paint<br/>/// <br/>/// :<br/>/// Access the details of a paint using an <br/>/// _OpaquePaint opaque paint<br/>/// object, which internally stores the offset to the respective `Paint`<br/>/// object in the 'COLR' table.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// opaque_paint ::<br/>/// The opaque paint object for which the underlying <br/>/// _COLR_Paint<br/>/// data is to be retrieved.<br/>/// <br/>/// :<br/>/// paint ::<br/>/// The specific <br/>/// _COLR_Paint object containing information coming<br/>/// from one of the font's `Paint*` tables.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetPaint([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "opaque_paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint")] FTOpaquePaint opaquePaint, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_COLR_Paint*")] FTCOLRPaint* paint)
		{
			byte ret = FTGetPaintNative(face, opaquePaint, paint);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Paint<br/>/// <br/>/// :<br/>/// Access the details of a paint using an <br/>/// _OpaquePaint opaque paint<br/>/// object, which internally stores the offset to the respective `Paint`<br/>/// object in the 'COLR' table.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the parent face object.<br/>/// opaque_paint ::<br/>/// The opaque paint object for which the underlying <br/>/// _COLR_Paint<br/>/// data is to be retrieved.<br/>/// <br/>/// :<br/>/// paint ::<br/>/// The specific <br/>/// _COLR_Paint object containing information coming<br/>/// from one of the font's `Paint*` tables.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FTGetPaint([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "opaque_paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint")] FTOpaquePaint opaquePaint, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_COLR_Paint*")] ref FTCOLRPaint paint)
		{
			fixed (FTCOLRPaint* ppaint = &paint)
			{
				byte ret = FTGetPaintNative(face, opaquePaint, (FTCOLRPaint*)ppaint);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Init<br/>
		/// <br/>
		/// :<br/>
		/// Initialize a pointer to an <br/>
		/// _Bitmap structure.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the bitmap structure.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Init")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Bitmap_Init")]
		internal static extern void FTBitmapInitNative([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* abitmap);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Init<br/>/// <br/>/// :<br/>/// Initialize a pointer to an <br/>/// _Bitmap structure.<br/>/// <br/>/// :<br/>/// abitmap ::<br/>/// A pointer to the bitmap structure.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Init")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTBitmapInit([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* abitmap)
		{
			FTBitmapInitNative(abitmap);
		}

		/// <summary>
		/// deprecated <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_New")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Bitmap_New")]
		internal static extern void FTBitmapNewNative([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* abitmap);

		/// <summary>/// deprecated <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_New")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTBitmapNew([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* abitmap)
		{
			FTBitmapNewNative(abitmap);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Bitmap_Copy")]
		internal static extern int FTBitmapCopyNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Copy<br/>/// <br/>/// :<br/>/// Copy a bitmap into another one.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// A handle to the source bitmap.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to the target bitmap.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapCopy([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target)
		{
			int ret = FTBitmapCopyNative(library, source, target);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Copy<br/>/// <br/>/// :<br/>/// Copy a bitmap into another one.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// A handle to the source bitmap.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to the target bitmap.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapCopy([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target)
		{
			fixed (FTBitmap* psource = &source)
			{
				int ret = FTBitmapCopyNative(library, (FTBitmap*)psource, target);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Copy<br/>/// <br/>/// :<br/>/// Copy a bitmap into another one.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// A handle to the source bitmap.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to the target bitmap.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapCopy([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				int ret = FTBitmapCopyNative(library, source, (FTBitmap*)ptarget);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Copy<br/>/// <br/>/// :<br/>/// Copy a bitmap into another one.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// A handle to the source bitmap.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to the target bitmap.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapCopy([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					int ret = FTBitmapCopyNative(library, (FTBitmap*)psource, (FTBitmap*)ptarget);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Embolden<br/>
		/// <br/>
		/// :<br/>
		/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>
		/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>
		/// kept unchanged.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// xStrength ::<br/>
		/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// yStrength ::<br/>
		/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// <br/>
		/// :<br/>
		/// bitmap ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// If you want to embolden the bitmap owned by a <br/>
		/// _GlyphSlotRec, you<br/>
		/// should call <br/>
		/// _GlyphSlot_Own_Bitmap on the slot first.<br/>
		/// Bitmaps in <br/>
		/// _PIXEL_MODE_GRAY2 and <br/>
		/// _PIXEL_MODE_GRAY<br/>
		/// @<br/>
		/// format are<br/>
		/// converted to <br/>
		/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Bitmap_Embolden")]
		internal static extern int FTBitmapEmboldenNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Embolden<br/>/// <br/>/// :<br/>/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>/// kept unchanged.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// xStrength ::<br/>/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>/// pixel format.<br/>/// yStrength ::<br/>/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>/// pixel format.<br/>/// <br/>/// :<br/>/// bitmap ::<br/>/// A handle to the target bitmap.<br/>/// <br/>/// <br/>/// If you want to embolden the bitmap owned by a <br/>/// _GlyphSlotRec, you<br/>/// should call <br/>/// _GlyphSlot_Own_Bitmap on the slot first.<br/>/// Bitmaps in <br/>/// _PIXEL_MODE_GRAY2 and <br/>/// _PIXEL_MODE_GRAY<br/>/// @<br/>/// format are<br/>/// converted to <br/>/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapEmbolden([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength)
		{
			int ret = FTBitmapEmboldenNative(library, bitmap, xStrength, yStrength);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Embolden<br/>/// <br/>/// :<br/>/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>/// kept unchanged.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// xStrength ::<br/>/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>/// pixel format.<br/>/// yStrength ::<br/>/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>/// pixel format.<br/>/// <br/>/// :<br/>/// bitmap ::<br/>/// A handle to the target bitmap.<br/>/// <br/>/// <br/>/// If you want to embolden the bitmap owned by a <br/>/// _GlyphSlotRec, you<br/>/// should call <br/>/// _GlyphSlot_Own_Bitmap on the slot first.<br/>/// Bitmaps in <br/>/// _PIXEL_MODE_GRAY2 and <br/>/// _PIXEL_MODE_GRAY<br/>/// @<br/>/// format are<br/>/// converted to <br/>/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapEmbolden([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength)
		{
			fixed (FTBitmap* pbitmap = &bitmap)
			{
				int ret = FTBitmapEmboldenNative(library, (FTBitmap*)pbitmap, xStrength, yStrength);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Bitmap_Convert")]
		internal static extern int FTBitmapConvertNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Convert<br/>/// <br/>/// :<br/>/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap.<br/>/// alignment ::<br/>/// The pitch of the bitmap is a multiple of this argument.  Common<br/>/// values are 1, 2, or 4.<br/>/// <br/>/// :<br/>/// target ::<br/>/// The target bitmap.<br/>/// <br/>/// <br/>/// Use <br/>/// _Bitmap_Done to finally remove the bitmap object.<br/>/// The `library` argument is taken to have access to FreeType's memory<br/>/// handling functions.<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapConvert([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			int ret = FTBitmapConvertNative(library, source, target, alignment);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Convert<br/>/// <br/>/// :<br/>/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap.<br/>/// alignment ::<br/>/// The pitch of the bitmap is a multiple of this argument.  Common<br/>/// values are 1, 2, or 4.<br/>/// <br/>/// :<br/>/// target ::<br/>/// The target bitmap.<br/>/// <br/>/// <br/>/// Use <br/>/// _Bitmap_Done to finally remove the bitmap object.<br/>/// The `library` argument is taken to have access to FreeType's memory<br/>/// handling functions.<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapConvert([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* psource = &source)
			{
				int ret = FTBitmapConvertNative(library, (FTBitmap*)psource, target, alignment);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Convert<br/>/// <br/>/// :<br/>/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap.<br/>/// alignment ::<br/>/// The pitch of the bitmap is a multiple of this argument.  Common<br/>/// values are 1, 2, or 4.<br/>/// <br/>/// :<br/>/// target ::<br/>/// The target bitmap.<br/>/// <br/>/// <br/>/// Use <br/>/// _Bitmap_Done to finally remove the bitmap object.<br/>/// The `library` argument is taken to have access to FreeType's memory<br/>/// handling functions.<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapConvert([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				int ret = FTBitmapConvertNative(library, source, (FTBitmap*)ptarget, alignment);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Convert<br/>/// <br/>/// :<br/>/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap.<br/>/// alignment ::<br/>/// The pitch of the bitmap is a multiple of this argument.  Common<br/>/// values are 1, 2, or 4.<br/>/// <br/>/// :<br/>/// target ::<br/>/// The target bitmap.<br/>/// <br/>/// <br/>/// Use <br/>/// _Bitmap_Done to finally remove the bitmap object.<br/>/// The `library` argument is taken to have access to FreeType's memory<br/>/// handling functions.<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapConvert([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					int ret = FTBitmapConvertNative(library, (FTBitmap*)psource, (FTBitmap*)ptarget, alignment);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Bitmap_Blend")]
		internal static extern int FTBitmapBlendNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Blend<br/>/// <br/>/// :<br/>/// Blend a bitmap onto another bitmap, using a given color.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap, which can have any <br/>/// _Pixel_Mode format.<br/>/// source_offset ::<br/>/// The offset vector to the upper left corner of the source bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// color ::<br/>/// The color used to draw `source` onto `target`.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>/// as empty with a call to <br/>/// _Bitmap_Init, or it should be of type<br/>/// <br/>/// _PIXEL_MODE_BGRA.<br/>/// atarget_offset ::<br/>/// The offset vector to the upper left corner of the target bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// <br/>/// <br/>/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>/// vector `atarget_offset` is updated accordingly.<br/>/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>/// flow (as indicated by the sign of the `pitch` field).<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			int ret = FTBitmapBlendNative(library, source, sourceOffset, target, atargetOffset, color);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Blend<br/>/// <br/>/// :<br/>/// Blend a bitmap onto another bitmap, using a given color.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap, which can have any <br/>/// _Pixel_Mode format.<br/>/// source_offset ::<br/>/// The offset vector to the upper left corner of the source bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// color ::<br/>/// The color used to draw `source` onto `target`.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>/// as empty with a call to <br/>/// _Bitmap_Init, or it should be of type<br/>/// <br/>/// _PIXEL_MODE_BGRA.<br/>/// atarget_offset ::<br/>/// The offset vector to the upper left corner of the target bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// <br/>/// <br/>/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>/// vector `atarget_offset` is updated accordingly.<br/>/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>/// flow (as indicated by the sign of the `pitch` field).<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				int ret = FTBitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, target, atargetOffset, color);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Blend<br/>/// <br/>/// :<br/>/// Blend a bitmap onto another bitmap, using a given color.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap, which can have any <br/>/// _Pixel_Mode format.<br/>/// source_offset ::<br/>/// The offset vector to the upper left corner of the source bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// color ::<br/>/// The color used to draw `source` onto `target`.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>/// as empty with a call to <br/>/// _Bitmap_Init, or it should be of type<br/>/// <br/>/// _PIXEL_MODE_BGRA.<br/>/// atarget_offset ::<br/>/// The offset vector to the upper left corner of the target bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// <br/>/// <br/>/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>/// vector `atarget_offset` is updated accordingly.<br/>/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>/// flow (as indicated by the sign of the `pitch` field).<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				int ret = FTBitmapBlendNative(library, source, sourceOffset, (FTBitmap*)ptarget, atargetOffset, color);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Blend<br/>/// <br/>/// :<br/>/// Blend a bitmap onto another bitmap, using a given color.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap, which can have any <br/>/// _Pixel_Mode format.<br/>/// source_offset ::<br/>/// The offset vector to the upper left corner of the source bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// color ::<br/>/// The color used to draw `source` onto `target`.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>/// as empty with a call to <br/>/// _Bitmap_Init, or it should be of type<br/>/// <br/>/// _PIXEL_MODE_BGRA.<br/>/// atarget_offset ::<br/>/// The offset vector to the upper left corner of the target bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// <br/>/// <br/>/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>/// vector `atarget_offset` is updated accordingly.<br/>/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>/// flow (as indicated by the sign of the `pitch` field).<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					int ret = FTBitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, (FTBitmap*)ptarget, atargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Blend<br/>/// <br/>/// :<br/>/// Blend a bitmap onto another bitmap, using a given color.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap, which can have any <br/>/// _Pixel_Mode format.<br/>/// source_offset ::<br/>/// The offset vector to the upper left corner of the source bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// color ::<br/>/// The color used to draw `source` onto `target`.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>/// as empty with a call to <br/>/// _Bitmap_Init, or it should be of type<br/>/// <br/>/// _PIXEL_MODE_BGRA.<br/>/// atarget_offset ::<br/>/// The offset vector to the upper left corner of the target bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// <br/>/// <br/>/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>/// vector `atarget_offset` is updated accordingly.<br/>/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>/// flow (as indicated by the sign of the `pitch` field).<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTVector* patargetOffset = &atargetOffset)
			{
				int ret = FTBitmapBlendNative(library, source, sourceOffset, target, (FTVector*)patargetOffset, color);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Blend<br/>/// <br/>/// :<br/>/// Blend a bitmap onto another bitmap, using a given color.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap, which can have any <br/>/// _Pixel_Mode format.<br/>/// source_offset ::<br/>/// The offset vector to the upper left corner of the source bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// color ::<br/>/// The color used to draw `source` onto `target`.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>/// as empty with a call to <br/>/// _Bitmap_Init, or it should be of type<br/>/// <br/>/// _PIXEL_MODE_BGRA.<br/>/// atarget_offset ::<br/>/// The offset vector to the upper left corner of the target bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// <br/>/// <br/>/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>/// vector `atarget_offset` is updated accordingly.<br/>/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>/// flow (as indicated by the sign of the `pitch` field).<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTVector* patargetOffset = &atargetOffset)
				{
					int ret = FTBitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, target, (FTVector*)patargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Blend<br/>/// <br/>/// :<br/>/// Blend a bitmap onto another bitmap, using a given color.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap, which can have any <br/>/// _Pixel_Mode format.<br/>/// source_offset ::<br/>/// The offset vector to the upper left corner of the source bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// color ::<br/>/// The color used to draw `source` onto `target`.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>/// as empty with a call to <br/>/// _Bitmap_Init, or it should be of type<br/>/// <br/>/// _PIXEL_MODE_BGRA.<br/>/// atarget_offset ::<br/>/// The offset vector to the upper left corner of the target bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// <br/>/// <br/>/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>/// vector `atarget_offset` is updated accordingly.<br/>/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>/// flow (as indicated by the sign of the `pitch` field).<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				fixed (FTVector* patargetOffset = &atargetOffset)
				{
					int ret = FTBitmapBlendNative(library, source, sourceOffset, (FTBitmap*)ptarget, (FTVector*)patargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Blend<br/>/// <br/>/// :<br/>/// Blend a bitmap onto another bitmap, using a given color.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// source ::<br/>/// The source bitmap, which can have any <br/>/// _Pixel_Mode format.<br/>/// source_offset ::<br/>/// The offset vector to the upper left corner of the source bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// color ::<br/>/// The color used to draw `source` onto `target`.<br/>/// <br/>/// :<br/>/// target ::<br/>/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>/// as empty with a call to <br/>/// _Bitmap_Init, or it should be of type<br/>/// <br/>/// _PIXEL_MODE_BGRA.<br/>/// atarget_offset ::<br/>/// The offset vector to the upper left corner of the target bitmap in<br/>/// 26.6 pixel format.  It should represent an integer offset; the<br/>/// function will set the lowest six bits to zero to enforce that.<br/>/// <br/>/// <br/>/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>/// vector `atarget_offset` is updated accordingly.<br/>/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>/// flow (as indicated by the sign of the `pitch` field).<br/>/// `source->buffer` and `target->buffer` must neither be equal nor<br/>/// overlap.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					fixed (FTVector* patargetOffset = &atargetOffset)
					{
						int ret = FTBitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, (FTBitmap*)ptarget, (FTVector*)patargetOffset, color);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_GlyphSlot_Own_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Make sure that a glyph slot owns `slot->bitmap`.<br/>
		/// <br/>
		/// :<br/>
		/// slot ::<br/>
		/// The glyph slot.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Own_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_GlyphSlot_Own_Bitmap")]
		internal static extern int FTGlyphSlotOwnBitmapNative([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_GlyphSlot_Own_Bitmap<br/>/// <br/>/// :<br/>/// Make sure that a glyph slot owns `slot->bitmap`.<br/>/// <br/>/// :<br/>/// slot ::<br/>/// The glyph slot.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Own_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGlyphSlotOwnBitmap([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot)
		{
			int ret = FTGlyphSlotOwnBitmapNative(slot);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a bitmap object initialized with <br/>
		/// _Bitmap_Init.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// bitmap ::<br/>
		/// The bitmap object to be freed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Bitmap_Done")]
		internal static extern int FTBitmapDoneNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* bitmap);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Done<br/>/// <br/>/// :<br/>/// Destroy a bitmap object initialized with <br/>/// _Bitmap_Init.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// bitmap ::<br/>/// The bitmap object to be freed.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapDone([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* bitmap)
		{
			int ret = FTBitmapDoneNative(library, bitmap);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Bitmap_Done<br/>/// <br/>/// :<br/>/// Destroy a bitmap object initialized with <br/>/// _Bitmap_Init.<br/>/// <br/>/// :<br/>/// library ::<br/>/// A handle to a library object.<br/>/// bitmap ::<br/>/// The bitmap object to be freed.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTBitmapDone([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap bitmap)
		{
			fixed (FTBitmap* pbitmap = &bitmap)
			{
				int ret = FTBitmapDoneNative(library, (FTBitmap*)pbitmap);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Table<br/>
		/// <br/>
		/// :<br/>
		/// Return a pointer to a given SFNT table stored within a face.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source.<br/>
		/// tag ::<br/>
		/// The index of the SFNT table.<br/>
		/// <br/>
		/// Use a typecast according to `tag` to access the structure elements.<br/>
		/// <br/>
		/// This function is only useful to access SFNT tables that are loaded by<br/>
		/// the sfnt, truetype, and opentype drivers.  See <br/>
		/// _Sfnt_Tag for a<br/>
		/// list.<br/>
		/// <br/>
		/// Here is an example demonstrating access to the 'vhea' table.<br/>
		/// ```<br/>
		/// TT_VertHeader*  vert_header;<br/>
		/// vert_header =<br/>
		/// (TT_VertHeader*)FT_Get_Sfnt_Table( face, FT_SFNT_VHEA );<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_Sfnt_Table")]
		internal static extern void* FTGetSfntTableNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_Sfnt_Tag")] FTSfntTag tag);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Sfnt_Table<br/>/// <br/>/// :<br/>/// Return a pointer to a given SFNT table stored within a face.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source.<br/>/// tag ::<br/>/// The index of the SFNT table.<br/>/// <br/>/// Use a typecast according to `tag` to access the structure elements.<br/>/// <br/>/// This function is only useful to access SFNT tables that are loaded by<br/>/// the sfnt, truetype, and opentype drivers.  See <br/>/// _Sfnt_Tag for a<br/>/// list.<br/>/// <br/>/// Here is an example demonstrating access to the 'vhea' table.<br/>/// ```<br/>/// TT_VertHeader*  vert_header;<br/>/// vert_header =<br/>/// (TT_VertHeader*)FT_Get_Sfnt_Table( face, FT_SFNT_VHEA );<br/>/// ```<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* FTGetSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_Sfnt_Tag")] FTSfntTag tag)
		{
			void* ret = FTGetSfntTableNative(face, tag);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Load_Sfnt_Table<br/>
		/// <br/>
		/// :<br/>
		/// Load any SFNT font table into client memory.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// tag ::<br/>
		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>
		/// access the whole font file.  Otherwise, you can use one of the<br/>
		/// definitions found in the <br/>
		/// _TRUETYPE_TAGS_H file, or forge a new<br/>
		/// one with <br/>
		/// _MAKE_TAG.<br/>
		/// offset ::<br/>
		/// The starting offset in the table (or file if tag~==~0).<br/>
		/// <br/>
		/// :<br/>
		/// buffer ::<br/>
		/// The target buffer address.  The client must ensure that the memory<br/>
		/// array is big enough to hold the data.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>
		/// Return an error code if it fails.<br/>
		/// Else, if `*length` is~0, exit immediately while returning the<br/>
		/// table's (or file) full size in it.<br/>
		/// Else the number of bytes to read from the table or file, from the<br/>
		/// starting offset.<br/>
		/// <br/>
		/// <br/>
		/// ```<br/>
		/// FT_ULong  length = 0;<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... table does not exist ... }<br/>
		/// buffer = malloc( length );<br/>
		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... could not load table ... }<br/>
		/// ```<br/>
		/// Note that structures like <br/>
		/// _Header or <br/>
		/// _OS2 can't be used with<br/>
		/// this function; they are limited to <br/>
		/// _Get_Sfnt_Table.  Reason is that<br/>
		/// those structures depend on the processor architecture, with varying<br/>
		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Load_Sfnt_Table")]
		internal static extern int FTLoadSfntTableNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte*")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Load_Sfnt_Table<br/>/// <br/>/// :<br/>/// Load any SFNT font table into client memory.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// tag ::<br/>/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>/// access the whole font file.  Otherwise, you can use one of the<br/>/// definitions found in the <br/>/// _TRUETYPE_TAGS_H file, or forge a new<br/>/// one with <br/>/// _MAKE_TAG.<br/>/// offset ::<br/>/// The starting offset in the table (or file if tag~==~0).<br/>/// <br/>/// :<br/>/// buffer ::<br/>/// The target buffer address.  The client must ensure that the memory<br/>/// array is big enough to hold the data.<br/>/// <br/>/// :<br/>/// length ::<br/>/// If the `length` parameter is `NULL`, try to load the whole table.<br/>/// Return an error code if it fails.<br/>/// Else, if `*length` is~0, exit immediately while returning the<br/>/// table's (or file) full size in it.<br/>/// Else the number of bytes to read from the table or file, from the<br/>/// starting offset.<br/>/// <br/>/// <br/>/// ```<br/>/// FT_ULong  length = 0;<br/>/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>/// &length<br/>/// );<br/>/// if ( error ) { ... table does not exist ... }<br/>/// buffer = malloc( length );<br/>/// if ( buffer == NULL ) { ... not enough memory ... }<br/>/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>/// &length<br/>/// );<br/>/// if ( error ) { ... could not load table ... }<br/>/// ```<br/>/// Note that structures like <br/>/// _Header or <br/>/// _OS2 can't be used with<br/>/// this function; they are limited to <br/>/// _Get_Sfnt_Table.  Reason is that<br/>/// those structures depend on the processor architecture, with varying<br/>/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTLoadSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte*")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length)
		{
			int ret = FTLoadSfntTableNative(face, tag, offset, buffer, length);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Load_Sfnt_Table<br/>/// <br/>/// :<br/>/// Load any SFNT font table into client memory.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// tag ::<br/>/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>/// access the whole font file.  Otherwise, you can use one of the<br/>/// definitions found in the <br/>/// _TRUETYPE_TAGS_H file, or forge a new<br/>/// one with <br/>/// _MAKE_TAG.<br/>/// offset ::<br/>/// The starting offset in the table (or file if tag~==~0).<br/>/// <br/>/// :<br/>/// buffer ::<br/>/// The target buffer address.  The client must ensure that the memory<br/>/// array is big enough to hold the data.<br/>/// <br/>/// :<br/>/// length ::<br/>/// If the `length` parameter is `NULL`, try to load the whole table.<br/>/// Return an error code if it fails.<br/>/// Else, if `*length` is~0, exit immediately while returning the<br/>/// table's (or file) full size in it.<br/>/// Else the number of bytes to read from the table or file, from the<br/>/// starting offset.<br/>/// <br/>/// <br/>/// ```<br/>/// FT_ULong  length = 0;<br/>/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>/// &length<br/>/// );<br/>/// if ( error ) { ... table does not exist ... }<br/>/// buffer = malloc( length );<br/>/// if ( buffer == NULL ) { ... not enough memory ... }<br/>/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>/// &length<br/>/// );<br/>/// if ( error ) { ... could not load table ... }<br/>/// ```<br/>/// Note that structures like <br/>/// _Header or <br/>/// _OS2 can't be used with<br/>/// this function; they are limited to <br/>/// _Get_Sfnt_Table.  Reason is that<br/>/// those structures depend on the processor architecture, with varying<br/>/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTLoadSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte*")] ref byte buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = FTLoadSfntTableNative(face, tag, offset, (byte*)pbuffer, length);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Load_Sfnt_Table<br/>/// <br/>/// :<br/>/// Load any SFNT font table into client memory.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// tag ::<br/>/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>/// access the whole font file.  Otherwise, you can use one of the<br/>/// definitions found in the <br/>/// _TRUETYPE_TAGS_H file, or forge a new<br/>/// one with <br/>/// _MAKE_TAG.<br/>/// offset ::<br/>/// The starting offset in the table (or file if tag~==~0).<br/>/// <br/>/// :<br/>/// buffer ::<br/>/// The target buffer address.  The client must ensure that the memory<br/>/// array is big enough to hold the data.<br/>/// <br/>/// :<br/>/// length ::<br/>/// If the `length` parameter is `NULL`, try to load the whole table.<br/>/// Return an error code if it fails.<br/>/// Else, if `*length` is~0, exit immediately while returning the<br/>/// table's (or file) full size in it.<br/>/// Else the number of bytes to read from the table or file, from the<br/>/// starting offset.<br/>/// <br/>/// <br/>/// ```<br/>/// FT_ULong  length = 0;<br/>/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>/// &length<br/>/// );<br/>/// if ( error ) { ... table does not exist ... }<br/>/// buffer = malloc( length );<br/>/// if ( buffer == NULL ) { ... not enough memory ... }<br/>/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>/// &length<br/>/// );<br/>/// if ( error ) { ... could not load table ... }<br/>/// ```<br/>/// Note that structures like <br/>/// _Header or <br/>/// _OS2 can't be used with<br/>/// this function; they are limited to <br/>/// _Get_Sfnt_Table.  Reason is that<br/>/// those structures depend on the processor architecture, with varying<br/>/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTLoadSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte*")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint length)
		{
			fixed (uint* plength = &length)
			{
				int ret = FTLoadSfntTableNative(face, tag, offset, buffer, (uint*)plength);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Load_Sfnt_Table<br/>/// <br/>/// :<br/>/// Load any SFNT font table into client memory.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// tag ::<br/>/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>/// access the whole font file.  Otherwise, you can use one of the<br/>/// definitions found in the <br/>/// _TRUETYPE_TAGS_H file, or forge a new<br/>/// one with <br/>/// _MAKE_TAG.<br/>/// offset ::<br/>/// The starting offset in the table (or file if tag~==~0).<br/>/// <br/>/// :<br/>/// buffer ::<br/>/// The target buffer address.  The client must ensure that the memory<br/>/// array is big enough to hold the data.<br/>/// <br/>/// :<br/>/// length ::<br/>/// If the `length` parameter is `NULL`, try to load the whole table.<br/>/// Return an error code if it fails.<br/>/// Else, if `*length` is~0, exit immediately while returning the<br/>/// table's (or file) full size in it.<br/>/// Else the number of bytes to read from the table or file, from the<br/>/// starting offset.<br/>/// <br/>/// <br/>/// ```<br/>/// FT_ULong  length = 0;<br/>/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>/// &length<br/>/// );<br/>/// if ( error ) { ... table does not exist ... }<br/>/// buffer = malloc( length );<br/>/// if ( buffer == NULL ) { ... not enough memory ... }<br/>/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>/// &length<br/>/// );<br/>/// if ( error ) { ... could not load table ... }<br/>/// ```<br/>/// Note that structures like <br/>/// _Header or <br/>/// _OS2 can't be used with<br/>/// this function; they are limited to <br/>/// _Get_Sfnt_Table.  Reason is that<br/>/// those structures depend on the processor architecture, with varying<br/>/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTLoadSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte*")] ref byte buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint length)
		{
			fixed (byte* pbuffer = &buffer)
			{
				fixed (uint* plength = &length)
				{
					int ret = FTLoadSfntTableNative(face, tag, offset, (byte*)pbuffer, (uint*)plength);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Sfnt_Table_Info<br/>
		/// <br/>
		/// :<br/>
		/// Return information on an SFNT table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// table_index ::<br/>
		/// The index of an SFNT table.  The function returns<br/>
		/// FT_Err_Table_Missing for an invalid value.<br/>
		/// <br/>
		/// :<br/>
		/// tag ::<br/>
		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>
		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>
		/// tables in the font.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The length of the SFNT table (or the number of SFNT tables,<br/>
		/// depending on `tag`).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Sfnt_Table_Info")]
		internal static extern int FTSfntTableInfoNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Sfnt_Table_Info<br/>/// <br/>/// :<br/>/// Return information on an SFNT table.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// table_index ::<br/>/// The index of an SFNT table.  The function returns<br/>/// FT_Err_Table_Missing for an invalid value.<br/>/// <br/>/// :<br/>/// tag ::<br/>/// The name tag of the SFNT table.  If the value is `NULL`,<br/>/// `table_index` is ignored, and `length` returns the number of SFNT<br/>/// tables in the font.<br/>/// <br/>/// :<br/>/// length ::<br/>/// The length of the SFNT table (or the number of SFNT tables,<br/>/// depending on `tag`).<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTSfntTableInfo([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length)
		{
			int ret = FTSfntTableInfoNative(face, tableIndex, tag, length);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Sfnt_Table_Info<br/>/// <br/>/// :<br/>/// Return information on an SFNT table.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// table_index ::<br/>/// The index of an SFNT table.  The function returns<br/>/// FT_Err_Table_Missing for an invalid value.<br/>/// <br/>/// :<br/>/// tag ::<br/>/// The name tag of the SFNT table.  If the value is `NULL`,<br/>/// `table_index` is ignored, and `length` returns the number of SFNT<br/>/// tables in the font.<br/>/// <br/>/// :<br/>/// length ::<br/>/// The length of the SFNT table (or the number of SFNT tables,<br/>/// depending on `tag`).<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTSfntTableInfo([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length)
		{
			fixed (uint* ptag = &tag)
			{
				int ret = FTSfntTableInfoNative(face, tableIndex, (uint*)ptag, length);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Sfnt_Table_Info<br/>/// <br/>/// :<br/>/// Return information on an SFNT table.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// table_index ::<br/>/// The index of an SFNT table.  The function returns<br/>/// FT_Err_Table_Missing for an invalid value.<br/>/// <br/>/// :<br/>/// tag ::<br/>/// The name tag of the SFNT table.  If the value is `NULL`,<br/>/// `table_index` is ignored, and `length` returns the number of SFNT<br/>/// tables in the font.<br/>/// <br/>/// :<br/>/// length ::<br/>/// The length of the SFNT table (or the number of SFNT tables,<br/>/// depending on `tag`).<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTSfntTableInfo([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint length)
		{
			fixed (uint* plength = &length)
			{
				int ret = FTSfntTableInfoNative(face, tableIndex, tag, (uint*)plength);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Sfnt_Table_Info<br/>/// <br/>/// :<br/>/// Return information on an SFNT table.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// table_index ::<br/>/// The index of an SFNT table.  The function returns<br/>/// FT_Err_Table_Missing for an invalid value.<br/>/// <br/>/// :<br/>/// tag ::<br/>/// The name tag of the SFNT table.  If the value is `NULL`,<br/>/// `table_index` is ignored, and `length` returns the number of SFNT<br/>/// tables in the font.<br/>/// <br/>/// :<br/>/// length ::<br/>/// The length of the SFNT table (or the number of SFNT tables,<br/>/// depending on `tag`).<br/>/// <br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTSfntTableInfo([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint length)
		{
			fixed (uint* ptag = &tag)
			{
				fixed (uint* plength = &length)
				{
					int ret = FTSfntTableInfoNative(face, tableIndex, (uint*)ptag, (uint*)plength);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_CMap_Language_ID<br/>
		/// <br/>
		/// :<br/>
		/// Return cmap language ID as specified in the OpenType standard.<br/>
		/// Definitions of language ID values are in file <br/>
		/// _TRUETYPE_IDS_H.<br/>
		/// <br/>
		/// :<br/>
		/// charmap ::<br/>
		/// The target charmap.<br/>
		/// <br/>
		/// For a format~14 cmap (to access Unicode IVS), the return value is<br/>
		/// 0xFFFFFFFF.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_CMap_Language_ID")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_CMap_Language_ID")]
		internal static extern uint FTGetCMapLanguageIDNative([NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_CMap_Language_ID<br/>/// <br/>/// :<br/>/// Return cmap language ID as specified in the OpenType standard.<br/>/// Definitions of language ID values are in file <br/>/// _TRUETYPE_IDS_H.<br/>/// <br/>/// :<br/>/// charmap ::<br/>/// The target charmap.<br/>/// <br/>/// For a format~14 cmap (to access Unicode IVS), the return value is<br/>/// 0xFFFFFFFF.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_CMap_Language_ID")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint FTGetCMapLanguageID([NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap)
		{
			uint ret = FTGetCMapLanguageIDNative(charmap);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_CMap_Format<br/>
		/// <br/>
		/// :<br/>
		/// Return the format of an SFNT 'cmap' table.<br/>
		/// <br/>
		/// :<br/>
		/// charmap ::<br/>
		/// The target charmap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_CMap_Format")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_CMap_Format")]
		internal static extern int FTGetCMapFormatNative([NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_CMap_Format<br/>/// <br/>/// :<br/>/// Return the format of an SFNT 'cmap' table.<br/>/// <br/>/// :<br/>/// charmap ::<br/>/// The target charmap.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_CMap_Format")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		public static int FTGetCMapFormat([NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap)
		{
			int ret = FTGetCMapFormatNative(charmap);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Name_Count<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the number of name strings in the SFNT 'name' table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name_Count")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_Sfnt_Name_Count")]
		internal static extern uint FTGetSfntNameCountNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Sfnt_Name_Count<br/>/// <br/>/// :<br/>/// Retrieve the number of name strings in the SFNT 'name' table.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name_Count")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint FTGetSfntNameCount([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			uint ret = FTGetSfntNameCountNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Name<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a string of the SFNT 'name' table for a given index.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// idx ::<br/>
		/// The index of the 'name' string.<br/>
		/// <br/>
		/// :<br/>
		/// aname ::<br/>
		/// The indexed <br/>
		/// _SfntName structure.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Get_Sfnt_Name_Count to get the total number of available<br/>
		/// 'name' table entries, then do a loop until you get the right platform,<br/>
		/// encoding, and name ID.<br/>
		/// 'name' table format~1 entries can use language tags also, see<br/>
		/// <br/>
		/// _Get_Sfnt_LangTag.<br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_Sfnt_Name")]
		internal static extern int FTGetSfntNameNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "FT_UInt")] uint idx, [NativeName(NativeNameType.Param, "aname")] [NativeName(NativeNameType.Type, "FT_SfntName*")] FTSfntName* aname);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Sfnt_Name<br/>/// <br/>/// :<br/>/// Retrieve a string of the SFNT 'name' table for a given index.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// idx ::<br/>/// The index of the 'name' string.<br/>/// <br/>/// :<br/>/// aname ::<br/>/// The indexed <br/>/// _SfntName structure.<br/>/// <br/>/// <br/>/// Use <br/>/// _Get_Sfnt_Name_Count to get the total number of available<br/>/// 'name' table entries, then do a loop until you get the right platform,<br/>/// encoding, and name ID.<br/>/// 'name' table format~1 entries can use language tags also, see<br/>/// <br/>/// _Get_Sfnt_LangTag.<br/>/// This function always returns an error if the config macro<br/>/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSfntName([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "FT_UInt")] uint idx, [NativeName(NativeNameType.Param, "aname")] [NativeName(NativeNameType.Type, "FT_SfntName*")] FTSfntName* aname)
		{
			int ret = FTGetSfntNameNative(face, idx, aname);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Sfnt_Name<br/>/// <br/>/// :<br/>/// Retrieve a string of the SFNT 'name' table for a given index.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// idx ::<br/>/// The index of the 'name' string.<br/>/// <br/>/// :<br/>/// aname ::<br/>/// The indexed <br/>/// _SfntName structure.<br/>/// <br/>/// <br/>/// Use <br/>/// _Get_Sfnt_Name_Count to get the total number of available<br/>/// 'name' table entries, then do a loop until you get the right platform,<br/>/// encoding, and name ID.<br/>/// 'name' table format~1 entries can use language tags also, see<br/>/// <br/>/// _Get_Sfnt_LangTag.<br/>/// This function always returns an error if the config macro<br/>/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSfntName([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "FT_UInt")] uint idx, [NativeName(NativeNameType.Param, "aname")] [NativeName(NativeNameType.Type, "FT_SfntName*")] ref FTSfntName aname)
		{
			fixed (FTSfntName* paname = &aname)
			{
				int ret = FTGetSfntNameNative(face, idx, (FTSfntName*)paname);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_LangTag<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the language tag associated with a language ID of an SFNT<br/>
		/// 'name' table entry.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// langID ::<br/>
		/// The language ID, as returned by <br/>
		/// _Get_Sfnt_Name.  This is always a<br/>
		/// value larger than 0x8000.<br/>
		/// <br/>
		/// :<br/>
		/// alangTag ::<br/>
		/// The language tag associated with the 'name' table entry's language<br/>
		/// ID.<br/>
		/// <br/>
		/// <br/>
		/// Only 'name' table format~1 supports language tags.  For format~0<br/>
		/// tables, this function always returns FT_Err_Invalid_Table.  For<br/>
		/// invalid format~1 language ID values, FT_Err_Invalid_Argument is<br/>
		/// returned.<br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_LangTag")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Get_Sfnt_LangTag")]
		internal static extern int FTGetSfntLangTagNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "langID")] [NativeName(NativeNameType.Type, "FT_UInt")] uint langID, [NativeName(NativeNameType.Param, "alangTag")] [NativeName(NativeNameType.Type, "FT_SfntLangTag*")] FTSfntLangTag* alangTag);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Sfnt_LangTag<br/>/// <br/>/// :<br/>/// Retrieve the language tag associated with a language ID of an SFNT<br/>/// 'name' table entry.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// langID ::<br/>/// The language ID, as returned by <br/>/// _Get_Sfnt_Name.  This is always a<br/>/// value larger than 0x8000.<br/>/// <br/>/// :<br/>/// alangTag ::<br/>/// The language tag associated with the 'name' table entry's language<br/>/// ID.<br/>/// <br/>/// <br/>/// Only 'name' table format~1 supports language tags.  For format~0<br/>/// tables, this function always returns FT_Err_Invalid_Table.  For<br/>/// invalid format~1 language ID values, FT_Err_Invalid_Argument is<br/>/// returned.<br/>/// This function always returns an error if the config macro<br/>/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_LangTag")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSfntLangTag([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "langID")] [NativeName(NativeNameType.Type, "FT_UInt")] uint langID, [NativeName(NativeNameType.Param, "alangTag")] [NativeName(NativeNameType.Type, "FT_SfntLangTag*")] FTSfntLangTag* alangTag)
		{
			int ret = FTGetSfntLangTagNative(face, langID, alangTag);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Get_Sfnt_LangTag<br/>/// <br/>/// :<br/>/// Retrieve the language tag associated with a language ID of an SFNT<br/>/// 'name' table entry.<br/>/// <br/>/// :<br/>/// face ::<br/>/// A handle to the source face.<br/>/// langID ::<br/>/// The language ID, as returned by <br/>/// _Get_Sfnt_Name.  This is always a<br/>/// value larger than 0x8000.<br/>/// <br/>/// :<br/>/// alangTag ::<br/>/// The language tag associated with the 'name' table entry's language<br/>/// ID.<br/>/// <br/>/// <br/>/// Only 'name' table format~1 supports language tags.  For format~0<br/>/// tables, this function always returns FT_Err_Invalid_Table.  For<br/>/// invalid format~1 language ID values, FT_Err_Invalid_Argument is<br/>/// returned.<br/>/// This function always returns an error if the config macro<br/>/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_LangTag")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTGetSfntLangTag([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "langID")] [NativeName(NativeNameType.Type, "FT_UInt")] uint langID, [NativeName(NativeNameType.Param, "alangTag")] [NativeName(NativeNameType.Type, "FT_SfntLangTag*")] ref FTSfntLangTag alangTag)
		{
			fixed (FTSfntLangTag* palangTag = &alangTag)
			{
				int ret = FTGetSfntLangTagNative(face, langID, (FTSfntLangTag*)palangTag);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_BBox<br/>
		/// <br/>
		/// :<br/>
		/// Compute the exact bounding box of an outline.  This is slower than<br/>
		/// computing the control box.  However, it uses an advanced algorithm<br/>
		/// that returns _very_ quickly when the two boxes coincide.  Otherwise,<br/>
		/// the outline Bezier arcs are traversed to extract their extrema.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// abbox ::<br/>
		/// The outline's exact bounding box.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_BBox")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Outline_Get_BBox")]
		internal static extern int FTOutlineGetBBoxNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "abbox")] [NativeName(NativeNameType.Type, "FT_BBox*")] FTBBox* abbox);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Outline_Get_BBox<br/>/// <br/>/// :<br/>/// Compute the exact bounding box of an outline.  This is slower than<br/>/// computing the control box.  However, it uses an advanced algorithm<br/>/// that returns _very_ quickly when the two boxes coincide.  Otherwise,<br/>/// the outline Bezier arcs are traversed to extract their extrema.<br/>/// <br/>/// :<br/>/// outline ::<br/>/// A pointer to the source outline.<br/>/// <br/>/// :<br/>/// abbox ::<br/>/// The outline's exact bounding box.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Get_BBox")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTOutlineGetBBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "abbox")] [NativeName(NativeNameType.Type, "FT_BBox*")] FTBBox* abbox)
		{
			int ret = FTOutlineGetBBoxNative(outline, abbox);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Outline_Get_BBox<br/>/// <br/>/// :<br/>/// Compute the exact bounding box of an outline.  This is slower than<br/>/// computing the control box.  However, it uses an advanced algorithm<br/>/// that returns _very_ quickly when the two boxes coincide.  Otherwise,<br/>/// the outline Bezier arcs are traversed to extract their extrema.<br/>/// <br/>/// :<br/>/// outline ::<br/>/// A pointer to the source outline.<br/>/// <br/>/// :<br/>/// abbox ::<br/>/// The outline's exact bounding box.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Get_BBox")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTOutlineGetBBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "abbox")] [NativeName(NativeNameType.Type, "FT_BBox*")] ref FTBBox abbox)
		{
			fixed (FTBBox* pabbox = &abbox)
			{
				int ret = FTOutlineGetBBoxNative(outline, (FTBBox*)pabbox);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_GetInsideBorder<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the <br/>
		/// _StrokerBorder value corresponding to the 'inside'<br/>
		/// borders of a given outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// The source outline handle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_GetInsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Outline_GetInsideBorder")]
		internal static extern FTStrokerBorder FTOutlineGetInsideBorderNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Outline_GetInsideBorder<br/>/// <br/>/// :<br/>/// Retrieve the <br/>/// _StrokerBorder value corresponding to the 'inside'<br/>/// borders of a given outline.<br/>/// <br/>/// :<br/>/// outline ::<br/>/// The source outline handle.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_GetInsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		public static FTStrokerBorder FTOutlineGetInsideBorder([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline)
		{
			FTStrokerBorder ret = FTOutlineGetInsideBorderNative(outline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_GetOutsideBorder<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the <br/>
		/// _StrokerBorder value corresponding to the 'outside'<br/>
		/// borders of a given outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// The source outline handle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_GetOutsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Outline_GetOutsideBorder")]
		internal static extern FTStrokerBorder FTOutlineGetOutsideBorderNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Outline_GetOutsideBorder<br/>/// <br/>/// :<br/>/// Retrieve the <br/>/// _StrokerBorder value corresponding to the 'outside'<br/>/// borders of a given outline.<br/>/// <br/>/// :<br/>/// outline ::<br/>/// The source outline handle.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_GetOutsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		public static FTStrokerBorder FTOutlineGetOutsideBorder([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline)
		{
			FTStrokerBorder ret = FTOutlineGetOutsideBorderNative(outline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// FreeType library handle.<br/>
		/// <br/>
		/// :<br/>
		/// astroker ::<br/>
		/// A new stroker object handle.  `NULL` in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_New")]
		internal static extern int FTStrokerNewNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker*")] FTStroker* astroker);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_New<br/>/// <br/>/// :<br/>/// Create a new stroker object.<br/>/// <br/>/// :<br/>/// library ::<br/>/// FreeType library handle.<br/>/// <br/>/// :<br/>/// astroker ::<br/>/// A new stroker object handle.  `NULL` in case of error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerNew([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker*")] FTStroker* astroker)
		{
			int ret = FTStrokerNewNative(library, astroker);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_New<br/>/// <br/>/// :<br/>/// Create a new stroker object.<br/>/// <br/>/// :<br/>/// library ::<br/>/// FreeType library handle.<br/>/// <br/>/// :<br/>/// astroker ::<br/>/// A new stroker object handle.  `NULL` in case of error.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerNew([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker*")] ref FTStroker astroker)
		{
			fixed (FTStroker* pastroker = &astroker)
			{
				int ret = FTStrokerNewNative(library, (FTStroker*)pastroker);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Set<br/>
		/// <br/>
		/// :<br/>
		/// Reset a stroker object's attributes.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// radius ::<br/>
		/// The border radius.<br/>
		/// line_cap ::<br/>
		/// The line cap style.<br/>
		/// line_join ::<br/>
		/// The line join style.<br/>
		/// miter_limit ::<br/>
		/// The maximum reciprocal sine of half-angle at the miter join,<br/>
		/// expressed as 16.16 fixed-point value.<br/>
		/// <br/>
		/// The `miter_limit` multiplied by the `radius` gives the maximum size<br/>
		/// of a miter spike, at which it is clipped for<br/>
		/// <br/>
		/// _STROKER_LINEJOIN_MITER_VARIABLE or replaced with a bevel join for<br/>
		/// <br/>
		/// _STROKER_LINEJOIN_MITER_FIXED.<br/>
		/// This function calls <br/>
		/// _Stroker_Rewind automatically.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Set")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_Set")]
		internal static extern void FTStrokerSetNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "FT_Fixed")] int radius, [NativeName(NativeNameType.Param, "line_cap")] [NativeName(NativeNameType.Type, "FT_Stroker_LineCap")] FTStrokerLineCap lineCap, [NativeName(NativeNameType.Param, "line_join")] [NativeName(NativeNameType.Type, "FT_Stroker_LineJoin")] FTStrokerLineJoin lineJoin, [NativeName(NativeNameType.Param, "miter_limit")] [NativeName(NativeNameType.Type, "FT_Fixed")] int miterLimit);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_Set<br/>/// <br/>/// :<br/>/// Reset a stroker object's attributes.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// radius ::<br/>/// The border radius.<br/>/// line_cap ::<br/>/// The line cap style.<br/>/// line_join ::<br/>/// The line join style.<br/>/// miter_limit ::<br/>/// The maximum reciprocal sine of half-angle at the miter join,<br/>/// expressed as 16.16 fixed-point value.<br/>/// <br/>/// The `miter_limit` multiplied by the `radius` gives the maximum size<br/>/// of a miter spike, at which it is clipped for<br/>/// <br/>/// _STROKER_LINEJOIN_MITER_VARIABLE or replaced with a bevel join for<br/>/// <br/>/// _STROKER_LINEJOIN_MITER_FIXED.<br/>/// This function calls <br/>/// _Stroker_Rewind automatically.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Set")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTStrokerSet([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "FT_Fixed")] int radius, [NativeName(NativeNameType.Param, "line_cap")] [NativeName(NativeNameType.Type, "FT_Stroker_LineCap")] FTStrokerLineCap lineCap, [NativeName(NativeNameType.Param, "line_join")] [NativeName(NativeNameType.Type, "FT_Stroker_LineJoin")] FTStrokerLineJoin lineJoin, [NativeName(NativeNameType.Param, "miter_limit")] [NativeName(NativeNameType.Type, "FT_Fixed")] int miterLimit)
		{
			FTStrokerSetNative(stroker, radius, lineCap, lineJoin, miterLimit);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Rewind<br/>
		/// <br/>
		/// :<br/>
		/// Reset a stroker object without changing its attributes.  You should<br/>
		/// call this function before beginning a new series of calls to<br/>
		/// <br/>
		/// _Stroker_BeginSubPath or <br/>
		/// _Stroker_EndSubPath.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Rewind")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_Rewind")]
		internal static extern void FTStrokerRewindNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_Rewind<br/>/// <br/>/// :<br/>/// Reset a stroker object without changing its attributes.  You should<br/>/// call this function before beginning a new series of calls to<br/>/// <br/>/// _Stroker_BeginSubPath or <br/>/// _Stroker_EndSubPath.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Rewind")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTStrokerRewind([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker)
		{
			FTStrokerRewindNative(stroker);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ParseOutline<br/>
		/// <br/>
		/// :<br/>
		/// A convenience function used to parse a whole outline with the stroker.<br/>
		/// The resulting outline(s) can be retrieved later by functions like<br/>
		/// <br/>
		/// _Stroker_GetCounts and <br/>
		/// _Stroker_Export.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The source outline.<br/>
		/// opened ::<br/>
		/// A boolean.  If~1, the outline is treated as an open path instead of<br/>
		/// a closed one.<br/>
		/// <br/>
		/// <br/>
		/// If `opened` is~1, the outline is processed as an open path, and the<br/>
		/// stroker generates a single 'stroke' outline.<br/>
		/// This function calls <br/>
		/// _Stroker_Rewind automatically.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ParseOutline")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_ParseOutline")]
		internal static extern int FTStrokerParseOutlineNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "opened")] [NativeName(NativeNameType.Type, "FT_Bool")] byte opened);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_ParseOutline<br/>/// <br/>/// :<br/>/// A convenience function used to parse a whole outline with the stroker.<br/>/// The resulting outline(s) can be retrieved later by functions like<br/>/// <br/>/// _Stroker_GetCounts and <br/>/// _Stroker_Export.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// outline ::<br/>/// The source outline.<br/>/// opened ::<br/>/// A boolean.  If~1, the outline is treated as an open path instead of<br/>/// a closed one.<br/>/// <br/>/// <br/>/// If `opened` is~1, the outline is processed as an open path, and the<br/>/// stroker generates a single 'stroke' outline.<br/>/// This function calls <br/>/// _Stroker_Rewind automatically.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ParseOutline")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerParseOutline([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "opened")] [NativeName(NativeNameType.Type, "FT_Bool")] byte opened)
		{
			int ret = FTStrokerParseOutlineNative(stroker, outline, opened);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_ParseOutline<br/>/// <br/>/// :<br/>/// A convenience function used to parse a whole outline with the stroker.<br/>/// The resulting outline(s) can be retrieved later by functions like<br/>/// <br/>/// _Stroker_GetCounts and <br/>/// _Stroker_Export.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// outline ::<br/>/// The source outline.<br/>/// opened ::<br/>/// A boolean.  If~1, the outline is treated as an open path instead of<br/>/// a closed one.<br/>/// <br/>/// <br/>/// If `opened` is~1, the outline is processed as an open path, and the<br/>/// stroker generates a single 'stroke' outline.<br/>/// This function calls <br/>/// _Stroker_Rewind automatically.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ParseOutline")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerParseOutline([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline, [NativeName(NativeNameType.Param, "opened")] [NativeName(NativeNameType.Type, "FT_Bool")] byte opened)
		{
			fixed (FTOutline* poutline = &outline)
			{
				int ret = FTStrokerParseOutlineNative(stroker, (FTOutline*)poutline, opened);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_BeginSubPath<br/>
		/// <br/>
		/// :<br/>
		/// Start a new sub-path in the stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// to ::<br/>
		/// A pointer to the start vector.<br/>
		/// open ::<br/>
		/// A boolean.  If~1, the sub-path is treated as an open one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_BeginSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_BeginSubPath")]
		internal static extern int FTStrokerBeginSubPathNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to, [NativeName(NativeNameType.Param, "open")] [NativeName(NativeNameType.Type, "FT_Bool")] byte open);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_BeginSubPath<br/>/// <br/>/// :<br/>/// Start a new sub-path in the stroker.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// to ::<br/>/// A pointer to the start vector.<br/>/// open ::<br/>/// A boolean.  If~1, the sub-path is treated as an open one.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_BeginSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerBeginSubPath([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to, [NativeName(NativeNameType.Param, "open")] [NativeName(NativeNameType.Type, "FT_Bool")] byte open)
		{
			int ret = FTStrokerBeginSubPathNative(stroker, to, open);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_BeginSubPath<br/>/// <br/>/// :<br/>/// Start a new sub-path in the stroker.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// to ::<br/>/// A pointer to the start vector.<br/>/// open ::<br/>/// A boolean.  If~1, the sub-path is treated as an open one.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_BeginSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerBeginSubPath([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to, [NativeName(NativeNameType.Param, "open")] [NativeName(NativeNameType.Type, "FT_Bool")] byte open)
		{
			fixed (FTVector* pto = &to)
			{
				int ret = FTStrokerBeginSubPathNative(stroker, (FTVector*)pto, open);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_EndSubPath<br/>
		/// <br/>
		/// :<br/>
		/// Close the current sub-path in the stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_EndSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_EndSubPath")]
		internal static extern int FTStrokerEndSubPathNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_EndSubPath<br/>/// <br/>/// :<br/>/// Close the current sub-path in the stroker.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_EndSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerEndSubPath([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker)
		{
			int ret = FTStrokerEndSubPathNative(stroker);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_LineTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single line segment in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_LineTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_LineTo")]
		internal static extern int FTStrokerLineToNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_LineTo<br/>/// <br/>/// :<br/>/// 'Draw' a single line segment in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_LineTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerLineTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			int ret = FTStrokerLineToNative(stroker, to);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_LineTo<br/>/// <br/>/// :<br/>/// 'Draw' a single line segment in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_LineTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerLineTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				int ret = FTStrokerLineToNative(stroker, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ConicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>
		/// from the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control ::<br/>
		/// A pointer to a Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_ConicTo")]
		internal static extern int FTStrokerConicToNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_ConicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>/// from the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control ::<br/>/// A pointer to a Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerConicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			int ret = FTStrokerConicToNative(stroker, control, to);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_ConicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>/// from the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control ::<br/>/// A pointer to a Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerConicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			fixed (FTVector* pcontrol = &control)
			{
				int ret = FTStrokerConicToNative(stroker, (FTVector*)pcontrol, to);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_ConicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>/// from the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control ::<br/>/// A pointer to a Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerConicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				int ret = FTStrokerConicToNative(stroker, control, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_ConicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>/// from the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control ::<br/>/// A pointer to a Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerConicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pcontrol = &control)
			{
				fixed (FTVector* pto = &to)
				{
					int ret = FTStrokerConicToNative(stroker, (FTVector*)pcontrol, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_CubicTo")]
		internal static extern int FTStrokerCubicToNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_CubicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control1 ::<br/>/// A pointer to the first Bezier control point.<br/>/// control2 ::<br/>/// A pointer to second Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			int ret = FTStrokerCubicToNative(stroker, control1, control2, to);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_CubicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control1 ::<br/>/// A pointer to the first Bezier control point.<br/>/// control2 ::<br/>/// A pointer to second Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				int ret = FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, control2, to);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_CubicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control1 ::<br/>/// A pointer to the first Bezier control point.<br/>/// control2 ::<br/>/// A pointer to second Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			fixed (FTVector* pcontrol2 = &control2)
			{
				int ret = FTStrokerCubicToNative(stroker, control1, (FTVector*)pcontrol2, to);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_CubicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control1 ::<br/>/// A pointer to the first Bezier control point.<br/>/// control2 ::<br/>/// A pointer to second Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pcontrol2 = &control2)
				{
					int ret = FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, (FTVector*)pcontrol2, to);
					return ret;
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_CubicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control1 ::<br/>/// A pointer to the first Bezier control point.<br/>/// control2 ::<br/>/// A pointer to second Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				int ret = FTStrokerCubicToNative(stroker, control1, control2, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_CubicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control1 ::<br/>/// A pointer to the first Bezier control point.<br/>/// control2 ::<br/>/// A pointer to second Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pto = &to)
				{
					int ret = FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, control2, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_CubicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control1 ::<br/>/// A pointer to the first Bezier control point.<br/>/// control2 ::<br/>/// A pointer to second Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pcontrol2 = &control2)
			{
				fixed (FTVector* pto = &to)
				{
					int ret = FTStrokerCubicToNative(stroker, control1, (FTVector*)pcontrol2, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_CubicTo<br/>/// <br/>/// :<br/>/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>/// the last position.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// control1 ::<br/>/// A pointer to the first Bezier control point.<br/>/// control2 ::<br/>/// A pointer to second Bezier control point.<br/>/// to ::<br/>/// A pointer to the destination point.<br/>/// <br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pcontrol2 = &control2)
				{
					fixed (FTVector* pto = &to)
					{
						int ret = FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, (FTVector*)pcontrol2, (FTVector*)pto);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_GetBorderCounts")]
		internal static extern int FTStrokerGetBorderCountsNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_GetBorderCounts<br/>/// <br/>/// :<br/>/// Call this function once you have finished parsing your paths with the<br/>/// stroker.  It returns the number of points and contours necessary to<br/>/// export one of the 'border' or 'stroke' outlines generated by the<br/>/// stroker.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// border ::<br/>/// The border index.<br/>/// <br/>/// :<br/>/// anum_points ::<br/>/// The number of points.<br/>/// anum_contours ::<br/>/// The number of contours.<br/>/// <br/>/// <br/>/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>/// 'border' outlines with caps.  The 'left' border receives all points,<br/>/// while the 'right' border becomes empty.<br/>/// Use the function <br/>/// _Stroker_GetCounts instead if you want to retrieve<br/>/// the counts associated to both borders.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerGetBorderCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours)
		{
			int ret = FTStrokerGetBorderCountsNative(stroker, border, anumPoints, anumContours);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_GetBorderCounts<br/>/// <br/>/// :<br/>/// Call this function once you have finished parsing your paths with the<br/>/// stroker.  It returns the number of points and contours necessary to<br/>/// export one of the 'border' or 'stroke' outlines generated by the<br/>/// stroker.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// border ::<br/>/// The border index.<br/>/// <br/>/// :<br/>/// anum_points ::<br/>/// The number of points.<br/>/// anum_contours ::<br/>/// The number of contours.<br/>/// <br/>/// <br/>/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>/// 'border' outlines with caps.  The 'left' border receives all points,<br/>/// while the 'right' border becomes empty.<br/>/// Use the function <br/>/// _Stroker_GetCounts instead if you want to retrieve<br/>/// the counts associated to both borders.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerGetBorderCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				int ret = FTStrokerGetBorderCountsNative(stroker, border, (uint*)panumPoints, anumContours);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_GetBorderCounts<br/>/// <br/>/// :<br/>/// Call this function once you have finished parsing your paths with the<br/>/// stroker.  It returns the number of points and contours necessary to<br/>/// export one of the 'border' or 'stroke' outlines generated by the<br/>/// stroker.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// border ::<br/>/// The border index.<br/>/// <br/>/// :<br/>/// anum_points ::<br/>/// The number of points.<br/>/// anum_contours ::<br/>/// The number of contours.<br/>/// <br/>/// <br/>/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>/// 'border' outlines with caps.  The 'left' border receives all points,<br/>/// while the 'right' border becomes empty.<br/>/// Use the function <br/>/// _Stroker_GetCounts instead if you want to retrieve<br/>/// the counts associated to both borders.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerGetBorderCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumContours)
		{
			fixed (uint* panumContours = &anumContours)
			{
				int ret = FTStrokerGetBorderCountsNative(stroker, border, anumPoints, (uint*)panumContours);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_GetBorderCounts<br/>/// <br/>/// :<br/>/// Call this function once you have finished parsing your paths with the<br/>/// stroker.  It returns the number of points and contours necessary to<br/>/// export one of the 'border' or 'stroke' outlines generated by the<br/>/// stroker.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// border ::<br/>/// The border index.<br/>/// <br/>/// :<br/>/// anum_points ::<br/>/// The number of points.<br/>/// anum_contours ::<br/>/// The number of contours.<br/>/// <br/>/// <br/>/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>/// 'border' outlines with caps.  The 'left' border receives all points,<br/>/// while the 'right' border becomes empty.<br/>/// Use the function <br/>/// _Stroker_GetCounts instead if you want to retrieve<br/>/// the counts associated to both borders.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerGetBorderCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				fixed (uint* panumContours = &anumContours)
				{
					int ret = FTStrokerGetBorderCountsNative(stroker, border, (uint*)panumPoints, (uint*)panumContours);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ExportBorder<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export the<br/>
		/// corresponding border to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// <br/>
		/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>
		/// independent 'border' outlines, named 'left' and 'right'.<br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_Export instead if you want to retrieve<br/>
		/// all borders at once.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_ExportBorder")]
		internal static extern void FTStrokerExportBorderNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_ExportBorder<br/>/// <br/>/// :<br/>/// Call this function after <br/>/// _Stroker_GetBorderCounts to export the<br/>/// corresponding border to your own <br/>/// _Outline structure.<br/>/// Note that this function appends the border points and contours to your<br/>/// outline, but does not try to resize its arrays.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// border ::<br/>/// The border index.<br/>/// outline ::<br/>/// The target outline handle.<br/>/// <br/>/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>/// independent 'border' outlines, named 'left' and 'right'.<br/>/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>/// 'border' outlines with caps.  The 'left' border receives all points,<br/>/// while the 'right' border becomes empty.<br/>/// Use the function <br/>/// _Stroker_Export instead if you want to retrieve<br/>/// all borders at once.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTStrokerExportBorder([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline)
		{
			FTStrokerExportBorderNative(stroker, border, outline);
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_ExportBorder<br/>/// <br/>/// :<br/>/// Call this function after <br/>/// _Stroker_GetBorderCounts to export the<br/>/// corresponding border to your own <br/>/// _Outline structure.<br/>/// Note that this function appends the border points and contours to your<br/>/// outline, but does not try to resize its arrays.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// border ::<br/>/// The border index.<br/>/// outline ::<br/>/// The target outline handle.<br/>/// <br/>/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>/// independent 'border' outlines, named 'left' and 'right'.<br/>/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>/// 'border' outlines with caps.  The 'left' border receives all points,<br/>/// while the 'right' border becomes empty.<br/>/// Use the function <br/>/// _Stroker_Export instead if you want to retrieve<br/>/// all borders at once.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTStrokerExportBorder([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTStrokerExportBorderNative(stroker, border, (FTOutline*)poutline);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_GetCounts")]
		internal static extern int FTStrokerGetCountsNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_GetCounts<br/>/// <br/>/// :<br/>/// Call this function once you have finished parsing your paths with the<br/>/// stroker.  It returns the number of points and contours necessary to<br/>/// export all points/borders from the stroked outline/path.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// <br/>/// :<br/>/// anum_points ::<br/>/// The number of points.<br/>/// anum_contours ::<br/>/// The number of contours.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerGetCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours)
		{
			int ret = FTStrokerGetCountsNative(stroker, anumPoints, anumContours);
			return ret;
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_GetCounts<br/>/// <br/>/// :<br/>/// Call this function once you have finished parsing your paths with the<br/>/// stroker.  It returns the number of points and contours necessary to<br/>/// export all points/borders from the stroked outline/path.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// <br/>/// :<br/>/// anum_points ::<br/>/// The number of points.<br/>/// anum_contours ::<br/>/// The number of contours.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerGetCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				int ret = FTStrokerGetCountsNative(stroker, (uint*)panumPoints, anumContours);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_GetCounts<br/>/// <br/>/// :<br/>/// Call this function once you have finished parsing your paths with the<br/>/// stroker.  It returns the number of points and contours necessary to<br/>/// export all points/borders from the stroked outline/path.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// <br/>/// :<br/>/// anum_points ::<br/>/// The number of points.<br/>/// anum_contours ::<br/>/// The number of contours.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerGetCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumContours)
		{
			fixed (uint* panumContours = &anumContours)
			{
				int ret = FTStrokerGetCountsNative(stroker, anumPoints, (uint*)panumContours);
				return ret;
			}
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_GetCounts<br/>/// <br/>/// :<br/>/// Call this function once you have finished parsing your paths with the<br/>/// stroker.  It returns the number of points and contours necessary to<br/>/// export all points/borders from the stroked outline/path.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// <br/>/// :<br/>/// anum_points ::<br/>/// The number of points.<br/>/// anum_contours ::<br/>/// The number of contours.<br/>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int FTStrokerGetCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				fixed (uint* panumContours = &anumContours)
				{
					int ret = FTStrokerGetCountsNative(stroker, (uint*)panumPoints, (uint*)panumContours);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Export<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export all<br/>
		/// borders to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_Export")]
		internal static extern void FTStrokerExportNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_Export<br/>/// <br/>/// :<br/>/// Call this function after <br/>/// _Stroker_GetBorderCounts to export all<br/>/// borders to your own <br/>/// _Outline structure.<br/>/// Note that this function appends the border points and contours to your<br/>/// outline, but does not try to resize its arrays.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// outline ::<br/>/// The target outline handle.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTStrokerExport([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline)
		{
			FTStrokerExportNative(stroker, outline);
		}

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_Export<br/>/// <br/>/// :<br/>/// Call this function after <br/>/// _Stroker_GetBorderCounts to export all<br/>/// borders to your own <br/>/// _Outline structure.<br/>/// Note that this function appends the border points and contours to your<br/>/// outline, but does not try to resize its arrays.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// The target stroker handle.<br/>/// outline ::<br/>/// The target outline handle.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTStrokerExport([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTStrokerExportNative(stroker, (FTOutline*)poutline);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.  Can be `NULL`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Done")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "FT_Stroker_Done")]
		internal static extern void FTStrokerDoneNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker);

		/// <summary>/// ************************************************************************<br/>/// <br/>/// FT_Stroker_Done<br/>/// <br/>/// :<br/>/// Destroy a stroker object.<br/>/// <br/>/// :<br/>/// stroker ::<br/>/// A stroker handle.  Can be `NULL`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Done")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FTStrokerDone([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker)
		{
			FTStrokerDoneNative(stroker);
		}
	}
}
