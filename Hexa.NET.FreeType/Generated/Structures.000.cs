// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_MemoryRec<br/>
	/// <br/>
	/// :<br/>
	/// A structure used to describe a given memory manager to FreeType~2.<br/>
	/// <br/>
	/// :<br/>
	/// user ::<br/>
	/// A generic typeless pointer for user data.<br/>
	/// alloc ::<br/>
	/// A pointer type to an allocation function.<br/>
	/// free ::<br/>
	/// A pointer type to an memory freeing function.<br/>
	/// realloc ::<br/>
	/// A pointer type to a reallocation function.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_MemoryRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTMemoryRec
	{
		[NativeName(NativeNameType.Field, "user")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* User;
		[NativeName(NativeNameType.Field, "alloc")]
		[NativeName(NativeNameType.Type, "void* (*)()*")]
		public unsafe void* Alloc;
		[NativeName(NativeNameType.Field, "free")]
		[NativeName(NativeNameType.Type, "void (*)()*")]
		public unsafe void* Free;
		[NativeName(NativeNameType.Field, "realloc")]
		[NativeName(NativeNameType.Type, "void* (*)()*")]
		public unsafe void* Realloc;

		public unsafe FTMemoryRec(void* user = default, delegate*<void*> alloc = default, delegate*<void> free = default, delegate*<void*> realloc = default)
		{
			User = user;
			Alloc = (void*)alloc;
			Free = (void*)free;
			Realloc = (void*)realloc;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_StreamRec<br/>
	/// <br/>
	/// :<br/>
	/// A structure used to describe an input stream.<br/>
	/// <br/>
	/// :<br/>
	/// base ::<br/>
	/// For memory-based streams, this is the address of the first stream<br/>
	/// byte in memory.  This field should always be set to `NULL` for<br/>
	/// disk-based streams.<br/>
	/// size ::<br/>
	/// The stream size in bytes.<br/>
	/// In case of compressed streams where the size is unknown before<br/>
	/// actually doing the decompression, the value is set to 0x7FFFFFFF.<br/>
	/// (Note that this size value can occur for normal streams also; it is<br/>
	/// thus just a hint.)<br/>
	/// pos ::<br/>
	/// The current position within the stream.<br/>
	/// descriptor ::<br/>
	/// This field is a union that can hold an integer or a pointer.  It is<br/>
	/// used by stream implementations to store file descriptors or `FILE*`<br/>
	/// pointers.<br/>
	/// pathname ::<br/>
	/// This field is completely ignored by FreeType.  However, it is often<br/>
	/// useful during debugging to use it to store the stream's filename<br/>
	/// (where available).<br/>
	/// read ::<br/>
	/// The stream's input function.<br/>
	/// close ::<br/>
	/// The stream's close function.<br/>
	/// memory ::<br/>
	/// The memory manager to use to preload frames.  This is set internally<br/>
	/// by FreeType and shouldn't be touched by stream implementations.<br/>
	/// cursor ::<br/>
	/// This field is set and used internally by FreeType when parsing<br/>
	/// frames.  In particular, the `FT_GET_XXX` macros use this instead of<br/>
	/// the `pos` field.<br/>
	/// limit ::<br/>
	/// This field is set and used internally by FreeType when parsing<br/>
	/// frames.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_StreamRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTStreamRec
	{
		[NativeName(NativeNameType.Field, "base")]
		[NativeName(NativeNameType.Type, "unsigned char*")]
		public unsafe byte* Base;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint Size;
		[NativeName(NativeNameType.Field, "pos")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint Pos;
		[NativeName(NativeNameType.Field, "descriptor")]
		[NativeName(NativeNameType.Type, "FT_StreamDesc_")]
		public FTStreamDesc Descriptor;
		[NativeName(NativeNameType.Field, "pathname")]
		[NativeName(NativeNameType.Type, "FT_StreamDesc_")]
		public FTStreamDesc Pathname;
		[NativeName(NativeNameType.Field, "read")]
		[NativeName(NativeNameType.Type, "unsigned int (*)()*")]
		public unsafe void* Read;
		[NativeName(NativeNameType.Field, "close")]
		[NativeName(NativeNameType.Type, "void (*)()*")]
		public unsafe void* Close;
		[NativeName(NativeNameType.Field, "memory")]
		[NativeName(NativeNameType.Type, "FT_Memory")]
		public FTMemory Memory;
		[NativeName(NativeNameType.Field, "cursor")]
		[NativeName(NativeNameType.Type, "unsigned char*")]
		public unsafe byte* Cursor;
		[NativeName(NativeNameType.Field, "limit")]
		[NativeName(NativeNameType.Type, "unsigned char*")]
		public unsafe byte* Limit;

		public unsafe FTStreamRec(byte* baseValue = default, uint size = default, uint pos = default, FTStreamDesc descriptor = default, FTStreamDesc pathname = default, delegate*<uint> read = default, delegate*<void> close = default, FTMemory memory = default, byte* cursor = default, byte* limit = default)
		{
			Base = baseValue;
			Size = size;
			Pos = pos;
			Descriptor = descriptor;
			Pathname = pathname;
			Read = (void*)read;
			Close = (void*)close;
			Memory = memory;
			Cursor = cursor;
			Limit = limit;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_StreamDesc<br/>
	/// <br/>
	/// :<br/>
	/// A union type used to store either a long or a pointer.  This is used<br/>
	/// to store a file descriptor or a `FILE*` in an input stream.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_StreamDesc_")]
	[StructLayout(LayoutKind.Explicit)]
	public partial struct FTStreamDesc
	{
		[NativeName(NativeNameType.Field, "value")]
		[NativeName(NativeNameType.Type, "int")]
		[FieldOffset(0)]
		public int Value;
		[NativeName(NativeNameType.Field, "pointer")]
		[NativeName(NativeNameType.Type, "void*")]
		[FieldOffset(0)]
		public unsafe void* Pointer;

		public unsafe FTStreamDesc(int value = default, void* pointer = default)
		{
			Value = value;
			Pointer = pointer;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Vector<br/>
	/// <br/>
	/// :<br/>
	/// A simple structure used to store a 2D vector; coordinates are of the<br/>
	/// FT_Pos type.<br/>
	/// <br/>
	/// :<br/>
	/// x ::<br/>
	/// The horizontal coordinate.<br/>
	/// y ::<br/>
	/// The vertical coordinate.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Vector_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTVector
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int Y;

		public unsafe FTVector(int x = default, int y = default)
		{
			X = x;
			Y = y;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_BBox<br/>
	/// <br/>
	/// :<br/>
	/// A structure used to hold an outline's bounding box, i.e., the<br/>
	/// coordinates of its extrema in the horizontal and vertical directions.<br/>
	/// <br/>
	/// :<br/>
	/// xMin ::<br/>
	/// The horizontal minimum (left-most).<br/>
	/// yMin ::<br/>
	/// The vertical minimum (bottom-most).<br/>
	/// xMax ::<br/>
	/// The horizontal maximum (right-most).<br/>
	/// yMax ::<br/>
	/// The vertical maximum (top-most).<br/>
	/// <br/>
	/// If `yMin` is negative, this value gives the glyph's descender.<br/>
	/// Otherwise, the glyph doesn't descend below the baseline.  Similarly,<br/>
	/// if `ymax` is positive, this value gives the glyph's ascender.<br/>
	/// `xMin` gives the horizontal distance from the glyph's origin to the<br/>
	/// left edge of the glyph's bounding box.  If `xMin` is negative, the<br/>
	/// glyph extends to the left of the origin.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_BBox_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTBBox
	{
		[NativeName(NativeNameType.Field, "xMin")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int XMin;
		[NativeName(NativeNameType.Field, "yMin")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int YMin;
		[NativeName(NativeNameType.Field, "xMax")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int XMax;
		[NativeName(NativeNameType.Field, "yMax")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int YMax;

		public unsafe FTBBox(int xMin = default, int yMin = default, int xMax = default, int yMax = default)
		{
			XMin = xMin;
			YMin = yMin;
			XMax = xMax;
			YMax = yMax;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Bitmap<br/>
	/// <br/>
	/// :<br/>
	/// A structure used to describe a bitmap or pixmap to the raster.  Note<br/>
	/// that we now manage pixmaps of various depths through the `pixel_mode`<br/>
	/// field.<br/>
	/// <br/>
	/// :<br/>
	/// rows ::<br/>
	/// The number of bitmap rows.<br/>
	/// width ::<br/>
	/// The number of pixels in bitmap row.<br/>
	/// pitch ::<br/>
	/// The pitch's absolute value is the number of bytes taken by one<br/>
	/// bitmap row, including padding.  However, the pitch is positive when<br/>
	/// the bitmap has a 'down' flow, and negative when it has an 'up' flow.<br/>
	/// In all cases, the pitch is an offset to add to a bitmap pointer in<br/>
	/// order to go down one row.<br/>
	/// Note that 'padding' means the alignment of a bitmap to a byte<br/>
	/// border, and FreeType functions normally align to the smallest<br/>
	/// possible integer value.<br/>
	/// For the B/W rasterizer, `pitch` is always an even number.<br/>
	/// To change the pitch of a bitmap (say, to make it a multiple of 4),<br/>
	/// use <br/>
	/// _Bitmap_Convert.  Alternatively, you might use callback<br/>
	/// functions to directly render to the application's surface; see the<br/>
	/// file `example2.cpp` in the tutorial for a demonstration.<br/>
	/// buffer ::<br/>
	/// A typeless pointer to the bitmap buffer.  This value should be<br/>
	/// aligned on 32-bit boundaries in most cases.<br/>
	/// num_grays ::<br/>
	/// This field is only used with <br/>
	/// _PIXEL_MODE_GRAY; it gives the<br/>
	/// number of gray levels used in the bitmap.<br/>
	/// pixel_mode ::<br/>
	/// The pixel mode, i.e., how pixel bits are stored.  See <br/>
	/// _Pixel_Mode<br/>
	/// for possible values.<br/>
	/// palette_mode ::<br/>
	/// This field is intended for paletted pixel modes; it indicates how<br/>
	/// the palette is stored.  Not used currently.<br/>
	/// palette ::<br/>
	/// A typeless pointer to the bitmap palette; this field is intended for<br/>
	/// paletted pixel modes.  Not used currently.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Bitmap_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTBitmap
	{
		[NativeName(NativeNameType.Field, "rows")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint Rows;
		[NativeName(NativeNameType.Field, "width")]
		[NativeName(NativeNameType.Type, "unsigned int")]
		public uint Width;
		[NativeName(NativeNameType.Field, "pitch")]
		[NativeName(NativeNameType.Type, "int")]
		public int Pitch;
		[NativeName(NativeNameType.Field, "buffer")]
		[NativeName(NativeNameType.Type, "unsigned char*")]
		public unsafe byte* Buffer;
		[NativeName(NativeNameType.Field, "num_grays")]
		[NativeName(NativeNameType.Type, "unsigned short")]
		public ushort NumGrays;
		[NativeName(NativeNameType.Field, "pixel_mode")]
		[NativeName(NativeNameType.Type, "unsigned char")]
		public byte PixelMode;
		[NativeName(NativeNameType.Field, "palette_mode")]
		[NativeName(NativeNameType.Type, "unsigned char")]
		public byte PaletteMode;
		[NativeName(NativeNameType.Field, "palette")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* Palette;

		public unsafe FTBitmap(uint rows = default, uint width = default, int pitch = default, byte* buffer = default, ushort numGrays = default, byte pixelMode = default, byte paletteMode = default, void* palette = default)
		{
			Rows = rows;
			Width = width;
			Pitch = pitch;
			Buffer = buffer;
			NumGrays = numGrays;
			PixelMode = pixelMode;
			PaletteMode = paletteMode;
			Palette = palette;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Outline<br/>
	/// <br/>
	/// :<br/>
	/// This structure is used to describe an outline to the scan-line<br/>
	/// converter.<br/>
	/// <br/>
	/// :<br/>
	/// n_contours ::<br/>
	/// The number of contours in the outline.<br/>
	/// n_points ::<br/>
	/// The number of points in the outline.<br/>
	/// points ::<br/>
	/// A pointer to an array of `n_points` <br/>
	/// _Vector elements, giving the<br/>
	/// outline's point coordinates.<br/>
	/// tags ::<br/>
	/// A pointer to an array of `n_points` chars, giving each outline<br/>
	/// point's type.<br/>
	/// If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier<br/>
	/// control point, while it is 'on' if set.<br/>
	/// Bit~1 is meaningful for 'off' points only.  If set, it indicates a<br/>
	/// third-order Bezier arc control point; and a second-order control<br/>
	/// point if unset.<br/>
	/// If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in<br/>
	/// the OpenType specification; the value is the same as the argument to<br/>
	/// the 'SCANMODE' instruction).<br/>
	/// Bits 3 and~4 are reserved for internal purposes.<br/>
	/// contours ::<br/>
	/// An array of `n_contours` shorts, giving the end point of each<br/>
	/// contour within the outline.  For example, the first contour is<br/>
	/// defined by the points '0' to `contours[0]`, the second one is<br/>
	/// defined by the points `contours[0]+1` to `contours[1]`, etc.<br/>
	/// flags ::<br/>
	/// A set of bit flags used to characterize the outline and give hints<br/>
	/// to the scan-converter and hinter on how to convert/grid-fit it.  See<br/>
	/// <br/>
	/// _OUTLINE_XXX.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Outline_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTOutline
	{
		/// <summary>
		/// number of contours in glyph        <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "n_contours")]
		[NativeName(NativeNameType.Type, "short")]
		public short NContours;

		/// <summary>
		/// number of points in the glyph      <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "n_points")]
		[NativeName(NativeNameType.Type, "short")]
		public short NPoints;

		/// <summary>
		/// the outline's points               <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "points")]
		[NativeName(NativeNameType.Type, "FT_Vector*")]
		public unsafe FTVector* Points;

		/// <summary>
		/// the points flags                   <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "tags")]
		[NativeName(NativeNameType.Type, "char*")]
		public unsafe byte* Tags;

		/// <summary>
		/// the contour end points             <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "contours")]
		[NativeName(NativeNameType.Type, "short*")]
		public unsafe short* Contours;

		/// <summary>
		/// outline masks                      <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "int")]
		public int Flags;


		public unsafe FTOutline(short nContours = default, short nPoints = default, FTVector* points = default, byte* tags = default, short* contours = default, int flags = default)
		{
			NContours = nContours;
			NPoints = nPoints;
			Points = points;
			Tags = tags;
			Contours = contours;
			Flags = flags;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Outline_Funcs<br/>
	/// <br/>
	/// :<br/>
	/// A structure to hold various function pointers used during outline<br/>
	/// decomposition in order to emit segments, conic, and cubic Beziers.<br/>
	/// <br/>
	/// :<br/>
	/// move_to ::<br/>
	/// The 'move to' emitter.<br/>
	/// line_to ::<br/>
	/// The segment emitter.<br/>
	/// conic_to ::<br/>
	/// The second-order Bezier arc emitter.<br/>
	/// cubic_to ::<br/>
	/// The third-order Bezier arc emitter.<br/>
	/// shift ::<br/>
	/// The shift that is applied to coordinates before they are sent to the<br/>
	/// emitter.<br/>
	/// delta ::<br/>
	/// The delta that is applied to coordinates before they are sent to the<br/>
	/// emitter, but after the shift.<br/>
	/// <br/>
	/// ```<br/>
	/// x' = (x <br/>
	/// <<br/>
	/// <<br/>
	/// shift) - delta<br/>
	/// y' = (y <br/>
	/// <<br/>
	/// <<br/>
	/// shift) - delta<br/>
	/// ```<br/>
	/// Set the values of `shift` and `delta` to~0 to get the original point<br/>
	/// coordinates.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Outline_Funcs_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTOutlineFuncs
	{
		[NativeName(NativeNameType.Field, "move_to")]
		[NativeName(NativeNameType.Type, "FT_Outline_MoveToFunc")]
		public unsafe void* MoveTo;
		[NativeName(NativeNameType.Field, "line_to")]
		[NativeName(NativeNameType.Type, "FT_Outline_LineToFunc")]
		public unsafe void* LineTo;
		[NativeName(NativeNameType.Field, "conic_to")]
		[NativeName(NativeNameType.Type, "FT_Outline_ConicToFunc")]
		public unsafe void* ConicTo;
		[NativeName(NativeNameType.Field, "cubic_to")]
		[NativeName(NativeNameType.Type, "FT_Outline_CubicToFunc")]
		public unsafe void* CubicTo;
		[NativeName(NativeNameType.Field, "shift")]
		[NativeName(NativeNameType.Type, "int")]
		public int Shift;
		[NativeName(NativeNameType.Field, "delta")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int Delta;

		public unsafe FTOutlineFuncs(FTOutlineMoveToFunc moveTo = default, FTOutlineLineToFunc lineTo = default, FTOutlineConicToFunc conicTo = default, FTOutlineCubicToFunc cubicTo = default, int shift = default, int delta = default)
		{
			MoveTo = (void*)Marshal.GetFunctionPointerForDelegate(moveTo);
			LineTo = (void*)Marshal.GetFunctionPointerForDelegate(lineTo);
			ConicTo = (void*)Marshal.GetFunctionPointerForDelegate(conicTo);
			CubicTo = (void*)Marshal.GetFunctionPointerForDelegate(cubicTo);
			Shift = shift;
			Delta = delta;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Span<br/>
	/// <br/>
	/// :<br/>
	/// A structure to model a single span of consecutive pixels when<br/>
	/// rendering an anti-aliased bitmap.<br/>
	/// <br/>
	/// :<br/>
	/// x ::<br/>
	/// The span's horizontal start position.<br/>
	/// len ::<br/>
	/// The span's length in pixels.<br/>
	/// coverage ::<br/>
	/// The span color/coverage, ranging from 0 (background) to 255<br/>
	/// (foreground).<br/>
	/// <br/>
	/// The anti-aliased rasterizer produces coverage values from 0 to 255,<br/>
	/// that is, from completely transparent to completely opaque.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Span_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTSpan
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "short")]
		public short X;
		[NativeName(NativeNameType.Field, "len")]
		[NativeName(NativeNameType.Type, "unsigned short")]
		public ushort Len;
		[NativeName(NativeNameType.Field, "coverage")]
		[NativeName(NativeNameType.Type, "unsigned char")]
		public byte Coverage;

		public unsafe FTSpan(short x = default, ushort len = default, byte coverage = default)
		{
			X = x;
			Len = len;
			Coverage = coverage;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Raster_Params<br/>
	/// <br/>
	/// :<br/>
	/// A structure to hold the parameters used by a raster's render function,<br/>
	/// passed as an argument to <br/>
	/// _Outline_Render.<br/>
	/// <br/>
	/// :<br/>
	/// target ::<br/>
	/// The target bitmap.<br/>
	/// source ::<br/>
	/// A pointer to the source glyph image (e.g., an <br/>
	/// _Outline).<br/>
	/// flags ::<br/>
	/// The rendering flags.<br/>
	/// gray_spans ::<br/>
	/// The gray span drawing callback.<br/>
	/// black_spans ::<br/>
	/// Unused.<br/>
	/// bit_test ::<br/>
	/// Unused.<br/>
	/// bit_set ::<br/>
	/// Unused.<br/>
	/// user ::<br/>
	/// User-supplied data that is passed to each drawing callback.<br/>
	/// clip_box ::<br/>
	/// An optional span clipping box expressed in _integer_ pixels<br/>
	/// (not in 26.6 fixed-point units).<br/>
	/// <br/>
	/// If both <br/>
	/// _RASTER_FLAG_AA and <br/>
	/// _RASTER_FLAG_DIRECT bit flags<br/>
	/// are set in `flags`, the raster calls an <br/>
	/// _SpanFunc callback<br/>
	/// `gray_spans` with `user` data as an argument ignoring `target`.  This<br/>
	/// allows direct composition over a pre-existing user surface to perform<br/>
	/// the span drawing and composition.  To optionally clip the spans, set<br/>
	/// the <br/>
	/// _RASTER_FLAG_CLIP flag and `clip_box`.  The monochrome raster<br/>
	/// does not support the direct mode.<br/>
	/// The gray-level rasterizer always uses 256 gray levels.  If you want<br/>
	/// fewer gray levels, you have to use <br/>
	/// _RASTER_FLAG_DIRECT and reduce<br/>
	/// the levels in the callback function.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Raster_Params_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTRasterParams
	{
		[NativeName(NativeNameType.Field, "target")]
		[NativeName(NativeNameType.Type, "const FT_Bitmap*")]
		public unsafe FTBitmap* Target;
		[NativeName(NativeNameType.Field, "source")]
		[NativeName(NativeNameType.Type, "const void*")]
		public unsafe void* Source;
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "int")]
		public int Flags;
		[NativeName(NativeNameType.Field, "gray_spans")]
		[NativeName(NativeNameType.Type, "FT_SpanFunc")]
		public unsafe void* GraySpans;
		/// <summary>
		/// unused <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "black_spans")]
		[NativeName(NativeNameType.Type, "FT_SpanFunc")]
		public unsafe void* BlackSpans;
		/// <summary>
		/// unused <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "bit_test")]
		[NativeName(NativeNameType.Type, "FT_Raster_BitTest_Func")]
		public unsafe void* BitTest;
		/// <summary>
		/// unused <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "bit_set")]
		[NativeName(NativeNameType.Type, "FT_Raster_BitSet_Func")]
		public unsafe void* BitSet;
		[NativeName(NativeNameType.Field, "user")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* User;
		[NativeName(NativeNameType.Field, "clip_box")]
		[NativeName(NativeNameType.Type, "FT_BBox")]
		public FTBBox ClipBox;

		public unsafe FTRasterParams(FTBitmap* target = default, void* source = default, int flags = default, FTSpanFunc graySpans = default, FTSpanFunc blackSpans = default, FTRasterBitTestFunc bitTest = default, FTRasterBitSetFunc bitSet = default, void* user = default, FTBBox clipBox = default)
		{
			Target = target;
			Source = source;
			Flags = flags;
			GraySpans = (void*)Marshal.GetFunctionPointerForDelegate(graySpans);
			BlackSpans = (void*)Marshal.GetFunctionPointerForDelegate(blackSpans);
			BitTest = (void*)Marshal.GetFunctionPointerForDelegate(bitTest);
			BitSet = (void*)Marshal.GetFunctionPointerForDelegate(bitSet);
			User = user;
			ClipBox = clipBox;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "FT_RasterRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTRasterRec
	{


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Raster_Funcs<br/>
	/// <br/>
	/// :<br/>
	/// A structure used to describe a given raster class to the library.<br/>
	/// <br/>
	/// :<br/>
	/// glyph_format ::<br/>
	/// The supported glyph format for this raster.<br/>
	/// raster_new ::<br/>
	/// The raster constructor.<br/>
	/// raster_reset ::<br/>
	/// Used to reset the render pool within the raster.<br/>
	/// raster_render ::<br/>
	/// A function to render a glyph into a given bitmap.<br/>
	/// raster_done ::<br/>
	/// The raster destructor.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Raster_Funcs_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTRasterFuncs
	{
		[NativeName(NativeNameType.Field, "glyph_format")]
		[NativeName(NativeNameType.Type, "FT_Glyph_Format")]
		public FTGlyphFormat GlyphFormat;
		[NativeName(NativeNameType.Field, "raster_new")]
		[NativeName(NativeNameType.Type, "FT_Raster_NewFunc")]
		public unsafe void* RasterNew;
		[NativeName(NativeNameType.Field, "raster_reset")]
		[NativeName(NativeNameType.Type, "FT_Raster_ResetFunc")]
		public unsafe void* RasterReset;
		[NativeName(NativeNameType.Field, "raster_set_mode")]
		[NativeName(NativeNameType.Type, "FT_Raster_SetModeFunc")]
		public unsafe void* RasterSetMode;
		[NativeName(NativeNameType.Field, "raster_render")]
		[NativeName(NativeNameType.Type, "FT_Raster_RenderFunc")]
		public unsafe void* RasterRender;
		[NativeName(NativeNameType.Field, "raster_done")]
		[NativeName(NativeNameType.Type, "FT_Raster_DoneFunc")]
		public unsafe void* RasterDone;

		public unsafe FTRasterFuncs(FTGlyphFormat glyphFormat = default, FTRasterNewFunc rasterNew = default, FTRasterResetFunc rasterReset = default, FTRasterSetModeFunc rasterSetMode = default, FTRasterRenderFunc rasterRender = default, FTRasterDoneFunc rasterDone = default)
		{
			GlyphFormat = glyphFormat;
			RasterNew = (void*)Marshal.GetFunctionPointerForDelegate(rasterNew);
			RasterReset = (void*)Marshal.GetFunctionPointerForDelegate(rasterReset);
			RasterSetMode = (void*)Marshal.GetFunctionPointerForDelegate(rasterSetMode);
			RasterRender = (void*)Marshal.GetFunctionPointerForDelegate(rasterRender);
			RasterDone = (void*)Marshal.GetFunctionPointerForDelegate(rasterDone);
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_UnitVector<br/>
	/// <br/>
	/// :<br/>
	/// A simple structure used to store a 2D vector unit vector.  Uses<br/>
	/// FT_F2Dot14 types.<br/>
	/// <br/>
	/// :<br/>
	/// x ::<br/>
	/// Horizontal coordinate.<br/>
	/// y ::<br/>
	/// Vertical coordinate.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_UnitVector_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTUnitVector
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "FT_F2Dot14")]
		public short X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "FT_F2Dot14")]
		public short Y;

		public unsafe FTUnitVector(short x = default, short y = default)
		{
			X = x;
			Y = y;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Matrix<br/>
	/// <br/>
	/// :<br/>
	/// A simple structure used to store a 2x2 matrix.  Coefficients are in<br/>
	/// 16.16 fixed-point format.  The computation performed is:<br/>
	/// ```<br/>
	/// x' = x*xx + y*xy<br/>
	/// y' = x*yx + y*yy<br/>
	/// ```<br/>
	/// <br/>
	/// :<br/>
	/// xx ::<br/>
	/// Matrix coefficient.<br/>
	/// xy ::<br/>
	/// Matrix coefficient.<br/>
	/// yx ::<br/>
	/// Matrix coefficient.<br/>
	/// yy ::<br/>
	/// Matrix coefficient.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Matrix_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTMatrix
	{
		[NativeName(NativeNameType.Field, "xx")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int Xx;
		[NativeName(NativeNameType.Field, "xy")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int Xy;
		[NativeName(NativeNameType.Field, "yx")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int Yx;
		[NativeName(NativeNameType.Field, "yy")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int Yy;

		public unsafe FTMatrix(int xx = default, int xy = default, int yx = default, int yy = default)
		{
			Xx = xx;
			Xy = xy;
			Yx = yx;
			Yy = yy;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Data<br/>
	/// <br/>
	/// :<br/>
	/// Read-only binary data represented as a pointer and a length.<br/>
	/// <br/>
	/// :<br/>
	/// pointer ::<br/>
	/// The data.<br/>
	/// length ::<br/>
	/// The length of the data in bytes.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Data_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTData
	{
		[NativeName(NativeNameType.Field, "pointer")]
		[NativeName(NativeNameType.Type, "const FT_Byte*")]
		public unsafe byte* Pointer;
		[NativeName(NativeNameType.Field, "length")]
		[NativeName(NativeNameType.Type, "FT_UInt")]
		public uint Length;

		public unsafe FTData(byte* pointer = default, uint length = default)
		{
			Pointer = pointer;
			Length = length;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Generic<br/>
	/// <br/>
	/// :<br/>
	/// Client applications often need to associate their own data to a<br/>
	/// variety of FreeType core objects.  For example, a text layout API<br/>
	/// might want to associate a glyph cache to a given size object.<br/>
	/// Some FreeType object contains a `generic` field, of type `FT_Generic`,<br/>
	/// which usage is left to client applications and font servers.<br/>
	/// It can be used to store a pointer to client-specific data, as well as<br/>
	/// the address of a 'finalizer' function, which will be called by<br/>
	/// FreeType when the object is destroyed (for example, the previous<br/>
	/// client example would put the address of the glyph cache destructor in<br/>
	/// the `finalizer` field).<br/>
	/// <br/>
	/// :<br/>
	/// data ::<br/>
	/// A typeless pointer to any client-specified data. This field is<br/>
	/// completely ignored by the FreeType library.<br/>
	/// finalizer ::<br/>
	/// A pointer to a 'generic finalizer' function, which will be called<br/>
	/// when the object is destroyed.  If this field is set to `NULL`, no<br/>
	/// code will be called.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Generic_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTGeneric
	{
		[NativeName(NativeNameType.Field, "data")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* Data;
		[NativeName(NativeNameType.Field, "finalizer")]
		[NativeName(NativeNameType.Type, "FT_Generic_Finalizer")]
		public unsafe void* Finalizer;

		public unsafe FTGeneric(void* data = default, FTGenericFinalizer finalizer = default)
		{
			Data = data;
			Finalizer = (void*)Marshal.GetFunctionPointerForDelegate(finalizer);
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_ListNodeRec<br/>
	/// <br/>
	/// :<br/>
	/// A structure used to hold a single list element.<br/>
	/// <br/>
	/// :<br/>
	/// prev ::<br/>
	/// The previous element in the list.  `NULL` if first.<br/>
	/// next ::<br/>
	/// The next element in the list.  `NULL` if last.<br/>
	/// data ::<br/>
	/// A typeless pointer to the listed object.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_ListNodeRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTListNodeRec
	{
		[NativeName(NativeNameType.Field, "prev")]
		[NativeName(NativeNameType.Type, "FT_ListNodeRec_*")]
		public unsafe FTListNodeRec* Prev;
		[NativeName(NativeNameType.Field, "next")]
		[NativeName(NativeNameType.Type, "FT_ListNodeRec_*")]
		public unsafe FTListNodeRec* Next;
		[NativeName(NativeNameType.Field, "data")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* Data;

		public unsafe FTListNodeRec(FTListNodeRec* prev = default, FTListNodeRec* next = default, void* data = default)
		{
			Prev = prev;
			Next = next;
			Data = data;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_ListRec<br/>
	/// <br/>
	/// :<br/>
	/// A structure used to hold a simple doubly-linked list.  These are used<br/>
	/// in many parts of FreeType.<br/>
	/// <br/>
	/// :<br/>
	/// head ::<br/>
	/// The head (first element) of doubly-linked list.<br/>
	/// tail ::<br/>
	/// The tail (last element) of doubly-linked list.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_ListRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTListRec
	{
		[NativeName(NativeNameType.Field, "head")]
		[NativeName(NativeNameType.Type, "FT_ListNode")]
		public FTListNode Head;
		[NativeName(NativeNameType.Field, "tail")]
		[NativeName(NativeNameType.Type, "FT_ListNode")]
		public FTListNode Tail;

		public unsafe FTListRec(FTListNode head = default, FTListNode tail = default)
		{
			Head = head;
			Tail = tail;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Glyph_Metrics<br/>
	/// <br/>
	/// :<br/>
	/// A structure to model the metrics of a single glyph.  The values are<br/>
	/// expressed in 26.6 fractional pixel format; if the flag<br/>
	/// <br/>
	/// _LOAD_NO_SCALE has been used while loading the glyph, values are<br/>
	/// expressed in font units instead.<br/>
	/// <br/>
	/// :<br/>
	/// width ::<br/>
	/// The glyph's width.<br/>
	/// height ::<br/>
	/// The glyph's height.<br/>
	/// horiBearingX ::<br/>
	/// Left side bearing for horizontal layout.<br/>
	/// horiBearingY ::<br/>
	/// Top side bearing for horizontal layout.<br/>
	/// horiAdvance ::<br/>
	/// Advance width for horizontal layout.<br/>
	/// vertBearingX ::<br/>
	/// Left side bearing for vertical layout.<br/>
	/// vertBearingY ::<br/>
	/// Top side bearing for vertical layout.  Larger positive values mean<br/>
	/// further below the vertical glyph origin.<br/>
	/// vertAdvance ::<br/>
	/// Advance height for vertical layout.  Positive values mean the glyph<br/>
	/// has a positive advance downward.<br/>
	/// <br/>
	/// Stroking a glyph with an outside border does not increase<br/>
	/// `horiAdvance` or `vertAdvance`; you have to manually adjust these<br/>
	/// values to account for the added width and height.<br/>
	/// FreeType doesn't use the 'VORG' table data for CFF fonts because it<br/>
	/// doesn't have an interface to quickly retrieve the glyph height.  The<br/>
	/// y~coordinate of the vertical origin can be simply computed as<br/>
	/// `vertBearingY + height` after loading a glyph.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Glyph_Metrics_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTGlyphMetrics
	{
		[NativeName(NativeNameType.Field, "width")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int Width;
		[NativeName(NativeNameType.Field, "height")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int Height;
		[NativeName(NativeNameType.Field, "horiBearingX")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int HoriBearingX;
		[NativeName(NativeNameType.Field, "horiBearingY")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int HoriBearingY;
		[NativeName(NativeNameType.Field, "horiAdvance")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int HoriAdvance;
		[NativeName(NativeNameType.Field, "vertBearingX")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int VertBearingX;
		[NativeName(NativeNameType.Field, "vertBearingY")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int VertBearingY;
		[NativeName(NativeNameType.Field, "vertAdvance")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int VertAdvance;

		public unsafe FTGlyphMetrics(int width = default, int height = default, int horiBearingX = default, int horiBearingY = default, int horiAdvance = default, int vertBearingX = default, int vertBearingY = default, int vertAdvance = default)
		{
			Width = width;
			Height = height;
			HoriBearingX = horiBearingX;
			HoriBearingY = horiBearingY;
			HoriAdvance = horiAdvance;
			VertBearingX = vertBearingX;
			VertBearingY = vertBearingY;
			VertAdvance = vertAdvance;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Bitmap_Size<br/>
	/// <br/>
	/// :<br/>
	/// This structure models the metrics of a bitmap strike (i.e., a set of<br/>
	/// glyphs for a given point size and resolution) in a bitmap font.  It is<br/>
	/// used for the `available_sizes` field of <br/>
	/// _Face.<br/>
	/// <br/>
	/// :<br/>
	/// height ::<br/>
	/// The vertical distance, in pixels, between two consecutive baselines.<br/>
	/// It is always positive.<br/>
	/// width ::<br/>
	/// The average width, in pixels, of all glyphs in the strike.<br/>
	/// size ::<br/>
	/// The nominal size of the strike in 26.6 fractional points.  This<br/>
	/// field is not very useful.<br/>
	/// x_ppem ::<br/>
	/// The horizontal ppem (nominal width) in 26.6 fractional pixels.<br/>
	/// y_ppem ::<br/>
	/// The vertical ppem (nominal height) in 26.6 fractional pixels.<br/>
	/// <br/>
	/// TrueType embedded bitmaps:<br/>
	/// `size`, `width`, and `height` values are not contained in the bitmap<br/>
	/// strike itself.  They are computed from the global font parameters.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Bitmap_Size_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTBitmapSize
	{
		[NativeName(NativeNameType.Field, "height")]
		[NativeName(NativeNameType.Type, "FT_Short")]
		public short Height;
		[NativeName(NativeNameType.Field, "width")]
		[NativeName(NativeNameType.Type, "FT_Short")]
		public short Width;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int Size;
		[NativeName(NativeNameType.Field, "x_ppem")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int XPpem;
		[NativeName(NativeNameType.Field, "y_ppem")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int YPpem;

		public unsafe FTBitmapSize(short height = default, short width = default, int size = default, int xPpem = default, int yPpem = default)
		{
			Height = height;
			Width = width;
			Size = size;
			XPpem = xPpem;
			YPpem = yPpem;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "FT_LibraryRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTLibraryRec
	{


	}

	[NativeName(NativeNameType.StructOrClass, "FT_ModuleRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTModuleRec
	{


	}

	[NativeName(NativeNameType.StructOrClass, "FT_DriverRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTDriverRec
	{


	}

	[NativeName(NativeNameType.StructOrClass, "FT_RendererRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTRendererRec
	{


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_FaceRec<br/>
	/// <br/>
	/// :<br/>
	/// FreeType root face class structure.  A face object models a typeface<br/>
	/// in a font file.<br/>
	/// <br/>
	/// :<br/>
	/// num_faces ::<br/>
	/// The number of faces in the font file.  Some font formats can have<br/>
	/// multiple faces in a single font file.<br/>
	/// face_index ::<br/>
	/// This field holds two different values.  Bits 0-15 are the index of<br/>
	/// the face in the font file (starting with value~0).  They are set<br/>
	/// to~0 if there is only one face in the font file.<br/>
	/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>
	/// fonts only, holding the named instance index for the current face<br/>
	/// index (starting with value~1; value~0 indicates font access without<br/>
	/// a named instance).  For non-variation fonts, bits 16-30 are ignored.<br/>
	/// If we have the third named instance of face~4, say, `face_index` is<br/>
	/// set to 0x00030004.<br/>
	/// Bit 31 is always zero (that is, `face_index` is always a positive<br/>
	/// value).<br/>
	/// [Since 2.9] Changing the design coordinates with<br/>
	/// <br/>
	/// _Set_Var_Design_Coordinates or <br/>
	/// _Set_Var_Blend_Coordinates does<br/>
	/// not influence the named instance index value (only<br/>
	/// <br/>
	/// _Set_Named_Instance does that).<br/>
	/// face_flags ::<br/>
	/// A set of bit flags that give important information about the face;<br/>
	/// see <br/>
	/// _FACE_FLAG_XXX for the details.<br/>
	/// style_flags ::<br/>
	/// The lower 16~bits contain a set of bit flags indicating the style of<br/>
	/// the face; see <br/>
	/// _STYLE_FLAG_XXX for the details.<br/>
	/// [Since 2.6.1] Bits 16-30 hold the number of named instances<br/>
	/// available for the current face if we have a GX or OpenType variation<br/>
	/// (sub)font.  Bit 31 is always zero (that is, `style_flags` is always<br/>
	/// a positive value).  Note that a variation font has always at least<br/>
	/// one named instance, namely the default instance.<br/>
	/// num_glyphs ::<br/>
	/// The number of glyphs in the face.  If the face is scalable and has<br/>
	/// sbits (see `num_fixed_sizes`), it is set to the number of outline<br/>
	/// glyphs.<br/>
	/// For CID-keyed fonts (not in an SFNT wrapper) this value gives the<br/>
	/// highest CID used in the font.<br/>
	/// family_name ::<br/>
	/// The face's family name.  This is an ASCII string, usually in<br/>
	/// English, that describes the typeface's family (like 'Times New<br/>
	/// Roman', 'Bodoni', 'Garamond', etc).  This is a least common<br/>
	/// denominator used to list fonts.  Some formats (TrueType <br/>
	/// &<br/>
	/// OpenType)<br/>
	/// provide localized and Unicode versions of this string.  Applications<br/>
	/// should use the format-specific interface to access them.  Can be<br/>
	/// `NULL` (e.g., in fonts embedded in a PDF file).<br/>
	/// In case the font doesn't provide a specific family name entry,<br/>
	/// FreeType tries to synthesize one, deriving it from other name<br/>
	/// entries.<br/>
	/// style_name ::<br/>
	/// The face's style name.  This is an ASCII string, usually in English,<br/>
	/// that describes the typeface's style (like 'Italic', 'Bold',<br/>
	/// 'Condensed', etc).  Not all font formats provide a style name, so<br/>
	/// this field is optional, and can be set to `NULL`.  As for<br/>
	/// `family_name`, some formats provide localized and Unicode versions<br/>
	/// of this string.  Applications should use the format-specific<br/>
	/// interface to access them.<br/>
	/// num_fixed_sizes ::<br/>
	/// The number of bitmap strikes in the face.  Even if the face is<br/>
	/// scalable, there might still be bitmap strikes, which are called<br/>
	/// 'sbits' in that case.<br/>
	/// available_sizes ::<br/>
	/// An array of <br/>
	/// _Bitmap_Size for all bitmap strikes in the face.  It<br/>
	/// is set to `NULL` if there is no bitmap strike.<br/>
	/// Note that FreeType tries to sanitize the strike data since they are<br/>
	/// sometimes sloppy or incorrect, but this can easily fail.<br/>
	/// num_charmaps ::<br/>
	/// The number of charmaps in the face.<br/>
	/// charmaps ::<br/>
	/// An array of the charmaps of the face.<br/>
	/// generic ::<br/>
	/// A field reserved for client uses.  See the <br/>
	/// _Generic type<br/>
	/// description.<br/>
	/// bbox ::<br/>
	/// The font bounding box.  Coordinates are expressed in font units (see<br/>
	/// `units_per_EM`).  The box is large enough to contain any glyph from<br/>
	/// the font.  Thus, `bbox.yMax` can be seen as the 'maximum ascender',<br/>
	/// and `bbox.yMin` as the 'minimum descender'.  Only relevant for<br/>
	/// scalable formats.<br/>
	/// Note that the bounding box might be off by (at least) one pixel for<br/>
	/// hinted fonts.  See <br/>
	/// _Size_Metrics for further discussion.<br/>
	/// Note that the bounding box does not vary in OpenType variation fonts<br/>
	/// and should only be used in relation to the default instance.<br/>
	/// units_per_EM ::<br/>
	/// The number of font units per EM square for this face.  This is<br/>
	/// typically 2048 for TrueType fonts, and 1000 for Type~1 fonts.  Only<br/>
	/// relevant for scalable formats.<br/>
	/// ascender ::<br/>
	/// The typographic ascender of the face, expressed in font units.  For<br/>
	/// font formats not having this information, it is set to `bbox.yMax`.<br/>
	/// Only relevant for scalable formats.<br/>
	/// descender ::<br/>
	/// The typographic descender of the face, expressed in font units.  For<br/>
	/// font formats not having this information, it is set to `bbox.yMin`.<br/>
	/// Note that this field is negative for values below the baseline.<br/>
	/// Only relevant for scalable formats.<br/>
	/// height ::<br/>
	/// This value is the vertical distance between two consecutive<br/>
	/// baselines, expressed in font units.  It is always positive.  Only<br/>
	/// relevant for scalable formats.<br/>
	/// If you want the global glyph height, use `ascender - descender`.<br/>
	/// max_advance_width ::<br/>
	/// The maximum advance width, in font units, for all glyphs in this<br/>
	/// face.  This can be used to make word wrapping computations faster.<br/>
	/// Only relevant for scalable formats.<br/>
	/// max_advance_height ::<br/>
	/// The maximum advance height, in font units, for all glyphs in this<br/>
	/// face.  This is only relevant for vertical layouts, and is set to<br/>
	/// `height` for fonts that do not provide vertical metrics.  Only<br/>
	/// relevant for scalable formats.<br/>
	/// underline_position ::<br/>
	/// The position, in font units, of the underline line for this face.<br/>
	/// It is the center of the underlining stem.  Only relevant for<br/>
	/// scalable formats.<br/>
	/// underline_thickness ::<br/>
	/// The thickness, in font units, of the underline for this face.  Only<br/>
	/// relevant for scalable formats.<br/>
	/// glyph ::<br/>
	/// The face's associated glyph slot(s).<br/>
	/// size ::<br/>
	/// The current active size for this face.<br/>
	/// charmap ::<br/>
	/// The current active charmap for this face.<br/>
	/// <br/>
	/// For an OpenType variation font, the values of the following fields can<br/>
	/// change after a call to <br/>
	/// _Set_Var_Design_Coordinates (and friends) if<br/>
	/// the font contains an 'MVAR' table: `ascender`, `descender`, `height`,<br/>
	/// `underline_position`, and `underline_thickness`.<br/>
	/// Especially for TrueType fonts see also the documentation for<br/>
	/// <br/>
	/// _Size_Metrics.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_FaceRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTFaceRec
	{
		[NativeName(NativeNameType.Field, "num_faces")]
		[NativeName(NativeNameType.Type, "FT_Long")]
		public int NumFaces;
		[NativeName(NativeNameType.Field, "face_index")]
		[NativeName(NativeNameType.Type, "FT_Long")]
		public int FaceIndex;
		[NativeName(NativeNameType.Field, "face_flags")]
		[NativeName(NativeNameType.Type, "FT_Long")]
		public int FaceFlags;
		[NativeName(NativeNameType.Field, "style_flags")]
		[NativeName(NativeNameType.Type, "FT_Long")]
		public int StyleFlags;
		[NativeName(NativeNameType.Field, "num_glyphs")]
		[NativeName(NativeNameType.Type, "FT_Long")]
		public int NumGlyphs;
		[NativeName(NativeNameType.Field, "family_name")]
		[NativeName(NativeNameType.Type, "FT_String*")]
		public unsafe byte* FamilyName;
		[NativeName(NativeNameType.Field, "style_name")]
		[NativeName(NativeNameType.Type, "FT_String*")]
		public unsafe byte* StyleName;
		[NativeName(NativeNameType.Field, "num_fixed_sizes")]
		[NativeName(NativeNameType.Type, "FT_Int")]
		public int NumFixedSizes;
		[NativeName(NativeNameType.Field, "available_sizes")]
		[NativeName(NativeNameType.Type, "FT_Bitmap_Size*")]
		public unsafe FTBitmapSize* AvailableSizes;
		[NativeName(NativeNameType.Field, "num_charmaps")]
		[NativeName(NativeNameType.Type, "FT_Int")]
		public int NumCharmaps;
		[NativeName(NativeNameType.Field, "charmaps")]
		[NativeName(NativeNameType.Type, "FT_CharMapRec_**")]
		public unsafe FTCharMapRec** Charmaps;
		[NativeName(NativeNameType.Field, "generic")]
		[NativeName(NativeNameType.Type, "FT_Generic")]
		public FTGeneric Generic;
		/// <summary>
		/// The following member variables (down to `underline_thickness`) <br/>
		/// are only relevant to scalable outlines; cf. <br/>
		/// _Bitmap_Size    <br/>
		/// for bitmap fonts.                                              <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "bbox")]
		[NativeName(NativeNameType.Type, "FT_BBox")]
		public FTBBox Bbox;

		[NativeName(NativeNameType.Field, "units_per_EM")]
		[NativeName(NativeNameType.Type, "FT_UShort")]
		public ushort UnitsPerEM;
		[NativeName(NativeNameType.Field, "ascender")]
		[NativeName(NativeNameType.Type, "FT_Short")]
		public short Ascender;
		[NativeName(NativeNameType.Field, "descender")]
		[NativeName(NativeNameType.Type, "FT_Short")]
		public short Descender;
		[NativeName(NativeNameType.Field, "height")]
		[NativeName(NativeNameType.Type, "FT_Short")]
		public short Height;
		[NativeName(NativeNameType.Field, "max_advance_width")]
		[NativeName(NativeNameType.Type, "FT_Short")]
		public short MaxAdvanceWidth;
		[NativeName(NativeNameType.Field, "max_advance_height")]
		[NativeName(NativeNameType.Type, "FT_Short")]
		public short MaxAdvanceHeight;
		[NativeName(NativeNameType.Field, "underline_position")]
		[NativeName(NativeNameType.Type, "FT_Short")]
		public short UnderlinePosition;
		[NativeName(NativeNameType.Field, "underline_thickness")]
		[NativeName(NativeNameType.Type, "FT_Short")]
		public short UnderlineThickness;
		[NativeName(NativeNameType.Field, "glyph")]
		[NativeName(NativeNameType.Type, "FT_GlyphSlotRec_*")]
		public unsafe FTGlyphSlotRec* Glyph;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "FT_SizeRec_*")]
		public unsafe FTSizeRec* Size;
		[NativeName(NativeNameType.Field, "charmap")]
		[NativeName(NativeNameType.Type, "FT_CharMapRec_*")]
		public unsafe FTCharMapRec* Charmap;
		/// <summary>
		/// private fields, internal to FreeType <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "driver")]
		[NativeName(NativeNameType.Type, "FT_Driver")]
		public FTDriver Driver;

		[NativeName(NativeNameType.Field, "memory")]
		[NativeName(NativeNameType.Type, "FT_Memory")]
		public FTMemory Memory;
		[NativeName(NativeNameType.Field, "stream")]
		[NativeName(NativeNameType.Type, "FT_Stream")]
		public FTStream Stream;
		[NativeName(NativeNameType.Field, "sizes_list")]
		[NativeName(NativeNameType.Type, "FT_ListRec")]
		public FTListRec SizesList;
		/// <summary>
		/// face-specific auto-hinter data <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "autohint")]
		[NativeName(NativeNameType.Type, "FT_Generic")]
		public FTGeneric Autohint;

		/// <summary>
		/// unused                         <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "extensions")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* Extensions;

		[NativeName(NativeNameType.Field, "internal")]
		[NativeName(NativeNameType.Type, "FT_Face_InternalRec_*")]
		public unsafe FTFaceInternalRec* Internal;

		public unsafe FTFaceRec(int numFaces = default, int faceIndex = default, int faceFlags = default, int styleFlags = default, int numGlyphs = default, byte* familyName = default, byte* styleName = default, int numFixedSizes = default, FTBitmapSize* availableSizes = default, int numCharmaps = default, FTCharMapRec** charmaps = default, FTGeneric generic = default, FTBBox bbox = default, ushort unitsPerEm = default, short ascender = default, short descender = default, short height = default, short maxAdvanceWidth = default, short maxAdvanceHeight = default, short underlinePosition = default, short underlineThickness = default, FTGlyphSlotRec* glyph = default, FTSizeRec* size = default, FTCharMapRec* charmap = default, FTDriver driver = default, FTMemory memory = default, FTStream stream = default, FTListRec sizesList = default, FTGeneric autohint = default, void* extensions = default, FTFaceInternalRec* @internal = default)
		{
			NumFaces = numFaces;
			FaceIndex = faceIndex;
			FaceFlags = faceFlags;
			StyleFlags = styleFlags;
			NumGlyphs = numGlyphs;
			FamilyName = familyName;
			StyleName = styleName;
			NumFixedSizes = numFixedSizes;
			AvailableSizes = availableSizes;
			NumCharmaps = numCharmaps;
			Charmaps = charmaps;
			Generic = generic;
			Bbox = bbox;
			UnitsPerEM = unitsPerEm;
			Ascender = ascender;
			Descender = descender;
			Height = height;
			MaxAdvanceWidth = maxAdvanceWidth;
			MaxAdvanceHeight = maxAdvanceHeight;
			UnderlinePosition = underlinePosition;
			UnderlineThickness = underlineThickness;
			Glyph = glyph;
			Size = size;
			Charmap = charmap;
			Driver = driver;
			Memory = memory;
			Stream = stream;
			SizesList = sizesList;
			Autohint = autohint;
			Extensions = extensions;
			Internal = @internal;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_CharMapRec<br/>
	/// <br/>
	/// :<br/>
	/// The base charmap structure.<br/>
	/// <br/>
	/// :<br/>
	/// face ::<br/>
	/// A handle to the parent face object.<br/>
	/// encoding ::<br/>
	/// An <br/>
	/// _Encoding tag identifying the charmap.  Use this with<br/>
	/// <br/>
	/// _Select_Charmap.<br/>
	/// platform_id ::<br/>
	/// An ID number describing the platform for the following encoding ID.<br/>
	/// This comes directly from the TrueType specification and gets<br/>
	/// emulated for other formats.<br/>
	/// encoding_id ::<br/>
	/// A platform-specific encoding number.  This also comes from the<br/>
	/// TrueType specification and gets emulated similarly.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_CharMapRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTCharMapRec
	{
		[NativeName(NativeNameType.Field, "face")]
		[NativeName(NativeNameType.Type, "FT_FaceRec_*")]
		public unsafe FTFaceRec* Face;
		[NativeName(NativeNameType.Field, "encoding")]
		[NativeName(NativeNameType.Type, "FT_Encoding_")]
		public FTEncoding Encoding;
		[NativeName(NativeNameType.Field, "platform_id")]
		[NativeName(NativeNameType.Type, "FT_UShort")]
		public ushort PlatformId;
		[NativeName(NativeNameType.Field, "encoding_id")]
		[NativeName(NativeNameType.Type, "FT_UShort")]
		public ushort EncodingId;

		public unsafe FTCharMapRec(FTFaceRec* face = default, FTEncoding encoding = default, ushort platformId = default, ushort encodingId = default)
		{
			Face = face;
			Encoding = encoding;
			PlatformId = platformId;
			EncodingId = encodingId;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_GlyphSlotRec<br/>
	/// <br/>
	/// :<br/>
	/// FreeType root glyph slot class structure.  A glyph slot is a container<br/>
	/// where individual glyphs can be loaded, be they in outline or bitmap<br/>
	/// format.<br/>
	/// <br/>
	/// :<br/>
	/// library ::<br/>
	/// A handle to the FreeType library instance this slot belongs to.<br/>
	/// face ::<br/>
	/// A handle to the parent face object.<br/>
	/// next ::<br/>
	/// In some cases (like some font tools), several glyph slots per face<br/>
	/// object can be a good thing.  As this is rare, the glyph slots are<br/>
	/// listed through a direct, single-linked list using its `next` field.<br/>
	/// glyph_index ::<br/>
	/// [Since 2.10] The glyph index passed as an argument to <br/>
	/// _Load_Glyph<br/>
	/// while initializing the glyph slot.<br/>
	/// generic ::<br/>
	/// A typeless pointer unused by the FreeType library or any of its<br/>
	/// drivers.  It can be used by client applications to link their own<br/>
	/// data to each glyph slot object.<br/>
	/// metrics ::<br/>
	/// The metrics of the last loaded glyph in the slot.  The returned<br/>
	/// values depend on the last load flags (see the <br/>
	/// _Load_Glyph API<br/>
	/// function) and can be expressed either in 26.6 fractional pixels or<br/>
	/// font units.<br/>
	/// Note that even when the glyph image is transformed, the metrics are<br/>
	/// not.<br/>
	/// linearHoriAdvance ::<br/>
	/// The advance width of the unhinted glyph.  Its value is expressed in<br/>
	/// 16.16 fractional pixels, unless <br/>
	/// _LOAD_LINEAR_DESIGN is set when<br/>
	/// loading the glyph.  This field can be important to perform correct<br/>
	/// WYSIWYG layout.  Only relevant for scalable glyphs.<br/>
	/// linearVertAdvance ::<br/>
	/// The advance height of the unhinted glyph.  Its value is expressed in<br/>
	/// 16.16 fractional pixels, unless <br/>
	/// _LOAD_LINEAR_DESIGN is set when<br/>
	/// loading the glyph.  This field can be important to perform correct<br/>
	/// WYSIWYG layout.  Only relevant for scalable glyphs.<br/>
	/// advance ::<br/>
	/// This shorthand is, depending on <br/>
	/// _LOAD_IGNORE_TRANSFORM, the<br/>
	/// transformed (hinted) advance width for the glyph, in 26.6 fractional<br/>
	/// pixel format.  As specified with <br/>
	/// _LOAD_VERTICAL_LAYOUT, it uses<br/>
	/// either the `horiAdvance` or the `vertAdvance` value of `metrics`<br/>
	/// field.<br/>
	/// format ::<br/>
	/// This field indicates the format of the image contained in the glyph<br/>
	/// slot.  Typically <br/>
	/// _GLYPH_FORMAT_BITMAP, <br/>
	/// _GLYPH_FORMAT_OUTLINE,<br/>
	/// or <br/>
	/// _GLYPH_FORMAT_COMPOSITE, but other values are possible.<br/>
	/// bitmap ::<br/>
	/// This field is used as a bitmap descriptor.  Note that the address<br/>
	/// and content of the bitmap buffer can change between calls of<br/>
	/// <br/>
	/// _Load_Glyph and a few other functions.<br/>
	/// bitmap_left ::<br/>
	/// The bitmap's left bearing expressed in integer pixels.<br/>
	/// bitmap_top ::<br/>
	/// The bitmap's top bearing expressed in integer pixels.  This is the<br/>
	/// distance from the baseline to the top-most glyph scanline, upwards<br/>
	/// y~coordinates being **positive**.<br/>
	/// outline ::<br/>
	/// The outline descriptor for the current glyph image if its format is<br/>
	/// <br/>
	/// _GLYPH_FORMAT_OUTLINE.  Once a glyph is loaded, `outline` can be<br/>
	/// transformed, distorted, emboldened, etc.  However, it must not be<br/>
	/// freed.<br/>
	/// [Since 2.10.1] If <br/>
	/// _LOAD_NO_SCALE is set, outline coordinates of<br/>
	/// OpenType variation fonts for a selected instance are internally<br/>
	/// handled as 26.6 fractional font units but returned as (rounded)<br/>
	/// integers, as expected.  To get unrounded font units, don't use<br/>
	/// <br/>
	/// _LOAD_NO_SCALE but load the glyph with <br/>
	/// _LOAD_NO_HINTING and<br/>
	/// scale it, using the font's `units_per_EM` value as the ppem.<br/>
	/// num_subglyphs ::<br/>
	/// The number of subglyphs in a composite glyph.  This field is only<br/>
	/// valid for the composite glyph format that should normally only be<br/>
	/// loaded with the <br/>
	/// _LOAD_NO_RECURSE flag.<br/>
	/// subglyphs ::<br/>
	/// An array of subglyph descriptors for composite glyphs.  There are<br/>
	/// `num_subglyphs` elements in there.  Currently internal to FreeType.<br/>
	/// control_data ::<br/>
	/// Certain font drivers can also return the control data for a given<br/>
	/// glyph image (e.g.  TrueType bytecode, Type~1 charstrings, etc.).<br/>
	/// This field is a pointer to such data; it is currently internal to<br/>
	/// FreeType.<br/>
	/// control_len ::<br/>
	/// This is the length in bytes of the control data.  Currently internal<br/>
	/// to FreeType.<br/>
	/// other ::<br/>
	/// Reserved.<br/>
	/// lsb_delta ::<br/>
	/// The difference between hinted and unhinted left side bearing while<br/>
	/// auto-hinting is active.  Zero otherwise.<br/>
	/// rsb_delta ::<br/>
	/// The difference between hinted and unhinted right side bearing while<br/>
	/// auto-hinting is active.  Zero otherwise.<br/>
	/// <br/>
	/// This image can later be converted into a bitmap by calling<br/>
	/// <br/>
	/// _Render_Glyph.  This function searches the current renderer for the<br/>
	/// native image's format, then invokes it.<br/>
	/// The renderer is in charge of transforming the native image through the<br/>
	/// slot's face transformation fields, then converting it into a bitmap<br/>
	/// that is returned in `slot->bitmap`.<br/>
	/// Note that `slot->bitmap_left` and `slot->bitmap_top` are also used to<br/>
	/// specify the position of the bitmap relative to the current pen<br/>
	/// position (e.g., coordinates (0,0) on the baseline).  Of course,<br/>
	/// `slot->format` is also changed to <br/>
	/// _GLYPH_FORMAT_BITMAP.<br/>
	/// Here is a small pseudo code fragment that shows how to use `lsb_delta`<br/>
	/// and `rsb_delta` to do fractional positioning of glyphs:<br/>
	/// ```<br/>
	/// FT_GlyphSlot  slot     = face->glyph;<br/>
	/// FT_Pos        origin_x = 0;<br/>
	/// for all glyphs do<br/>
	/// <br/>
	/// <load<br/>
	/// glyph with `FT_Load_Glyph'><br/>
	/// FT_Outline_Translate( slot->outline, origin_x <br/>
	/// &<br/>
	/// 63, 0 );<br/>
	/// <br/>
	/// <save<br/>
	/// glyph image, or render glyph, or ...><br/>
	/// <br/>
	/// <compute<br/>
	/// kern between current and next glyph<br/>
	/// and add it to `origin_x'><br/>
	/// origin_x += slot->advance.x;<br/>
	/// origin_x += slot->lsb_delta - slot->rsb_delta;<br/>
	/// endfor<br/>
	/// ```<br/>
	/// Here is another small pseudo code fragment that shows how to use<br/>
	/// `lsb_delta` and `rsb_delta` to improve integer positioning of glyphs:<br/>
	/// ```<br/>
	/// FT_GlyphSlot  slot           = face->glyph;<br/>
	/// FT_Pos        origin_x       = 0;<br/>
	/// FT_Pos        prev_rsb_delta = 0;<br/>
	/// for all glyphs do<br/>
	/// <br/>
	/// <compute<br/>
	/// kern between current and previous glyph<br/>
	/// and add it to `origin_x'><br/>
	/// <br/>
	/// <load<br/>
	/// glyph with `FT_Load_Glyph'><br/>
	/// if ( prev_rsb_delta - slot->lsb_delta >  32 )<br/>
	/// origin_x -= 64;<br/>
	/// else if ( prev_rsb_delta - slot->lsb_delta <br/>
	/// <<br/>
	/// -31 )<br/>
	/// origin_x += 64;<br/>
	/// prev_rsb_delta = slot->rsb_delta;<br/>
	/// <br/>
	/// <save<br/>
	/// glyph image, or render glyph, or ...><br/>
	/// origin_x += slot->advance.x;<br/>
	/// endfor<br/>
	/// ```<br/>
	/// If you use strong auto-hinting, you **must** apply these delta values!<br/>
	/// Otherwise you will experience far too large inter-glyph spacing at<br/>
	/// small rendering sizes in most cases.  Note that it doesn't harm to use<br/>
	/// the above code for other hinting modes also, since the delta values<br/>
	/// are zero then.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_GlyphSlotRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTGlyphSlotRec
	{
		[NativeName(NativeNameType.Field, "library")]
		[NativeName(NativeNameType.Type, "FT_Library")]
		public FTLibrary Library;
		[NativeName(NativeNameType.Field, "face")]
		[NativeName(NativeNameType.Type, "FT_FaceRec_*")]
		public unsafe FTFaceRec* Face;
		[NativeName(NativeNameType.Field, "next")]
		[NativeName(NativeNameType.Type, "FT_GlyphSlotRec_*")]
		public unsafe FTGlyphSlotRec* Next;
		/// <summary>
		/// new in 2.10; was reserved previously <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "glyph_index")]
		[NativeName(NativeNameType.Type, "FT_UInt")]
		public uint GlyphIndex;

		[NativeName(NativeNameType.Field, "generic")]
		[NativeName(NativeNameType.Type, "FT_Generic")]
		public FTGeneric Generic;
		[NativeName(NativeNameType.Field, "metrics")]
		[NativeName(NativeNameType.Type, "FT_Glyph_Metrics")]
		public FTGlyphMetrics Metrics;
		[NativeName(NativeNameType.Field, "linearHoriAdvance")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int LinearHoriAdvance;
		[NativeName(NativeNameType.Field, "linearVertAdvance")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int LinearVertAdvance;
		[NativeName(NativeNameType.Field, "advance")]
		[NativeName(NativeNameType.Type, "FT_Vector")]
		public FTVector Advance;
		[NativeName(NativeNameType.Field, "format")]
		[NativeName(NativeNameType.Type, "FT_Glyph_Format")]
		public FTGlyphFormat Format;
		[NativeName(NativeNameType.Field, "bitmap")]
		[NativeName(NativeNameType.Type, "FT_Bitmap")]
		public FTBitmap Bitmap;
		[NativeName(NativeNameType.Field, "bitmap_left")]
		[NativeName(NativeNameType.Type, "FT_Int")]
		public int BitmapLeft;
		[NativeName(NativeNameType.Field, "bitmap_top")]
		[NativeName(NativeNameType.Type, "FT_Int")]
		public int BitmapTop;
		[NativeName(NativeNameType.Field, "outline")]
		[NativeName(NativeNameType.Type, "FT_Outline")]
		public FTOutline Outline;
		[NativeName(NativeNameType.Field, "num_subglyphs")]
		[NativeName(NativeNameType.Type, "FT_UInt")]
		public uint NumSubglyphs;
		[NativeName(NativeNameType.Field, "subglyphs")]
		[NativeName(NativeNameType.Type, "FT_SubGlyphRec_*")]
		public unsafe FTSubGlyphRec* Subglyphs;
		[NativeName(NativeNameType.Field, "control_data")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* ControlData;
		[NativeName(NativeNameType.Field, "control_len")]
		[NativeName(NativeNameType.Type, "int")]
		public int ControlLen;
		[NativeName(NativeNameType.Field, "lsb_delta")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int LsbDelta;
		[NativeName(NativeNameType.Field, "rsb_delta")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int RsbDelta;
		[NativeName(NativeNameType.Field, "other")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* Other;
		[NativeName(NativeNameType.Field, "internal")]
		[NativeName(NativeNameType.Type, "FT_Slot_InternalRec_*")]
		public unsafe FTSlotInternalRec* Internal;

		public unsafe FTGlyphSlotRec(FTLibrary library = default, FTFaceRec* face = default, FTGlyphSlotRec* next = default, uint glyphIndex = default, FTGeneric generic = default, FTGlyphMetrics metrics = default, int linearHoriAdvance = default, int linearVertAdvance = default, FTVector advance = default, FTGlyphFormat format = default, FTBitmap bitmap = default, int bitmapLeft = default, int bitmapTop = default, FTOutline outline = default, uint numSubglyphs = default, FTSubGlyphRec* subglyphs = default, void* controlData = default, int controlLen = default, int lsbDelta = default, int rsbDelta = default, void* other = default, FTSlotInternalRec* @internal = default)
		{
			Library = library;
			Face = face;
			Next = next;
			GlyphIndex = glyphIndex;
			Generic = generic;
			Metrics = metrics;
			LinearHoriAdvance = linearHoriAdvance;
			LinearVertAdvance = linearVertAdvance;
			Advance = advance;
			Format = format;
			Bitmap = bitmap;
			BitmapLeft = bitmapLeft;
			BitmapTop = bitmapTop;
			Outline = outline;
			NumSubglyphs = numSubglyphs;
			Subglyphs = subglyphs;
			ControlData = controlData;
			ControlLen = controlLen;
			LsbDelta = lsbDelta;
			RsbDelta = rsbDelta;
			Other = other;
			Internal = @internal;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "FT_SubGlyphRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTSubGlyphRec
	{


	}

	[NativeName(NativeNameType.StructOrClass, "FT_Slot_InternalRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTSlotInternalRec
	{


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_SizeRec<br/>
	/// <br/>
	/// :<br/>
	/// FreeType root size class structure.  A size object models a face<br/>
	/// object at a given size.<br/>
	/// <br/>
	/// :<br/>
	/// face ::<br/>
	/// Handle to the parent face object.<br/>
	/// generic ::<br/>
	/// A typeless pointer, unused by the FreeType library or any of its<br/>
	/// drivers.  It can be used by client applications to link their own<br/>
	/// data to each size object.<br/>
	/// metrics ::<br/>
	/// Metrics for this size object.  This field is read-only.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_SizeRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTSizeRec
	{
		/// <summary>
		/// parent face object              <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "face")]
		[NativeName(NativeNameType.Type, "FT_FaceRec_*")]
		public unsafe FTFaceRec* Face;

		/// <summary>
		/// generic pointer for client uses <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "generic")]
		[NativeName(NativeNameType.Type, "FT_Generic")]
		public FTGeneric Generic;

		/// <summary>
		/// size metrics                    <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "metrics")]
		[NativeName(NativeNameType.Type, "FT_Size_Metrics_")]
		public FTSizeMetrics Metrics;

		[NativeName(NativeNameType.Field, "internal")]
		[NativeName(NativeNameType.Type, "FT_Size_InternalRec_*")]
		public unsafe FTSizeInternalRec* Internal;

		public unsafe FTSizeRec(FTFaceRec* face = default, FTGeneric generic = default, FTSizeMetrics metrics = default, FTSizeInternalRec* @internal = default)
		{
			Face = face;
			Generic = generic;
			Metrics = metrics;
			Internal = @internal;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Size_Metrics<br/>
	/// <br/>
	/// :<br/>
	/// The size metrics structure gives the metrics of a size object.<br/>
	/// <br/>
	/// :<br/>
	/// x_ppem ::<br/>
	/// The width of the scaled EM square in pixels, hence the term 'ppem'<br/>
	/// (pixels per EM).  It is also referred to as 'nominal width'.<br/>
	/// y_ppem ::<br/>
	/// The height of the scaled EM square in pixels, hence the term 'ppem'<br/>
	/// (pixels per EM).  It is also referred to as 'nominal height'.<br/>
	/// x_scale ::<br/>
	/// A 16.16 fractional scaling value to convert horizontal metrics from<br/>
	/// font units to 26.6 fractional pixels.  Only relevant for scalable<br/>
	/// font formats.<br/>
	/// y_scale ::<br/>
	/// A 16.16 fractional scaling value to convert vertical metrics from<br/>
	/// font units to 26.6 fractional pixels.  Only relevant for scalable<br/>
	/// font formats.<br/>
	/// ascender ::<br/>
	/// The ascender in 26.6 fractional pixels, rounded up to an integer<br/>
	/// value.  See <br/>
	/// _FaceRec for the details.<br/>
	/// descender ::<br/>
	/// The descender in 26.6 fractional pixels, rounded down to an integer<br/>
	/// value.  See <br/>
	/// _FaceRec for the details.<br/>
	/// height ::<br/>
	/// The height in 26.6 fractional pixels, rounded to an integer value.<br/>
	/// See <br/>
	/// _FaceRec for the details.<br/>
	/// max_advance ::<br/>
	/// The maximum advance width in 26.6 fractional pixels, rounded to an<br/>
	/// integer value.  See <br/>
	/// _FaceRec for the details.<br/>
	/// <br/>
	/// ```<br/>
	/// scaled_ascender = FT_MulFix( face->ascender,<br/>
	/// size_metrics->y_scale );<br/>
	/// ```<br/>
	/// Note that due to glyph hinting and the selected rendering mode these<br/>
	/// values are usually not exact; consequently, they must be treated as<br/>
	/// unreliable with an error margin of at least one pixel!<br/>
	/// Indeed, the only way to get the exact metrics is to render _all_<br/>
	/// glyphs.  As this would be a definite performance hit, it is up to<br/>
	/// client applications to perform such computations.<br/>
	/// The `FT_Size_Metrics` structure is valid for bitmap fonts also.<br/>
	/// **TrueType fonts with native bytecode hinting**<br/>
	/// All applications that handle TrueType fonts with native hinting must<br/>
	/// be aware that TTFs expect different rounding of vertical font<br/>
	/// dimensions.  The application has to cater for this, especially if it<br/>
	/// wants to rely on a TTF's vertical data (for example, to properly align<br/>
	/// box characters vertically).<br/>
	/// Only the application knows _in advance_ that it is going to use native<br/>
	/// hinting for TTFs!  FreeType, on the other hand, selects the hinting<br/>
	/// mode not at the time of creating an <br/>
	/// _Size object but much later,<br/>
	/// namely while calling <br/>
	/// _Load_Glyph.<br/>
	/// Here is some pseudo code that illustrates a possible solution.<br/>
	/// ```<br/>
	/// font_format = FT_Get_Font_Format( face );<br/>
	/// if ( !strcmp( font_format, "TrueType" ) <br/>
	/// &<br/>
	/// &<br/>
	/// do_native_bytecode_hinting         )<br/>
	/// {<br/>
	/// ascender  = ROUND( FT_MulFix( face->ascender,<br/>
	/// size_metrics->y_scale ) );<br/>
	/// descender = ROUND( FT_MulFix( face->descender,<br/>
	/// size_metrics->y_scale ) );<br/>
	/// }<br/>
	/// else<br/>
	/// {<br/>
	/// ascender  = size_metrics->ascender;<br/>
	/// descender = size_metrics->descender;<br/>
	/// }<br/>
	/// height      = size_metrics->height;<br/>
	/// max_advance = size_metrics->max_advance;<br/>
	/// ```<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Size_Metrics_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTSizeMetrics
	{
		/// <summary>
		/// horizontal pixels per EM               <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "x_ppem")]
		[NativeName(NativeNameType.Type, "FT_UShort")]
		public ushort XPpem;

		/// <summary>
		/// vertical pixels per EM                 <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "y_ppem")]
		[NativeName(NativeNameType.Type, "FT_UShort")]
		public ushort YPpem;

		/// <summary>
		/// scaling values used to convert font    <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "x_scale")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int XScale;

		/// <summary>
		/// units to 26.6 fractional pixels        <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "y_scale")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int YScale;

		/// <summary>
		/// ascender in 26.6 frac. pixels          <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "ascender")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int Ascender;

		/// <summary>
		/// descender in 26.6 frac. pixels         <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "descender")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int Descender;

		/// <summary>
		/// text height in 26.6 frac. pixels       <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "height")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int Height;

		/// <summary>
		/// max horizontal advance, in 26.6 pixels <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "max_advance")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int MaxAdvance;


		public unsafe FTSizeMetrics(ushort xPpem = default, ushort yPpem = default, int xScale = default, int yScale = default, int ascender = default, int descender = default, int height = default, int maxAdvance = default)
		{
			XPpem = xPpem;
			YPpem = yPpem;
			XScale = xScale;
			YScale = yScale;
			Ascender = ascender;
			Descender = descender;
			Height = height;
			MaxAdvance = maxAdvance;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "FT_Size_InternalRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTSizeInternalRec
	{


	}

	[NativeName(NativeNameType.StructOrClass, "FT_Face_InternalRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTFaceInternalRec
	{


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Parameter<br/>
	/// <br/>
	/// :<br/>
	/// A simple structure to pass more or less generic parameters to<br/>
	/// <br/>
	/// _Open_Face and <br/>
	/// _Face_Properties.<br/>
	/// <br/>
	/// :<br/>
	/// tag ::<br/>
	/// A four-byte identification tag.<br/>
	/// data ::<br/>
	/// A pointer to the parameter data.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Parameter_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTParameter
	{
		[NativeName(NativeNameType.Field, "tag")]
		[NativeName(NativeNameType.Type, "FT_ULong")]
		public uint Tag;
		[NativeName(NativeNameType.Field, "data")]
		[NativeName(NativeNameType.Type, "FT_Pointer")]
		public FTPointer Data;

		public unsafe FTParameter(uint tag = default, FTPointer data = default)
		{
			Tag = tag;
			Data = data;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Open_Args<br/>
	/// <br/>
	/// :<br/>
	/// A structure to indicate how to open a new font file or stream.  A<br/>
	/// pointer to such a structure can be used as a parameter for the<br/>
	/// functions <br/>
	/// _Open_Face and <br/>
	/// _Attach_Stream.<br/>
	/// <br/>
	/// :<br/>
	/// flags ::<br/>
	/// A set of bit flags indicating how to use the structure.<br/>
	/// memory_base ::<br/>
	/// The first byte of the file in memory.<br/>
	/// memory_size ::<br/>
	/// The size in bytes of the file in memory.<br/>
	/// pathname ::<br/>
	/// A pointer to an 8-bit file pathname, which must be a C~string (i.e.,<br/>
	/// no null bytes except at the very end).  The pointer is not owned by<br/>
	/// FreeType.<br/>
	/// stream ::<br/>
	/// A handle to a source stream object.<br/>
	/// driver ::<br/>
	/// This field is exclusively used by <br/>
	/// _Open_Face; it simply specifies<br/>
	/// the font driver to use for opening the face.  If set to `NULL`,<br/>
	/// FreeType tries to load the face with each one of the drivers in its<br/>
	/// list.<br/>
	/// num_params ::<br/>
	/// The number of extra parameters.<br/>
	/// params ::<br/>
	/// Extra parameters passed to the font driver when opening a new face.<br/>
	/// <br/>
	/// If the <br/>
	/// _OPEN_MEMORY bit is set, assume that this is a memory file<br/>
	/// of `memory_size` bytes, located at `memory_address`.  The data are not<br/>
	/// copied, and the client is responsible for releasing and destroying<br/>
	/// them _after_ the corresponding call to <br/>
	/// _Done_Face.<br/>
	/// Otherwise, if the <br/>
	/// _OPEN_STREAM bit is set, assume that a custom<br/>
	/// input stream `stream` is used.<br/>
	/// Otherwise, if the <br/>
	/// _OPEN_PATHNAME bit is set, assume that this is a<br/>
	/// normal file and use `pathname` to open it.<br/>
	/// If none of the above bits are set or if multiple are set at the same<br/>
	/// time, the flags are invalid and <br/>
	/// _Open_Face fails.<br/>
	/// If the <br/>
	/// _OPEN_DRIVER bit is set, <br/>
	/// _Open_Face only tries to open<br/>
	/// the file with the driver whose handler is in `driver`.<br/>
	/// If the <br/>
	/// _OPEN_PARAMS bit is set, the parameters given by<br/>
	/// `num_params` and `params` is used.  They are ignored otherwise.<br/>
	/// Ideally, both the `pathname` and `params` fields should be tagged as<br/>
	/// 'const'; this is missing for API backward compatibility.  In other<br/>
	/// words, applications should treat them as read-only.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Open_Args_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTOpenArgs
	{
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "FT_UInt")]
		public uint Flags;
		[NativeName(NativeNameType.Field, "memory_base")]
		[NativeName(NativeNameType.Type, "const FT_Byte*")]
		public unsafe byte* MemoryBase;
		[NativeName(NativeNameType.Field, "memory_size")]
		[NativeName(NativeNameType.Type, "FT_Long")]
		public int MemorySize;
		[NativeName(NativeNameType.Field, "pathname")]
		[NativeName(NativeNameType.Type, "FT_String*")]
		public unsafe byte* Pathname;
		[NativeName(NativeNameType.Field, "stream")]
		[NativeName(NativeNameType.Type, "FT_Stream")]
		public FTStream Stream;
		[NativeName(NativeNameType.Field, "driver")]
		[NativeName(NativeNameType.Type, "FT_Module")]
		public FTModule Driver;
		[NativeName(NativeNameType.Field, "num_params")]
		[NativeName(NativeNameType.Type, "FT_Int")]
		public int NumParams;
		[NativeName(NativeNameType.Field, "params")]
		[NativeName(NativeNameType.Type, "FT_Parameter*")]
		public unsafe FTParameter* Params;

		public unsafe FTOpenArgs(uint flags = default, byte* memoryBase = default, int memorySize = default, byte* pathname = default, FTStream stream = default, FTModule driver = default, int numParams = default, FTParameter* @params = default)
		{
			Flags = flags;
			MemoryBase = memoryBase;
			MemorySize = memorySize;
			Pathname = pathname;
			Stream = stream;
			Driver = driver;
			NumParams = numParams;
			Params = @params;
		}


	}

	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Size_RequestRec<br/>
	/// <br/>
	/// :<br/>
	/// A structure to model a size request.<br/>
	/// <br/>
	/// :<br/>
	/// type ::<br/>
	/// See <br/>
	/// _Size_Request_Type.<br/>
	/// width ::<br/>
	/// The desired width, given as a 26.6 fractional point value (with 72pt<br/>
	/// = 1in).<br/>
	/// height ::<br/>
	/// The desired height, given as a 26.6 fractional point value (with<br/>
	/// 72pt = 1in).<br/>
	/// horiResolution ::<br/>
	/// The horizontal resolution (dpi, i.e., pixels per inch).  If set to<br/>
	/// zero, `width` is treated as a 26.6 fractional **pixel** value, which<br/>
	/// gets internally rounded to an integer.<br/>
	/// vertResolution ::<br/>
	/// The vertical resolution (dpi, i.e., pixels per inch).  If set to<br/>
	/// zero, `height` is treated as a 26.6 fractional **pixel** value,<br/>
	/// which gets internally rounded to an integer.<br/>
	/// <br/>
	/// If `type` is `FT_SIZE_REQUEST_TYPE_SCALES`, `width` and `height` are<br/>
	/// interpreted directly as 16.16 fractional scaling values, without any<br/>
	/// further modification, and both `horiResolution` and `vertResolution`<br/>
	/// are ignored.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Size_RequestRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTSizeRequestRec
	{
		[NativeName(NativeNameType.Field, "type")]
		[NativeName(NativeNameType.Type, "FT_Size_Request_Type")]
		public FTSizeRequestType Type;
		[NativeName(NativeNameType.Field, "width")]
		[NativeName(NativeNameType.Type, "FT_Long")]
		public int Width;
		[NativeName(NativeNameType.Field, "height")]
		[NativeName(NativeNameType.Type, "FT_Long")]
		public int Height;
		[NativeName(NativeNameType.Field, "horiResolution")]
		[NativeName(NativeNameType.Type, "FT_UInt")]
		public uint HoriResolution;
		[NativeName(NativeNameType.Field, "vertResolution")]
		[NativeName(NativeNameType.Type, "FT_UInt")]
		public uint VertResolution;

		public unsafe FTSizeRequestRec(FTSizeRequestType type = default, int width = default, int height = default, uint horiResolution = default, uint vertResolution = default)
		{
			Type = type;
			Width = width;
			Height = height;
			HoriResolution = horiResolution;
			VertResolution = vertResolution;
		}


	}

}
