// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	public static unsafe class Extensions
	{
		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Done_FreeType<br/>		/// <br/>		/// :<br/>		/// Destroy a given FreeType library object and all of its children,<br/>		/// including resources, drivers, faces, sizes, etc.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the target library object.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Done_FreeType")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int DoneFreeType(this FTLibrary library)
		{
			int ret = FreeType.FTDoneFreeTypeNative(library);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] byte* filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			int ret = FreeType.FTNewFaceNative(library, filepathname, faceIndex, aface);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] ref byte filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			fixed (byte* pfilepathname = &filepathname)
			{
				int ret = FreeType.FTNewFaceNative(library, (byte*)pfilepathname, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] string filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filepathname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filepathname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filepathname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FreeType.FTNewFaceNative(library, pStr0, faceIndex, aface);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] byte* filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (FTFace* paface = &aface)
			{
				int ret = FreeType.FTNewFaceNative(library, filepathname, faceIndex, (FTFace*)paface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] ref byte filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (byte* pfilepathname = &filepathname)
			{
				fixed (FTFace* paface = &aface)
				{
					int ret = FreeType.FTNewFaceNative(library, (byte*)pfilepathname, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] string filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filepathname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filepathname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filepathname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (FTFace* paface = &aface)
			{
				int ret = FreeType.FTNewFaceNative(library, pStr0, faceIndex, (FTFace*)paface);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Memory_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font that has been loaded into memory.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// file_base ::<br/>		/// A pointer to the beginning of the font data.<br/>		/// file_size ::<br/>		/// The size of the memory chunk used by the font data.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "const FT_Byte*")] byte* fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			int ret = FreeType.FTNewMemoryFaceNative(library, fileBase, fileSize, faceIndex, aface);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Memory_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font that has been loaded into memory.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// file_base ::<br/>		/// A pointer to the beginning of the font data.<br/>		/// file_size ::<br/>		/// The size of the memory chunk used by the font data.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "const FT_Byte*")] ref byte fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			fixed (byte* pfileBase = &fileBase)
			{
				int ret = FreeType.FTNewMemoryFaceNative(library, (byte*)pfileBase, fileSize, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Memory_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font that has been loaded into memory.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// file_base ::<br/>		/// A pointer to the beginning of the font data.<br/>		/// file_size ::<br/>		/// The size of the memory chunk used by the font data.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "const FT_Byte*")] byte* fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (FTFace* paface = &aface)
			{
				int ret = FreeType.FTNewMemoryFaceNative(library, fileBase, fileSize, faceIndex, (FTFace*)paface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Memory_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font that has been loaded into memory.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// file_base ::<br/>		/// A pointer to the beginning of the font data.<br/>		/// file_size ::<br/>		/// The size of the memory chunk used by the font data.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "const FT_Byte*")] ref byte fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (byte* pfileBase = &fileBase)
			{
				fixed (FTFace* paface = &aface)
				{
					int ret = FreeType.FTNewMemoryFaceNative(library, (byte*)pfileBase, fileSize, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Open_Face<br/>		/// <br/>		/// :<br/>		/// Create a face object from a given resource described by <br/>		/// _Open_Args.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// args ::<br/>		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>		/// caller.<br/>		/// face_index ::<br/>		/// This field holds two different values.  Bits 0-15 are the index of<br/>		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>		/// there is only one face in the font file.<br/>		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>		/// fonts only, specifying the named instance index for the current face<br/>		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>		/// Assuming that you want to access the third named instance in face~4,<br/>		/// `face_index` should be set to 0x00030004.  If you want to access<br/>		/// face~4 without variation handling, simply set `face_index` to<br/>		/// value~4.<br/>		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>		/// the font format of a given font resource is supported by FreeType.<br/>		/// In general, if the `face_index` argument is negative, the function's<br/>		/// return value is~0 if the font format is recognized, or non-zero<br/>		/// otherwise.  The function allocates a more or less empty face handle<br/>		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>		/// this special case are `face->num_faces` and `face->style_flags`.<br/>		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>		/// number of faces within the font file.  For the negative value<br/>		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>		/// `face->style_flags` give the number of named instances in face 'N'<br/>		/// if we have a variation font (or zero otherwise).  After examination,<br/>		/// the returned <br/>		/// _Face structure should be deallocated with a call to<br/>		/// <br/>		/// _Done_Face.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Each new face object created with this function also owns a default<br/>		/// <br/>		/// _Size object, accessible as `face->size`.<br/>		/// One <br/>		/// _Library instance can have multiple face objects, that is,<br/>		/// <br/>		/// _Open_Face and its siblings can be called multiple times using the<br/>		/// same `library` argument.<br/>		/// See the discussion of reference counters in the description of<br/>		/// <br/>		/// _Reference_Face.<br/>		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>		/// `args->stream` is automatically closed before this function returns<br/>		/// any error (including `FT_Err_Invalid_Argument`).<br/>		/// <br/>		/// To loop over all faces, use code similar to the following snippet<br/>		/// (omitting the error handling).<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  i, num_faces;<br/>		/// error = FT_Open_Face( library, args, -1, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces = face->num_faces;<br/>		/// FT_Done_Face( face );<br/>		/// for ( i = 0; i <br/>		/// <<br/>		/// num_faces; i++ )<br/>		/// {<br/>		/// ...<br/>		/// error = FT_Open_Face( library, args, i, <br/>		/// &face<br/>		/// );<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// ...<br/>		/// }<br/>		/// ```<br/>		/// To loop over all valid values for `face_index`, use something similar<br/>		/// to the following snippet, again without error handling.  The code<br/>		/// accesses all faces immediately (thus only a single call of<br/>		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  num_faces     = 0;<br/>		/// FT_Long  num_instances = 0;<br/>		/// FT_Long  face_idx     = 0;<br/>		/// FT_Long  instance_idx = 0;<br/>		/// do<br/>		/// {<br/>		/// FT_Long  id = ( instance_idx <br/>		/// <<br/>		/// <<br/>		/// 16 ) + face_idx;<br/>		/// error = FT_Open_Face( library, args, id, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces     = face->num_faces;<br/>		/// num_instances = face->style_flags >> 16;<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// if ( instance_idx <br/>		/// <<br/>		/// num_instances )<br/>		/// instance_idx++;<br/>		/// else<br/>		/// {<br/>		/// face_idx++;<br/>		/// instance_idx = 0;<br/>		/// }<br/>		/// } while ( face_idx <br/>		/// <<br/>		/// num_faces )<br/>		/// ```<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] FTOpenArgs* args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			int ret = FreeType.FTOpenFaceNative(library, args, faceIndex, aface);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Open_Face<br/>		/// <br/>		/// :<br/>		/// Create a face object from a given resource described by <br/>		/// _Open_Args.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// args ::<br/>		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>		/// caller.<br/>		/// face_index ::<br/>		/// This field holds two different values.  Bits 0-15 are the index of<br/>		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>		/// there is only one face in the font file.<br/>		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>		/// fonts only, specifying the named instance index for the current face<br/>		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>		/// Assuming that you want to access the third named instance in face~4,<br/>		/// `face_index` should be set to 0x00030004.  If you want to access<br/>		/// face~4 without variation handling, simply set `face_index` to<br/>		/// value~4.<br/>		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>		/// the font format of a given font resource is supported by FreeType.<br/>		/// In general, if the `face_index` argument is negative, the function's<br/>		/// return value is~0 if the font format is recognized, or non-zero<br/>		/// otherwise.  The function allocates a more or less empty face handle<br/>		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>		/// this special case are `face->num_faces` and `face->style_flags`.<br/>		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>		/// number of faces within the font file.  For the negative value<br/>		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>		/// `face->style_flags` give the number of named instances in face 'N'<br/>		/// if we have a variation font (or zero otherwise).  After examination,<br/>		/// the returned <br/>		/// _Face structure should be deallocated with a call to<br/>		/// <br/>		/// _Done_Face.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Each new face object created with this function also owns a default<br/>		/// <br/>		/// _Size object, accessible as `face->size`.<br/>		/// One <br/>		/// _Library instance can have multiple face objects, that is,<br/>		/// <br/>		/// _Open_Face and its siblings can be called multiple times using the<br/>		/// same `library` argument.<br/>		/// See the discussion of reference counters in the description of<br/>		/// <br/>		/// _Reference_Face.<br/>		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>		/// `args->stream` is automatically closed before this function returns<br/>		/// any error (including `FT_Err_Invalid_Argument`).<br/>		/// <br/>		/// To loop over all faces, use code similar to the following snippet<br/>		/// (omitting the error handling).<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  i, num_faces;<br/>		/// error = FT_Open_Face( library, args, -1, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces = face->num_faces;<br/>		/// FT_Done_Face( face );<br/>		/// for ( i = 0; i <br/>		/// <<br/>		/// num_faces; i++ )<br/>		/// {<br/>		/// ...<br/>		/// error = FT_Open_Face( library, args, i, <br/>		/// &face<br/>		/// );<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// ...<br/>		/// }<br/>		/// ```<br/>		/// To loop over all valid values for `face_index`, use something similar<br/>		/// to the following snippet, again without error handling.  The code<br/>		/// accesses all faces immediately (thus only a single call of<br/>		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  num_faces     = 0;<br/>		/// FT_Long  num_instances = 0;<br/>		/// FT_Long  face_idx     = 0;<br/>		/// FT_Long  instance_idx = 0;<br/>		/// do<br/>		/// {<br/>		/// FT_Long  id = ( instance_idx <br/>		/// <<br/>		/// <<br/>		/// 16 ) + face_idx;<br/>		/// error = FT_Open_Face( library, args, id, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces     = face->num_faces;<br/>		/// num_instances = face->style_flags >> 16;<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// if ( instance_idx <br/>		/// <<br/>		/// num_instances )<br/>		/// instance_idx++;<br/>		/// else<br/>		/// {<br/>		/// face_idx++;<br/>		/// instance_idx = 0;<br/>		/// }<br/>		/// } while ( face_idx <br/>		/// <<br/>		/// num_faces )<br/>		/// ```<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] ref FTOpenArgs args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			fixed (FTOpenArgs* pargs = &args)
			{
				int ret = FreeType.FTOpenFaceNative(library, (FTOpenArgs*)pargs, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Open_Face<br/>		/// <br/>		/// :<br/>		/// Create a face object from a given resource described by <br/>		/// _Open_Args.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// args ::<br/>		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>		/// caller.<br/>		/// face_index ::<br/>		/// This field holds two different values.  Bits 0-15 are the index of<br/>		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>		/// there is only one face in the font file.<br/>		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>		/// fonts only, specifying the named instance index for the current face<br/>		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>		/// Assuming that you want to access the third named instance in face~4,<br/>		/// `face_index` should be set to 0x00030004.  If you want to access<br/>		/// face~4 without variation handling, simply set `face_index` to<br/>		/// value~4.<br/>		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>		/// the font format of a given font resource is supported by FreeType.<br/>		/// In general, if the `face_index` argument is negative, the function's<br/>		/// return value is~0 if the font format is recognized, or non-zero<br/>		/// otherwise.  The function allocates a more or less empty face handle<br/>		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>		/// this special case are `face->num_faces` and `face->style_flags`.<br/>		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>		/// number of faces within the font file.  For the negative value<br/>		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>		/// `face->style_flags` give the number of named instances in face 'N'<br/>		/// if we have a variation font (or zero otherwise).  After examination,<br/>		/// the returned <br/>		/// _Face structure should be deallocated with a call to<br/>		/// <br/>		/// _Done_Face.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Each new face object created with this function also owns a default<br/>		/// <br/>		/// _Size object, accessible as `face->size`.<br/>		/// One <br/>		/// _Library instance can have multiple face objects, that is,<br/>		/// <br/>		/// _Open_Face and its siblings can be called multiple times using the<br/>		/// same `library` argument.<br/>		/// See the discussion of reference counters in the description of<br/>		/// <br/>		/// _Reference_Face.<br/>		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>		/// `args->stream` is automatically closed before this function returns<br/>		/// any error (including `FT_Err_Invalid_Argument`).<br/>		/// <br/>		/// To loop over all faces, use code similar to the following snippet<br/>		/// (omitting the error handling).<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  i, num_faces;<br/>		/// error = FT_Open_Face( library, args, -1, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces = face->num_faces;<br/>		/// FT_Done_Face( face );<br/>		/// for ( i = 0; i <br/>		/// <<br/>		/// num_faces; i++ )<br/>		/// {<br/>		/// ...<br/>		/// error = FT_Open_Face( library, args, i, <br/>		/// &face<br/>		/// );<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// ...<br/>		/// }<br/>		/// ```<br/>		/// To loop over all valid values for `face_index`, use something similar<br/>		/// to the following snippet, again without error handling.  The code<br/>		/// accesses all faces immediately (thus only a single call of<br/>		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  num_faces     = 0;<br/>		/// FT_Long  num_instances = 0;<br/>		/// FT_Long  face_idx     = 0;<br/>		/// FT_Long  instance_idx = 0;<br/>		/// do<br/>		/// {<br/>		/// FT_Long  id = ( instance_idx <br/>		/// <<br/>		/// <<br/>		/// 16 ) + face_idx;<br/>		/// error = FT_Open_Face( library, args, id, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces     = face->num_faces;<br/>		/// num_instances = face->style_flags >> 16;<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// if ( instance_idx <br/>		/// <<br/>		/// num_instances )<br/>		/// instance_idx++;<br/>		/// else<br/>		/// {<br/>		/// face_idx++;<br/>		/// instance_idx = 0;<br/>		/// }<br/>		/// } while ( face_idx <br/>		/// <<br/>		/// num_faces )<br/>		/// ```<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] FTOpenArgs* args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (FTFace* paface = &aface)
			{
				int ret = FreeType.FTOpenFaceNative(library, args, faceIndex, (FTFace*)paface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Open_Face<br/>		/// <br/>		/// :<br/>		/// Create a face object from a given resource described by <br/>		/// _Open_Args.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// args ::<br/>		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>		/// caller.<br/>		/// face_index ::<br/>		/// This field holds two different values.  Bits 0-15 are the index of<br/>		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>		/// there is only one face in the font file.<br/>		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>		/// fonts only, specifying the named instance index for the current face<br/>		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>		/// Assuming that you want to access the third named instance in face~4,<br/>		/// `face_index` should be set to 0x00030004.  If you want to access<br/>		/// face~4 without variation handling, simply set `face_index` to<br/>		/// value~4.<br/>		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>		/// the font format of a given font resource is supported by FreeType.<br/>		/// In general, if the `face_index` argument is negative, the function's<br/>		/// return value is~0 if the font format is recognized, or non-zero<br/>		/// otherwise.  The function allocates a more or less empty face handle<br/>		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>		/// this special case are `face->num_faces` and `face->style_flags`.<br/>		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>		/// number of faces within the font file.  For the negative value<br/>		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>		/// `face->style_flags` give the number of named instances in face 'N'<br/>		/// if we have a variation font (or zero otherwise).  After examination,<br/>		/// the returned <br/>		/// _Face structure should be deallocated with a call to<br/>		/// <br/>		/// _Done_Face.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Each new face object created with this function also owns a default<br/>		/// <br/>		/// _Size object, accessible as `face->size`.<br/>		/// One <br/>		/// _Library instance can have multiple face objects, that is,<br/>		/// <br/>		/// _Open_Face and its siblings can be called multiple times using the<br/>		/// same `library` argument.<br/>		/// See the discussion of reference counters in the description of<br/>		/// <br/>		/// _Reference_Face.<br/>		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>		/// `args->stream` is automatically closed before this function returns<br/>		/// any error (including `FT_Err_Invalid_Argument`).<br/>		/// <br/>		/// To loop over all faces, use code similar to the following snippet<br/>		/// (omitting the error handling).<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  i, num_faces;<br/>		/// error = FT_Open_Face( library, args, -1, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces = face->num_faces;<br/>		/// FT_Done_Face( face );<br/>		/// for ( i = 0; i <br/>		/// <<br/>		/// num_faces; i++ )<br/>		/// {<br/>		/// ...<br/>		/// error = FT_Open_Face( library, args, i, <br/>		/// &face<br/>		/// );<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// ...<br/>		/// }<br/>		/// ```<br/>		/// To loop over all valid values for `face_index`, use something similar<br/>		/// to the following snippet, again without error handling.  The code<br/>		/// accesses all faces immediately (thus only a single call of<br/>		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  num_faces     = 0;<br/>		/// FT_Long  num_instances = 0;<br/>		/// FT_Long  face_idx     = 0;<br/>		/// FT_Long  instance_idx = 0;<br/>		/// do<br/>		/// {<br/>		/// FT_Long  id = ( instance_idx <br/>		/// <<br/>		/// <<br/>		/// 16 ) + face_idx;<br/>		/// error = FT_Open_Face( library, args, id, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces     = face->num_faces;<br/>		/// num_instances = face->style_flags >> 16;<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// if ( instance_idx <br/>		/// <<br/>		/// num_instances )<br/>		/// instance_idx++;<br/>		/// else<br/>		/// {<br/>		/// face_idx++;<br/>		/// instance_idx = 0;<br/>		/// }<br/>		/// } while ( face_idx <br/>		/// <<br/>		/// num_faces )<br/>		/// ```<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] ref FTOpenArgs args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (FTOpenArgs* pargs = &args)
			{
				fixed (FTFace* paface = &aface)
				{
					int ret = FreeType.FTOpenFaceNative(library, (FTOpenArgs*)pargs, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			FreeType.FTLibraryVersionNative(library, amajor, aminor, apatch);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				FreeType.FTLibraryVersionNative(library, (int*)pamajor, aminor, apatch);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			fixed (int* paminor = &aminor)
			{
				FreeType.FTLibraryVersionNative(library, amajor, (int*)paminor, apatch);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					FreeType.FTLibraryVersionNative(library, (int*)pamajor, (int*)paminor, apatch);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* papatch = &apatch)
			{
				FreeType.FTLibraryVersionNative(library, amajor, aminor, (int*)papatch);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* papatch = &apatch)
				{
					FreeType.FTLibraryVersionNative(library, (int*)pamajor, aminor, (int*)papatch);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* paminor = &aminor)
			{
				fixed (int* papatch = &apatch)
				{
					FreeType.FTLibraryVersionNative(library, amajor, (int*)paminor, (int*)papatch);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					fixed (int* papatch = &apatch)
					{
						FreeType.FTLibraryVersionNative(library, (int*)pamajor, (int*)paminor, (int*)papatch);
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Glyph<br/>		/// <br/>		/// :<br/>		/// A function used to create a new empty glyph image.  Note that the<br/>		/// created <br/>		/// _Glyph object must be released with <br/>		/// _Done_Glyph.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the FreeType library object.<br/>		/// format ::<br/>		/// The format of the glyph's image.<br/>		/// <br/>		/// :<br/>		/// aglyph ::<br/>		/// A handle to the glyph object.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewGlyph(this FTLibrary library, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "FT_Glyph_Format")] FTGlyphFormat format, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph*")] FTGlyph* aglyph)
		{
			int ret = FreeType.FTNewGlyphNative(library, format, aglyph);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Glyph<br/>		/// <br/>		/// :<br/>		/// A function used to create a new empty glyph image.  Note that the<br/>		/// created <br/>		/// _Glyph object must be released with <br/>		/// _Done_Glyph.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the FreeType library object.<br/>		/// format ::<br/>		/// The format of the glyph's image.<br/>		/// <br/>		/// :<br/>		/// aglyph ::<br/>		/// A handle to the glyph object.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewGlyph(this FTLibrary library, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "FT_Glyph_Format")] FTGlyphFormat format, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph*")] ref FTGlyph aglyph)
		{
			fixed (FTGlyph* paglyph = &aglyph)
			{
				int ret = FreeType.FTNewGlyphNative(library, format, (FTGlyph*)paglyph);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_New<br/>		/// <br/>		/// :<br/>		/// Create a new outline of a given size.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library object from where the outline is allocated.<br/>		/// Note however that the new outline will **not** necessarily be<br/>		/// **freed**, when destroying the library, by <br/>		/// _Done_FreeType.<br/>		/// numPoints ::<br/>		/// The maximum number of points within the outline.  Must be smaller<br/>		/// than or equal to 0xFFFF (65535).<br/>		/// numContours ::<br/>		/// The maximum number of contours within the outline.  This value must<br/>		/// be in the range 0 to `numPoints`.<br/>		/// <br/>		/// :<br/>		/// anoutline ::<br/>		/// A handle to the new outline.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineNew(this FTLibrary library, [NativeName(NativeNameType.Param, "numPoints")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numPoints, [NativeName(NativeNameType.Param, "numContours")] [NativeName(NativeNameType.Type, "FT_Int")] int numContours, [NativeName(NativeNameType.Param, "anoutline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* anoutline)
		{
			int ret = FreeType.FTOutlineNewNative(library, numPoints, numContours, anoutline);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_New<br/>		/// <br/>		/// :<br/>		/// Create a new outline of a given size.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library object from where the outline is allocated.<br/>		/// Note however that the new outline will **not** necessarily be<br/>		/// **freed**, when destroying the library, by <br/>		/// _Done_FreeType.<br/>		/// numPoints ::<br/>		/// The maximum number of points within the outline.  Must be smaller<br/>		/// than or equal to 0xFFFF (65535).<br/>		/// numContours ::<br/>		/// The maximum number of contours within the outline.  This value must<br/>		/// be in the range 0 to `numPoints`.<br/>		/// <br/>		/// :<br/>		/// anoutline ::<br/>		/// A handle to the new outline.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineNew(this FTLibrary library, [NativeName(NativeNameType.Param, "numPoints")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numPoints, [NativeName(NativeNameType.Param, "numContours")] [NativeName(NativeNameType.Type, "FT_Int")] int numContours, [NativeName(NativeNameType.Param, "anoutline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline anoutline)
		{
			fixed (FTOutline* panoutline = &anoutline)
			{
				int ret = FreeType.FTOutlineNewNative(library, numPoints, numContours, (FTOutline*)panoutline);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Done<br/>		/// <br/>		/// :<br/>		/// Destroy an outline created with <br/>		/// _Outline_New.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle of the library object used to allocate the outline.<br/>		/// outline ::<br/>		/// A pointer to the outline object to be discarded.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineDone(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline)
		{
			int ret = FreeType.FTOutlineDoneNative(library, outline);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Done<br/>		/// <br/>		/// :<br/>		/// Destroy an outline created with <br/>		/// _Outline_New.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle of the library object used to allocate the outline.<br/>		/// outline ::<br/>		/// A pointer to the outline object to be discarded.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineDone(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				int ret = FreeType.FTOutlineDoneNative(library, (FTOutline*)poutline);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Get_Bitmap<br/>		/// <br/>		/// :<br/>		/// Render an outline within a bitmap.  The outline's image is simply<br/>		/// OR-ed to the target bitmap.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a FreeType library object.<br/>		/// outline ::<br/>		/// A pointer to the source outline descriptor.<br/>		/// <br/>		/// :<br/>		/// abitmap ::<br/>		/// A pointer to the target bitmap descriptor.<br/>		/// <br/>		/// <br/>		/// It will use the raster corresponding to the default glyph format.<br/>		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>		/// select the gray-level rasterizer, and you want less than 256 gray<br/>		/// levels, you have to use <br/>		/// _Outline_Render directly.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineGetBitmap(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* abitmap)
		{
			int ret = FreeType.FTOutlineGetBitmapNative(library, outline, abitmap);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Get_Bitmap<br/>		/// <br/>		/// :<br/>		/// Render an outline within a bitmap.  The outline's image is simply<br/>		/// OR-ed to the target bitmap.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a FreeType library object.<br/>		/// outline ::<br/>		/// A pointer to the source outline descriptor.<br/>		/// <br/>		/// :<br/>		/// abitmap ::<br/>		/// A pointer to the target bitmap descriptor.<br/>		/// <br/>		/// <br/>		/// It will use the raster corresponding to the default glyph format.<br/>		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>		/// select the gray-level rasterizer, and you want less than 256 gray<br/>		/// levels, you have to use <br/>		/// _Outline_Render directly.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineGetBitmap(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* abitmap)
		{
			fixed (FTOutline* poutline = &outline)
			{
				int ret = FreeType.FTOutlineGetBitmapNative(library, (FTOutline*)poutline, abitmap);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Get_Bitmap<br/>		/// <br/>		/// :<br/>		/// Render an outline within a bitmap.  The outline's image is simply<br/>		/// OR-ed to the target bitmap.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a FreeType library object.<br/>		/// outline ::<br/>		/// A pointer to the source outline descriptor.<br/>		/// <br/>		/// :<br/>		/// abitmap ::<br/>		/// A pointer to the target bitmap descriptor.<br/>		/// <br/>		/// <br/>		/// It will use the raster corresponding to the default glyph format.<br/>		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>		/// select the gray-level rasterizer, and you want less than 256 gray<br/>		/// levels, you have to use <br/>		/// _Outline_Render directly.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineGetBitmap(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap abitmap)
		{
			fixed (FTBitmap* pabitmap = &abitmap)
			{
				int ret = FreeType.FTOutlineGetBitmapNative(library, outline, (FTBitmap*)pabitmap);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Get_Bitmap<br/>		/// <br/>		/// :<br/>		/// Render an outline within a bitmap.  The outline's image is simply<br/>		/// OR-ed to the target bitmap.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a FreeType library object.<br/>		/// outline ::<br/>		/// A pointer to the source outline descriptor.<br/>		/// <br/>		/// :<br/>		/// abitmap ::<br/>		/// A pointer to the target bitmap descriptor.<br/>		/// <br/>		/// <br/>		/// It will use the raster corresponding to the default glyph format.<br/>		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>		/// select the gray-level rasterizer, and you want less than 256 gray<br/>		/// levels, you have to use <br/>		/// _Outline_Render directly.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineGetBitmap(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap abitmap)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTBitmap* pabitmap = &abitmap)
				{
					int ret = FreeType.FTOutlineGetBitmapNative(library, (FTOutline*)poutline, (FTBitmap*)pabitmap);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Render<br/>		/// <br/>		/// :<br/>		/// Render an outline within a bitmap using the current scan-convert.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a FreeType library object.<br/>		/// outline ::<br/>		/// A pointer to the source outline descriptor.<br/>		/// <br/>		/// :<br/>		/// params ::<br/>		/// A pointer to an <br/>		/// _Raster_Params structure used to describe the<br/>		/// rendering operation.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineRender(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params*")] FTRasterParams* @params)
		{
			int ret = FreeType.FTOutlineRenderNative(library, outline, @params);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Render<br/>		/// <br/>		/// :<br/>		/// Render an outline within a bitmap using the current scan-convert.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a FreeType library object.<br/>		/// outline ::<br/>		/// A pointer to the source outline descriptor.<br/>		/// <br/>		/// :<br/>		/// params ::<br/>		/// A pointer to an <br/>		/// _Raster_Params structure used to describe the<br/>		/// rendering operation.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineRender(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params*")] FTRasterParams* @params)
		{
			fixed (FTOutline* poutline = &outline)
			{
				int ret = FreeType.FTOutlineRenderNative(library, (FTOutline*)poutline, @params);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Render<br/>		/// <br/>		/// :<br/>		/// Render an outline within a bitmap using the current scan-convert.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a FreeType library object.<br/>		/// outline ::<br/>		/// A pointer to the source outline descriptor.<br/>		/// <br/>		/// :<br/>		/// params ::<br/>		/// A pointer to an <br/>		/// _Raster_Params structure used to describe the<br/>		/// rendering operation.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineRender(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params*")] ref FTRasterParams @params)
		{
			fixed (FTRasterParams* pparams = &@params)
			{
				int ret = FreeType.FTOutlineRenderNative(library, outline, (FTRasterParams*)pparams);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Outline_Render<br/>		/// <br/>		/// :<br/>		/// Render an outline within a bitmap using the current scan-convert.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a FreeType library object.<br/>		/// outline ::<br/>		/// A pointer to the source outline descriptor.<br/>		/// <br/>		/// :<br/>		/// params ::<br/>		/// A pointer to an <br/>		/// _Raster_Params structure used to describe the<br/>		/// rendering operation.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OutlineRender(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params*")] ref FTRasterParams @params)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTRasterParams* pparams = &@params)
				{
					int ret = FreeType.FTOutlineRenderNative(library, (FTOutline*)poutline, (FTRasterParams*)pparams);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Copy<br/>		/// <br/>		/// :<br/>		/// Copy a bitmap into another one.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// A handle to the source bitmap.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to the target bitmap.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapCopy(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target)
		{
			int ret = FreeType.FTBitmapCopyNative(library, source, target);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Copy<br/>		/// <br/>		/// :<br/>		/// Copy a bitmap into another one.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// A handle to the source bitmap.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to the target bitmap.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapCopy(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target)
		{
			fixed (FTBitmap* psource = &source)
			{
				int ret = FreeType.FTBitmapCopyNative(library, (FTBitmap*)psource, target);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Copy<br/>		/// <br/>		/// :<br/>		/// Copy a bitmap into another one.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// A handle to the source bitmap.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to the target bitmap.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapCopy(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				int ret = FreeType.FTBitmapCopyNative(library, source, (FTBitmap*)ptarget);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Copy<br/>		/// <br/>		/// :<br/>		/// Copy a bitmap into another one.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// A handle to the source bitmap.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to the target bitmap.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapCopy(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					int ret = FreeType.FTBitmapCopyNative(library, (FTBitmap*)psource, (FTBitmap*)ptarget);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Embolden<br/>		/// <br/>		/// :<br/>		/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>		/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>		/// kept unchanged.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// xStrength ::<br/>		/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>		/// pixel format.<br/>		/// yStrength ::<br/>		/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>		/// pixel format.<br/>		/// <br/>		/// :<br/>		/// bitmap ::<br/>		/// A handle to the target bitmap.<br/>		/// <br/>		/// <br/>		/// If you want to embolden the bitmap owned by a <br/>		/// _GlyphSlotRec, you<br/>		/// should call <br/>		/// _GlyphSlot_Own_Bitmap on the slot first.<br/>		/// Bitmaps in <br/>		/// _PIXEL_MODE_GRAY2 and <br/>		/// _PIXEL_MODE_GRAY<br/>		/// @<br/>		/// format are<br/>		/// converted to <br/>		/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapEmbolden(this FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength)
		{
			int ret = FreeType.FTBitmapEmboldenNative(library, bitmap, xStrength, yStrength);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Embolden<br/>		/// <br/>		/// :<br/>		/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>		/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>		/// kept unchanged.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// xStrength ::<br/>		/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>		/// pixel format.<br/>		/// yStrength ::<br/>		/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>		/// pixel format.<br/>		/// <br/>		/// :<br/>		/// bitmap ::<br/>		/// A handle to the target bitmap.<br/>		/// <br/>		/// <br/>		/// If you want to embolden the bitmap owned by a <br/>		/// _GlyphSlotRec, you<br/>		/// should call <br/>		/// _GlyphSlot_Own_Bitmap on the slot first.<br/>		/// Bitmaps in <br/>		/// _PIXEL_MODE_GRAY2 and <br/>		/// _PIXEL_MODE_GRAY<br/>		/// @<br/>		/// format are<br/>		/// converted to <br/>		/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapEmbolden(this FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength)
		{
			fixed (FTBitmap* pbitmap = &bitmap)
			{
				int ret = FreeType.FTBitmapEmboldenNative(library, (FTBitmap*)pbitmap, xStrength, yStrength);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Convert<br/>		/// <br/>		/// :<br/>		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap.<br/>		/// alignment ::<br/>		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>		/// values are 1, 2, or 4.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// The target bitmap.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Bitmap_Done to finally remove the bitmap object.<br/>		/// The `library` argument is taken to have access to FreeType's memory<br/>		/// handling functions.<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapConvert(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			int ret = FreeType.FTBitmapConvertNative(library, source, target, alignment);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Convert<br/>		/// <br/>		/// :<br/>		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap.<br/>		/// alignment ::<br/>		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>		/// values are 1, 2, or 4.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// The target bitmap.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Bitmap_Done to finally remove the bitmap object.<br/>		/// The `library` argument is taken to have access to FreeType's memory<br/>		/// handling functions.<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapConvert(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* psource = &source)
			{
				int ret = FreeType.FTBitmapConvertNative(library, (FTBitmap*)psource, target, alignment);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Convert<br/>		/// <br/>		/// :<br/>		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap.<br/>		/// alignment ::<br/>		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>		/// values are 1, 2, or 4.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// The target bitmap.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Bitmap_Done to finally remove the bitmap object.<br/>		/// The `library` argument is taken to have access to FreeType's memory<br/>		/// handling functions.<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapConvert(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				int ret = FreeType.FTBitmapConvertNative(library, source, (FTBitmap*)ptarget, alignment);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Convert<br/>		/// <br/>		/// :<br/>		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap.<br/>		/// alignment ::<br/>		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>		/// values are 1, 2, or 4.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// The target bitmap.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Bitmap_Done to finally remove the bitmap object.<br/>		/// The `library` argument is taken to have access to FreeType's memory<br/>		/// handling functions.<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapConvert(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					int ret = FreeType.FTBitmapConvertNative(library, (FTBitmap*)psource, (FTBitmap*)ptarget, alignment);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Blend<br/>		/// <br/>		/// :<br/>		/// Blend a bitmap onto another bitmap, using a given color.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap, which can have any <br/>		/// _Pixel_Mode format.<br/>		/// source_offset ::<br/>		/// The offset vector to the upper left corner of the source bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// color ::<br/>		/// The color used to draw `source` onto `target`.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>		/// as empty with a call to <br/>		/// _Bitmap_Init, or it should be of type<br/>		/// <br/>		/// _PIXEL_MODE_BGRA.<br/>		/// atarget_offset ::<br/>		/// The offset vector to the upper left corner of the target bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// <br/>		/// <br/>		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>		/// vector `atarget_offset` is updated accordingly.<br/>		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>		/// flow (as indicated by the sign of the `pitch` field).<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			int ret = FreeType.FTBitmapBlendNative(library, source, sourceOffset, target, atargetOffset, color);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Blend<br/>		/// <br/>		/// :<br/>		/// Blend a bitmap onto another bitmap, using a given color.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap, which can have any <br/>		/// _Pixel_Mode format.<br/>		/// source_offset ::<br/>		/// The offset vector to the upper left corner of the source bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// color ::<br/>		/// The color used to draw `source` onto `target`.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>		/// as empty with a call to <br/>		/// _Bitmap_Init, or it should be of type<br/>		/// <br/>		/// _PIXEL_MODE_BGRA.<br/>		/// atarget_offset ::<br/>		/// The offset vector to the upper left corner of the target bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// <br/>		/// <br/>		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>		/// vector `atarget_offset` is updated accordingly.<br/>		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>		/// flow (as indicated by the sign of the `pitch` field).<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				int ret = FreeType.FTBitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, target, atargetOffset, color);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Blend<br/>		/// <br/>		/// :<br/>		/// Blend a bitmap onto another bitmap, using a given color.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap, which can have any <br/>		/// _Pixel_Mode format.<br/>		/// source_offset ::<br/>		/// The offset vector to the upper left corner of the source bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// color ::<br/>		/// The color used to draw `source` onto `target`.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>		/// as empty with a call to <br/>		/// _Bitmap_Init, or it should be of type<br/>		/// <br/>		/// _PIXEL_MODE_BGRA.<br/>		/// atarget_offset ::<br/>		/// The offset vector to the upper left corner of the target bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// <br/>		/// <br/>		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>		/// vector `atarget_offset` is updated accordingly.<br/>		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>		/// flow (as indicated by the sign of the `pitch` field).<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				int ret = FreeType.FTBitmapBlendNative(library, source, sourceOffset, (FTBitmap*)ptarget, atargetOffset, color);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Blend<br/>		/// <br/>		/// :<br/>		/// Blend a bitmap onto another bitmap, using a given color.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap, which can have any <br/>		/// _Pixel_Mode format.<br/>		/// source_offset ::<br/>		/// The offset vector to the upper left corner of the source bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// color ::<br/>		/// The color used to draw `source` onto `target`.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>		/// as empty with a call to <br/>		/// _Bitmap_Init, or it should be of type<br/>		/// <br/>		/// _PIXEL_MODE_BGRA.<br/>		/// atarget_offset ::<br/>		/// The offset vector to the upper left corner of the target bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// <br/>		/// <br/>		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>		/// vector `atarget_offset` is updated accordingly.<br/>		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>		/// flow (as indicated by the sign of the `pitch` field).<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					int ret = FreeType.FTBitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, (FTBitmap*)ptarget, atargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Blend<br/>		/// <br/>		/// :<br/>		/// Blend a bitmap onto another bitmap, using a given color.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap, which can have any <br/>		/// _Pixel_Mode format.<br/>		/// source_offset ::<br/>		/// The offset vector to the upper left corner of the source bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// color ::<br/>		/// The color used to draw `source` onto `target`.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>		/// as empty with a call to <br/>		/// _Bitmap_Init, or it should be of type<br/>		/// <br/>		/// _PIXEL_MODE_BGRA.<br/>		/// atarget_offset ::<br/>		/// The offset vector to the upper left corner of the target bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// <br/>		/// <br/>		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>		/// vector `atarget_offset` is updated accordingly.<br/>		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>		/// flow (as indicated by the sign of the `pitch` field).<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTVector* patargetOffset = &atargetOffset)
			{
				int ret = FreeType.FTBitmapBlendNative(library, source, sourceOffset, target, (FTVector*)patargetOffset, color);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Blend<br/>		/// <br/>		/// :<br/>		/// Blend a bitmap onto another bitmap, using a given color.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap, which can have any <br/>		/// _Pixel_Mode format.<br/>		/// source_offset ::<br/>		/// The offset vector to the upper left corner of the source bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// color ::<br/>		/// The color used to draw `source` onto `target`.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>		/// as empty with a call to <br/>		/// _Bitmap_Init, or it should be of type<br/>		/// <br/>		/// _PIXEL_MODE_BGRA.<br/>		/// atarget_offset ::<br/>		/// The offset vector to the upper left corner of the target bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// <br/>		/// <br/>		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>		/// vector `atarget_offset` is updated accordingly.<br/>		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>		/// flow (as indicated by the sign of the `pitch` field).<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTVector* patargetOffset = &atargetOffset)
				{
					int ret = FreeType.FTBitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, target, (FTVector*)patargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Blend<br/>		/// <br/>		/// :<br/>		/// Blend a bitmap onto another bitmap, using a given color.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap, which can have any <br/>		/// _Pixel_Mode format.<br/>		/// source_offset ::<br/>		/// The offset vector to the upper left corner of the source bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// color ::<br/>		/// The color used to draw `source` onto `target`.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>		/// as empty with a call to <br/>		/// _Bitmap_Init, or it should be of type<br/>		/// <br/>		/// _PIXEL_MODE_BGRA.<br/>		/// atarget_offset ::<br/>		/// The offset vector to the upper left corner of the target bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// <br/>		/// <br/>		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>		/// vector `atarget_offset` is updated accordingly.<br/>		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>		/// flow (as indicated by the sign of the `pitch` field).<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				fixed (FTVector* patargetOffset = &atargetOffset)
				{
					int ret = FreeType.FTBitmapBlendNative(library, source, sourceOffset, (FTBitmap*)ptarget, (FTVector*)patargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Blend<br/>		/// <br/>		/// :<br/>		/// Blend a bitmap onto another bitmap, using a given color.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// source ::<br/>		/// The source bitmap, which can have any <br/>		/// _Pixel_Mode format.<br/>		/// source_offset ::<br/>		/// The offset vector to the upper left corner of the source bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// color ::<br/>		/// The color used to draw `source` onto `target`.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>		/// as empty with a call to <br/>		/// _Bitmap_Init, or it should be of type<br/>		/// <br/>		/// _PIXEL_MODE_BGRA.<br/>		/// atarget_offset ::<br/>		/// The offset vector to the upper left corner of the target bitmap in<br/>		/// 26.6 pixel format.  It should represent an integer offset; the<br/>		/// function will set the lowest six bits to zero to enforce that.<br/>		/// <br/>		/// <br/>		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>		/// vector `atarget_offset` is updated accordingly.<br/>		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>		/// flow (as indicated by the sign of the `pitch` field).<br/>		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>		/// overlap.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "const FT_Bitmap*")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "const FT_Vector")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					fixed (FTVector* patargetOffset = &atargetOffset)
					{
						int ret = FreeType.FTBitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, (FTBitmap*)ptarget, (FTVector*)patargetOffset, color);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Done<br/>		/// <br/>		/// :<br/>		/// Destroy a bitmap object initialized with <br/>		/// _Bitmap_Init.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// bitmap ::<br/>		/// The bitmap object to be freed.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapDone(this FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] FTBitmap* bitmap)
		{
			int ret = FreeType.FTBitmapDoneNative(library, bitmap);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Bitmap_Done<br/>		/// <br/>		/// :<br/>		/// Destroy a bitmap object initialized with <br/>		/// _Bitmap_Init.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to a library object.<br/>		/// bitmap ::<br/>		/// The bitmap object to be freed.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BitmapDone(this FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap*")] ref FTBitmap bitmap)
		{
			fixed (FTBitmap* pbitmap = &bitmap)
			{
				int ret = FreeType.FTBitmapDoneNative(library, (FTBitmap*)pbitmap);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_New<br/>		/// <br/>		/// :<br/>		/// Create a new stroker object.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// FreeType library handle.<br/>		/// <br/>		/// :<br/>		/// astroker ::<br/>		/// A new stroker object handle.  `NULL` in case of error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int StrokerNew(this FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker*")] FTStroker* astroker)
		{
			int ret = FreeType.FTStrokerNewNative(library, astroker);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_New<br/>		/// <br/>		/// :<br/>		/// Create a new stroker object.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// FreeType library handle.<br/>		/// <br/>		/// :<br/>		/// astroker ::<br/>		/// A new stroker object handle.  `NULL` in case of error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int StrokerNew(this FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker*")] ref FTStroker astroker)
		{
			fixed (FTStroker* pastroker = &astroker)
			{
				int ret = FreeType.FTStrokerNewNative(library, (FTStroker*)pastroker);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_File<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Attach_Stream to attach a file.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// filepathname ::<br/>		/// The pathname.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] byte* filepathname)
		{
			int ret = FreeType.FTAttachFileNative(face, filepathname);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_File<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Attach_Stream to attach a file.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// filepathname ::<br/>		/// The pathname.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] ref byte filepathname)
		{
			fixed (byte* pfilepathname = &filepathname)
			{
				int ret = FreeType.FTAttachFileNative(face, (byte*)pfilepathname);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_File<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Attach_Stream to attach a file.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// filepathname ::<br/>		/// The pathname.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] string filepathname)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filepathname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filepathname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filepathname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FreeType.FTAttachFileNative(face, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_Stream<br/>		/// <br/>		/// :<br/>		/// 'Attach' data to a face object.  Normally, this is used to read<br/>		/// additional information for the face object.  For example, you can<br/>		/// attach an AFM file that comes with a Type~1 font to get the kerning<br/>		/// values and other metrics.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// parameters ::<br/>		/// A pointer to <br/>		/// _Open_Args that must be filled by the caller.<br/>		/// <br/>		/// <br/>		/// Client applications are expected to know what they are doing when<br/>		/// invoking this function.  Most drivers simply do not implement file or<br/>		/// stream attachments.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_Stream")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachStream(this FTFace face, [NativeName(NativeNameType.Param, "parameters")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] FTOpenArgs* parameters)
		{
			int ret = FreeType.FTAttachStreamNative(face, parameters);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_Stream<br/>		/// <br/>		/// :<br/>		/// 'Attach' data to a face object.  Normally, this is used to read<br/>		/// additional information for the face object.  For example, you can<br/>		/// attach an AFM file that comes with a Type~1 font to get the kerning<br/>		/// values and other metrics.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// parameters ::<br/>		/// A pointer to <br/>		/// _Open_Args that must be filled by the caller.<br/>		/// <br/>		/// <br/>		/// Client applications are expected to know what they are doing when<br/>		/// invoking this function.  Most drivers simply do not implement file or<br/>		/// stream attachments.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_Stream")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachStream(this FTFace face, [NativeName(NativeNameType.Param, "parameters")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] ref FTOpenArgs parameters)
		{
			fixed (FTOpenArgs* pparameters = &parameters)
			{
				int ret = FreeType.FTAttachStreamNative(face, (FTOpenArgs*)pparameters);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Reference_Face<br/>		/// <br/>		/// :<br/>		/// A counter gets initialized to~1 at the time an <br/>		/// _Face structure is<br/>		/// created.  This function increments the counter.  <br/>		/// _Done_Face then<br/>		/// only destroys a face if the counter is~1, otherwise it simply<br/>		/// decrements the counter.<br/>		/// This function helps in managing life-cycles of structures that<br/>		/// reference <br/>		/// _Face objects.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Reference_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int ReferenceFace(this FTFace face)
		{
			int ret = FreeType.FTReferenceFaceNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Done_Face<br/>		/// <br/>		/// :<br/>		/// Discard a given face object, as well as all of its child slots and<br/>		/// sizes.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Done_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int DoneFace(this FTFace face)
		{
			int ret = FreeType.FTDoneFaceNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Select_Size<br/>		/// <br/>		/// :<br/>		/// Select a bitmap strike.  To be more precise, this function sets the<br/>		/// scaling factors of the active <br/>		/// _Size object in a face so that<br/>		/// bitmaps from this particular strike are taken by <br/>		/// _Load_Glyph and<br/>		/// friends.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// :<br/>		/// strike_index ::<br/>		/// The index of the bitmap strike in the `available_sizes` field of<br/>		/// <br/>		/// _FaceRec structure.<br/>		/// <br/>		/// <br/>		/// For GX and OpenType variation fonts, a bitmap strike makes sense only<br/>		/// if the default instance is active (that is, no glyph variation takes<br/>		/// place); otherwise, FreeType simply ignores bitmap strikes.  The same<br/>		/// is true for all named instances that are different from the default<br/>		/// instance.<br/>		/// Don't use this function if you are using the FreeType cache API.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Select_Size")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SelectSize(this FTFace face, [NativeName(NativeNameType.Param, "strike_index")] [NativeName(NativeNameType.Type, "FT_Int")] int strikeIndex)
		{
			int ret = FreeType.FTSelectSizeNative(face, strikeIndex);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Request_Size<br/>		/// <br/>		/// :<br/>		/// Resize the scale of the active <br/>		/// _Size object in a face.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// :<br/>		/// req ::<br/>		/// A pointer to a <br/>		/// _Size_RequestRec.<br/>		/// <br/>		/// <br/>		/// The relation between the requested size and the resulting glyph size<br/>		/// is dependent entirely on how the size is defined in the source face.<br/>		/// The font designer chooses the final size of each glyph relative to<br/>		/// this size.  For more information refer to<br/>		/// 'https://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'.<br/>		/// Contrary to <br/>		/// _Set_Char_Size, this function doesn't have special code<br/>		/// to normalize zero-valued widths, heights, or resolutions, which are<br/>		/// treated as <br/>		/// _LOAD_NO_SCALE.<br/>		/// Don't use this function if you are using the FreeType cache API.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Request_Size")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int RequestSize(this FTFace face, [NativeName(NativeNameType.Param, "req")] [NativeName(NativeNameType.Type, "FT_Size_Request")] FTSizeRequest req)
		{
			int ret = FreeType.FTRequestSizeNative(face, req);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Char_Size<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Request_Size to request the nominal size (in points).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// :<br/>		/// char_width ::<br/>		/// The nominal width, in 26.6 fractional points.<br/>		/// char_height ::<br/>		/// The nominal height, in 26.6 fractional points.<br/>		/// horz_resolution ::<br/>		/// The horizontal resolution in dpi.<br/>		/// vert_resolution ::<br/>		/// The vertical resolution in dpi.<br/>		/// <br/>		/// <br/>		/// If either the character width or height is zero, it is set equal to<br/>		/// the other value.<br/>		/// If either the horizontal or vertical resolution is zero, it is set<br/>		/// equal to the other value.<br/>		/// A character width or height smaller than 1pt is set to 1pt; if both<br/>		/// resolution values are zero, they are set to 72dpi.<br/>		/// Don't use this function if you are using the FreeType cache API.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Char_Size")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SetCharSize(this FTFace face, [NativeName(NativeNameType.Param, "char_width")] [NativeName(NativeNameType.Type, "FT_F26Dot6")] int charWidth, [NativeName(NativeNameType.Param, "char_height")] [NativeName(NativeNameType.Type, "FT_F26Dot6")] int charHeight, [NativeName(NativeNameType.Param, "horz_resolution")] [NativeName(NativeNameType.Type, "FT_UInt")] uint horzResolution, [NativeName(NativeNameType.Param, "vert_resolution")] [NativeName(NativeNameType.Type, "FT_UInt")] uint vertResolution)
		{
			int ret = FreeType.FTSetCharSizeNative(face, charWidth, charHeight, horzResolution, vertResolution);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Pixel_Sizes<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Request_Size to request the nominal size (in pixels).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the target face object.<br/>		/// <br/>		/// :<br/>		/// pixel_width ::<br/>		/// The nominal width, in pixels.<br/>		/// pixel_height ::<br/>		/// The nominal height, in pixels.<br/>		/// <br/>		/// <br/>		/// Don't use this function if you are using the FreeType cache API.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Pixel_Sizes")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SetPixelSizes(this FTFace face, [NativeName(NativeNameType.Param, "pixel_width")] [NativeName(NativeNameType.Type, "FT_UInt")] uint pixelWidth, [NativeName(NativeNameType.Param, "pixel_height")] [NativeName(NativeNameType.Type, "FT_UInt")] uint pixelHeight)
		{
			int ret = FreeType.FTSetPixelSizesNative(face, pixelWidth, pixelHeight);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Load_Glyph<br/>		/// <br/>		/// :<br/>		/// Load a glyph into the glyph slot of a face object.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the target face object where the glyph is loaded.<br/>		/// <br/>		/// :<br/>		/// glyph_index ::<br/>		/// The index of the glyph in the font file.  For CID-keyed fonts<br/>		/// (either in PS or in CFF format) this argument specifies the CID<br/>		/// value.<br/>		/// load_flags ::<br/>		/// A flag indicating what to load for this glyph.  The <br/>		/// _LOAD_XXX<br/>		/// flags can be used to control the glyph loading process (e.g.,<br/>		/// whether the outline should be scaled, whether to load bitmaps or<br/>		/// not, whether to hint the outline, etc).<br/>		/// <br/>		/// <br/>		/// For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument` is returned<br/>		/// for invalid CID values (that is, for CID values that don't have a<br/>		/// corresponding glyph in the font).  See the discussion of the<br/>		/// <br/>		/// _FACE_FLAG_CID_KEYED flag for more details.<br/>		/// If you receive `FT_Err_Glyph_Too_Big`, try getting the glyph outline<br/>		/// at EM size, then scale it manually and fill it as a graphics<br/>		/// operation.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LoadGlyph(this FTFace face, [NativeName(NativeNameType.Param, "glyph_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint glyphIndex, [NativeName(NativeNameType.Param, "load_flags")] [NativeName(NativeNameType.Type, "FT_Int32")] int loadFlags)
		{
			int ret = FreeType.FTLoadGlyphNative(face, glyphIndex, loadFlags);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Load_Char<br/>		/// <br/>		/// :<br/>		/// Load a glyph into the glyph slot of a face object, accessed by its<br/>		/// character code.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object where the glyph is loaded.<br/>		/// <br/>		/// :<br/>		/// char_code ::<br/>		/// The glyph's character code, according to the current charmap used in<br/>		/// the face.<br/>		/// load_flags ::<br/>		/// A flag indicating what to load for this glyph.  The <br/>		/// _LOAD_XXX<br/>		/// constants can be used to control the glyph loading process (e.g.,<br/>		/// whether the outline should be scaled, whether to load bitmaps or<br/>		/// not, whether to hint the outline, etc).<br/>		/// <br/>		/// <br/>		/// Many fonts contain glyphs that can't be loaded by this function since<br/>		/// its glyph indices are not listed in any of the font's charmaps.<br/>		/// If no active cmap is set up (i.e., `face->charmap` is zero), the call<br/>		/// to <br/>		/// _Get_Char_Index is omitted, and the function behaves identically<br/>		/// to <br/>		/// _Load_Glyph.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Char")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LoadChar(this FTFace face, [NativeName(NativeNameType.Param, "char_code")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charCode, [NativeName(NativeNameType.Param, "load_flags")] [NativeName(NativeNameType.Type, "FT_Int32")] int loadFlags)
		{
			int ret = FreeType.FTLoadCharNative(face, charCode, loadFlags);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Transform<br/>		/// <br/>		/// :<br/>		/// Set the transformation that is applied to glyph images when they are<br/>		/// loaded into a glyph slot through <br/>		/// _Load_Glyph.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>		/// identity matrix.<br/>		/// delta ::<br/>		/// A pointer to the translation vector.  Use `NULL` for the null<br/>		/// vector.<br/>		/// <br/>		/// The transformation is only applied to scalable image formats after the<br/>		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>		/// transformation and is performed on the character size given in the<br/>		/// last call to <br/>		/// _Set_Char_Size or <br/>		/// _Set_Pixel_Sizes.<br/>		/// Note that this also transforms the `face.glyph.advance` field, but<br/>		/// **not** the values in `face.glyph.metrics`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* delta)
		{
			FreeType.FTSetTransformNative(face, matrix, delta);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Transform<br/>		/// <br/>		/// :<br/>		/// Set the transformation that is applied to glyph images when they are<br/>		/// loaded into a glyph slot through <br/>		/// _Load_Glyph.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>		/// identity matrix.<br/>		/// delta ::<br/>		/// A pointer to the translation vector.  Use `NULL` for the null<br/>		/// vector.<br/>		/// <br/>		/// The transformation is only applied to scalable image formats after the<br/>		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>		/// transformation and is performed on the character size given in the<br/>		/// last call to <br/>		/// _Set_Char_Size or <br/>		/// _Set_Pixel_Sizes.<br/>		/// Note that this also transforms the `face.glyph.advance` field, but<br/>		/// **not** the values in `face.glyph.metrics`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				FreeType.FTSetTransformNative(face, (FTMatrix*)pmatrix, delta);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Transform<br/>		/// <br/>		/// :<br/>		/// Set the transformation that is applied to glyph images when they are<br/>		/// loaded into a glyph slot through <br/>		/// _Load_Glyph.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>		/// identity matrix.<br/>		/// delta ::<br/>		/// A pointer to the translation vector.  Use `NULL` for the null<br/>		/// vector.<br/>		/// <br/>		/// The transformation is only applied to scalable image formats after the<br/>		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>		/// transformation and is performed on the character size given in the<br/>		/// last call to <br/>		/// _Set_Char_Size or <br/>		/// _Set_Pixel_Sizes.<br/>		/// Note that this also transforms the `face.glyph.advance` field, but<br/>		/// **not** the values in `face.glyph.metrics`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector delta)
		{
			fixed (FTVector* pdelta = &delta)
			{
				FreeType.FTSetTransformNative(face, matrix, (FTVector*)pdelta);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Transform<br/>		/// <br/>		/// :<br/>		/// Set the transformation that is applied to glyph images when they are<br/>		/// loaded into a glyph slot through <br/>		/// _Load_Glyph.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>		/// identity matrix.<br/>		/// delta ::<br/>		/// A pointer to the translation vector.  Use `NULL` for the null<br/>		/// vector.<br/>		/// <br/>		/// The transformation is only applied to scalable image formats after the<br/>		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>		/// transformation and is performed on the character size given in the<br/>		/// last call to <br/>		/// _Set_Char_Size or <br/>		/// _Set_Pixel_Sizes.<br/>		/// Note that this also transforms the `face.glyph.advance` field, but<br/>		/// **not** the values in `face.glyph.metrics`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				fixed (FTVector* pdelta = &delta)
				{
					FreeType.FTSetTransformNative(face, (FTMatrix*)pmatrix, (FTVector*)pdelta);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Transform<br/>		/// <br/>		/// :<br/>		/// Return the transformation that is applied to glyph images when they<br/>		/// are loaded into a glyph slot through <br/>		/// _Load_Glyph.  See<br/>		/// <br/>		/// _Set_Transform for more details.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>		/// are not interested in the value.<br/>		/// delta ::<br/>		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>		/// interested in the value.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* delta)
		{
			FreeType.FTGetTransformNative(face, matrix, delta);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Transform<br/>		/// <br/>		/// :<br/>		/// Return the transformation that is applied to glyph images when they<br/>		/// are loaded into a glyph slot through <br/>		/// _Load_Glyph.  See<br/>		/// <br/>		/// _Set_Transform for more details.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>		/// are not interested in the value.<br/>		/// delta ::<br/>		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>		/// interested in the value.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				FreeType.FTGetTransformNative(face, (FTMatrix*)pmatrix, delta);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Transform<br/>		/// <br/>		/// :<br/>		/// Return the transformation that is applied to glyph images when they<br/>		/// are loaded into a glyph slot through <br/>		/// _Load_Glyph.  See<br/>		/// <br/>		/// _Set_Transform for more details.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>		/// are not interested in the value.<br/>		/// delta ::<br/>		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>		/// interested in the value.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector delta)
		{
			fixed (FTVector* pdelta = &delta)
			{
				FreeType.FTGetTransformNative(face, matrix, (FTVector*)pdelta);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Transform<br/>		/// <br/>		/// :<br/>		/// Return the transformation that is applied to glyph images when they<br/>		/// are loaded into a glyph slot through <br/>		/// _Load_Glyph.  See<br/>		/// <br/>		/// _Set_Transform for more details.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>		/// are not interested in the value.<br/>		/// delta ::<br/>		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>		/// interested in the value.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				fixed (FTVector* pdelta = &delta)
				{
					FreeType.FTGetTransformNative(face, (FTMatrix*)pmatrix, (FTVector*)pdelta);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Kerning<br/>		/// <br/>		/// :<br/>		/// Return the kerning vector between two glyphs of the same face.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// left_glyph ::<br/>		/// The index of the left glyph in the kern pair.<br/>		/// right_glyph ::<br/>		/// The index of the right glyph in the kern pair.<br/>		/// kern_mode ::<br/>		/// See <br/>		/// _Kerning_Mode for more information.  Determines the scale and<br/>		/// dimension of the returned kerning vector.<br/>		/// <br/>		/// :<br/>		/// akerning ::<br/>		/// The kerning vector.  This is either in font units, fractional pixels<br/>		/// (26.6 format), or pixels for scalable formats, and in pixels for<br/>		/// fixed-sizes formats.<br/>		/// <br/>		/// <br/>		/// Kerning for OpenType fonts implemented in a 'GPOS' table is not<br/>		/// supported; use <br/>		/// _HAS_KERNING to find out whether a font has data<br/>		/// that can be extracted with `FT_Get_Kerning`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetKerning(this FTFace face, [NativeName(NativeNameType.Param, "left_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint leftGlyph, [NativeName(NativeNameType.Param, "right_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint rightGlyph, [NativeName(NativeNameType.Param, "kern_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint kernMode, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* akerning)
		{
			int ret = FreeType.FTGetKerningNative(face, leftGlyph, rightGlyph, kernMode, akerning);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Kerning<br/>		/// <br/>		/// :<br/>		/// Return the kerning vector between two glyphs of the same face.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// left_glyph ::<br/>		/// The index of the left glyph in the kern pair.<br/>		/// right_glyph ::<br/>		/// The index of the right glyph in the kern pair.<br/>		/// kern_mode ::<br/>		/// See <br/>		/// _Kerning_Mode for more information.  Determines the scale and<br/>		/// dimension of the returned kerning vector.<br/>		/// <br/>		/// :<br/>		/// akerning ::<br/>		/// The kerning vector.  This is either in font units, fractional pixels<br/>		/// (26.6 format), or pixels for scalable formats, and in pixels for<br/>		/// fixed-sizes formats.<br/>		/// <br/>		/// <br/>		/// Kerning for OpenType fonts implemented in a 'GPOS' table is not<br/>		/// supported; use <br/>		/// _HAS_KERNING to find out whether a font has data<br/>		/// that can be extracted with `FT_Get_Kerning`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetKerning(this FTFace face, [NativeName(NativeNameType.Param, "left_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint leftGlyph, [NativeName(NativeNameType.Param, "right_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint rightGlyph, [NativeName(NativeNameType.Param, "kern_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint kernMode, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector akerning)
		{
			fixed (FTVector* pakerning = &akerning)
			{
				int ret = FreeType.FTGetKerningNative(face, leftGlyph, rightGlyph, kernMode, (FTVector*)pakerning);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Track_Kerning<br/>		/// <br/>		/// :<br/>		/// Return the track kerning for a given face object at a given size.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// point_size ::<br/>		/// The point size in 16.16 fractional points.<br/>		/// degree ::<br/>		/// The degree of tightness.  Increasingly negative values represent<br/>		/// tighter track kerning, while increasingly positive values represent<br/>		/// looser track kerning.  Value zero means no track kerning.<br/>		/// <br/>		/// :<br/>		/// akerning ::<br/>		/// The kerning in 16.16 fractional points, to be uniformly applied<br/>		/// between all glyphs.<br/>		/// <br/>		/// <br/>		/// Only very few AFM files come with track kerning data; please refer to<br/>		/// Adobe's AFM specification for more details.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Track_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetTrackKerning(this FTFace face, [NativeName(NativeNameType.Param, "point_size")] [NativeName(NativeNameType.Type, "FT_Fixed")] int pointSize, [NativeName(NativeNameType.Param, "degree")] [NativeName(NativeNameType.Type, "FT_Int")] int degree, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Fixed*")] int* akerning)
		{
			int ret = FreeType.FTGetTrackKerningNative(face, pointSize, degree, akerning);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Track_Kerning<br/>		/// <br/>		/// :<br/>		/// Return the track kerning for a given face object at a given size.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// point_size ::<br/>		/// The point size in 16.16 fractional points.<br/>		/// degree ::<br/>		/// The degree of tightness.  Increasingly negative values represent<br/>		/// tighter track kerning, while increasingly positive values represent<br/>		/// looser track kerning.  Value zero means no track kerning.<br/>		/// <br/>		/// :<br/>		/// akerning ::<br/>		/// The kerning in 16.16 fractional points, to be uniformly applied<br/>		/// between all glyphs.<br/>		/// <br/>		/// <br/>		/// Only very few AFM files come with track kerning data; please refer to<br/>		/// Adobe's AFM specification for more details.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Track_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetTrackKerning(this FTFace face, [NativeName(NativeNameType.Param, "point_size")] [NativeName(NativeNameType.Type, "FT_Fixed")] int pointSize, [NativeName(NativeNameType.Param, "degree")] [NativeName(NativeNameType.Type, "FT_Int")] int degree, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Fixed*")] ref int akerning)
		{
			fixed (int* pakerning = &akerning)
			{
				int ret = FreeType.FTGetTrackKerningNative(face, pointSize, degree, (int*)pakerning);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Select_Charmap<br/>		/// <br/>		/// :<br/>		/// Select a given charmap by its encoding tag (as listed in<br/>		/// `freetype.h`).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// encoding ::<br/>		/// A handle to the selected encoding.<br/>		/// <br/>		/// <br/>		/// Because many fonts contain more than a single cmap for Unicode<br/>		/// encoding, this function has some special code to select the one that<br/>		/// covers Unicode best ('best' in the sense that a UCS-4 cmap is<br/>		/// preferred to a UCS-2 cmap).  It is thus preferable to <br/>		/// _Set_Charmap<br/>		/// in this case.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Select_Charmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SelectCharmap(this FTFace face, [NativeName(NativeNameType.Param, "encoding")] [NativeName(NativeNameType.Type, "FT_Encoding")] FTEncoding encoding)
		{
			int ret = FreeType.FTSelectCharmapNative(face, encoding);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Charmap<br/>		/// <br/>		/// :<br/>		/// Select a given charmap for character code to glyph index mapping.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// charmap ::<br/>		/// A handle to the selected charmap.<br/>		/// <br/>		/// <br/>		/// It also fails if an OpenType type~14 charmap is selected (which<br/>		/// doesn't map character codes to glyph indices at all).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Charmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SetCharmap(this FTFace face, [NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap)
		{
			int ret = FreeType.FTSetCharmapNative(face, charmap);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Char_Index<br/>		/// <br/>		/// :<br/>		/// Return the glyph index of a given character code.  This function uses<br/>		/// the currently selected charmap to do the mapping.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// charcode ::<br/>		/// The character code.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Char_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetCharIndex(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode)
		{
			uint ret = FreeType.FTGetCharIndexNative(face, charcode);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_First_Char<br/>		/// <br/>		/// :<br/>		/// Return the first character code in the current charmap of a given<br/>		/// face, together with its corresponding glyph index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// agindex ::<br/>		/// Glyph index of first character code.  0~if charmap is empty.<br/>		/// <br/>		/// <br/>		/// ```<br/>		/// FT_ULong  charcode;<br/>		/// FT_UInt   gindex;<br/>		/// charcode = FT_Get_First_Char( face, <br/>		/// &gindex<br/>		/// );<br/>		/// while ( gindex != 0 )<br/>		/// {<br/>		/// ... do something with (charcode,gindex) pair ...<br/>		/// charcode = FT_Get_Next_Char( face, charcode, <br/>		/// &gindex<br/>		/// );<br/>		/// }<br/>		/// ```<br/>		/// Be aware that character codes can have values up to 0xFFFFFFFF; this<br/>		/// might happen for non-Unicode or malformed cmaps.  However, even with<br/>		/// regular Unicode encoding, so-called 'last resort fonts' (using SFNT<br/>		/// cmap format 13, see function <br/>		/// _Get_CMap_Format) normally have<br/>		/// entries for all Unicode characters up to 0x1FFFFF, which can cause *a<br/>		/// lot* of iterations.<br/>		/// Note that `*agindex` is set to~0 if the charmap is empty.  The result<br/>		/// itself can be~0 in two cases: if the charmap is empty or if the<br/>		/// value~0 is the first valid character code.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_First_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetFirstChar(this FTFace face, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* agindex)
		{
			uint ret = FreeType.FTGetFirstCharNative(face, agindex);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_First_Char<br/>		/// <br/>		/// :<br/>		/// Return the first character code in the current charmap of a given<br/>		/// face, together with its corresponding glyph index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// agindex ::<br/>		/// Glyph index of first character code.  0~if charmap is empty.<br/>		/// <br/>		/// <br/>		/// ```<br/>		/// FT_ULong  charcode;<br/>		/// FT_UInt   gindex;<br/>		/// charcode = FT_Get_First_Char( face, <br/>		/// &gindex<br/>		/// );<br/>		/// while ( gindex != 0 )<br/>		/// {<br/>		/// ... do something with (charcode,gindex) pair ...<br/>		/// charcode = FT_Get_Next_Char( face, charcode, <br/>		/// &gindex<br/>		/// );<br/>		/// }<br/>		/// ```<br/>		/// Be aware that character codes can have values up to 0xFFFFFFFF; this<br/>		/// might happen for non-Unicode or malformed cmaps.  However, even with<br/>		/// regular Unicode encoding, so-called 'last resort fonts' (using SFNT<br/>		/// cmap format 13, see function <br/>		/// _Get_CMap_Format) normally have<br/>		/// entries for all Unicode characters up to 0x1FFFFF, which can cause *a<br/>		/// lot* of iterations.<br/>		/// Note that `*agindex` is set to~0 if the charmap is empty.  The result<br/>		/// itself can be~0 in two cases: if the charmap is empty or if the<br/>		/// value~0 is the first valid character code.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_First_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetFirstChar(this FTFace face, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint agindex)
		{
			fixed (uint* pagindex = &agindex)
			{
				uint ret = FreeType.FTGetFirstCharNative(face, (uint*)pagindex);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Next_Char<br/>		/// <br/>		/// :<br/>		/// Return the next character code in the current charmap of a given face<br/>		/// following the value `char_code`, as well as the corresponding glyph<br/>		/// index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// char_code ::<br/>		/// The starting character code.<br/>		/// <br/>		/// :<br/>		/// agindex ::<br/>		/// Glyph index of next character code.  0~if charmap is empty.<br/>		/// <br/>		/// <br/>		/// Note that `*agindex` is set to~0 when there are no more codes in the<br/>		/// charmap.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Next_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetNextChar(this FTFace face, [NativeName(NativeNameType.Param, "char_code")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charCode, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* agindex)
		{
			uint ret = FreeType.FTGetNextCharNative(face, charCode, agindex);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Next_Char<br/>		/// <br/>		/// :<br/>		/// Return the next character code in the current charmap of a given face<br/>		/// following the value `char_code`, as well as the corresponding glyph<br/>		/// index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// char_code ::<br/>		/// The starting character code.<br/>		/// <br/>		/// :<br/>		/// agindex ::<br/>		/// Glyph index of next character code.  0~if charmap is empty.<br/>		/// <br/>		/// <br/>		/// Note that `*agindex` is set to~0 when there are no more codes in the<br/>		/// charmap.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Next_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetNextChar(this FTFace face, [NativeName(NativeNameType.Param, "char_code")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charCode, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint agindex)
		{
			fixed (uint* pagindex = &agindex)
			{
				uint ret = FreeType.FTGetNextCharNative(face, charCode, (uint*)pagindex);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_Properties<br/>		/// <br/>		/// :<br/>		/// Set or override certain (library or module-wide) properties on a<br/>		/// face-by-face basis.  Useful for finer-grained control and avoiding<br/>		/// locks on shared structures (threads can modify their own faces as they<br/>		/// see fit).<br/>		/// Contrary to <br/>		/// _Property_Set, this function uses <br/>		/// _Parameter so that<br/>		/// you can pass multiple properties to the target face in one call.  Note<br/>		/// that only a subset of the available properties can be controlled.<br/>		/// * <br/>		/// _PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the<br/>		/// property `no-stem-darkening` provided by the 'autofit', 'cff',<br/>		/// 'type1', and 't1cid' modules; see <br/>		/// -stem-darkening).<br/>		/// * <br/>		/// _PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding<br/>		/// to function <br/>		/// _Library_SetLcdFilterWeights).<br/>		/// * <br/>		/// _PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID<br/>		/// 'random' operator, corresponding to the `random-seed` property<br/>		/// provided by the 'cff', 'type1', and 't1cid' modules; see<br/>		/// <br/>		/// -seed).<br/>		/// Pass `NULL` as `data` in <br/>		/// _Parameter for a given tag to reset the<br/>		/// option and use the library or module default again.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// num_properties ::<br/>		/// The number of properties that follow.<br/>		/// properties ::<br/>		/// A handle to an <br/>		/// _Parameter array with `num_properties` elements.<br/>		/// <br/>		/// <br/>		/// Here is an example that sets three properties.  You must define<br/>		/// `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples<br/>		/// work.<br/>		/// ```<br/>		/// FT_Parameter         property1;<br/>		/// FT_Bool              darken_stems = 1;<br/>		/// FT_Parameter         property2;<br/>		/// FT_LcdFiveTapFilter  custom_weight =<br/>		/// { 0x11, 0x44, 0x56, 0x44, 0x11 };<br/>		/// FT_Parameter         property3;<br/>		/// FT_Int32             random_seed = 314159265;<br/>		/// FT_Parameter         properties[3] = { property1,<br/>		/// property2,<br/>		/// property3 };<br/>		/// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;<br/>		/// property1.data = <br/>		/// &darken<br/>		/// _stems;<br/>		/// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>		/// property2.data = custom_weight;<br/>		/// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;<br/>		/// property3.data = <br/>		/// &random<br/>		/// _seed;<br/>		/// FT_Face_Properties( face, 3, properties );<br/>		/// ```<br/>		/// The next example resets a single property to its default value.<br/>		/// ```<br/>		/// FT_Parameter  property;<br/>		/// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>		/// property.data = NULL;<br/>		/// FT_Face_Properties( face, 1, <br/>		/// &property<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_Properties")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Properties(this FTFace face, [NativeName(NativeNameType.Param, "num_properties")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numProperties, [NativeName(NativeNameType.Param, "properties")] [NativeName(NativeNameType.Type, "FT_Parameter*")] FTParameter* properties)
		{
			int ret = FreeType.FTFacePropertiesNative(face, numProperties, properties);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_Properties<br/>		/// <br/>		/// :<br/>		/// Set or override certain (library or module-wide) properties on a<br/>		/// face-by-face basis.  Useful for finer-grained control and avoiding<br/>		/// locks on shared structures (threads can modify their own faces as they<br/>		/// see fit).<br/>		/// Contrary to <br/>		/// _Property_Set, this function uses <br/>		/// _Parameter so that<br/>		/// you can pass multiple properties to the target face in one call.  Note<br/>		/// that only a subset of the available properties can be controlled.<br/>		/// * <br/>		/// _PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the<br/>		/// property `no-stem-darkening` provided by the 'autofit', 'cff',<br/>		/// 'type1', and 't1cid' modules; see <br/>		/// -stem-darkening).<br/>		/// * <br/>		/// _PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding<br/>		/// to function <br/>		/// _Library_SetLcdFilterWeights).<br/>		/// * <br/>		/// _PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID<br/>		/// 'random' operator, corresponding to the `random-seed` property<br/>		/// provided by the 'cff', 'type1', and 't1cid' modules; see<br/>		/// <br/>		/// -seed).<br/>		/// Pass `NULL` as `data` in <br/>		/// _Parameter for a given tag to reset the<br/>		/// option and use the library or module default again.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// num_properties ::<br/>		/// The number of properties that follow.<br/>		/// properties ::<br/>		/// A handle to an <br/>		/// _Parameter array with `num_properties` elements.<br/>		/// <br/>		/// <br/>		/// Here is an example that sets three properties.  You must define<br/>		/// `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples<br/>		/// work.<br/>		/// ```<br/>		/// FT_Parameter         property1;<br/>		/// FT_Bool              darken_stems = 1;<br/>		/// FT_Parameter         property2;<br/>		/// FT_LcdFiveTapFilter  custom_weight =<br/>		/// { 0x11, 0x44, 0x56, 0x44, 0x11 };<br/>		/// FT_Parameter         property3;<br/>		/// FT_Int32             random_seed = 314159265;<br/>		/// FT_Parameter         properties[3] = { property1,<br/>		/// property2,<br/>		/// property3 };<br/>		/// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;<br/>		/// property1.data = <br/>		/// &darken<br/>		/// _stems;<br/>		/// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>		/// property2.data = custom_weight;<br/>		/// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;<br/>		/// property3.data = <br/>		/// &random<br/>		/// _seed;<br/>		/// FT_Face_Properties( face, 3, properties );<br/>		/// ```<br/>		/// The next example resets a single property to its default value.<br/>		/// ```<br/>		/// FT_Parameter  property;<br/>		/// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>		/// property.data = NULL;<br/>		/// FT_Face_Properties( face, 1, <br/>		/// &property<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_Properties")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Properties(this FTFace face, [NativeName(NativeNameType.Param, "num_properties")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numProperties, [NativeName(NativeNameType.Param, "properties")] [NativeName(NativeNameType.Type, "FT_Parameter*")] ref FTParameter properties)
		{
			fixed (FTParameter* pproperties = &properties)
			{
				int ret = FreeType.FTFacePropertiesNative(face, numProperties, (FTParameter*)pproperties);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Name_Index<br/>		/// <br/>		/// :<br/>		/// Return the glyph index of a given glyph name.  This only works<br/>		/// for those faces where <br/>		/// _HAS_GLYPH_NAMES returns true.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// glyph_name ::<br/>		/// The glyph name.<br/>		/// <br/>		/// <br/>		/// This function has limited capabilities if the config macro<br/>		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>		/// It then works only for fonts that actually embed glyph names (which<br/>		/// many recent OpenType fonts do not).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Name_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetNameIndex(this FTFace face, [NativeName(NativeNameType.Param, "glyph_name")] [NativeName(NativeNameType.Type, "const FT_String*")] byte* glyphName)
		{
			uint ret = FreeType.FTGetNameIndexNative(face, glyphName);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Name_Index<br/>		/// <br/>		/// :<br/>		/// Return the glyph index of a given glyph name.  This only works<br/>		/// for those faces where <br/>		/// _HAS_GLYPH_NAMES returns true.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// glyph_name ::<br/>		/// The glyph name.<br/>		/// <br/>		/// <br/>		/// This function has limited capabilities if the config macro<br/>		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>		/// It then works only for fonts that actually embed glyph names (which<br/>		/// many recent OpenType fonts do not).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Name_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetNameIndex(this FTFace face, [NativeName(NativeNameType.Param, "glyph_name")] [NativeName(NativeNameType.Type, "const FT_String*")] ref byte glyphName)
		{
			fixed (byte* pglyphName = &glyphName)
			{
				uint ret = FreeType.FTGetNameIndexNative(face, (byte*)pglyphName);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Glyph_Name<br/>		/// <br/>		/// :<br/>		/// Retrieve the ASCII name of a given glyph in a face.  This only works<br/>		/// for those faces where <br/>		/// _HAS_GLYPH_NAMES returns true.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// glyph_index ::<br/>		/// The glyph index.<br/>		/// buffer_max ::<br/>		/// The maximum number of bytes available in the buffer.<br/>		/// <br/>		/// :<br/>		/// buffer ::<br/>		/// A pointer to a target buffer where the name is copied to.<br/>		/// <br/>		/// <br/>		/// The glyph name is truncated to fit within the buffer if it is too<br/>		/// long.  The returned string is always zero-terminated.<br/>		/// Be aware that FreeType reorders glyph indices internally so that glyph<br/>		/// index~0 always corresponds to the 'missing glyph' (called '.notdef').<br/>		/// This function has limited capabilities if the config macro<br/>		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>		/// It then works only for fonts that actually embed glyph names (which<br/>		/// many recent OpenType fonts do not).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Glyph_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetGlyphName(this FTFace face, [NativeName(NativeNameType.Param, "glyph_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint glyphIndex, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Pointer")] FTPointer buffer, [NativeName(NativeNameType.Param, "buffer_max")] [NativeName(NativeNameType.Type, "FT_UInt")] uint bufferMax)
		{
			int ret = FreeType.FTGetGlyphNameNative(face, glyphIndex, buffer, bufferMax);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Postscript_Name<br/>		/// <br/>		/// :<br/>		/// Retrieve the ASCII PostScript name of a given face, if available.<br/>		/// This only works with PostScript, TrueType, and OpenType fonts.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// <br/>		/// For variation fonts, this string changes if you select a different<br/>		/// instance, and you have to call `FT_Get_PostScript_Name` again to<br/>		/// retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating<br/>		/// PostScript Names for Fonts Using OpenType Font Variations'.<br/>		/// https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html<br/>		/// [Since 2.9] Special PostScript names for named instances are only<br/>		/// returned if the named instance is set with <br/>		/// _Set_Named_Instance (and<br/>		/// the font has corresponding entries in its 'fvar' table or is the<br/>		/// default named instance).  If <br/>		/// _IS_VARIATION returns true, the<br/>		/// algorithmically derived PostScript name is provided, not looking up<br/>		/// special entries for named instances.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Postscript_Name")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetPostscriptName(this FTFace face)
		{
			byte* ret = FreeType.FTGetPostscriptNameNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Postscript_Name<br/>		/// <br/>		/// :<br/>		/// Retrieve the ASCII PostScript name of a given face, if available.<br/>		/// This only works with PostScript, TrueType, and OpenType fonts.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// <br/>		/// For variation fonts, this string changes if you select a different<br/>		/// instance, and you have to call `FT_Get_PostScript_Name` again to<br/>		/// retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating<br/>		/// PostScript Names for Fonts Using OpenType Font Variations'.<br/>		/// https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html<br/>		/// [Since 2.9] Special PostScript names for named instances are only<br/>		/// returned if the named instance is set with <br/>		/// _Set_Named_Instance (and<br/>		/// the font has corresponding entries in its 'fvar' table or is the<br/>		/// default named instance).  If <br/>		/// _IS_VARIATION returns true, the<br/>		/// algorithmically derived PostScript name is provided, not looking up<br/>		/// special entries for named instances.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Postscript_Name")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string GetPostscriptNameS(this FTFace face)
		{
			string ret = Utils.DecodeStringUTF8(FreeType.FTGetPostscriptNameNative(face));
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_FSType_Flags<br/>		/// <br/>		/// :<br/>		/// Return the `fsType` flags for a font.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_FSType_Flags")]
		[return: NativeName(NativeNameType.Type, "FT_UShort")]
		public static ushort GetFsTypeFlags(this FTFace face)
		{
			ushort ret = FreeType.FTGetFSTypeFlagsNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetCharVariantIndex<br/>		/// <br/>		/// :<br/>		/// Return the glyph index of a given character code as modified by the<br/>		/// variation selector.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// charcode ::<br/>		/// The character code point in Unicode.<br/>		/// variantSelector ::<br/>		/// The Unicode code point of the variation selector.<br/>		/// <br/>		/// <br/>		/// This function is only meaningful if<br/>		/// a) the font has a variation selector cmap sub table, and<br/>		/// b) the current charmap has a Unicode encoding.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIndex")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetCharVariantIndex(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint ret = FreeType.FTFaceGetCharVariantIndexNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetCharVariantIsDefault<br/>		/// <br/>		/// :<br/>		/// Check whether this variation of this Unicode character is the one to<br/>		/// be found in the charmap.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// charcode ::<br/>		/// The character codepoint in Unicode.<br/>		/// variantSelector ::<br/>		/// The Unicode codepoint of the variation selector.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIsDefault")]
		[return: NativeName(NativeNameType.Type, "FT_Int")]
		public static int GetCharVariantIsDefault(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			int ret = FreeType.FTFaceGetCharVariantIsDefaultNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetVariantSelectors<br/>		/// <br/>		/// :<br/>		/// Return a zero-terminated list of Unicode variation selectors found in<br/>		/// the font.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetVariantSelectors")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		public static uint* GetVariantSelectors(this FTFace face)
		{
			uint* ret = FreeType.FTFaceGetVariantSelectorsNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetVariantsOfChar<br/>		/// <br/>		/// :<br/>		/// Return a zero-terminated list of Unicode variation selectors found for<br/>		/// the specified character code.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// charcode ::<br/>		/// The character codepoint in Unicode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetVariantsOfChar")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		public static uint* GetVariantsOfChar(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode)
		{
			uint* ret = FreeType.FTFaceGetVariantsOfCharNative(face, charcode);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetCharsOfVariant<br/>		/// <br/>		/// :<br/>		/// Return a zero-terminated list of Unicode character codes found for the<br/>		/// specified variation selector.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// variantSelector ::<br/>		/// The variation selector code point in Unicode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetCharsOfVariant")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		public static uint* GetCharsOfVariant(this FTFace face, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint* ret = FreeType.FTFaceGetCharsOfVariantNative(face, variantSelector);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_CheckTrueTypePatents<br/>		/// <br/>		/// :<br/>		/// Deprecated, does nothing.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A face handle.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_CheckTrueTypePatents")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte CheckTrueTypePatents(this FTFace face)
		{
			byte ret = FreeType.FTFaceCheckTrueTypePatentsNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_SetUnpatentedHinting<br/>		/// <br/>		/// :<br/>		/// Deprecated, does nothing.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A face handle.<br/>		/// value ::<br/>		/// New boolean setting.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_SetUnpatentedHinting")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte SetUnpatentedHinting(this FTFace face, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "FT_Bool")] byte value)
		{
			byte ret = FreeType.FTFaceSetUnpatentedHintingNative(face, value);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Palette_Data_Get<br/>		/// <br/>		/// :<br/>		/// Retrieve the face's color palette data.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The source face handle.<br/>		/// <br/>		/// :<br/>		/// apalette ::<br/>		/// A pointer to an <br/>		/// _Palette_Data structure.<br/>		/// <br/>		/// <br/>		/// This function always returns an error if the config macro<br/>		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Palette_Data_Get")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int PaletteDataGet(this FTFace face, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Palette_Data*")] FTPaletteData* apalette)
		{
			int ret = FreeType.FTPaletteDataGetNative(face, apalette);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Palette_Data_Get<br/>		/// <br/>		/// :<br/>		/// Retrieve the face's color palette data.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The source face handle.<br/>		/// <br/>		/// :<br/>		/// apalette ::<br/>		/// A pointer to an <br/>		/// _Palette_Data structure.<br/>		/// <br/>		/// <br/>		/// This function always returns an error if the config macro<br/>		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Palette_Data_Get")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int PaletteDataGet(this FTFace face, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Palette_Data*")] ref FTPaletteData apalette)
		{
			fixed (FTPaletteData* papalette = &apalette)
			{
				int ret = FreeType.FTPaletteDataGetNative(face, (FTPaletteData*)papalette);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Palette_Select<br/>		/// <br/>		/// :<br/>		/// This function has two purposes.<br/>		/// (1) It activates a palette for rendering color glyphs, and<br/>		/// (2) it retrieves all (unmodified) color entries of this palette.  This<br/>		/// function returns a read-write array, which means that a calling<br/>		/// application can modify the palette entries on demand.<br/>		/// A corollary of (2) is that calling the function, then modifying some<br/>		/// values, then calling the function again with the same arguments resets<br/>		/// all color entries to the original 'CPAL' values; all user modifications<br/>		/// are lost.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The source face handle.<br/>		/// palette_index ::<br/>		/// The palette index.<br/>		/// <br/>		/// :<br/>		/// apalette ::<br/>		/// An array of color entries for a palette with index `palette_index`,<br/>		/// having `num_palette_entries` elements (as found in the<br/>		/// `FT_Palette_Data` structure).  If `apalette` is set to `NULL`, no<br/>		/// array gets returned (and no color entries can be modified).<br/>		/// In case the font doesn't support color palettes, `NULL` is returned.<br/>		/// <br/>		/// <br/>		/// This function always returns an error if the config macro<br/>		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Palette_Select")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int PaletteSelect(this FTFace face, [NativeName(NativeNameType.Param, "palette_index")] [NativeName(NativeNameType.Type, "FT_UShort")] ushort paletteIndex, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Color**")] FTColor** apalette)
		{
			int ret = FreeType.FTPaletteSelectNative(face, paletteIndex, apalette);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Palette_Select<br/>		/// <br/>		/// :<br/>		/// This function has two purposes.<br/>		/// (1) It activates a palette for rendering color glyphs, and<br/>		/// (2) it retrieves all (unmodified) color entries of this palette.  This<br/>		/// function returns a read-write array, which means that a calling<br/>		/// application can modify the palette entries on demand.<br/>		/// A corollary of (2) is that calling the function, then modifying some<br/>		/// values, then calling the function again with the same arguments resets<br/>		/// all color entries to the original 'CPAL' values; all user modifications<br/>		/// are lost.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The source face handle.<br/>		/// palette_index ::<br/>		/// The palette index.<br/>		/// <br/>		/// :<br/>		/// apalette ::<br/>		/// An array of color entries for a palette with index `palette_index`,<br/>		/// having `num_palette_entries` elements (as found in the<br/>		/// `FT_Palette_Data` structure).  If `apalette` is set to `NULL`, no<br/>		/// array gets returned (and no color entries can be modified).<br/>		/// In case the font doesn't support color palettes, `NULL` is returned.<br/>		/// <br/>		/// <br/>		/// This function always returns an error if the config macro<br/>		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Palette_Select")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int PaletteSelect(this FTFace face, [NativeName(NativeNameType.Param, "palette_index")] [NativeName(NativeNameType.Type, "FT_UShort")] ushort paletteIndex, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Color**")] ref FTColor* apalette)
		{
			fixed (FTColor** papalette = &apalette)
			{
				int ret = FreeType.FTPaletteSelectNative(face, paletteIndex, (FTColor**)papalette);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Palette_Set_Foreground_Color<br/>		/// <br/>		/// :<br/>		/// 'COLR' uses palette index 0xFFFF to indicate a 'text foreground<br/>		/// color'.  This function sets this value.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The source face handle.<br/>		/// foreground_color ::<br/>		/// An `FT_Color` structure to define the text foreground color.<br/>		/// <br/>		/// <br/>		/// This function always returns an error if the config macro<br/>		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Palette_Set_Foreground_Color")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int PaletteSetForegroundColor(this FTFace face, [NativeName(NativeNameType.Param, "foreground_color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor foregroundColor)
		{
			int ret = FreeType.FTPaletteSetForegroundColorNative(face, foregroundColor);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Layer<br/>		/// <br/>		/// :<br/>		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>		/// iteratively retrieve the colored glyph layers associated with the<br/>		/// current glyph slot.<br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>		/// The glyph layer data for a given glyph index, if present, provides an<br/>		/// alternative, multi-color glyph representation: Instead of rendering<br/>		/// the outline or bitmap with the given glyph index, glyphs with the<br/>		/// indices and colors returned by this function are rendered layer by<br/>		/// layer.<br/>		/// The returned elements are ordered in the z~direction from bottom to<br/>		/// top; the 'n'th element should be rendered with the associated palette<br/>		/// color and blended on top of the already rendered layers (elements 0,<br/>		/// 1, ..., n-1).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index the colored glyph layers are associated with.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// An <br/>		/// _LayerIterator object.  For the first call you should set<br/>		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>		/// same object again.<br/>		/// <br/>		/// :<br/>		/// aglyph_index ::<br/>		/// The glyph index of the current layer.<br/>		/// acolor_index ::<br/>		/// The color index into the font face's color palette of the current<br/>		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>		/// entry but indicates that the text foreground color should be used<br/>		/// instead (to be set up by the application outside of FreeType).<br/>		/// The color palette can be retrieved with <br/>		/// _Palette_Select.<br/>		/// <br/>		/// <br/>		/// Note that <br/>		/// _Render_Glyph is able to handle colored glyph layers<br/>		/// automatically if the <br/>		/// _LOAD_COLOR flag is passed to a previous call<br/>		/// to <br/>		/// _Load_Glyph.  [This is an experimental feature.]<br/>		/// <br/>		/// ```<br/>		/// FT_Color*         palette;<br/>		/// FT_LayerIterator  iterator;<br/>		/// FT_Bool  have_layers;<br/>		/// FT_UInt  layer_glyph_index;<br/>		/// FT_UInt  layer_color_index;<br/>		/// error = FT_Palette_Select( face, palette_index, <br/>		/// &palette<br/>		/// );<br/>		/// if ( error )<br/>		/// palette = NULL;<br/>		/// iterator.p  = NULL;<br/>		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// );<br/>		/// if ( palette <br/>		/// &<br/>		/// &<br/>		/// have_layers )<br/>		/// {<br/>		/// do<br/>		/// {<br/>		/// FT_Color  layer_color;<br/>		/// if ( layer_color_index == 0xFFFF )<br/>		/// layer_color = text_foreground_color;<br/>		/// else<br/>		/// layer_color = palette[layer_color_index];<br/>		/// // Load and render glyph `layer_glyph_index', then<br/>		/// // blend resulting pixmap (using color `layer_color')<br/>		/// // with previously created pixmaps.<br/>		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// ) );<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] FTLayerIterator* iterator)
		{
			byte ret = FreeType.FTGetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, acolorIndex, iterator);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Layer<br/>		/// <br/>		/// :<br/>		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>		/// iteratively retrieve the colored glyph layers associated with the<br/>		/// current glyph slot.<br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>		/// The glyph layer data for a given glyph index, if present, provides an<br/>		/// alternative, multi-color glyph representation: Instead of rendering<br/>		/// the outline or bitmap with the given glyph index, glyphs with the<br/>		/// indices and colors returned by this function are rendered layer by<br/>		/// layer.<br/>		/// The returned elements are ordered in the z~direction from bottom to<br/>		/// top; the 'n'th element should be rendered with the associated palette<br/>		/// color and blended on top of the already rendered layers (elements 0,<br/>		/// 1, ..., n-1).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index the colored glyph layers are associated with.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// An <br/>		/// _LayerIterator object.  For the first call you should set<br/>		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>		/// same object again.<br/>		/// <br/>		/// :<br/>		/// aglyph_index ::<br/>		/// The glyph index of the current layer.<br/>		/// acolor_index ::<br/>		/// The color index into the font face's color palette of the current<br/>		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>		/// entry but indicates that the text foreground color should be used<br/>		/// instead (to be set up by the application outside of FreeType).<br/>		/// The color palette can be retrieved with <br/>		/// _Palette_Select.<br/>		/// <br/>		/// <br/>		/// Note that <br/>		/// _Render_Glyph is able to handle colored glyph layers<br/>		/// automatically if the <br/>		/// _LOAD_COLOR flag is passed to a previous call<br/>		/// to <br/>		/// _Load_Glyph.  [This is an experimental feature.]<br/>		/// <br/>		/// ```<br/>		/// FT_Color*         palette;<br/>		/// FT_LayerIterator  iterator;<br/>		/// FT_Bool  have_layers;<br/>		/// FT_UInt  layer_glyph_index;<br/>		/// FT_UInt  layer_color_index;<br/>		/// error = FT_Palette_Select( face, palette_index, <br/>		/// &palette<br/>		/// );<br/>		/// if ( error )<br/>		/// palette = NULL;<br/>		/// iterator.p  = NULL;<br/>		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// );<br/>		/// if ( palette <br/>		/// &<br/>		/// &<br/>		/// have_layers )<br/>		/// {<br/>		/// do<br/>		/// {<br/>		/// FT_Color  layer_color;<br/>		/// if ( layer_color_index == 0xFFFF )<br/>		/// layer_color = text_foreground_color;<br/>		/// else<br/>		/// layer_color = palette[layer_color_index];<br/>		/// // Load and render glyph `layer_glyph_index', then<br/>		/// // blend resulting pixmap (using color `layer_color')<br/>		/// // with previously created pixmaps.<br/>		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// ) );<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] FTLayerIterator* iterator)
		{
			fixed (uint* paglyphIndex = &aglyphIndex)
			{
				byte ret = FreeType.FTGetColorGlyphLayerNative(face, baseGlyph, (uint*)paglyphIndex, acolorIndex, iterator);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Layer<br/>		/// <br/>		/// :<br/>		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>		/// iteratively retrieve the colored glyph layers associated with the<br/>		/// current glyph slot.<br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>		/// The glyph layer data for a given glyph index, if present, provides an<br/>		/// alternative, multi-color glyph representation: Instead of rendering<br/>		/// the outline or bitmap with the given glyph index, glyphs with the<br/>		/// indices and colors returned by this function are rendered layer by<br/>		/// layer.<br/>		/// The returned elements are ordered in the z~direction from bottom to<br/>		/// top; the 'n'th element should be rendered with the associated palette<br/>		/// color and blended on top of the already rendered layers (elements 0,<br/>		/// 1, ..., n-1).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index the colored glyph layers are associated with.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// An <br/>		/// _LayerIterator object.  For the first call you should set<br/>		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>		/// same object again.<br/>		/// <br/>		/// :<br/>		/// aglyph_index ::<br/>		/// The glyph index of the current layer.<br/>		/// acolor_index ::<br/>		/// The color index into the font face's color palette of the current<br/>		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>		/// entry but indicates that the text foreground color should be used<br/>		/// instead (to be set up by the application outside of FreeType).<br/>		/// The color palette can be retrieved with <br/>		/// _Palette_Select.<br/>		/// <br/>		/// <br/>		/// Note that <br/>		/// _Render_Glyph is able to handle colored glyph layers<br/>		/// automatically if the <br/>		/// _LOAD_COLOR flag is passed to a previous call<br/>		/// to <br/>		/// _Load_Glyph.  [This is an experimental feature.]<br/>		/// <br/>		/// ```<br/>		/// FT_Color*         palette;<br/>		/// FT_LayerIterator  iterator;<br/>		/// FT_Bool  have_layers;<br/>		/// FT_UInt  layer_glyph_index;<br/>		/// FT_UInt  layer_color_index;<br/>		/// error = FT_Palette_Select( face, palette_index, <br/>		/// &palette<br/>		/// );<br/>		/// if ( error )<br/>		/// palette = NULL;<br/>		/// iterator.p  = NULL;<br/>		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// );<br/>		/// if ( palette <br/>		/// &<br/>		/// &<br/>		/// have_layers )<br/>		/// {<br/>		/// do<br/>		/// {<br/>		/// FT_Color  layer_color;<br/>		/// if ( layer_color_index == 0xFFFF )<br/>		/// layer_color = text_foreground_color;<br/>		/// else<br/>		/// layer_color = palette[layer_color_index];<br/>		/// // Load and render glyph `layer_glyph_index', then<br/>		/// // blend resulting pixmap (using color `layer_color')<br/>		/// // with previously created pixmaps.<br/>		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// ) );<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] FTLayerIterator* iterator)
		{
			fixed (uint* pacolorIndex = &acolorIndex)
			{
				byte ret = FreeType.FTGetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, (uint*)pacolorIndex, iterator);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Layer<br/>		/// <br/>		/// :<br/>		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>		/// iteratively retrieve the colored glyph layers associated with the<br/>		/// current glyph slot.<br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>		/// The glyph layer data for a given glyph index, if present, provides an<br/>		/// alternative, multi-color glyph representation: Instead of rendering<br/>		/// the outline or bitmap with the given glyph index, glyphs with the<br/>		/// indices and colors returned by this function are rendered layer by<br/>		/// layer.<br/>		/// The returned elements are ordered in the z~direction from bottom to<br/>		/// top; the 'n'th element should be rendered with the associated palette<br/>		/// color and blended on top of the already rendered layers (elements 0,<br/>		/// 1, ..., n-1).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index the colored glyph layers are associated with.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// An <br/>		/// _LayerIterator object.  For the first call you should set<br/>		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>		/// same object again.<br/>		/// <br/>		/// :<br/>		/// aglyph_index ::<br/>		/// The glyph index of the current layer.<br/>		/// acolor_index ::<br/>		/// The color index into the font face's color palette of the current<br/>		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>		/// entry but indicates that the text foreground color should be used<br/>		/// instead (to be set up by the application outside of FreeType).<br/>		/// The color palette can be retrieved with <br/>		/// _Palette_Select.<br/>		/// <br/>		/// <br/>		/// Note that <br/>		/// _Render_Glyph is able to handle colored glyph layers<br/>		/// automatically if the <br/>		/// _LOAD_COLOR flag is passed to a previous call<br/>		/// to <br/>		/// _Load_Glyph.  [This is an experimental feature.]<br/>		/// <br/>		/// ```<br/>		/// FT_Color*         palette;<br/>		/// FT_LayerIterator  iterator;<br/>		/// FT_Bool  have_layers;<br/>		/// FT_UInt  layer_glyph_index;<br/>		/// FT_UInt  layer_color_index;<br/>		/// error = FT_Palette_Select( face, palette_index, <br/>		/// &palette<br/>		/// );<br/>		/// if ( error )<br/>		/// palette = NULL;<br/>		/// iterator.p  = NULL;<br/>		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// );<br/>		/// if ( palette <br/>		/// &<br/>		/// &<br/>		/// have_layers )<br/>		/// {<br/>		/// do<br/>		/// {<br/>		/// FT_Color  layer_color;<br/>		/// if ( layer_color_index == 0xFFFF )<br/>		/// layer_color = text_foreground_color;<br/>		/// else<br/>		/// layer_color = palette[layer_color_index];<br/>		/// // Load and render glyph `layer_glyph_index', then<br/>		/// // blend resulting pixmap (using color `layer_color')<br/>		/// // with previously created pixmaps.<br/>		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// ) );<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] FTLayerIterator* iterator)
		{
			fixed (uint* paglyphIndex = &aglyphIndex)
			{
				fixed (uint* pacolorIndex = &acolorIndex)
				{
					byte ret = FreeType.FTGetColorGlyphLayerNative(face, baseGlyph, (uint*)paglyphIndex, (uint*)pacolorIndex, iterator);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Layer<br/>		/// <br/>		/// :<br/>		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>		/// iteratively retrieve the colored glyph layers associated with the<br/>		/// current glyph slot.<br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>		/// The glyph layer data for a given glyph index, if present, provides an<br/>		/// alternative, multi-color glyph representation: Instead of rendering<br/>		/// the outline or bitmap with the given glyph index, glyphs with the<br/>		/// indices and colors returned by this function are rendered layer by<br/>		/// layer.<br/>		/// The returned elements are ordered in the z~direction from bottom to<br/>		/// top; the 'n'th element should be rendered with the associated palette<br/>		/// color and blended on top of the already rendered layers (elements 0,<br/>		/// 1, ..., n-1).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index the colored glyph layers are associated with.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// An <br/>		/// _LayerIterator object.  For the first call you should set<br/>		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>		/// same object again.<br/>		/// <br/>		/// :<br/>		/// aglyph_index ::<br/>		/// The glyph index of the current layer.<br/>		/// acolor_index ::<br/>		/// The color index into the font face's color palette of the current<br/>		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>		/// entry but indicates that the text foreground color should be used<br/>		/// instead (to be set up by the application outside of FreeType).<br/>		/// The color palette can be retrieved with <br/>		/// _Palette_Select.<br/>		/// <br/>		/// <br/>		/// Note that <br/>		/// _Render_Glyph is able to handle colored glyph layers<br/>		/// automatically if the <br/>		/// _LOAD_COLOR flag is passed to a previous call<br/>		/// to <br/>		/// _Load_Glyph.  [This is an experimental feature.]<br/>		/// <br/>		/// ```<br/>		/// FT_Color*         palette;<br/>		/// FT_LayerIterator  iterator;<br/>		/// FT_Bool  have_layers;<br/>		/// FT_UInt  layer_glyph_index;<br/>		/// FT_UInt  layer_color_index;<br/>		/// error = FT_Palette_Select( face, palette_index, <br/>		/// &palette<br/>		/// );<br/>		/// if ( error )<br/>		/// palette = NULL;<br/>		/// iterator.p  = NULL;<br/>		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// );<br/>		/// if ( palette <br/>		/// &<br/>		/// &<br/>		/// have_layers )<br/>		/// {<br/>		/// do<br/>		/// {<br/>		/// FT_Color  layer_color;<br/>		/// if ( layer_color_index == 0xFFFF )<br/>		/// layer_color = text_foreground_color;<br/>		/// else<br/>		/// layer_color = palette[layer_color_index];<br/>		/// // Load and render glyph `layer_glyph_index', then<br/>		/// // blend resulting pixmap (using color `layer_color')<br/>		/// // with previously created pixmaps.<br/>		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// ) );<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator)
		{
			fixed (FTLayerIterator* piterator = &iterator)
			{
				byte ret = FreeType.FTGetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, acolorIndex, (FTLayerIterator*)piterator);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Layer<br/>		/// <br/>		/// :<br/>		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>		/// iteratively retrieve the colored glyph layers associated with the<br/>		/// current glyph slot.<br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>		/// The glyph layer data for a given glyph index, if present, provides an<br/>		/// alternative, multi-color glyph representation: Instead of rendering<br/>		/// the outline or bitmap with the given glyph index, glyphs with the<br/>		/// indices and colors returned by this function are rendered layer by<br/>		/// layer.<br/>		/// The returned elements are ordered in the z~direction from bottom to<br/>		/// top; the 'n'th element should be rendered with the associated palette<br/>		/// color and blended on top of the already rendered layers (elements 0,<br/>		/// 1, ..., n-1).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index the colored glyph layers are associated with.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// An <br/>		/// _LayerIterator object.  For the first call you should set<br/>		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>		/// same object again.<br/>		/// <br/>		/// :<br/>		/// aglyph_index ::<br/>		/// The glyph index of the current layer.<br/>		/// acolor_index ::<br/>		/// The color index into the font face's color palette of the current<br/>		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>		/// entry but indicates that the text foreground color should be used<br/>		/// instead (to be set up by the application outside of FreeType).<br/>		/// The color palette can be retrieved with <br/>		/// _Palette_Select.<br/>		/// <br/>		/// <br/>		/// Note that <br/>		/// _Render_Glyph is able to handle colored glyph layers<br/>		/// automatically if the <br/>		/// _LOAD_COLOR flag is passed to a previous call<br/>		/// to <br/>		/// _Load_Glyph.  [This is an experimental feature.]<br/>		/// <br/>		/// ```<br/>		/// FT_Color*         palette;<br/>		/// FT_LayerIterator  iterator;<br/>		/// FT_Bool  have_layers;<br/>		/// FT_UInt  layer_glyph_index;<br/>		/// FT_UInt  layer_color_index;<br/>		/// error = FT_Palette_Select( face, palette_index, <br/>		/// &palette<br/>		/// );<br/>		/// if ( error )<br/>		/// palette = NULL;<br/>		/// iterator.p  = NULL;<br/>		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// );<br/>		/// if ( palette <br/>		/// &<br/>		/// &<br/>		/// have_layers )<br/>		/// {<br/>		/// do<br/>		/// {<br/>		/// FT_Color  layer_color;<br/>		/// if ( layer_color_index == 0xFFFF )<br/>		/// layer_color = text_foreground_color;<br/>		/// else<br/>		/// layer_color = palette[layer_color_index];<br/>		/// // Load and render glyph `layer_glyph_index', then<br/>		/// // blend resulting pixmap (using color `layer_color')<br/>		/// // with previously created pixmaps.<br/>		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// ) );<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator)
		{
			fixed (uint* paglyphIndex = &aglyphIndex)
			{
				fixed (FTLayerIterator* piterator = &iterator)
				{
					byte ret = FreeType.FTGetColorGlyphLayerNative(face, baseGlyph, (uint*)paglyphIndex, acolorIndex, (FTLayerIterator*)piterator);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Layer<br/>		/// <br/>		/// :<br/>		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>		/// iteratively retrieve the colored glyph layers associated with the<br/>		/// current glyph slot.<br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>		/// The glyph layer data for a given glyph index, if present, provides an<br/>		/// alternative, multi-color glyph representation: Instead of rendering<br/>		/// the outline or bitmap with the given glyph index, glyphs with the<br/>		/// indices and colors returned by this function are rendered layer by<br/>		/// layer.<br/>		/// The returned elements are ordered in the z~direction from bottom to<br/>		/// top; the 'n'th element should be rendered with the associated palette<br/>		/// color and blended on top of the already rendered layers (elements 0,<br/>		/// 1, ..., n-1).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index the colored glyph layers are associated with.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// An <br/>		/// _LayerIterator object.  For the first call you should set<br/>		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>		/// same object again.<br/>		/// <br/>		/// :<br/>		/// aglyph_index ::<br/>		/// The glyph index of the current layer.<br/>		/// acolor_index ::<br/>		/// The color index into the font face's color palette of the current<br/>		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>		/// entry but indicates that the text foreground color should be used<br/>		/// instead (to be set up by the application outside of FreeType).<br/>		/// The color palette can be retrieved with <br/>		/// _Palette_Select.<br/>		/// <br/>		/// <br/>		/// Note that <br/>		/// _Render_Glyph is able to handle colored glyph layers<br/>		/// automatically if the <br/>		/// _LOAD_COLOR flag is passed to a previous call<br/>		/// to <br/>		/// _Load_Glyph.  [This is an experimental feature.]<br/>		/// <br/>		/// ```<br/>		/// FT_Color*         palette;<br/>		/// FT_LayerIterator  iterator;<br/>		/// FT_Bool  have_layers;<br/>		/// FT_UInt  layer_glyph_index;<br/>		/// FT_UInt  layer_color_index;<br/>		/// error = FT_Palette_Select( face, palette_index, <br/>		/// &palette<br/>		/// );<br/>		/// if ( error )<br/>		/// palette = NULL;<br/>		/// iterator.p  = NULL;<br/>		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// );<br/>		/// if ( palette <br/>		/// &<br/>		/// &<br/>		/// have_layers )<br/>		/// {<br/>		/// do<br/>		/// {<br/>		/// FT_Color  layer_color;<br/>		/// if ( layer_color_index == 0xFFFF )<br/>		/// layer_color = text_foreground_color;<br/>		/// else<br/>		/// layer_color = palette[layer_color_index];<br/>		/// // Load and render glyph `layer_glyph_index', then<br/>		/// // blend resulting pixmap (using color `layer_color')<br/>		/// // with previously created pixmaps.<br/>		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// ) );<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator)
		{
			fixed (uint* pacolorIndex = &acolorIndex)
			{
				fixed (FTLayerIterator* piterator = &iterator)
				{
					byte ret = FreeType.FTGetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, (uint*)pacolorIndex, (FTLayerIterator*)piterator);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Layer<br/>		/// <br/>		/// :<br/>		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>		/// iteratively retrieve the colored glyph layers associated with the<br/>		/// current glyph slot.<br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>		/// The glyph layer data for a given glyph index, if present, provides an<br/>		/// alternative, multi-color glyph representation: Instead of rendering<br/>		/// the outline or bitmap with the given glyph index, glyphs with the<br/>		/// indices and colors returned by this function are rendered layer by<br/>		/// layer.<br/>		/// The returned elements are ordered in the z~direction from bottom to<br/>		/// top; the 'n'th element should be rendered with the associated palette<br/>		/// color and blended on top of the already rendered layers (elements 0,<br/>		/// 1, ..., n-1).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index the colored glyph layers are associated with.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// An <br/>		/// _LayerIterator object.  For the first call you should set<br/>		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>		/// same object again.<br/>		/// <br/>		/// :<br/>		/// aglyph_index ::<br/>		/// The glyph index of the current layer.<br/>		/// acolor_index ::<br/>		/// The color index into the font face's color palette of the current<br/>		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>		/// entry but indicates that the text foreground color should be used<br/>		/// instead (to be set up by the application outside of FreeType).<br/>		/// The color palette can be retrieved with <br/>		/// _Palette_Select.<br/>		/// <br/>		/// <br/>		/// Note that <br/>		/// _Render_Glyph is able to handle colored glyph layers<br/>		/// automatically if the <br/>		/// _LOAD_COLOR flag is passed to a previous call<br/>		/// to <br/>		/// _Load_Glyph.  [This is an experimental feature.]<br/>		/// <br/>		/// ```<br/>		/// FT_Color*         palette;<br/>		/// FT_LayerIterator  iterator;<br/>		/// FT_Bool  have_layers;<br/>		/// FT_UInt  layer_glyph_index;<br/>		/// FT_UInt  layer_color_index;<br/>		/// error = FT_Palette_Select( face, palette_index, <br/>		/// &palette<br/>		/// );<br/>		/// if ( error )<br/>		/// palette = NULL;<br/>		/// iterator.p  = NULL;<br/>		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// );<br/>		/// if ( palette <br/>		/// &<br/>		/// &<br/>		/// have_layers )<br/>		/// {<br/>		/// do<br/>		/// {<br/>		/// FT_Color  layer_color;<br/>		/// if ( layer_color_index == 0xFFFF )<br/>		/// layer_color = text_foreground_color;<br/>		/// else<br/>		/// layer_color = palette[layer_color_index];<br/>		/// // Load and render glyph `layer_glyph_index', then<br/>		/// // blend resulting pixmap (using color `layer_color')<br/>		/// // with previously created pixmaps.<br/>		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>		/// glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _glyph_index,<br/>		/// <br/>		/// &layer<br/>		/// _color_index,<br/>		/// <br/>		/// &iterator<br/>		/// ) );<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator)
		{
			fixed (uint* paglyphIndex = &aglyphIndex)
			{
				fixed (uint* pacolorIndex = &acolorIndex)
				{
					fixed (FTLayerIterator* piterator = &iterator)
					{
						byte ret = FreeType.FTGetColorGlyphLayerNative(face, baseGlyph, (uint*)paglyphIndex, (uint*)pacolorIndex, (FTLayerIterator*)piterator);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Paint<br/>		/// <br/>		/// :<br/>		/// This is the starting point and interface to color gradient<br/>		/// information in a 'COLR' v1 table in OpenType fonts to recursively<br/>		/// retrieve the paint tables for the directed acyclic graph of a colored<br/>		/// glyph, given a glyph ID.<br/>		/// https://github.com/googlefonts/colr-gradients-spec<br/>		/// In a 'COLR' v1 font, each color glyph defines a directed acyclic<br/>		/// graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,<br/>		/// `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this<br/>		/// function and specifying a glyph ID, one retrieves the root paint<br/>		/// table for this glyph ID.<br/>		/// This function allows control whether an initial root transform is<br/>		/// returned to configure scaling, transform, and translation correctly<br/>		/// on the client's graphics context.  The initial root transform is<br/>		/// computed and returned according to the values configured for <br/>		/// _Size<br/>		/// and <br/>		/// _Set_Transform on the <br/>		/// _Face object, see below for details<br/>		/// of the `root_transform` parameter.  This has implications for a<br/>		/// client 'COLR' v1 implementation: When this function returns an<br/>		/// initially computed root transform, at the time of executing the<br/>		/// <br/>		/// _PaintGlyph operation, the contours should be retrieved using<br/>		/// <br/>		/// _Load_Glyph at unscaled, untransformed size.  This is because the<br/>		/// root transform applied to the graphics context will take care of<br/>		/// correct scaling.<br/>		/// Alternatively, to allow hinting of contours, at the time of executing<br/>		/// <br/>		/// _Load_Glyph, the current graphics context transformation matrix<br/>		/// can be decomposed into a scaling matrix and a remainder, and<br/>		/// <br/>		/// _Load_Glyph can be used to retrieve the contours at scaled size.<br/>		/// Care must then be taken to blit or clip to the graphics context with<br/>		/// taking this remainder transformation into account.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index for which to retrieve the root paint table.<br/>		/// root_transform ::<br/>		/// Specifies whether an initially computed root is returned by the<br/>		/// <br/>		/// _PaintTransform operation to account for the activated size<br/>		/// (see <br/>		/// _Activate_Size) and the configured transform and translate<br/>		/// (see <br/>		/// _Set_Transform).<br/>		/// This root transform is returned before nodes of the glyph graph of<br/>		/// the font are returned.  Subsequent <br/>		/// _COLR_Paint structures<br/>		/// contain unscaled and untransformed values.  The inserted root<br/>		/// transform enables the client application to apply an initial<br/>		/// transform to its graphics context.  When executing subsequent<br/>		/// FT_COLR_Paint operations, values from <br/>		/// _COLR_Paint operations<br/>		/// will ultimately be correctly scaled because of the root transform<br/>		/// applied to the graphics context.  Use<br/>		/// <br/>		/// _COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use<br/>		/// <br/>		/// _COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be<br/>		/// useful when traversing the 'COLR' v1 glyph graph and reaching a<br/>		/// <br/>		/// _PaintColrGlyph.  When recursing into <br/>		/// _PaintColrGlyph and<br/>		/// painting that inline, no additional root transform is needed as it<br/>		/// has already been applied to the graphics context at the beginning<br/>		/// of drawing this glyph.<br/>		/// <br/>		/// :<br/>		/// paint ::<br/>		/// The <br/>		/// _OpaquePaint object that references the actual paint table.<br/>		/// The respective actual <br/>		/// _COLR_Paint object is retrieved via<br/>		/// <br/>		/// _Get_Paint.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphPaint(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "root_transform")] [NativeName(NativeNameType.Type, "FT_Color_Root_Transform")] FTColorRootTransform rootTransform, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] FTOpaquePaint* paint)
		{
			byte ret = FreeType.FTGetColorGlyphPaintNative(face, baseGlyph, rootTransform, paint);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_Paint<br/>		/// <br/>		/// :<br/>		/// This is the starting point and interface to color gradient<br/>		/// information in a 'COLR' v1 table in OpenType fonts to recursively<br/>		/// retrieve the paint tables for the directed acyclic graph of a colored<br/>		/// glyph, given a glyph ID.<br/>		/// https://github.com/googlefonts/colr-gradients-spec<br/>		/// In a 'COLR' v1 font, each color glyph defines a directed acyclic<br/>		/// graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,<br/>		/// `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this<br/>		/// function and specifying a glyph ID, one retrieves the root paint<br/>		/// table for this glyph ID.<br/>		/// This function allows control whether an initial root transform is<br/>		/// returned to configure scaling, transform, and translation correctly<br/>		/// on the client's graphics context.  The initial root transform is<br/>		/// computed and returned according to the values configured for <br/>		/// _Size<br/>		/// and <br/>		/// _Set_Transform on the <br/>		/// _Face object, see below for details<br/>		/// of the `root_transform` parameter.  This has implications for a<br/>		/// client 'COLR' v1 implementation: When this function returns an<br/>		/// initially computed root transform, at the time of executing the<br/>		/// <br/>		/// _PaintGlyph operation, the contours should be retrieved using<br/>		/// <br/>		/// _Load_Glyph at unscaled, untransformed size.  This is because the<br/>		/// root transform applied to the graphics context will take care of<br/>		/// correct scaling.<br/>		/// Alternatively, to allow hinting of contours, at the time of executing<br/>		/// <br/>		/// _Load_Glyph, the current graphics context transformation matrix<br/>		/// can be decomposed into a scaling matrix and a remainder, and<br/>		/// <br/>		/// _Load_Glyph can be used to retrieve the contours at scaled size.<br/>		/// Care must then be taken to blit or clip to the graphics context with<br/>		/// taking this remainder transformation into account.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index for which to retrieve the root paint table.<br/>		/// root_transform ::<br/>		/// Specifies whether an initially computed root is returned by the<br/>		/// <br/>		/// _PaintTransform operation to account for the activated size<br/>		/// (see <br/>		/// _Activate_Size) and the configured transform and translate<br/>		/// (see <br/>		/// _Set_Transform).<br/>		/// This root transform is returned before nodes of the glyph graph of<br/>		/// the font are returned.  Subsequent <br/>		/// _COLR_Paint structures<br/>		/// contain unscaled and untransformed values.  The inserted root<br/>		/// transform enables the client application to apply an initial<br/>		/// transform to its graphics context.  When executing subsequent<br/>		/// FT_COLR_Paint operations, values from <br/>		/// _COLR_Paint operations<br/>		/// will ultimately be correctly scaled because of the root transform<br/>		/// applied to the graphics context.  Use<br/>		/// <br/>		/// _COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use<br/>		/// <br/>		/// _COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be<br/>		/// useful when traversing the 'COLR' v1 glyph graph and reaching a<br/>		/// <br/>		/// _PaintColrGlyph.  When recursing into <br/>		/// _PaintColrGlyph and<br/>		/// painting that inline, no additional root transform is needed as it<br/>		/// has already been applied to the graphics context at the beginning<br/>		/// of drawing this glyph.<br/>		/// <br/>		/// :<br/>		/// paint ::<br/>		/// The <br/>		/// _OpaquePaint object that references the actual paint table.<br/>		/// The respective actual <br/>		/// _COLR_Paint object is retrieved via<br/>		/// <br/>		/// _Get_Paint.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphPaint(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "root_transform")] [NativeName(NativeNameType.Type, "FT_Color_Root_Transform")] FTColorRootTransform rootTransform, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] ref FTOpaquePaint paint)
		{
			fixed (FTOpaquePaint* ppaint = &paint)
			{
				byte ret = FreeType.FTGetColorGlyphPaintNative(face, baseGlyph, rootTransform, (FTOpaquePaint*)ppaint);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_ClipBox<br/>		/// <br/>		/// :<br/>		/// Search for a 'COLR' v1 clip box for the specified `base_glyph` and<br/>		/// fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information<br/>		/// if one is found.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index for which to retrieve the clip box.<br/>		/// <br/>		/// :<br/>		/// clip_box ::<br/>		/// The clip box for the requested `base_glyph` if one is found.  The<br/>		/// clip box is computed taking scale and transformations configured on<br/>		/// the <br/>		/// _Face into account.  <br/>		/// _ClipBox contains <br/>		/// _Vector values<br/>		/// in 26.6 format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_ClipBox")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphClipBox(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "clip_box")] [NativeName(NativeNameType.Type, "FT_ClipBox*")] FTClipBox* clipBox)
		{
			byte ret = FreeType.FTGetColorGlyphClipBoxNative(face, baseGlyph, clipBox);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Color_Glyph_ClipBox<br/>		/// <br/>		/// :<br/>		/// Search for a 'COLR' v1 clip box for the specified `base_glyph` and<br/>		/// fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information<br/>		/// if one is found.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// base_glyph ::<br/>		/// The glyph index for which to retrieve the clip box.<br/>		/// <br/>		/// :<br/>		/// clip_box ::<br/>		/// The clip box for the requested `base_glyph` if one is found.  The<br/>		/// clip box is computed taking scale and transformations configured on<br/>		/// the <br/>		/// _Face into account.  <br/>		/// _ClipBox contains <br/>		/// _Vector values<br/>		/// in 26.6 format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_ClipBox")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphClipBox(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "clip_box")] [NativeName(NativeNameType.Type, "FT_ClipBox*")] ref FTClipBox clipBox)
		{
			fixed (FTClipBox* pclipBox = &clipBox)
			{
				byte ret = FreeType.FTGetColorGlyphClipBoxNative(face, baseGlyph, (FTClipBox*)pclipBox);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Paint_Layers<br/>		/// <br/>		/// :<br/>		/// Access the layers of a `PaintColrLayers` table.<br/>		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>		/// layers of the `PaintColrLayers` table.<br/>		/// The <br/>		/// _PaintColrLayers object contains an <br/>		/// _LayerIterator, which<br/>		/// is used here to iterate over the layers.  Each layer is returned as<br/>		/// an <br/>		/// _OpaquePaint object, which then can be used with <br/>		/// _Get_Paint<br/>		/// to retrieve the actual paint object.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// The <br/>		/// _LayerIterator from an <br/>		/// _PaintColrLayers object, for which<br/>		/// the layers are to be retrieved.  The internal state of the iterator<br/>		/// is incremented after one call to this function for retrieving one<br/>		/// layer.<br/>		/// <br/>		/// :<br/>		/// paint ::<br/>		/// The <br/>		/// _OpaquePaint object that references the actual paint table.<br/>		/// The respective actual <br/>		/// _COLR_Paint object is retrieved via<br/>		/// <br/>		/// _Get_Paint.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaintLayers(this FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] FTLayerIterator* iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] FTOpaquePaint* paint)
		{
			byte ret = FreeType.FTGetPaintLayersNative(face, iterator, paint);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Paint_Layers<br/>		/// <br/>		/// :<br/>		/// Access the layers of a `PaintColrLayers` table.<br/>		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>		/// layers of the `PaintColrLayers` table.<br/>		/// The <br/>		/// _PaintColrLayers object contains an <br/>		/// _LayerIterator, which<br/>		/// is used here to iterate over the layers.  Each layer is returned as<br/>		/// an <br/>		/// _OpaquePaint object, which then can be used with <br/>		/// _Get_Paint<br/>		/// to retrieve the actual paint object.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// The <br/>		/// _LayerIterator from an <br/>		/// _PaintColrLayers object, for which<br/>		/// the layers are to be retrieved.  The internal state of the iterator<br/>		/// is incremented after one call to this function for retrieving one<br/>		/// layer.<br/>		/// <br/>		/// :<br/>		/// paint ::<br/>		/// The <br/>		/// _OpaquePaint object that references the actual paint table.<br/>		/// The respective actual <br/>		/// _COLR_Paint object is retrieved via<br/>		/// <br/>		/// _Get_Paint.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaintLayers(this FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] FTOpaquePaint* paint)
		{
			fixed (FTLayerIterator* piterator = &iterator)
			{
				byte ret = FreeType.FTGetPaintLayersNative(face, (FTLayerIterator*)piterator, paint);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Paint_Layers<br/>		/// <br/>		/// :<br/>		/// Access the layers of a `PaintColrLayers` table.<br/>		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>		/// layers of the `PaintColrLayers` table.<br/>		/// The <br/>		/// _PaintColrLayers object contains an <br/>		/// _LayerIterator, which<br/>		/// is used here to iterate over the layers.  Each layer is returned as<br/>		/// an <br/>		/// _OpaquePaint object, which then can be used with <br/>		/// _Get_Paint<br/>		/// to retrieve the actual paint object.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// The <br/>		/// _LayerIterator from an <br/>		/// _PaintColrLayers object, for which<br/>		/// the layers are to be retrieved.  The internal state of the iterator<br/>		/// is incremented after one call to this function for retrieving one<br/>		/// layer.<br/>		/// <br/>		/// :<br/>		/// paint ::<br/>		/// The <br/>		/// _OpaquePaint object that references the actual paint table.<br/>		/// The respective actual <br/>		/// _COLR_Paint object is retrieved via<br/>		/// <br/>		/// _Get_Paint.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaintLayers(this FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] FTLayerIterator* iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] ref FTOpaquePaint paint)
		{
			fixed (FTOpaquePaint* ppaint = &paint)
			{
				byte ret = FreeType.FTGetPaintLayersNative(face, iterator, (FTOpaquePaint*)ppaint);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Paint_Layers<br/>		/// <br/>		/// :<br/>		/// Access the layers of a `PaintColrLayers` table.<br/>		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>		/// layers of the `PaintColrLayers` table.<br/>		/// The <br/>		/// _PaintColrLayers object contains an <br/>		/// _LayerIterator, which<br/>		/// is used here to iterate over the layers.  Each layer is returned as<br/>		/// an <br/>		/// _OpaquePaint object, which then can be used with <br/>		/// _Get_Paint<br/>		/// to retrieve the actual paint object.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// The <br/>		/// _LayerIterator from an <br/>		/// _PaintColrLayers object, for which<br/>		/// the layers are to be retrieved.  The internal state of the iterator<br/>		/// is incremented after one call to this function for retrieving one<br/>		/// layer.<br/>		/// <br/>		/// :<br/>		/// paint ::<br/>		/// The <br/>		/// _OpaquePaint object that references the actual paint table.<br/>		/// The respective actual <br/>		/// _COLR_Paint object is retrieved via<br/>		/// <br/>		/// _Get_Paint.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaintLayers(this FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator*")] ref FTLayerIterator iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint*")] ref FTOpaquePaint paint)
		{
			fixed (FTLayerIterator* piterator = &iterator)
			{
				fixed (FTOpaquePaint* ppaint = &paint)
				{
					byte ret = FreeType.FTGetPaintLayersNative(face, (FTLayerIterator*)piterator, (FTOpaquePaint*)ppaint);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Colorline_Stops<br/>		/// <br/>		/// :<br/>		/// This is an interface to color gradient information in a 'COLR' v1<br/>		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>		/// solid fill information for colored glyph layers for a specified glyph<br/>		/// ID.<br/>		/// https://github.com/googlefonts/colr-gradients-spec<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// The retrieved <br/>		/// _ColorStopIterator, configured on an <br/>		/// _ColorLine,<br/>		/// which in turn got retrieved via paint information in<br/>		/// <br/>		/// _PaintLinearGradient or <br/>		/// _PaintRadialGradient.<br/>		/// <br/>		/// :<br/>		/// color_stop ::<br/>		/// Color index and alpha value for the retrieved color stop.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorlineStops(this FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop*")] FTColorStop* colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator*")] FTColorStopIterator* iterator)
		{
			byte ret = FreeType.FTGetColorlineStopsNative(face, colorStop, iterator);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Colorline_Stops<br/>		/// <br/>		/// :<br/>		/// This is an interface to color gradient information in a 'COLR' v1<br/>		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>		/// solid fill information for colored glyph layers for a specified glyph<br/>		/// ID.<br/>		/// https://github.com/googlefonts/colr-gradients-spec<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// The retrieved <br/>		/// _ColorStopIterator, configured on an <br/>		/// _ColorLine,<br/>		/// which in turn got retrieved via paint information in<br/>		/// <br/>		/// _PaintLinearGradient or <br/>		/// _PaintRadialGradient.<br/>		/// <br/>		/// :<br/>		/// color_stop ::<br/>		/// Color index and alpha value for the retrieved color stop.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorlineStops(this FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop*")] ref FTColorStop colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator*")] FTColorStopIterator* iterator)
		{
			fixed (FTColorStop* pcolorStop = &colorStop)
			{
				byte ret = FreeType.FTGetColorlineStopsNative(face, (FTColorStop*)pcolorStop, iterator);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Colorline_Stops<br/>		/// <br/>		/// :<br/>		/// This is an interface to color gradient information in a 'COLR' v1<br/>		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>		/// solid fill information for colored glyph layers for a specified glyph<br/>		/// ID.<br/>		/// https://github.com/googlefonts/colr-gradients-spec<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// The retrieved <br/>		/// _ColorStopIterator, configured on an <br/>		/// _ColorLine,<br/>		/// which in turn got retrieved via paint information in<br/>		/// <br/>		/// _PaintLinearGradient or <br/>		/// _PaintRadialGradient.<br/>		/// <br/>		/// :<br/>		/// color_stop ::<br/>		/// Color index and alpha value for the retrieved color stop.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorlineStops(this FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop*")] FTColorStop* colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator*")] ref FTColorStopIterator iterator)
		{
			fixed (FTColorStopIterator* piterator = &iterator)
			{
				byte ret = FreeType.FTGetColorlineStopsNative(face, colorStop, (FTColorStopIterator*)piterator);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Colorline_Stops<br/>		/// <br/>		/// :<br/>		/// This is an interface to color gradient information in a 'COLR' v1<br/>		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>		/// solid fill information for colored glyph layers for a specified glyph<br/>		/// ID.<br/>		/// https://github.com/googlefonts/colr-gradients-spec<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// <br/>		/// :<br/>		/// iterator ::<br/>		/// The retrieved <br/>		/// _ColorStopIterator, configured on an <br/>		/// _ColorLine,<br/>		/// which in turn got retrieved via paint information in<br/>		/// <br/>		/// _PaintLinearGradient or <br/>		/// _PaintRadialGradient.<br/>		/// <br/>		/// :<br/>		/// color_stop ::<br/>		/// Color index and alpha value for the retrieved color stop.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorlineStops(this FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop*")] ref FTColorStop colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator*")] ref FTColorStopIterator iterator)
		{
			fixed (FTColorStop* pcolorStop = &colorStop)
			{
				fixed (FTColorStopIterator* piterator = &iterator)
				{
					byte ret = FreeType.FTGetColorlineStopsNative(face, (FTColorStop*)pcolorStop, (FTColorStopIterator*)piterator);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Paint<br/>		/// <br/>		/// :<br/>		/// Access the details of a paint using an <br/>		/// _OpaquePaint opaque paint<br/>		/// object, which internally stores the offset to the respective `Paint`<br/>		/// object in the 'COLR' table.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// opaque_paint ::<br/>		/// The opaque paint object for which the underlying <br/>		/// _COLR_Paint<br/>		/// data is to be retrieved.<br/>		/// <br/>		/// :<br/>		/// paint ::<br/>		/// The specific <br/>		/// _COLR_Paint object containing information coming<br/>		/// from one of the font's `Paint*` tables.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaint(this FTFace face, [NativeName(NativeNameType.Param, "opaque_paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint")] FTOpaquePaint opaquePaint, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_COLR_Paint*")] FTCOLRPaint* paint)
		{
			byte ret = FreeType.FTGetPaintNative(face, opaquePaint, paint);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Paint<br/>		/// <br/>		/// :<br/>		/// Access the details of a paint using an <br/>		/// _OpaquePaint opaque paint<br/>		/// object, which internally stores the offset to the respective `Paint`<br/>		/// object in the 'COLR' table.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the parent face object.<br/>		/// opaque_paint ::<br/>		/// The opaque paint object for which the underlying <br/>		/// _COLR_Paint<br/>		/// data is to be retrieved.<br/>		/// <br/>		/// :<br/>		/// paint ::<br/>		/// The specific <br/>		/// _COLR_Paint object containing information coming<br/>		/// from one of the font's `Paint*` tables.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaint(this FTFace face, [NativeName(NativeNameType.Param, "opaque_paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint")] FTOpaquePaint opaquePaint, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_COLR_Paint*")] ref FTCOLRPaint paint)
		{
			fixed (FTCOLRPaint* ppaint = &paint)
			{
				byte ret = FreeType.FTGetPaintNative(face, opaquePaint, (FTCOLRPaint*)ppaint);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Sfnt_Table<br/>		/// <br/>		/// :<br/>		/// Return a pointer to a given SFNT table stored within a face.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source.<br/>		/// tag ::<br/>		/// The index of the SFNT table.<br/>		/// <br/>		/// Use a typecast according to `tag` to access the structure elements.<br/>		/// <br/>		/// This function is only useful to access SFNT tables that are loaded by<br/>		/// the sfnt, truetype, and opentype drivers.  See <br/>		/// _Sfnt_Tag for a<br/>		/// list.<br/>		/// <br/>		/// Here is an example demonstrating access to the 'vhea' table.<br/>		/// ```<br/>		/// TT_VertHeader*  vert_header;<br/>		/// vert_header =<br/>		/// (TT_VertHeader*)FT_Get_Sfnt_Table( face, FT_SFNT_VHEA );<br/>		/// ```<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* GetSfntTable(this FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_Sfnt_Tag")] FTSfntTag tag)
		{
			void* ret = FreeType.FTGetSfntTableNative(face, tag);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Load_Sfnt_Table<br/>		/// <br/>		/// :<br/>		/// Load any SFNT font table into client memory.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// tag ::<br/>		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>		/// access the whole font file.  Otherwise, you can use one of the<br/>		/// definitions found in the <br/>		/// _TRUETYPE_TAGS_H file, or forge a new<br/>		/// one with <br/>		/// _MAKE_TAG.<br/>		/// offset ::<br/>		/// The starting offset in the table (or file if tag~==~0).<br/>		/// <br/>		/// :<br/>		/// buffer ::<br/>		/// The target buffer address.  The client must ensure that the memory<br/>		/// array is big enough to hold the data.<br/>		/// <br/>		/// :<br/>		/// length ::<br/>		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>		/// Return an error code if it fails.<br/>		/// Else, if `*length` is~0, exit immediately while returning the<br/>		/// table's (or file) full size in it.<br/>		/// Else the number of bytes to read from the table or file, from the<br/>		/// starting offset.<br/>		/// <br/>		/// <br/>		/// ```<br/>		/// FT_ULong  length = 0;<br/>		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>		/// &length<br/>		/// );<br/>		/// if ( error ) { ... table does not exist ... }<br/>		/// buffer = malloc( length );<br/>		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>		/// &length<br/>		/// );<br/>		/// if ( error ) { ... could not load table ... }<br/>		/// ```<br/>		/// Note that structures like <br/>		/// _Header or <br/>		/// _OS2 can't be used with<br/>		/// this function; they are limited to <br/>		/// _Get_Sfnt_Table.  Reason is that<br/>		/// those structures depend on the processor architecture, with varying<br/>		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LoadSfntTable(this FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte*")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length)
		{
			int ret = FreeType.FTLoadSfntTableNative(face, tag, offset, buffer, length);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Load_Sfnt_Table<br/>		/// <br/>		/// :<br/>		/// Load any SFNT font table into client memory.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// tag ::<br/>		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>		/// access the whole font file.  Otherwise, you can use one of the<br/>		/// definitions found in the <br/>		/// _TRUETYPE_TAGS_H file, or forge a new<br/>		/// one with <br/>		/// _MAKE_TAG.<br/>		/// offset ::<br/>		/// The starting offset in the table (or file if tag~==~0).<br/>		/// <br/>		/// :<br/>		/// buffer ::<br/>		/// The target buffer address.  The client must ensure that the memory<br/>		/// array is big enough to hold the data.<br/>		/// <br/>		/// :<br/>		/// length ::<br/>		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>		/// Return an error code if it fails.<br/>		/// Else, if `*length` is~0, exit immediately while returning the<br/>		/// table's (or file) full size in it.<br/>		/// Else the number of bytes to read from the table or file, from the<br/>		/// starting offset.<br/>		/// <br/>		/// <br/>		/// ```<br/>		/// FT_ULong  length = 0;<br/>		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>		/// &length<br/>		/// );<br/>		/// if ( error ) { ... table does not exist ... }<br/>		/// buffer = malloc( length );<br/>		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>		/// &length<br/>		/// );<br/>		/// if ( error ) { ... could not load table ... }<br/>		/// ```<br/>		/// Note that structures like <br/>		/// _Header or <br/>		/// _OS2 can't be used with<br/>		/// this function; they are limited to <br/>		/// _Get_Sfnt_Table.  Reason is that<br/>		/// those structures depend on the processor architecture, with varying<br/>		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LoadSfntTable(this FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte*")] ref byte buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length)
		{
			fixed (byte* pbuffer = &buffer)
			{
				int ret = FreeType.FTLoadSfntTableNative(face, tag, offset, (byte*)pbuffer, length);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Load_Sfnt_Table<br/>		/// <br/>		/// :<br/>		/// Load any SFNT font table into client memory.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// tag ::<br/>		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>		/// access the whole font file.  Otherwise, you can use one of the<br/>		/// definitions found in the <br/>		/// _TRUETYPE_TAGS_H file, or forge a new<br/>		/// one with <br/>		/// _MAKE_TAG.<br/>		/// offset ::<br/>		/// The starting offset in the table (or file if tag~==~0).<br/>		/// <br/>		/// :<br/>		/// buffer ::<br/>		/// The target buffer address.  The client must ensure that the memory<br/>		/// array is big enough to hold the data.<br/>		/// <br/>		/// :<br/>		/// length ::<br/>		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>		/// Return an error code if it fails.<br/>		/// Else, if `*length` is~0, exit immediately while returning the<br/>		/// table's (or file) full size in it.<br/>		/// Else the number of bytes to read from the table or file, from the<br/>		/// starting offset.<br/>		/// <br/>		/// <br/>		/// ```<br/>		/// FT_ULong  length = 0;<br/>		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>		/// &length<br/>		/// );<br/>		/// if ( error ) { ... table does not exist ... }<br/>		/// buffer = malloc( length );<br/>		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>		/// &length<br/>		/// );<br/>		/// if ( error ) { ... could not load table ... }<br/>		/// ```<br/>		/// Note that structures like <br/>		/// _Header or <br/>		/// _OS2 can't be used with<br/>		/// this function; they are limited to <br/>		/// _Get_Sfnt_Table.  Reason is that<br/>		/// those structures depend on the processor architecture, with varying<br/>		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LoadSfntTable(this FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte*")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint length)
		{
			fixed (uint* plength = &length)
			{
				int ret = FreeType.FTLoadSfntTableNative(face, tag, offset, buffer, (uint*)plength);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Load_Sfnt_Table<br/>		/// <br/>		/// :<br/>		/// Load any SFNT font table into client memory.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// tag ::<br/>		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>		/// access the whole font file.  Otherwise, you can use one of the<br/>		/// definitions found in the <br/>		/// _TRUETYPE_TAGS_H file, or forge a new<br/>		/// one with <br/>		/// _MAKE_TAG.<br/>		/// offset ::<br/>		/// The starting offset in the table (or file if tag~==~0).<br/>		/// <br/>		/// :<br/>		/// buffer ::<br/>		/// The target buffer address.  The client must ensure that the memory<br/>		/// array is big enough to hold the data.<br/>		/// <br/>		/// :<br/>		/// length ::<br/>		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>		/// Return an error code if it fails.<br/>		/// Else, if `*length` is~0, exit immediately while returning the<br/>		/// table's (or file) full size in it.<br/>		/// Else the number of bytes to read from the table or file, from the<br/>		/// starting offset.<br/>		/// <br/>		/// <br/>		/// ```<br/>		/// FT_ULong  length = 0;<br/>		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>		/// &length<br/>		/// );<br/>		/// if ( error ) { ... table does not exist ... }<br/>		/// buffer = malloc( length );<br/>		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>		/// &length<br/>		/// );<br/>		/// if ( error ) { ... could not load table ... }<br/>		/// ```<br/>		/// Note that structures like <br/>		/// _Header or <br/>		/// _OS2 can't be used with<br/>		/// this function; they are limited to <br/>		/// _Get_Sfnt_Table.  Reason is that<br/>		/// those structures depend on the processor architecture, with varying<br/>		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LoadSfntTable(this FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte*")] ref byte buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint length)
		{
			fixed (byte* pbuffer = &buffer)
			{
				fixed (uint* plength = &length)
				{
					int ret = FreeType.FTLoadSfntTableNative(face, tag, offset, (byte*)pbuffer, (uint*)plength);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Sfnt_Table_Info<br/>		/// <br/>		/// :<br/>		/// Return information on an SFNT table.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// table_index ::<br/>		/// The index of an SFNT table.  The function returns<br/>		/// FT_Err_Table_Missing for an invalid value.<br/>		/// <br/>		/// :<br/>		/// tag ::<br/>		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>		/// tables in the font.<br/>		/// <br/>		/// :<br/>		/// length ::<br/>		/// The length of the SFNT table (or the number of SFNT tables,<br/>		/// depending on `tag`).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SfntTableInfo(this FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length)
		{
			int ret = FreeType.FTSfntTableInfoNative(face, tableIndex, tag, length);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Sfnt_Table_Info<br/>		/// <br/>		/// :<br/>		/// Return information on an SFNT table.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// table_index ::<br/>		/// The index of an SFNT table.  The function returns<br/>		/// FT_Err_Table_Missing for an invalid value.<br/>		/// <br/>		/// :<br/>		/// tag ::<br/>		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>		/// tables in the font.<br/>		/// <br/>		/// :<br/>		/// length ::<br/>		/// The length of the SFNT table (or the number of SFNT tables,<br/>		/// depending on `tag`).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SfntTableInfo(this FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* length)
		{
			fixed (uint* ptag = &tag)
			{
				int ret = FreeType.FTSfntTableInfoNative(face, tableIndex, (uint*)ptag, length);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Sfnt_Table_Info<br/>		/// <br/>		/// :<br/>		/// Return information on an SFNT table.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// table_index ::<br/>		/// The index of an SFNT table.  The function returns<br/>		/// FT_Err_Table_Missing for an invalid value.<br/>		/// <br/>		/// :<br/>		/// tag ::<br/>		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>		/// tables in the font.<br/>		/// <br/>		/// :<br/>		/// length ::<br/>		/// The length of the SFNT table (or the number of SFNT tables,<br/>		/// depending on `tag`).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SfntTableInfo(this FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong*")] uint* tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint length)
		{
			fixed (uint* plength = &length)
			{
				int ret = FreeType.FTSfntTableInfoNative(face, tableIndex, tag, (uint*)plength);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Sfnt_Table_Info<br/>		/// <br/>		/// :<br/>		/// Return information on an SFNT table.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// table_index ::<br/>		/// The index of an SFNT table.  The function returns<br/>		/// FT_Err_Table_Missing for an invalid value.<br/>		/// <br/>		/// :<br/>		/// tag ::<br/>		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>		/// tables in the font.<br/>		/// <br/>		/// :<br/>		/// length ::<br/>		/// The length of the SFNT table (or the number of SFNT tables,<br/>		/// depending on `tag`).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SfntTableInfo(this FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong*")] ref uint length)
		{
			fixed (uint* ptag = &tag)
			{
				fixed (uint* plength = &length)
				{
					int ret = FreeType.FTSfntTableInfoNative(face, tableIndex, (uint*)ptag, (uint*)plength);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Sfnt_Name_Count<br/>		/// <br/>		/// :<br/>		/// Retrieve the number of name strings in the SFNT 'name' table.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name_Count")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetSfntNameCount(this FTFace face)
		{
			uint ret = FreeType.FTGetSfntNameCountNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Sfnt_Name<br/>		/// <br/>		/// :<br/>		/// Retrieve a string of the SFNT 'name' table for a given index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// idx ::<br/>		/// The index of the 'name' string.<br/>		/// <br/>		/// :<br/>		/// aname ::<br/>		/// The indexed <br/>		/// _SfntName structure.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Get_Sfnt_Name_Count to get the total number of available<br/>		/// 'name' table entries, then do a loop until you get the right platform,<br/>		/// encoding, and name ID.<br/>		/// 'name' table format~1 entries can use language tags also, see<br/>		/// <br/>		/// _Get_Sfnt_LangTag.<br/>		/// This function always returns an error if the config macro<br/>		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSfntName(this FTFace face, [NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "FT_UInt")] uint idx, [NativeName(NativeNameType.Param, "aname")] [NativeName(NativeNameType.Type, "FT_SfntName*")] FTSfntName* aname)
		{
			int ret = FreeType.FTGetSfntNameNative(face, idx, aname);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Sfnt_Name<br/>		/// <br/>		/// :<br/>		/// Retrieve a string of the SFNT 'name' table for a given index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// idx ::<br/>		/// The index of the 'name' string.<br/>		/// <br/>		/// :<br/>		/// aname ::<br/>		/// The indexed <br/>		/// _SfntName structure.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Get_Sfnt_Name_Count to get the total number of available<br/>		/// 'name' table entries, then do a loop until you get the right platform,<br/>		/// encoding, and name ID.<br/>		/// 'name' table format~1 entries can use language tags also, see<br/>		/// <br/>		/// _Get_Sfnt_LangTag.<br/>		/// This function always returns an error if the config macro<br/>		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSfntName(this FTFace face, [NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "FT_UInt")] uint idx, [NativeName(NativeNameType.Param, "aname")] [NativeName(NativeNameType.Type, "FT_SfntName*")] ref FTSfntName aname)
		{
			fixed (FTSfntName* paname = &aname)
			{
				int ret = FreeType.FTGetSfntNameNative(face, idx, (FTSfntName*)paname);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Sfnt_LangTag<br/>		/// <br/>		/// :<br/>		/// Retrieve the language tag associated with a language ID of an SFNT<br/>		/// 'name' table entry.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// langID ::<br/>		/// The language ID, as returned by <br/>		/// _Get_Sfnt_Name.  This is always a<br/>		/// value larger than 0x8000.<br/>		/// <br/>		/// :<br/>		/// alangTag ::<br/>		/// The language tag associated with the 'name' table entry's language<br/>		/// ID.<br/>		/// <br/>		/// <br/>		/// Only 'name' table format~1 supports language tags.  For format~0<br/>		/// tables, this function always returns FT_Err_Invalid_Table.  For<br/>		/// invalid format~1 language ID values, FT_Err_Invalid_Argument is<br/>		/// returned.<br/>		/// This function always returns an error if the config macro<br/>		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_LangTag")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSfntLangTag(this FTFace face, [NativeName(NativeNameType.Param, "langID")] [NativeName(NativeNameType.Type, "FT_UInt")] uint langID, [NativeName(NativeNameType.Param, "alangTag")] [NativeName(NativeNameType.Type, "FT_SfntLangTag*")] FTSfntLangTag* alangTag)
		{
			int ret = FreeType.FTGetSfntLangTagNative(face, langID, alangTag);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Sfnt_LangTag<br/>		/// <br/>		/// :<br/>		/// Retrieve the language tag associated with a language ID of an SFNT<br/>		/// 'name' table entry.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face.<br/>		/// langID ::<br/>		/// The language ID, as returned by <br/>		/// _Get_Sfnt_Name.  This is always a<br/>		/// value larger than 0x8000.<br/>		/// <br/>		/// :<br/>		/// alangTag ::<br/>		/// The language tag associated with the 'name' table entry's language<br/>		/// ID.<br/>		/// <br/>		/// <br/>		/// Only 'name' table format~1 supports language tags.  For format~0<br/>		/// tables, this function always returns FT_Err_Invalid_Table.  For<br/>		/// invalid format~1 language ID values, FT_Err_Invalid_Argument is<br/>		/// returned.<br/>		/// This function always returns an error if the config macro<br/>		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_LangTag")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSfntLangTag(this FTFace face, [NativeName(NativeNameType.Param, "langID")] [NativeName(NativeNameType.Type, "FT_UInt")] uint langID, [NativeName(NativeNameType.Param, "alangTag")] [NativeName(NativeNameType.Type, "FT_SfntLangTag*")] ref FTSfntLangTag alangTag)
		{
			fixed (FTSfntLangTag* palangTag = &alangTag)
			{
				int ret = FreeType.FTGetSfntLangTagNative(face, langID, (FTSfntLangTag*)palangTag);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Render_Glyph<br/>		/// <br/>		/// :<br/>		/// Convert a given glyph image to a bitmap.  It does so by inspecting the<br/>		/// glyph image format, finding the relevant renderer, and invoking it.<br/>		/// <br/>		/// :<br/>		/// slot ::<br/>		/// A handle to the glyph slot containing the image to convert.<br/>		/// <br/>		/// :<br/>		/// render_mode ::<br/>		/// The render mode used to render the glyph image into a bitmap.  See<br/>		/// <br/>		/// _Render_Mode for a list of possible values.<br/>		/// If <br/>		/// _RENDER_MODE_NORMAL is used, a previous call of <br/>		/// _Load_Glyph<br/>		/// with flag <br/>		/// _LOAD_COLOR makes `FT_Render_Glyph` provide a default<br/>		/// blending of colored glyph layers associated with the current glyph<br/>		/// slot (provided the font contains such layers) instead of rendering<br/>		/// the glyph slot's outline.  This is an experimental feature; see<br/>		/// <br/>		/// _LOAD_COLOR for more information.<br/>		/// <br/>		/// <br/>		/// On high-DPI screens like on smartphones and tablets, the pixels are so<br/>		/// small that their chance of being completely covered and therefore<br/>		/// completely black are fairly good.  On the low-DPI screens, however,<br/>		/// the situation is different.  The pixels are too large for most of the<br/>		/// details of a glyph and shades of gray are the norm rather than the<br/>		/// exception.<br/>		/// This is relevant because all our screens have a second problem: they<br/>		/// are not linear.  1~+~1 is not~2.  Twice the value does not result in<br/>		/// twice the brightness.  When a pixel is only 50% covered, the coverage<br/>		/// map says 50% black, and this translates to a pixel value of 128 when<br/>		/// you use 8~bits per channel (0-255).  However, this does not translate<br/>		/// to 50% brightness for that pixel on our sRGB and gamma~2.2 screens.<br/>		/// Due to their non-linearity, they dwell longer in the darks and only a<br/>		/// pixel value of about 186 results in 50% brightness -- 128 ends up too<br/>		/// dark on both bright and dark backgrounds.  The net result is that dark<br/>		/// text looks burnt-out, pixely and blotchy on bright background, bright<br/>		/// text too frail on dark backgrounds, and colored text on colored<br/>		/// background (for example, red on green) seems to have dark halos or<br/>		/// 'dirt' around it.  The situation is especially ugly for diagonal stems<br/>		/// like in 'w' glyph shapes where the quality of FreeType's anti-aliasing<br/>		/// depends on the correct display of grays.  On high-DPI screens where<br/>		/// smaller, fully black pixels reign supreme, this doesn't matter, but on<br/>		/// our low-DPI screens with all the gray shades, it does.  0% and 100%<br/>		/// brightness are the same things in linear and non-linear space, just<br/>		/// all the shades in-between aren't.<br/>		/// The blending function for placing text over a background is<br/>		/// ```<br/>		/// dst = alpha * src + (1 - alpha) * dst    ,<br/>		/// ```<br/>		/// which is known as the OVER operator.<br/>		/// To correctly composite an anti-aliased pixel of a glyph onto a<br/>		/// surface,<br/>		/// 1. take the foreground and background colors (e.g., in sRGB space)<br/>		/// and apply gamma to get them in a linear space,<br/>		/// 2. use OVER to blend the two linear colors using the glyph pixel<br/>		/// as the alpha value (remember, the glyph bitmap is an alpha coverage<br/>		/// bitmap), and<br/>		/// 3. apply inverse gamma to the blended pixel and write it back to<br/>		/// the image.<br/>		/// Internal testing at Adobe found that a target inverse gamma of~1.8 for<br/>		/// step~3 gives good results across a wide range of displays with an sRGB<br/>		/// gamma curve or a similar one.<br/>		/// This process can cost performance.  There is an approximation that<br/>		/// does not need to know about the background color; see<br/>		/// https://bel.fi/alankila/lcd/ and<br/>		/// https://bel.fi/alankila/lcd/alpcor.html for details.<br/>		/// **ATTENTION**: Linear blending is even more important when dealing<br/>		/// with subpixel-rendered glyphs to prevent color-fringing!  A<br/>		/// subpixel-rendered glyph must first be filtered with a filter that<br/>		/// gives equal weight to the three color primaries and does not exceed a<br/>		/// sum of 0x100, see section <br/>		/// _rendering.  Then the only difference to<br/>		/// gray linear blending is that subpixel-rendered linear blending is done<br/>		/// 3~times per pixel: red foreground subpixel to red background subpixel<br/>		/// and so on for green and blue.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Render_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int RenderGlyph(this FTGlyphSlot slot, [NativeName(NativeNameType.Param, "render_mode")] [NativeName(NativeNameType.Type, "FT_Render_Mode")] FTRenderMode renderMode)
		{
			int ret = FreeType.FTRenderGlyphNative(slot, renderMode);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, parg2, pTransform);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, parg2, pTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, parg2, pTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, parg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, parg2, pTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, parg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, parg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, parg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* pparg2 = &parg2)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, (int*)pparg2, pTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg2 = &parg2)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, (int*)pparg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg2 = &parg2)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, (int*)pparg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg2 = &parg2)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, (int*)pparg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (int* pparg2 = &parg2)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, (int*)pparg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, (int*)pparg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (int* pparg2 = &parg2)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, pTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (FTMatrix* ppTransform = &pTransform)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, parg2, (FTMatrix*)ppTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, parg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, parg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* pparg2 = &parg2)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (int* pparg2 = &parg2)
						{
							fixed (FTMatrix* ppTransform = &pTransform)
							{
								int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Glyph<br/>		/// <br/>		/// :<br/>		/// A function used to extract a glyph image from a slot.  Note that the<br/>		/// created <br/>		/// _Glyph object must be released with <br/>		/// _Done_Glyph.<br/>		/// <br/>		/// :<br/>		/// slot ::<br/>		/// A handle to the source glyph slot.<br/>		/// <br/>		/// :<br/>		/// aglyph ::<br/>		/// A handle to the glyph object.  `NULL` in case of error.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetGlyph(this FTGlyphSlot slot, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph*")] FTGlyph* aglyph)
		{
			int ret = FreeType.FTGetGlyphNative(slot, aglyph);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Glyph<br/>		/// <br/>		/// :<br/>		/// A function used to extract a glyph image from a slot.  Note that the<br/>		/// created <br/>		/// _Glyph object must be released with <br/>		/// _Done_Glyph.<br/>		/// <br/>		/// :<br/>		/// slot ::<br/>		/// A handle to the source glyph slot.<br/>		/// <br/>		/// :<br/>		/// aglyph ::<br/>		/// A handle to the glyph object.  `NULL` in case of error.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetGlyph(this FTGlyphSlot slot, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph*")] ref FTGlyph aglyph)
		{
			fixed (FTGlyph* paglyph = &aglyph)
			{
				int ret = FreeType.FTGetGlyphNative(slot, (FTGlyph*)paglyph);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_GlyphSlot_Own_Bitmap<br/>		/// <br/>		/// :<br/>		/// Make sure that a glyph slot owns `slot->bitmap`.<br/>		/// <br/>		/// :<br/>		/// slot ::<br/>		/// The glyph slot.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Own_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OwnBitmap(this FTGlyphSlot slot)
		{
			int ret = FreeType.FTGlyphSlotOwnBitmapNative(slot);
			return ret;
		}

		/// <summary>		/// Embolden a glyph by a 'reasonable' value (which is highly a matter of <br/>		/// taste).  This function is actually a convenience function, providing  <br/>		/// a wrapper for <br/>		/// _Outline_Embolden and <br/>		/// _Bitmap_Embolden.           <br/>		/// <br/>		/// For emboldened outlines the height, width, and advance metrics are    <br/>		/// increased by the strength of the emboldening -- this even affects     <br/>		/// mono-width fonts!                                                     <br/>		/// <br/>		/// You can also call <br/>		/// _Outline_Get_CBox to get precise values.         <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Embolden")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Embolden(this FTGlyphSlot slot)
		{
			FreeType.FTGlyphSlotEmboldenNative(slot);
		}

		/// <summary>		/// Precisely adjust the glyph weight either horizontally or vertically.  <br/>		/// The `xdelta` and `ydelta` values are fractions of the face Em size    <br/>		/// (in fixed-point format).  Considering that a regular face would have  <br/>		/// stem widths on the order of 0.1 Em, a delta of 0.05 (0x0CCC) should   <br/>		/// be very noticeable.  To increase or decrease the weight, use positive <br/>		/// or negative values, respectively.                                     <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_GlyphSlot_AdjustWeight")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void AdjustWeight(this FTGlyphSlot slot, [NativeName(NativeNameType.Param, "xdelta")] [NativeName(NativeNameType.Type, "FT_Fixed")] int xdelta, [NativeName(NativeNameType.Param, "ydelta")] [NativeName(NativeNameType.Type, "FT_Fixed")] int ydelta)
		{
			FreeType.FTGlyphSlotAdjustWeightNative(slot, xdelta, ydelta);
		}

		/// <summary>		/// Slant an outline glyph to the right by about 12 degrees.              <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Oblique")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Oblique(this FTGlyphSlot slot)
		{
			FreeType.FTGlyphSlotObliqueNative(slot);
		}

		/// <summary>		/// Slant an outline glyph by a given sine of an angle.  You can apply    <br/>		/// slant along either x- or y-axis by choosing a corresponding non-zero  <br/>		/// argument.  If both slants are non-zero, some affine transformation    <br/>		/// will result.                                                          <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Slant")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Slant(this FTGlyphSlot slot, [NativeName(NativeNameType.Param, "xslant")] [NativeName(NativeNameType.Type, "FT_Fixed")] int xslant, [NativeName(NativeNameType.Param, "yslant")] [NativeName(NativeNameType.Type, "FT_Fixed")] int yslant)
		{
			FreeType.FTGlyphSlotSlantNative(slot, xslant, yslant);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Charmap_Index<br/>		/// <br/>		/// :<br/>		/// Retrieve index of a given charmap.<br/>		/// <br/>		/// :<br/>		/// charmap ::<br/>		/// A handle to a charmap.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Charmap_Index")]
		[return: NativeName(NativeNameType.Type, "FT_Int")]
		public static int GetCharmapIndex(this FTCharMap charmap)
		{
			int ret = FreeType.FTGetCharmapIndexNative(charmap);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_CMap_Language_ID<br/>		/// <br/>		/// :<br/>		/// Return cmap language ID as specified in the OpenType standard.<br/>		/// Definitions of language ID values are in file <br/>		/// _TRUETYPE_IDS_H.<br/>		/// <br/>		/// :<br/>		/// charmap ::<br/>		/// The target charmap.<br/>		/// <br/>		/// For a format~14 cmap (to access Unicode IVS), the return value is<br/>		/// 0xFFFFFFFF.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_CMap_Language_ID")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetCMapLanguageId(this FTCharMap charmap)
		{
			uint ret = FreeType.FTGetCMapLanguageIDNative(charmap);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_CMap_Format<br/>		/// <br/>		/// :<br/>		/// Return the format of an SFNT 'cmap' table.<br/>		/// <br/>		/// :<br/>		/// charmap ::<br/>		/// The target charmap.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_CMap_Format")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		public static int GetCMapFormat(this FTCharMap charmap)
		{
			int ret = FreeType.FTGetCMapFormatNative(charmap);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Glyph_Copy<br/>		/// <br/>		/// :<br/>		/// A function used to copy a glyph image.  Note that the created<br/>		/// <br/>		/// _Glyph object must be released with <br/>		/// _Done_Glyph.<br/>		/// <br/>		/// :<br/>		/// source ::<br/>		/// A handle to the source glyph object.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to the target glyph object.  `NULL` in case of error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Glyph_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Copy(this FTGlyph source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Glyph*")] FTGlyph* target)
		{
			int ret = FreeType.FTGlyphCopyNative(source, target);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Glyph_Copy<br/>		/// <br/>		/// :<br/>		/// A function used to copy a glyph image.  Note that the created<br/>		/// <br/>		/// _Glyph object must be released with <br/>		/// _Done_Glyph.<br/>		/// <br/>		/// :<br/>		/// source ::<br/>		/// A handle to the source glyph object.<br/>		/// <br/>		/// :<br/>		/// target ::<br/>		/// A handle to the target glyph object.  `NULL` in case of error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Glyph_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Copy(this FTGlyph source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Glyph*")] ref FTGlyph target)
		{
			fixed (FTGlyph* ptarget = &target)
			{
				int ret = FreeType.FTGlyphCopyNative(source, (FTGlyph*)ptarget);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Glyph_Transform<br/>		/// <br/>		/// :<br/>		/// Transform a glyph image if its format is scalable.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// A handle to the target glyph object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a 2x2 matrix to apply.<br/>		/// delta ::<br/>		/// A pointer to a 2d vector to apply.  Coordinates are expressed in<br/>		/// 1/64 of a pixel.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Glyph_Transform")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Transform(this FTGlyph glyph, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "const FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "const FT_Vector*")] FTVector* delta)
		{
			int ret = FreeType.FTGlyphTransformNative(glyph, matrix, delta);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Glyph_Transform<br/>		/// <br/>		/// :<br/>		/// Transform a glyph image if its format is scalable.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// A handle to the target glyph object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a 2x2 matrix to apply.<br/>		/// delta ::<br/>		/// A pointer to a 2d vector to apply.  Coordinates are expressed in<br/>		/// 1/64 of a pixel.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Glyph_Transform")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Transform(this FTGlyph glyph, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "const FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "const FT_Vector*")] FTVector* delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				int ret = FreeType.FTGlyphTransformNative(glyph, (FTMatrix*)pmatrix, delta);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Glyph_Transform<br/>		/// <br/>		/// :<br/>		/// Transform a glyph image if its format is scalable.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// A handle to the target glyph object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a 2x2 matrix to apply.<br/>		/// delta ::<br/>		/// A pointer to a 2d vector to apply.  Coordinates are expressed in<br/>		/// 1/64 of a pixel.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Glyph_Transform")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Transform(this FTGlyph glyph, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "const FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "const FT_Vector*")] ref FTVector delta)
		{
			fixed (FTVector* pdelta = &delta)
			{
				int ret = FreeType.FTGlyphTransformNative(glyph, matrix, (FTVector*)pdelta);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Glyph_Transform<br/>		/// <br/>		/// :<br/>		/// Transform a glyph image if its format is scalable.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// A handle to the target glyph object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a 2x2 matrix to apply.<br/>		/// delta ::<br/>		/// A pointer to a 2d vector to apply.  Coordinates are expressed in<br/>		/// 1/64 of a pixel.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Glyph_Transform")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Transform(this FTGlyph glyph, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "const FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "const FT_Vector*")] ref FTVector delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				fixed (FTVector* pdelta = &delta)
				{
					int ret = FreeType.FTGlyphTransformNative(glyph, (FTMatrix*)pmatrix, (FTVector*)pdelta);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Glyph_Get_CBox<br/>		/// <br/>		/// :<br/>		/// Return a glyph's 'control box'.  The control box encloses all the<br/>		/// outline's points, including Bezier control points.  Though it<br/>		/// coincides with the exact bounding box for most glyphs, it can be<br/>		/// slightly larger in some situations (like when rotating an outline that<br/>		/// contains Bezier outside arcs).<br/>		/// Computing the control box is very fast, while getting the bounding box<br/>		/// can take much more time as it needs to walk over all segments and arcs<br/>		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>		/// component, which is dedicated to this single task.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// A handle to the source glyph object.<br/>		/// mode ::<br/>		/// The mode that indicates how to interpret the returned bounding box<br/>		/// values.<br/>		/// <br/>		/// :<br/>		/// acbox ::<br/>		/// The glyph coordinate bounding box.  Coordinates are expressed in<br/>		/// 1/64 of pixels if it is grid-fitted.<br/>		/// <br/>		/// If the glyph has been loaded with <br/>		/// _LOAD_NO_SCALE, `bbox_mode` must<br/>		/// be set to <br/>		/// _GLYPH_BBOX_UNSCALED to get unscaled font units in 26.6<br/>		/// pixel format.  The value <br/>		/// _GLYPH_BBOX_SUBPIXELS is another name for<br/>		/// this constant.<br/>		/// If the font is tricky and the glyph has been loaded with<br/>		/// <br/>		/// _LOAD_NO_SCALE, the resulting CBox is meaningless.  To get<br/>		/// reasonable values for the CBox it is necessary to load the glyph at a<br/>		/// large ppem value (so that the hinting instructions can properly shift<br/>		/// and scale the subglyphs), then extracting the CBox, which can be<br/>		/// eventually converted back to font units.<br/>		/// Note that the maximum coordinates are exclusive, which means that one<br/>		/// can compute the width and height of the glyph image (be it in integer<br/>		/// or 26.6 pixels) as:<br/>		/// ```<br/>		/// width  = bbox.xMax - bbox.xMin;<br/>		/// height = bbox.yMax - bbox.yMin;<br/>		/// ```<br/>		/// Note also that for 26.6 coordinates, if `bbox_mode` is set to<br/>		/// <br/>		/// _GLYPH_BBOX_GRIDFIT, the coordinates will also be grid-fitted,<br/>		/// which corresponds to:<br/>		/// ```<br/>		/// bbox.xMin = FLOOR(bbox.xMin);<br/>		/// bbox.yMin = FLOOR(bbox.yMin);<br/>		/// bbox.xMax = CEILING(bbox.xMax);<br/>		/// bbox.yMax = CEILING(bbox.yMax);<br/>		/// ```<br/>		/// To get the bbox in pixel coordinates, set `bbox_mode` to<br/>		/// <br/>		/// _GLYPH_BBOX_TRUNCATE.<br/>		/// To get the bbox in grid-fitted pixel coordinates, set `bbox_mode` to<br/>		/// <br/>		/// _GLYPH_BBOX_PIXELS.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Glyph_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetCBox(this FTGlyph glyph, [NativeName(NativeNameType.Param, "bbox_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint bboxMode, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox*")] FTBBox* acbox)
		{
			FreeType.FTGlyphGetCBoxNative(glyph, bboxMode, acbox);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Glyph_Get_CBox<br/>		/// <br/>		/// :<br/>		/// Return a glyph's 'control box'.  The control box encloses all the<br/>		/// outline's points, including Bezier control points.  Though it<br/>		/// coincides with the exact bounding box for most glyphs, it can be<br/>		/// slightly larger in some situations (like when rotating an outline that<br/>		/// contains Bezier outside arcs).<br/>		/// Computing the control box is very fast, while getting the bounding box<br/>		/// can take much more time as it needs to walk over all segments and arcs<br/>		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>		/// component, which is dedicated to this single task.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// A handle to the source glyph object.<br/>		/// mode ::<br/>		/// The mode that indicates how to interpret the returned bounding box<br/>		/// values.<br/>		/// <br/>		/// :<br/>		/// acbox ::<br/>		/// The glyph coordinate bounding box.  Coordinates are expressed in<br/>		/// 1/64 of pixels if it is grid-fitted.<br/>		/// <br/>		/// If the glyph has been loaded with <br/>		/// _LOAD_NO_SCALE, `bbox_mode` must<br/>		/// be set to <br/>		/// _GLYPH_BBOX_UNSCALED to get unscaled font units in 26.6<br/>		/// pixel format.  The value <br/>		/// _GLYPH_BBOX_SUBPIXELS is another name for<br/>		/// this constant.<br/>		/// If the font is tricky and the glyph has been loaded with<br/>		/// <br/>		/// _LOAD_NO_SCALE, the resulting CBox is meaningless.  To get<br/>		/// reasonable values for the CBox it is necessary to load the glyph at a<br/>		/// large ppem value (so that the hinting instructions can properly shift<br/>		/// and scale the subglyphs), then extracting the CBox, which can be<br/>		/// eventually converted back to font units.<br/>		/// Note that the maximum coordinates are exclusive, which means that one<br/>		/// can compute the width and height of the glyph image (be it in integer<br/>		/// or 26.6 pixels) as:<br/>		/// ```<br/>		/// width  = bbox.xMax - bbox.xMin;<br/>		/// height = bbox.yMax - bbox.yMin;<br/>		/// ```<br/>		/// Note also that for 26.6 coordinates, if `bbox_mode` is set to<br/>		/// <br/>		/// _GLYPH_BBOX_GRIDFIT, the coordinates will also be grid-fitted,<br/>		/// which corresponds to:<br/>		/// ```<br/>		/// bbox.xMin = FLOOR(bbox.xMin);<br/>		/// bbox.yMin = FLOOR(bbox.yMin);<br/>		/// bbox.xMax = CEILING(bbox.xMax);<br/>		/// bbox.yMax = CEILING(bbox.yMax);<br/>		/// ```<br/>		/// To get the bbox in pixel coordinates, set `bbox_mode` to<br/>		/// <br/>		/// _GLYPH_BBOX_TRUNCATE.<br/>		/// To get the bbox in grid-fitted pixel coordinates, set `bbox_mode` to<br/>		/// <br/>		/// _GLYPH_BBOX_PIXELS.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Glyph_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetCBox(this FTGlyph glyph, [NativeName(NativeNameType.Param, "bbox_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint bboxMode, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox*")] ref FTBBox acbox)
		{
			fixed (FTBBox* pacbox = &acbox)
			{
				FreeType.FTGlyphGetCBoxNative(glyph, bboxMode, (FTBBox*)pacbox);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Done_Glyph<br/>		/// <br/>		/// :<br/>		/// Destroy a given glyph.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// A handle to the target glyph object.  Can be `NULL`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Done_Glyph")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DoneGlyph(this FTGlyph glyph)
		{
			FreeType.FTDoneGlyphNative(glyph);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_Set<br/>		/// <br/>		/// :<br/>		/// Reset a stroker object's attributes.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// radius ::<br/>		/// The border radius.<br/>		/// line_cap ::<br/>		/// The line cap style.<br/>		/// line_join ::<br/>		/// The line join style.<br/>		/// miter_limit ::<br/>		/// The maximum reciprocal sine of half-angle at the miter join,<br/>		/// expressed as 16.16 fixed-point value.<br/>		/// <br/>		/// The `miter_limit` multiplied by the `radius` gives the maximum size<br/>		/// of a miter spike, at which it is clipped for<br/>		/// <br/>		/// _STROKER_LINEJOIN_MITER_VARIABLE or replaced with a bevel join for<br/>		/// <br/>		/// _STROKER_LINEJOIN_MITER_FIXED.<br/>		/// This function calls <br/>		/// _Stroker_Rewind automatically.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Set")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Set(this FTStroker stroker, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "FT_Fixed")] int radius, [NativeName(NativeNameType.Param, "line_cap")] [NativeName(NativeNameType.Type, "FT_Stroker_LineCap")] FTStrokerLineCap lineCap, [NativeName(NativeNameType.Param, "line_join")] [NativeName(NativeNameType.Type, "FT_Stroker_LineJoin")] FTStrokerLineJoin lineJoin, [NativeName(NativeNameType.Param, "miter_limit")] [NativeName(NativeNameType.Type, "FT_Fixed")] int miterLimit)
		{
			FreeType.FTStrokerSetNative(stroker, radius, lineCap, lineJoin, miterLimit);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_Rewind<br/>		/// <br/>		/// :<br/>		/// Reset a stroker object without changing its attributes.  You should<br/>		/// call this function before beginning a new series of calls to<br/>		/// <br/>		/// _Stroker_BeginSubPath or <br/>		/// _Stroker_EndSubPath.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Rewind")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Rewind(this FTStroker stroker)
		{
			FreeType.FTStrokerRewindNative(stroker);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_ParseOutline<br/>		/// <br/>		/// :<br/>		/// A convenience function used to parse a whole outline with the stroker.<br/>		/// The resulting outline(s) can be retrieved later by functions like<br/>		/// <br/>		/// _Stroker_GetCounts and <br/>		/// _Stroker_Export.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// outline ::<br/>		/// The source outline.<br/>		/// opened ::<br/>		/// A boolean.  If~1, the outline is treated as an open path instead of<br/>		/// a closed one.<br/>		/// <br/>		/// <br/>		/// If `opened` is~1, the outline is processed as an open path, and the<br/>		/// stroker generates a single 'stroke' outline.<br/>		/// This function calls <br/>		/// _Stroker_Rewind automatically.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ParseOutline")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int ParseOutline(this FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline, [NativeName(NativeNameType.Param, "opened")] [NativeName(NativeNameType.Type, "FT_Bool")] byte opened)
		{
			int ret = FreeType.FTStrokerParseOutlineNative(stroker, outline, opened);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_ParseOutline<br/>		/// <br/>		/// :<br/>		/// A convenience function used to parse a whole outline with the stroker.<br/>		/// The resulting outline(s) can be retrieved later by functions like<br/>		/// <br/>		/// _Stroker_GetCounts and <br/>		/// _Stroker_Export.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// outline ::<br/>		/// The source outline.<br/>		/// opened ::<br/>		/// A boolean.  If~1, the outline is treated as an open path instead of<br/>		/// a closed one.<br/>		/// <br/>		/// <br/>		/// If `opened` is~1, the outline is processed as an open path, and the<br/>		/// stroker generates a single 'stroke' outline.<br/>		/// This function calls <br/>		/// _Stroker_Rewind automatically.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ParseOutline")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int ParseOutline(this FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline, [NativeName(NativeNameType.Param, "opened")] [NativeName(NativeNameType.Type, "FT_Bool")] byte opened)
		{
			fixed (FTOutline* poutline = &outline)
			{
				int ret = FreeType.FTStrokerParseOutlineNative(stroker, (FTOutline*)poutline, opened);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_BeginSubPath<br/>		/// <br/>		/// :<br/>		/// Start a new sub-path in the stroker.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// to ::<br/>		/// A pointer to the start vector.<br/>		/// open ::<br/>		/// A boolean.  If~1, the sub-path is treated as an open one.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_BeginSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BeginSubPath(this FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to, [NativeName(NativeNameType.Param, "open")] [NativeName(NativeNameType.Type, "FT_Bool")] byte open)
		{
			int ret = FreeType.FTStrokerBeginSubPathNative(stroker, to, open);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_BeginSubPath<br/>		/// <br/>		/// :<br/>		/// Start a new sub-path in the stroker.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// to ::<br/>		/// A pointer to the start vector.<br/>		/// open ::<br/>		/// A boolean.  If~1, the sub-path is treated as an open one.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_BeginSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int BeginSubPath(this FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to, [NativeName(NativeNameType.Param, "open")] [NativeName(NativeNameType.Type, "FT_Bool")] byte open)
		{
			fixed (FTVector* pto = &to)
			{
				int ret = FreeType.FTStrokerBeginSubPathNative(stroker, (FTVector*)pto, open);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_EndSubPath<br/>		/// <br/>		/// :<br/>		/// Close the current sub-path in the stroker.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_EndSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int EndSubPath(this FTStroker stroker)
		{
			int ret = FreeType.FTStrokerEndSubPathNative(stroker);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_LineTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single line segment in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_LineTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LineTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			int ret = FreeType.FTStrokerLineToNative(stroker, to);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_LineTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single line segment in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_LineTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LineTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				int ret = FreeType.FTStrokerLineToNative(stroker, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_ConicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>		/// from the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control ::<br/>		/// A pointer to a Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int ConicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			int ret = FreeType.FTStrokerConicToNative(stroker, control, to);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_ConicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>		/// from the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control ::<br/>		/// A pointer to a Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int ConicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			fixed (FTVector* pcontrol = &control)
			{
				int ret = FreeType.FTStrokerConicToNative(stroker, (FTVector*)pcontrol, to);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_ConicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>		/// from the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control ::<br/>		/// A pointer to a Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int ConicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				int ret = FreeType.FTStrokerConicToNative(stroker, control, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_ConicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>		/// from the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control ::<br/>		/// A pointer to a Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int ConicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pcontrol = &control)
			{
				fixed (FTVector* pto = &to)
				{
					int ret = FreeType.FTStrokerConicToNative(stroker, (FTVector*)pcontrol, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_CubicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control1 ::<br/>		/// A pointer to the first Bezier control point.<br/>		/// control2 ::<br/>		/// A pointer to second Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			int ret = FreeType.FTStrokerCubicToNative(stroker, control1, control2, to);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_CubicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control1 ::<br/>		/// A pointer to the first Bezier control point.<br/>		/// control2 ::<br/>		/// A pointer to second Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				int ret = FreeType.FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, control2, to);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_CubicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control1 ::<br/>		/// A pointer to the first Bezier control point.<br/>		/// control2 ::<br/>		/// A pointer to second Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			fixed (FTVector* pcontrol2 = &control2)
			{
				int ret = FreeType.FTStrokerCubicToNative(stroker, control1, (FTVector*)pcontrol2, to);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_CubicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control1 ::<br/>		/// A pointer to the first Bezier control point.<br/>		/// control2 ::<br/>		/// A pointer to second Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pcontrol2 = &control2)
				{
					int ret = FreeType.FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, (FTVector*)pcontrol2, to);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_CubicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control1 ::<br/>		/// A pointer to the first Bezier control point.<br/>		/// control2 ::<br/>		/// A pointer to second Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				int ret = FreeType.FTStrokerCubicToNative(stroker, control1, control2, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_CubicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control1 ::<br/>		/// A pointer to the first Bezier control point.<br/>		/// control2 ::<br/>		/// A pointer to second Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pto = &to)
				{
					int ret = FreeType.FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, control2, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_CubicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control1 ::<br/>		/// A pointer to the first Bezier control point.<br/>		/// control2 ::<br/>		/// A pointer to second Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pcontrol2 = &control2)
			{
				fixed (FTVector* pto = &to)
				{
					int ret = FreeType.FTStrokerCubicToNative(stroker, control1, (FTVector*)pcontrol2, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_CubicTo<br/>		/// <br/>		/// :<br/>		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>		/// the last position.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// control1 ::<br/>		/// A pointer to the first Bezier control point.<br/>		/// control2 ::<br/>		/// A pointer to second Bezier control point.<br/>		/// to ::<br/>		/// A pointer to the destination point.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pcontrol2 = &control2)
				{
					fixed (FTVector* pto = &to)
					{
						int ret = FreeType.FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, (FTVector*)pcontrol2, (FTVector*)pto);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_GetBorderCounts<br/>		/// <br/>		/// :<br/>		/// Call this function once you have finished parsing your paths with the<br/>		/// stroker.  It returns the number of points and contours necessary to<br/>		/// export one of the 'border' or 'stroke' outlines generated by the<br/>		/// stroker.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// border ::<br/>		/// The border index.<br/>		/// <br/>		/// :<br/>		/// anum_points ::<br/>		/// The number of points.<br/>		/// anum_contours ::<br/>		/// The number of contours.<br/>		/// <br/>		/// <br/>		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>		/// while the 'right' border becomes empty.<br/>		/// Use the function <br/>		/// _Stroker_GetCounts instead if you want to retrieve<br/>		/// the counts associated to both borders.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetBorderCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours)
		{
			int ret = FreeType.FTStrokerGetBorderCountsNative(stroker, border, anumPoints, anumContours);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_GetBorderCounts<br/>		/// <br/>		/// :<br/>		/// Call this function once you have finished parsing your paths with the<br/>		/// stroker.  It returns the number of points and contours necessary to<br/>		/// export one of the 'border' or 'stroke' outlines generated by the<br/>		/// stroker.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// border ::<br/>		/// The border index.<br/>		/// <br/>		/// :<br/>		/// anum_points ::<br/>		/// The number of points.<br/>		/// anum_contours ::<br/>		/// The number of contours.<br/>		/// <br/>		/// <br/>		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>		/// while the 'right' border becomes empty.<br/>		/// Use the function <br/>		/// _Stroker_GetCounts instead if you want to retrieve<br/>		/// the counts associated to both borders.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetBorderCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				int ret = FreeType.FTStrokerGetBorderCountsNative(stroker, border, (uint*)panumPoints, anumContours);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_GetBorderCounts<br/>		/// <br/>		/// :<br/>		/// Call this function once you have finished parsing your paths with the<br/>		/// stroker.  It returns the number of points and contours necessary to<br/>		/// export one of the 'border' or 'stroke' outlines generated by the<br/>		/// stroker.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// border ::<br/>		/// The border index.<br/>		/// <br/>		/// :<br/>		/// anum_points ::<br/>		/// The number of points.<br/>		/// anum_contours ::<br/>		/// The number of contours.<br/>		/// <br/>		/// <br/>		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>		/// while the 'right' border becomes empty.<br/>		/// Use the function <br/>		/// _Stroker_GetCounts instead if you want to retrieve<br/>		/// the counts associated to both borders.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetBorderCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumContours)
		{
			fixed (uint* panumContours = &anumContours)
			{
				int ret = FreeType.FTStrokerGetBorderCountsNative(stroker, border, anumPoints, (uint*)panumContours);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_GetBorderCounts<br/>		/// <br/>		/// :<br/>		/// Call this function once you have finished parsing your paths with the<br/>		/// stroker.  It returns the number of points and contours necessary to<br/>		/// export one of the 'border' or 'stroke' outlines generated by the<br/>		/// stroker.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// border ::<br/>		/// The border index.<br/>		/// <br/>		/// :<br/>		/// anum_points ::<br/>		/// The number of points.<br/>		/// anum_contours ::<br/>		/// The number of contours.<br/>		/// <br/>		/// <br/>		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>		/// while the 'right' border becomes empty.<br/>		/// Use the function <br/>		/// _Stroker_GetCounts instead if you want to retrieve<br/>		/// the counts associated to both borders.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetBorderCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				fixed (uint* panumContours = &anumContours)
				{
					int ret = FreeType.FTStrokerGetBorderCountsNative(stroker, border, (uint*)panumPoints, (uint*)panumContours);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_ExportBorder<br/>		/// <br/>		/// :<br/>		/// Call this function after <br/>		/// _Stroker_GetBorderCounts to export the<br/>		/// corresponding border to your own <br/>		/// _Outline structure.<br/>		/// Note that this function appends the border points and contours to your<br/>		/// outline, but does not try to resize its arrays.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// border ::<br/>		/// The border index.<br/>		/// outline ::<br/>		/// The target outline handle.<br/>		/// <br/>		/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>		/// independent 'border' outlines, named 'left' and 'right'.<br/>		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>		/// while the 'right' border becomes empty.<br/>		/// Use the function <br/>		/// _Stroker_Export instead if you want to retrieve<br/>		/// all borders at once.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ExportBorder(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline)
		{
			FreeType.FTStrokerExportBorderNative(stroker, border, outline);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_ExportBorder<br/>		/// <br/>		/// :<br/>		/// Call this function after <br/>		/// _Stroker_GetBorderCounts to export the<br/>		/// corresponding border to your own <br/>		/// _Outline structure.<br/>		/// Note that this function appends the border points and contours to your<br/>		/// outline, but does not try to resize its arrays.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// border ::<br/>		/// The border index.<br/>		/// outline ::<br/>		/// The target outline handle.<br/>		/// <br/>		/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>		/// independent 'border' outlines, named 'left' and 'right'.<br/>		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>		/// while the 'right' border becomes empty.<br/>		/// Use the function <br/>		/// _Stroker_Export instead if you want to retrieve<br/>		/// all borders at once.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ExportBorder(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FreeType.FTStrokerExportBorderNative(stroker, border, (FTOutline*)poutline);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_GetCounts<br/>		/// <br/>		/// :<br/>		/// Call this function once you have finished parsing your paths with the<br/>		/// stroker.  It returns the number of points and contours necessary to<br/>		/// export all points/borders from the stroked outline/path.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// <br/>		/// :<br/>		/// anum_points ::<br/>		/// The number of points.<br/>		/// anum_contours ::<br/>		/// The number of contours.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours)
		{
			int ret = FreeType.FTStrokerGetCountsNative(stroker, anumPoints, anumContours);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_GetCounts<br/>		/// <br/>		/// :<br/>		/// Call this function once you have finished parsing your paths with the<br/>		/// stroker.  It returns the number of points and contours necessary to<br/>		/// export all points/borders from the stroked outline/path.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// <br/>		/// :<br/>		/// anum_points ::<br/>		/// The number of points.<br/>		/// anum_contours ::<br/>		/// The number of contours.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				int ret = FreeType.FTStrokerGetCountsNative(stroker, (uint*)panumPoints, anumContours);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_GetCounts<br/>		/// <br/>		/// :<br/>		/// Call this function once you have finished parsing your paths with the<br/>		/// stroker.  It returns the number of points and contours necessary to<br/>		/// export all points/borders from the stroked outline/path.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// <br/>		/// :<br/>		/// anum_points ::<br/>		/// The number of points.<br/>		/// anum_contours ::<br/>		/// The number of contours.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumContours)
		{
			fixed (uint* panumContours = &anumContours)
			{
				int ret = FreeType.FTStrokerGetCountsNative(stroker, anumPoints, (uint*)panumContours);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_GetCounts<br/>		/// <br/>		/// :<br/>		/// Call this function once you have finished parsing your paths with the<br/>		/// stroker.  It returns the number of points and contours necessary to<br/>		/// export all points/borders from the stroked outline/path.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// <br/>		/// :<br/>		/// anum_points ::<br/>		/// The number of points.<br/>		/// anum_contours ::<br/>		/// The number of contours.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				fixed (uint* panumContours = &anumContours)
				{
					int ret = FreeType.FTStrokerGetCountsNative(stroker, (uint*)panumPoints, (uint*)panumContours);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_Export<br/>		/// <br/>		/// :<br/>		/// Call this function after <br/>		/// _Stroker_GetBorderCounts to export all<br/>		/// borders to your own <br/>		/// _Outline structure.<br/>		/// Note that this function appends the border points and contours to your<br/>		/// outline, but does not try to resize its arrays.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// outline ::<br/>		/// The target outline handle.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Export(this FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] FTOutline* outline)
		{
			FreeType.FTStrokerExportNative(stroker, outline);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_Export<br/>		/// <br/>		/// :<br/>		/// Call this function after <br/>		/// _Stroker_GetBorderCounts to export all<br/>		/// borders to your own <br/>		/// _Outline structure.<br/>		/// Note that this function appends the border points and contours to your<br/>		/// outline, but does not try to resize its arrays.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// The target stroker handle.<br/>		/// outline ::<br/>		/// The target outline handle.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Export(this FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline*")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FreeType.FTStrokerExportNative(stroker, (FTOutline*)poutline);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Stroker_Done<br/>		/// <br/>		/// :<br/>		/// Destroy a stroker object.<br/>		/// <br/>		/// :<br/>		/// stroker ::<br/>		/// A stroker handle.  Can be `NULL`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Stroker_Done")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Done(this FTStroker stroker)
		{
			FreeType.FTStrokerDoneNative(stroker);
		}

	}
}
