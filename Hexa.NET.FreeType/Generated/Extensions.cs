// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	public static unsafe class Extensions
	{
		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Done_FreeType<br/>		/// <br/>		/// :<br/>		/// Destroy a given FreeType library object and all of its children,<br/>		/// including resources, drivers, faces, sizes, etc.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the target library object.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Done_FreeType")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int DoneFreeType(this FTLibrary library)
		{
			int ret = FreeType.FTDoneFreeTypeNative(library);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] byte* filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			int ret = FreeType.FTNewFaceNative(library, filepathname, faceIndex, aface);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] ref byte filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			fixed (byte* pfilepathname = &filepathname)
			{
				int ret = FreeType.FTNewFaceNative(library, (byte*)pfilepathname, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] string filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filepathname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filepathname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filepathname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FreeType.FTNewFaceNative(library, pStr0, faceIndex, aface);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] byte* filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (FTFace* paface = &aface)
			{
				int ret = FreeType.FTNewFaceNative(library, filepathname, faceIndex, (FTFace*)paface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] ref byte filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (byte* pfilepathname = &filepathname)
			{
				fixed (FTFace* paface = &aface)
				{
					int ret = FreeType.FTNewFaceNative(library, (byte*)pfilepathname, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font by its pathname.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// pathname ::<br/>		/// A path to the font file.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Use <br/>		/// _Done_Face to destroy the created <br/>		/// _Face object (along with<br/>		/// its slot and sizes).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] string filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filepathname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filepathname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filepathname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (FTFace* paface = &aface)
			{
				int ret = FreeType.FTNewFaceNative(library, pStr0, faceIndex, (FTFace*)paface);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Memory_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font that has been loaded into memory.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// file_base ::<br/>		/// A pointer to the beginning of the font data.<br/>		/// file_size ::<br/>		/// The size of the memory chunk used by the font data.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "const FT_Byte*")] byte* fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			int ret = FreeType.FTNewMemoryFaceNative(library, fileBase, fileSize, faceIndex, aface);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Memory_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font that has been loaded into memory.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// file_base ::<br/>		/// A pointer to the beginning of the font data.<br/>		/// file_size ::<br/>		/// The size of the memory chunk used by the font data.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "const FT_Byte*")] ref byte fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			fixed (byte* pfileBase = &fileBase)
			{
				int ret = FreeType.FTNewMemoryFaceNative(library, (byte*)pfileBase, fileSize, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Memory_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font that has been loaded into memory.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// file_base ::<br/>		/// A pointer to the beginning of the font data.<br/>		/// file_size ::<br/>		/// The size of the memory chunk used by the font data.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "const FT_Byte*")] byte* fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (FTFace* paface = &aface)
			{
				int ret = FreeType.FTNewMemoryFaceNative(library, fileBase, fileSize, faceIndex, (FTFace*)paface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_New_Memory_Face<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Open_Face to open a font that has been loaded into memory.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// file_base ::<br/>		/// A pointer to the beginning of the font data.<br/>		/// file_size ::<br/>		/// The size of the memory chunk used by the font data.<br/>		/// face_index ::<br/>		/// See <br/>		/// _Open_Face for a detailed description of this parameter.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "const FT_Byte*")] ref byte fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (byte* pfileBase = &fileBase)
			{
				fixed (FTFace* paface = &aface)
				{
					int ret = FreeType.FTNewMemoryFaceNative(library, (byte*)pfileBase, fileSize, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Open_Face<br/>		/// <br/>		/// :<br/>		/// Create a face object from a given resource described by <br/>		/// _Open_Args.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// args ::<br/>		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>		/// caller.<br/>		/// face_index ::<br/>		/// This field holds two different values.  Bits 0-15 are the index of<br/>		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>		/// there is only one face in the font file.<br/>		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>		/// fonts only, specifying the named instance index for the current face<br/>		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>		/// Assuming that you want to access the third named instance in face~4,<br/>		/// `face_index` should be set to 0x00030004.  If you want to access<br/>		/// face~4 without variation handling, simply set `face_index` to<br/>		/// value~4.<br/>		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>		/// the font format of a given font resource is supported by FreeType.<br/>		/// In general, if the `face_index` argument is negative, the function's<br/>		/// return value is~0 if the font format is recognized, or non-zero<br/>		/// otherwise.  The function allocates a more or less empty face handle<br/>		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>		/// this special case are `face->num_faces` and `face->style_flags`.<br/>		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>		/// number of faces within the font file.  For the negative value<br/>		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>		/// `face->style_flags` give the number of named instances in face 'N'<br/>		/// if we have a variation font (or zero otherwise).  After examination,<br/>		/// the returned <br/>		/// _Face structure should be deallocated with a call to<br/>		/// <br/>		/// _Done_Face.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Each new face object created with this function also owns a default<br/>		/// <br/>		/// _Size object, accessible as `face->size`.<br/>		/// One <br/>		/// _Library instance can have multiple face objects, that is,<br/>		/// <br/>		/// _Open_Face and its siblings can be called multiple times using the<br/>		/// same `library` argument.<br/>		/// See the discussion of reference counters in the description of<br/>		/// <br/>		/// _Reference_Face.<br/>		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>		/// `args->stream` is automatically closed before this function returns<br/>		/// any error (including `FT_Err_Invalid_Argument`).<br/>		/// <br/>		/// To loop over all faces, use code similar to the following snippet<br/>		/// (omitting the error handling).<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  i, num_faces;<br/>		/// error = FT_Open_Face( library, args, -1, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces = face->num_faces;<br/>		/// FT_Done_Face( face );<br/>		/// for ( i = 0; i <br/>		/// <<br/>		/// num_faces; i++ )<br/>		/// {<br/>		/// ...<br/>		/// error = FT_Open_Face( library, args, i, <br/>		/// &face<br/>		/// );<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// ...<br/>		/// }<br/>		/// ```<br/>		/// To loop over all valid values for `face_index`, use something similar<br/>		/// to the following snippet, again without error handling.  The code<br/>		/// accesses all faces immediately (thus only a single call of<br/>		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  num_faces     = 0;<br/>		/// FT_Long  num_instances = 0;<br/>		/// FT_Long  face_idx     = 0;<br/>		/// FT_Long  instance_idx = 0;<br/>		/// do<br/>		/// {<br/>		/// FT_Long  id = ( instance_idx <br/>		/// <<br/>		/// <<br/>		/// 16 ) + face_idx;<br/>		/// error = FT_Open_Face( library, args, id, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces     = face->num_faces;<br/>		/// num_instances = face->style_flags >> 16;<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// if ( instance_idx <br/>		/// <<br/>		/// num_instances )<br/>		/// instance_idx++;<br/>		/// else<br/>		/// {<br/>		/// face_idx++;<br/>		/// instance_idx = 0;<br/>		/// }<br/>		/// } while ( face_idx <br/>		/// <<br/>		/// num_faces )<br/>		/// ```<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] FTOpenArgs* args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			int ret = FreeType.FTOpenFaceNative(library, args, faceIndex, aface);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Open_Face<br/>		/// <br/>		/// :<br/>		/// Create a face object from a given resource described by <br/>		/// _Open_Args.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// args ::<br/>		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>		/// caller.<br/>		/// face_index ::<br/>		/// This field holds two different values.  Bits 0-15 are the index of<br/>		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>		/// there is only one face in the font file.<br/>		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>		/// fonts only, specifying the named instance index for the current face<br/>		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>		/// Assuming that you want to access the third named instance in face~4,<br/>		/// `face_index` should be set to 0x00030004.  If you want to access<br/>		/// face~4 without variation handling, simply set `face_index` to<br/>		/// value~4.<br/>		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>		/// the font format of a given font resource is supported by FreeType.<br/>		/// In general, if the `face_index` argument is negative, the function's<br/>		/// return value is~0 if the font format is recognized, or non-zero<br/>		/// otherwise.  The function allocates a more or less empty face handle<br/>		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>		/// this special case are `face->num_faces` and `face->style_flags`.<br/>		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>		/// number of faces within the font file.  For the negative value<br/>		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>		/// `face->style_flags` give the number of named instances in face 'N'<br/>		/// if we have a variation font (or zero otherwise).  After examination,<br/>		/// the returned <br/>		/// _Face structure should be deallocated with a call to<br/>		/// <br/>		/// _Done_Face.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Each new face object created with this function also owns a default<br/>		/// <br/>		/// _Size object, accessible as `face->size`.<br/>		/// One <br/>		/// _Library instance can have multiple face objects, that is,<br/>		/// <br/>		/// _Open_Face and its siblings can be called multiple times using the<br/>		/// same `library` argument.<br/>		/// See the discussion of reference counters in the description of<br/>		/// <br/>		/// _Reference_Face.<br/>		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>		/// `args->stream` is automatically closed before this function returns<br/>		/// any error (including `FT_Err_Invalid_Argument`).<br/>		/// <br/>		/// To loop over all faces, use code similar to the following snippet<br/>		/// (omitting the error handling).<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  i, num_faces;<br/>		/// error = FT_Open_Face( library, args, -1, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces = face->num_faces;<br/>		/// FT_Done_Face( face );<br/>		/// for ( i = 0; i <br/>		/// <<br/>		/// num_faces; i++ )<br/>		/// {<br/>		/// ...<br/>		/// error = FT_Open_Face( library, args, i, <br/>		/// &face<br/>		/// );<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// ...<br/>		/// }<br/>		/// ```<br/>		/// To loop over all valid values for `face_index`, use something similar<br/>		/// to the following snippet, again without error handling.  The code<br/>		/// accesses all faces immediately (thus only a single call of<br/>		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  num_faces     = 0;<br/>		/// FT_Long  num_instances = 0;<br/>		/// FT_Long  face_idx     = 0;<br/>		/// FT_Long  instance_idx = 0;<br/>		/// do<br/>		/// {<br/>		/// FT_Long  id = ( instance_idx <br/>		/// <<br/>		/// <<br/>		/// 16 ) + face_idx;<br/>		/// error = FT_Open_Face( library, args, id, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces     = face->num_faces;<br/>		/// num_instances = face->style_flags >> 16;<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// if ( instance_idx <br/>		/// <<br/>		/// num_instances )<br/>		/// instance_idx++;<br/>		/// else<br/>		/// {<br/>		/// face_idx++;<br/>		/// instance_idx = 0;<br/>		/// }<br/>		/// } while ( face_idx <br/>		/// <<br/>		/// num_faces )<br/>		/// ```<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] ref FTOpenArgs args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] FTFace* aface)
		{
			fixed (FTOpenArgs* pargs = &args)
			{
				int ret = FreeType.FTOpenFaceNative(library, (FTOpenArgs*)pargs, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Open_Face<br/>		/// <br/>		/// :<br/>		/// Create a face object from a given resource described by <br/>		/// _Open_Args.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// args ::<br/>		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>		/// caller.<br/>		/// face_index ::<br/>		/// This field holds two different values.  Bits 0-15 are the index of<br/>		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>		/// there is only one face in the font file.<br/>		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>		/// fonts only, specifying the named instance index for the current face<br/>		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>		/// Assuming that you want to access the third named instance in face~4,<br/>		/// `face_index` should be set to 0x00030004.  If you want to access<br/>		/// face~4 without variation handling, simply set `face_index` to<br/>		/// value~4.<br/>		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>		/// the font format of a given font resource is supported by FreeType.<br/>		/// In general, if the `face_index` argument is negative, the function's<br/>		/// return value is~0 if the font format is recognized, or non-zero<br/>		/// otherwise.  The function allocates a more or less empty face handle<br/>		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>		/// this special case are `face->num_faces` and `face->style_flags`.<br/>		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>		/// number of faces within the font file.  For the negative value<br/>		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>		/// `face->style_flags` give the number of named instances in face 'N'<br/>		/// if we have a variation font (or zero otherwise).  After examination,<br/>		/// the returned <br/>		/// _Face structure should be deallocated with a call to<br/>		/// <br/>		/// _Done_Face.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Each new face object created with this function also owns a default<br/>		/// <br/>		/// _Size object, accessible as `face->size`.<br/>		/// One <br/>		/// _Library instance can have multiple face objects, that is,<br/>		/// <br/>		/// _Open_Face and its siblings can be called multiple times using the<br/>		/// same `library` argument.<br/>		/// See the discussion of reference counters in the description of<br/>		/// <br/>		/// _Reference_Face.<br/>		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>		/// `args->stream` is automatically closed before this function returns<br/>		/// any error (including `FT_Err_Invalid_Argument`).<br/>		/// <br/>		/// To loop over all faces, use code similar to the following snippet<br/>		/// (omitting the error handling).<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  i, num_faces;<br/>		/// error = FT_Open_Face( library, args, -1, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces = face->num_faces;<br/>		/// FT_Done_Face( face );<br/>		/// for ( i = 0; i <br/>		/// <<br/>		/// num_faces; i++ )<br/>		/// {<br/>		/// ...<br/>		/// error = FT_Open_Face( library, args, i, <br/>		/// &face<br/>		/// );<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// ...<br/>		/// }<br/>		/// ```<br/>		/// To loop over all valid values for `face_index`, use something similar<br/>		/// to the following snippet, again without error handling.  The code<br/>		/// accesses all faces immediately (thus only a single call of<br/>		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  num_faces     = 0;<br/>		/// FT_Long  num_instances = 0;<br/>		/// FT_Long  face_idx     = 0;<br/>		/// FT_Long  instance_idx = 0;<br/>		/// do<br/>		/// {<br/>		/// FT_Long  id = ( instance_idx <br/>		/// <<br/>		/// <<br/>		/// 16 ) + face_idx;<br/>		/// error = FT_Open_Face( library, args, id, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces     = face->num_faces;<br/>		/// num_instances = face->style_flags >> 16;<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// if ( instance_idx <br/>		/// <<br/>		/// num_instances )<br/>		/// instance_idx++;<br/>		/// else<br/>		/// {<br/>		/// face_idx++;<br/>		/// instance_idx = 0;<br/>		/// }<br/>		/// } while ( face_idx <br/>		/// <<br/>		/// num_faces )<br/>		/// ```<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] FTOpenArgs* args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (FTFace* paface = &aface)
			{
				int ret = FreeType.FTOpenFaceNative(library, args, faceIndex, (FTFace*)paface);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Open_Face<br/>		/// <br/>		/// :<br/>		/// Create a face object from a given resource described by <br/>		/// _Open_Args.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A handle to the library resource.<br/>		/// <br/>		/// :<br/>		/// args ::<br/>		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>		/// caller.<br/>		/// face_index ::<br/>		/// This field holds two different values.  Bits 0-15 are the index of<br/>		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>		/// there is only one face in the font file.<br/>		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>		/// fonts only, specifying the named instance index for the current face<br/>		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>		/// Assuming that you want to access the third named instance in face~4,<br/>		/// `face_index` should be set to 0x00030004.  If you want to access<br/>		/// face~4 without variation handling, simply set `face_index` to<br/>		/// value~4.<br/>		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>		/// the font format of a given font resource is supported by FreeType.<br/>		/// In general, if the `face_index` argument is negative, the function's<br/>		/// return value is~0 if the font format is recognized, or non-zero<br/>		/// otherwise.  The function allocates a more or less empty face handle<br/>		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>		/// this special case are `face->num_faces` and `face->style_flags`.<br/>		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>		/// number of faces within the font file.  For the negative value<br/>		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>		/// `face->style_flags` give the number of named instances in face 'N'<br/>		/// if we have a variation font (or zero otherwise).  After examination,<br/>		/// the returned <br/>		/// _Face structure should be deallocated with a call to<br/>		/// <br/>		/// _Done_Face.<br/>		/// <br/>		/// :<br/>		/// aface ::<br/>		/// A handle to a new face object.  If `face_index` is greater than or<br/>		/// equal to zero, it must be non-`NULL`.<br/>		/// <br/>		/// <br/>		/// Each new face object created with this function also owns a default<br/>		/// <br/>		/// _Size object, accessible as `face->size`.<br/>		/// One <br/>		/// _Library instance can have multiple face objects, that is,<br/>		/// <br/>		/// _Open_Face and its siblings can be called multiple times using the<br/>		/// same `library` argument.<br/>		/// See the discussion of reference counters in the description of<br/>		/// <br/>		/// _Reference_Face.<br/>		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>		/// `args->stream` is automatically closed before this function returns<br/>		/// any error (including `FT_Err_Invalid_Argument`).<br/>		/// <br/>		/// To loop over all faces, use code similar to the following snippet<br/>		/// (omitting the error handling).<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  i, num_faces;<br/>		/// error = FT_Open_Face( library, args, -1, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces = face->num_faces;<br/>		/// FT_Done_Face( face );<br/>		/// for ( i = 0; i <br/>		/// <<br/>		/// num_faces; i++ )<br/>		/// {<br/>		/// ...<br/>		/// error = FT_Open_Face( library, args, i, <br/>		/// &face<br/>		/// );<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// ...<br/>		/// }<br/>		/// ```<br/>		/// To loop over all valid values for `face_index`, use something similar<br/>		/// to the following snippet, again without error handling.  The code<br/>		/// accesses all faces immediately (thus only a single call of<br/>		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>		/// ```<br/>		/// ...<br/>		/// FT_Face  face;<br/>		/// FT_Long  num_faces     = 0;<br/>		/// FT_Long  num_instances = 0;<br/>		/// FT_Long  face_idx     = 0;<br/>		/// FT_Long  instance_idx = 0;<br/>		/// do<br/>		/// {<br/>		/// FT_Long  id = ( instance_idx <br/>		/// <<br/>		/// <<br/>		/// 16 ) + face_idx;<br/>		/// error = FT_Open_Face( library, args, id, <br/>		/// &face<br/>		/// );<br/>		/// if ( error ) { ... }<br/>		/// num_faces     = face->num_faces;<br/>		/// num_instances = face->style_flags >> 16;<br/>		/// ...<br/>		/// FT_Done_Face( face );<br/>		/// if ( instance_idx <br/>		/// <<br/>		/// num_instances )<br/>		/// instance_idx++;<br/>		/// else<br/>		/// {<br/>		/// face_idx++;<br/>		/// instance_idx = 0;<br/>		/// }<br/>		/// } while ( face_idx <br/>		/// <<br/>		/// num_faces )<br/>		/// ```<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] ref FTOpenArgs args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face*")] ref FTFace aface)
		{
			fixed (FTOpenArgs* pargs = &args)
			{
				fixed (FTFace* paface = &aface)
				{
					int ret = FreeType.FTOpenFaceNative(library, (FTOpenArgs*)pargs, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			FreeType.FTLibraryVersionNative(library, amajor, aminor, apatch);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				FreeType.FTLibraryVersionNative(library, (int*)pamajor, aminor, apatch);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			fixed (int* paminor = &aminor)
			{
				FreeType.FTLibraryVersionNative(library, amajor, (int*)paminor, apatch);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					FreeType.FTLibraryVersionNative(library, (int*)pamajor, (int*)paminor, apatch);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* papatch = &apatch)
			{
				FreeType.FTLibraryVersionNative(library, amajor, aminor, (int*)papatch);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* papatch = &apatch)
				{
					FreeType.FTLibraryVersionNative(library, (int*)pamajor, aminor, (int*)papatch);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* paminor = &aminor)
			{
				fixed (int* papatch = &apatch)
				{
					FreeType.FTLibraryVersionNative(library, amajor, (int*)paminor, (int*)papatch);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Library_Version<br/>		/// <br/>		/// :<br/>		/// Return the version of the FreeType library being used.  This is useful<br/>		/// when dynamically linking to the library, since one cannot use the<br/>		/// macros <br/>		/// _MAJOR, <br/>		/// _MINOR, and <br/>		/// _PATCH.<br/>		/// <br/>		/// :<br/>		/// library ::<br/>		/// A source library handle.<br/>		/// <br/>		/// :<br/>		/// amajor ::<br/>		/// The major version number.<br/>		/// aminor ::<br/>		/// The minor version number.<br/>		/// apatch ::<br/>		/// The patch version number.<br/>		/// <br/>		/// In such cases, the library version might not be available before the<br/>		/// library object has been created.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					fixed (int* papatch = &apatch)
					{
						FreeType.FTLibraryVersionNative(library, (int*)pamajor, (int*)paminor, (int*)papatch);
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_File<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Attach_Stream to attach a file.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// filepathname ::<br/>		/// The pathname.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] byte* filepathname)
		{
			int ret = FreeType.FTAttachFileNative(face, filepathname);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_File<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Attach_Stream to attach a file.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// filepathname ::<br/>		/// The pathname.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] ref byte filepathname)
		{
			fixed (byte* pfilepathname = &filepathname)
			{
				int ret = FreeType.FTAttachFileNative(face, (byte*)pfilepathname);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_File<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Attach_Stream to attach a file.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// filepathname ::<br/>		/// The pathname.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "const char*")] string filepathname)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filepathname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filepathname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filepathname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = FreeType.FTAttachFileNative(face, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_Stream<br/>		/// <br/>		/// :<br/>		/// 'Attach' data to a face object.  Normally, this is used to read<br/>		/// additional information for the face object.  For example, you can<br/>		/// attach an AFM file that comes with a Type~1 font to get the kerning<br/>		/// values and other metrics.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// parameters ::<br/>		/// A pointer to <br/>		/// _Open_Args that must be filled by the caller.<br/>		/// <br/>		/// <br/>		/// Client applications are expected to know what they are doing when<br/>		/// invoking this function.  Most drivers simply do not implement file or<br/>		/// stream attachments.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_Stream")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachStream(this FTFace face, [NativeName(NativeNameType.Param, "parameters")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] FTOpenArgs* parameters)
		{
			int ret = FreeType.FTAttachStreamNative(face, parameters);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Attach_Stream<br/>		/// <br/>		/// :<br/>		/// 'Attach' data to a face object.  Normally, this is used to read<br/>		/// additional information for the face object.  For example, you can<br/>		/// attach an AFM file that comes with a Type~1 font to get the kerning<br/>		/// values and other metrics.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// The target face object.<br/>		/// <br/>		/// :<br/>		/// parameters ::<br/>		/// A pointer to <br/>		/// _Open_Args that must be filled by the caller.<br/>		/// <br/>		/// <br/>		/// Client applications are expected to know what they are doing when<br/>		/// invoking this function.  Most drivers simply do not implement file or<br/>		/// stream attachments.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Attach_Stream")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int AttachStream(this FTFace face, [NativeName(NativeNameType.Param, "parameters")] [NativeName(NativeNameType.Type, "const FT_Open_Args*")] ref FTOpenArgs parameters)
		{
			fixed (FTOpenArgs* pparameters = &parameters)
			{
				int ret = FreeType.FTAttachStreamNative(face, (FTOpenArgs*)pparameters);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Reference_Face<br/>		/// <br/>		/// :<br/>		/// A counter gets initialized to~1 at the time an <br/>		/// _Face structure is<br/>		/// created.  This function increments the counter.  <br/>		/// _Done_Face then<br/>		/// only destroys a face if the counter is~1, otherwise it simply<br/>		/// decrements the counter.<br/>		/// This function helps in managing life-cycles of structures that<br/>		/// reference <br/>		/// _Face objects.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Reference_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int ReferenceFace(this FTFace face)
		{
			int ret = FreeType.FTReferenceFaceNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Done_Face<br/>		/// <br/>		/// :<br/>		/// Discard a given face object, as well as all of its child slots and<br/>		/// sizes.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Done_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int DoneFace(this FTFace face)
		{
			int ret = FreeType.FTDoneFaceNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Select_Size<br/>		/// <br/>		/// :<br/>		/// Select a bitmap strike.  To be more precise, this function sets the<br/>		/// scaling factors of the active <br/>		/// _Size object in a face so that<br/>		/// bitmaps from this particular strike are taken by <br/>		/// _Load_Glyph and<br/>		/// friends.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// :<br/>		/// strike_index ::<br/>		/// The index of the bitmap strike in the `available_sizes` field of<br/>		/// <br/>		/// _FaceRec structure.<br/>		/// <br/>		/// <br/>		/// For GX and OpenType variation fonts, a bitmap strike makes sense only<br/>		/// if the default instance is active (that is, no glyph variation takes<br/>		/// place); otherwise, FreeType simply ignores bitmap strikes.  The same<br/>		/// is true for all named instances that are different from the default<br/>		/// instance.<br/>		/// Don't use this function if you are using the FreeType cache API.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Select_Size")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SelectSize(this FTFace face, [NativeName(NativeNameType.Param, "strike_index")] [NativeName(NativeNameType.Type, "FT_Int")] int strikeIndex)
		{
			int ret = FreeType.FTSelectSizeNative(face, strikeIndex);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Request_Size<br/>		/// <br/>		/// :<br/>		/// Resize the scale of the active <br/>		/// _Size object in a face.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// :<br/>		/// req ::<br/>		/// A pointer to a <br/>		/// _Size_RequestRec.<br/>		/// <br/>		/// <br/>		/// The relation between the requested size and the resulting glyph size<br/>		/// is dependent entirely on how the size is defined in the source face.<br/>		/// The font designer chooses the final size of each glyph relative to<br/>		/// this size.  For more information refer to<br/>		/// 'https://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'.<br/>		/// Contrary to <br/>		/// _Set_Char_Size, this function doesn't have special code<br/>		/// to normalize zero-valued widths, heights, or resolutions, which are<br/>		/// treated as <br/>		/// _LOAD_NO_SCALE.<br/>		/// Don't use this function if you are using the FreeType cache API.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Request_Size")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int RequestSize(this FTFace face, [NativeName(NativeNameType.Param, "req")] [NativeName(NativeNameType.Type, "FT_Size_Request")] FTSizeRequest req)
		{
			int ret = FreeType.FTRequestSizeNative(face, req);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Char_Size<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Request_Size to request the nominal size (in points).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object.<br/>		/// <br/>		/// :<br/>		/// char_width ::<br/>		/// The nominal width, in 26.6 fractional points.<br/>		/// char_height ::<br/>		/// The nominal height, in 26.6 fractional points.<br/>		/// horz_resolution ::<br/>		/// The horizontal resolution in dpi.<br/>		/// vert_resolution ::<br/>		/// The vertical resolution in dpi.<br/>		/// <br/>		/// <br/>		/// If either the character width or height is zero, it is set equal to<br/>		/// the other value.<br/>		/// If either the horizontal or vertical resolution is zero, it is set<br/>		/// equal to the other value.<br/>		/// A character width or height smaller than 1pt is set to 1pt; if both<br/>		/// resolution values are zero, they are set to 72dpi.<br/>		/// Don't use this function if you are using the FreeType cache API.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Char_Size")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SetCharSize(this FTFace face, [NativeName(NativeNameType.Param, "char_width")] [NativeName(NativeNameType.Type, "FT_F26Dot6")] int charWidth, [NativeName(NativeNameType.Param, "char_height")] [NativeName(NativeNameType.Type, "FT_F26Dot6")] int charHeight, [NativeName(NativeNameType.Param, "horz_resolution")] [NativeName(NativeNameType.Type, "FT_UInt")] uint horzResolution, [NativeName(NativeNameType.Param, "vert_resolution")] [NativeName(NativeNameType.Type, "FT_UInt")] uint vertResolution)
		{
			int ret = FreeType.FTSetCharSizeNative(face, charWidth, charHeight, horzResolution, vertResolution);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Pixel_Sizes<br/>		/// <br/>		/// :<br/>		/// Call <br/>		/// _Request_Size to request the nominal size (in pixels).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the target face object.<br/>		/// <br/>		/// :<br/>		/// pixel_width ::<br/>		/// The nominal width, in pixels.<br/>		/// pixel_height ::<br/>		/// The nominal height, in pixels.<br/>		/// <br/>		/// <br/>		/// Don't use this function if you are using the FreeType cache API.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Pixel_Sizes")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SetPixelSizes(this FTFace face, [NativeName(NativeNameType.Param, "pixel_width")] [NativeName(NativeNameType.Type, "FT_UInt")] uint pixelWidth, [NativeName(NativeNameType.Param, "pixel_height")] [NativeName(NativeNameType.Type, "FT_UInt")] uint pixelHeight)
		{
			int ret = FreeType.FTSetPixelSizesNative(face, pixelWidth, pixelHeight);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Load_Glyph<br/>		/// <br/>		/// :<br/>		/// Load a glyph into the glyph slot of a face object.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the target face object where the glyph is loaded.<br/>		/// <br/>		/// :<br/>		/// glyph_index ::<br/>		/// The index of the glyph in the font file.  For CID-keyed fonts<br/>		/// (either in PS or in CFF format) this argument specifies the CID<br/>		/// value.<br/>		/// load_flags ::<br/>		/// A flag indicating what to load for this glyph.  The <br/>		/// _LOAD_XXX<br/>		/// flags can be used to control the glyph loading process (e.g.,<br/>		/// whether the outline should be scaled, whether to load bitmaps or<br/>		/// not, whether to hint the outline, etc).<br/>		/// <br/>		/// <br/>		/// For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument` is returned<br/>		/// for invalid CID values (that is, for CID values that don't have a<br/>		/// corresponding glyph in the font).  See the discussion of the<br/>		/// <br/>		/// _FACE_FLAG_CID_KEYED flag for more details.<br/>		/// If you receive `FT_Err_Glyph_Too_Big`, try getting the glyph outline<br/>		/// at EM size, then scale it manually and fill it as a graphics<br/>		/// operation.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LoadGlyph(this FTFace face, [NativeName(NativeNameType.Param, "glyph_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint glyphIndex, [NativeName(NativeNameType.Param, "load_flags")] [NativeName(NativeNameType.Type, "FT_Int32")] int loadFlags)
		{
			int ret = FreeType.FTLoadGlyphNative(face, glyphIndex, loadFlags);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Load_Char<br/>		/// <br/>		/// :<br/>		/// Load a glyph into the glyph slot of a face object, accessed by its<br/>		/// character code.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a target face object where the glyph is loaded.<br/>		/// <br/>		/// :<br/>		/// char_code ::<br/>		/// The glyph's character code, according to the current charmap used in<br/>		/// the face.<br/>		/// load_flags ::<br/>		/// A flag indicating what to load for this glyph.  The <br/>		/// _LOAD_XXX<br/>		/// constants can be used to control the glyph loading process (e.g.,<br/>		/// whether the outline should be scaled, whether to load bitmaps or<br/>		/// not, whether to hint the outline, etc).<br/>		/// <br/>		/// <br/>		/// Many fonts contain glyphs that can't be loaded by this function since<br/>		/// its glyph indices are not listed in any of the font's charmaps.<br/>		/// If no active cmap is set up (i.e., `face->charmap` is zero), the call<br/>		/// to <br/>		/// _Get_Char_Index is omitted, and the function behaves identically<br/>		/// to <br/>		/// _Load_Glyph.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Load_Char")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int LoadChar(this FTFace face, [NativeName(NativeNameType.Param, "char_code")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charCode, [NativeName(NativeNameType.Param, "load_flags")] [NativeName(NativeNameType.Type, "FT_Int32")] int loadFlags)
		{
			int ret = FreeType.FTLoadCharNative(face, charCode, loadFlags);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Transform<br/>		/// <br/>		/// :<br/>		/// Set the transformation that is applied to glyph images when they are<br/>		/// loaded into a glyph slot through <br/>		/// _Load_Glyph.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>		/// identity matrix.<br/>		/// delta ::<br/>		/// A pointer to the translation vector.  Use `NULL` for the null<br/>		/// vector.<br/>		/// <br/>		/// The transformation is only applied to scalable image formats after the<br/>		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>		/// transformation and is performed on the character size given in the<br/>		/// last call to <br/>		/// _Set_Char_Size or <br/>		/// _Set_Pixel_Sizes.<br/>		/// Note that this also transforms the `face.glyph.advance` field, but<br/>		/// **not** the values in `face.glyph.metrics`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* delta)
		{
			FreeType.FTSetTransformNative(face, matrix, delta);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Transform<br/>		/// <br/>		/// :<br/>		/// Set the transformation that is applied to glyph images when they are<br/>		/// loaded into a glyph slot through <br/>		/// _Load_Glyph.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>		/// identity matrix.<br/>		/// delta ::<br/>		/// A pointer to the translation vector.  Use `NULL` for the null<br/>		/// vector.<br/>		/// <br/>		/// The transformation is only applied to scalable image formats after the<br/>		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>		/// transformation and is performed on the character size given in the<br/>		/// last call to <br/>		/// _Set_Char_Size or <br/>		/// _Set_Pixel_Sizes.<br/>		/// Note that this also transforms the `face.glyph.advance` field, but<br/>		/// **not** the values in `face.glyph.metrics`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				FreeType.FTSetTransformNative(face, (FTMatrix*)pmatrix, delta);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Transform<br/>		/// <br/>		/// :<br/>		/// Set the transformation that is applied to glyph images when they are<br/>		/// loaded into a glyph slot through <br/>		/// _Load_Glyph.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>		/// identity matrix.<br/>		/// delta ::<br/>		/// A pointer to the translation vector.  Use `NULL` for the null<br/>		/// vector.<br/>		/// <br/>		/// The transformation is only applied to scalable image formats after the<br/>		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>		/// transformation and is performed on the character size given in the<br/>		/// last call to <br/>		/// _Set_Char_Size or <br/>		/// _Set_Pixel_Sizes.<br/>		/// Note that this also transforms the `face.glyph.advance` field, but<br/>		/// **not** the values in `face.glyph.metrics`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector delta)
		{
			fixed (FTVector* pdelta = &delta)
			{
				FreeType.FTSetTransformNative(face, matrix, (FTVector*)pdelta);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Transform<br/>		/// <br/>		/// :<br/>		/// Set the transformation that is applied to glyph images when they are<br/>		/// loaded into a glyph slot through <br/>		/// _Load_Glyph.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>		/// identity matrix.<br/>		/// delta ::<br/>		/// A pointer to the translation vector.  Use `NULL` for the null<br/>		/// vector.<br/>		/// <br/>		/// The transformation is only applied to scalable image formats after the<br/>		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>		/// transformation and is performed on the character size given in the<br/>		/// last call to <br/>		/// _Set_Char_Size or <br/>		/// _Set_Pixel_Sizes.<br/>		/// Note that this also transforms the `face.glyph.advance` field, but<br/>		/// **not** the values in `face.glyph.metrics`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				fixed (FTVector* pdelta = &delta)
				{
					FreeType.FTSetTransformNative(face, (FTMatrix*)pmatrix, (FTVector*)pdelta);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Transform<br/>		/// <br/>		/// :<br/>		/// Return the transformation that is applied to glyph images when they<br/>		/// are loaded into a glyph slot through <br/>		/// _Load_Glyph.  See<br/>		/// <br/>		/// _Set_Transform for more details.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>		/// are not interested in the value.<br/>		/// delta ::<br/>		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>		/// interested in the value.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* delta)
		{
			FreeType.FTGetTransformNative(face, matrix, delta);
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Transform<br/>		/// <br/>		/// :<br/>		/// Return the transformation that is applied to glyph images when they<br/>		/// are loaded into a glyph slot through <br/>		/// _Load_Glyph.  See<br/>		/// <br/>		/// _Set_Transform for more details.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>		/// are not interested in the value.<br/>		/// delta ::<br/>		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>		/// interested in the value.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				FreeType.FTGetTransformNative(face, (FTMatrix*)pmatrix, delta);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Transform<br/>		/// <br/>		/// :<br/>		/// Return the transformation that is applied to glyph images when they<br/>		/// are loaded into a glyph slot through <br/>		/// _Load_Glyph.  See<br/>		/// <br/>		/// _Set_Transform for more details.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>		/// are not interested in the value.<br/>		/// delta ::<br/>		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>		/// interested in the value.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector delta)
		{
			fixed (FTVector* pdelta = &delta)
			{
				FreeType.FTGetTransformNative(face, matrix, (FTVector*)pdelta);
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Transform<br/>		/// <br/>		/// :<br/>		/// Return the transformation that is applied to glyph images when they<br/>		/// are loaded into a glyph slot through <br/>		/// _Load_Glyph.  See<br/>		/// <br/>		/// _Set_Transform for more details.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// matrix ::<br/>		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>		/// are not interested in the value.<br/>		/// delta ::<br/>		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>		/// interested in the value.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				fixed (FTVector* pdelta = &delta)
				{
					FreeType.FTGetTransformNative(face, (FTMatrix*)pmatrix, (FTVector*)pdelta);
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Kerning<br/>		/// <br/>		/// :<br/>		/// Return the kerning vector between two glyphs of the same face.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// left_glyph ::<br/>		/// The index of the left glyph in the kern pair.<br/>		/// right_glyph ::<br/>		/// The index of the right glyph in the kern pair.<br/>		/// kern_mode ::<br/>		/// See <br/>		/// _Kerning_Mode for more information.  Determines the scale and<br/>		/// dimension of the returned kerning vector.<br/>		/// <br/>		/// :<br/>		/// akerning ::<br/>		/// The kerning vector.  This is either in font units, fractional pixels<br/>		/// (26.6 format), or pixels for scalable formats, and in pixels for<br/>		/// fixed-sizes formats.<br/>		/// <br/>		/// <br/>		/// Kerning for OpenType fonts implemented in a 'GPOS' table is not<br/>		/// supported; use <br/>		/// _HAS_KERNING to find out whether a font has data<br/>		/// that can be extracted with `FT_Get_Kerning`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetKerning(this FTFace face, [NativeName(NativeNameType.Param, "left_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint leftGlyph, [NativeName(NativeNameType.Param, "right_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint rightGlyph, [NativeName(NativeNameType.Param, "kern_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint kernMode, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Vector*")] FTVector* akerning)
		{
			int ret = FreeType.FTGetKerningNative(face, leftGlyph, rightGlyph, kernMode, akerning);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Kerning<br/>		/// <br/>		/// :<br/>		/// Return the kerning vector between two glyphs of the same face.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// left_glyph ::<br/>		/// The index of the left glyph in the kern pair.<br/>		/// right_glyph ::<br/>		/// The index of the right glyph in the kern pair.<br/>		/// kern_mode ::<br/>		/// See <br/>		/// _Kerning_Mode for more information.  Determines the scale and<br/>		/// dimension of the returned kerning vector.<br/>		/// <br/>		/// :<br/>		/// akerning ::<br/>		/// The kerning vector.  This is either in font units, fractional pixels<br/>		/// (26.6 format), or pixels for scalable formats, and in pixels for<br/>		/// fixed-sizes formats.<br/>		/// <br/>		/// <br/>		/// Kerning for OpenType fonts implemented in a 'GPOS' table is not<br/>		/// supported; use <br/>		/// _HAS_KERNING to find out whether a font has data<br/>		/// that can be extracted with `FT_Get_Kerning`.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetKerning(this FTFace face, [NativeName(NativeNameType.Param, "left_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint leftGlyph, [NativeName(NativeNameType.Param, "right_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint rightGlyph, [NativeName(NativeNameType.Param, "kern_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint kernMode, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Vector*")] ref FTVector akerning)
		{
			fixed (FTVector* pakerning = &akerning)
			{
				int ret = FreeType.FTGetKerningNative(face, leftGlyph, rightGlyph, kernMode, (FTVector*)pakerning);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Track_Kerning<br/>		/// <br/>		/// :<br/>		/// Return the track kerning for a given face object at a given size.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// point_size ::<br/>		/// The point size in 16.16 fractional points.<br/>		/// degree ::<br/>		/// The degree of tightness.  Increasingly negative values represent<br/>		/// tighter track kerning, while increasingly positive values represent<br/>		/// looser track kerning.  Value zero means no track kerning.<br/>		/// <br/>		/// :<br/>		/// akerning ::<br/>		/// The kerning in 16.16 fractional points, to be uniformly applied<br/>		/// between all glyphs.<br/>		/// <br/>		/// <br/>		/// Only very few AFM files come with track kerning data; please refer to<br/>		/// Adobe's AFM specification for more details.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Track_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetTrackKerning(this FTFace face, [NativeName(NativeNameType.Param, "point_size")] [NativeName(NativeNameType.Type, "FT_Fixed")] int pointSize, [NativeName(NativeNameType.Param, "degree")] [NativeName(NativeNameType.Type, "FT_Int")] int degree, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Fixed*")] int* akerning)
		{
			int ret = FreeType.FTGetTrackKerningNative(face, pointSize, degree, akerning);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Track_Kerning<br/>		/// <br/>		/// :<br/>		/// Return the track kerning for a given face object at a given size.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// point_size ::<br/>		/// The point size in 16.16 fractional points.<br/>		/// degree ::<br/>		/// The degree of tightness.  Increasingly negative values represent<br/>		/// tighter track kerning, while increasingly positive values represent<br/>		/// looser track kerning.  Value zero means no track kerning.<br/>		/// <br/>		/// :<br/>		/// akerning ::<br/>		/// The kerning in 16.16 fractional points, to be uniformly applied<br/>		/// between all glyphs.<br/>		/// <br/>		/// <br/>		/// Only very few AFM files come with track kerning data; please refer to<br/>		/// Adobe's AFM specification for more details.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Track_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetTrackKerning(this FTFace face, [NativeName(NativeNameType.Param, "point_size")] [NativeName(NativeNameType.Type, "FT_Fixed")] int pointSize, [NativeName(NativeNameType.Param, "degree")] [NativeName(NativeNameType.Type, "FT_Int")] int degree, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Fixed*")] ref int akerning)
		{
			fixed (int* pakerning = &akerning)
			{
				int ret = FreeType.FTGetTrackKerningNative(face, pointSize, degree, (int*)pakerning);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Select_Charmap<br/>		/// <br/>		/// :<br/>		/// Select a given charmap by its encoding tag (as listed in<br/>		/// `freetype.h`).<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// encoding ::<br/>		/// A handle to the selected encoding.<br/>		/// <br/>		/// <br/>		/// Because many fonts contain more than a single cmap for Unicode<br/>		/// encoding, this function has some special code to select the one that<br/>		/// covers Unicode best ('best' in the sense that a UCS-4 cmap is<br/>		/// preferred to a UCS-2 cmap).  It is thus preferable to <br/>		/// _Set_Charmap<br/>		/// in this case.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Select_Charmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SelectCharmap(this FTFace face, [NativeName(NativeNameType.Param, "encoding")] [NativeName(NativeNameType.Type, "FT_Encoding")] FTEncoding encoding)
		{
			int ret = FreeType.FTSelectCharmapNative(face, encoding);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Set_Charmap<br/>		/// <br/>		/// :<br/>		/// Select a given charmap for character code to glyph index mapping.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// charmap ::<br/>		/// A handle to the selected charmap.<br/>		/// <br/>		/// <br/>		/// It also fails if an OpenType type~14 charmap is selected (which<br/>		/// doesn't map character codes to glyph indices at all).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Set_Charmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int SetCharmap(this FTFace face, [NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap)
		{
			int ret = FreeType.FTSetCharmapNative(face, charmap);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Char_Index<br/>		/// <br/>		/// :<br/>		/// Return the glyph index of a given character code.  This function uses<br/>		/// the currently selected charmap to do the mapping.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// charcode ::<br/>		/// The character code.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Char_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetCharIndex(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode)
		{
			uint ret = FreeType.FTGetCharIndexNative(face, charcode);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_First_Char<br/>		/// <br/>		/// :<br/>		/// Return the first character code in the current charmap of a given<br/>		/// face, together with its corresponding glyph index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// agindex ::<br/>		/// Glyph index of first character code.  0~if charmap is empty.<br/>		/// <br/>		/// <br/>		/// ```<br/>		/// FT_ULong  charcode;<br/>		/// FT_UInt   gindex;<br/>		/// charcode = FT_Get_First_Char( face, <br/>		/// &gindex<br/>		/// );<br/>		/// while ( gindex != 0 )<br/>		/// {<br/>		/// ... do something with (charcode,gindex) pair ...<br/>		/// charcode = FT_Get_Next_Char( face, charcode, <br/>		/// &gindex<br/>		/// );<br/>		/// }<br/>		/// ```<br/>		/// Be aware that character codes can have values up to 0xFFFFFFFF; this<br/>		/// might happen for non-Unicode or malformed cmaps.  However, even with<br/>		/// regular Unicode encoding, so-called 'last resort fonts' (using SFNT<br/>		/// cmap format 13, see function <br/>		/// _Get_CMap_Format) normally have<br/>		/// entries for all Unicode characters up to 0x1FFFFF, which can cause *a<br/>		/// lot* of iterations.<br/>		/// Note that `*agindex` is set to~0 if the charmap is empty.  The result<br/>		/// itself can be~0 in two cases: if the charmap is empty or if the<br/>		/// value~0 is the first valid character code.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_First_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetFirstChar(this FTFace face, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* agindex)
		{
			uint ret = FreeType.FTGetFirstCharNative(face, agindex);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_First_Char<br/>		/// <br/>		/// :<br/>		/// Return the first character code in the current charmap of a given<br/>		/// face, together with its corresponding glyph index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// :<br/>		/// agindex ::<br/>		/// Glyph index of first character code.  0~if charmap is empty.<br/>		/// <br/>		/// <br/>		/// ```<br/>		/// FT_ULong  charcode;<br/>		/// FT_UInt   gindex;<br/>		/// charcode = FT_Get_First_Char( face, <br/>		/// &gindex<br/>		/// );<br/>		/// while ( gindex != 0 )<br/>		/// {<br/>		/// ... do something with (charcode,gindex) pair ...<br/>		/// charcode = FT_Get_Next_Char( face, charcode, <br/>		/// &gindex<br/>		/// );<br/>		/// }<br/>		/// ```<br/>		/// Be aware that character codes can have values up to 0xFFFFFFFF; this<br/>		/// might happen for non-Unicode or malformed cmaps.  However, even with<br/>		/// regular Unicode encoding, so-called 'last resort fonts' (using SFNT<br/>		/// cmap format 13, see function <br/>		/// _Get_CMap_Format) normally have<br/>		/// entries for all Unicode characters up to 0x1FFFFF, which can cause *a<br/>		/// lot* of iterations.<br/>		/// Note that `*agindex` is set to~0 if the charmap is empty.  The result<br/>		/// itself can be~0 in two cases: if the charmap is empty or if the<br/>		/// value~0 is the first valid character code.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_First_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetFirstChar(this FTFace face, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint agindex)
		{
			fixed (uint* pagindex = &agindex)
			{
				uint ret = FreeType.FTGetFirstCharNative(face, (uint*)pagindex);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Next_Char<br/>		/// <br/>		/// :<br/>		/// Return the next character code in the current charmap of a given face<br/>		/// following the value `char_code`, as well as the corresponding glyph<br/>		/// index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// char_code ::<br/>		/// The starting character code.<br/>		/// <br/>		/// :<br/>		/// agindex ::<br/>		/// Glyph index of next character code.  0~if charmap is empty.<br/>		/// <br/>		/// <br/>		/// Note that `*agindex` is set to~0 when there are no more codes in the<br/>		/// charmap.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Next_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetNextChar(this FTFace face, [NativeName(NativeNameType.Param, "char_code")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charCode, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* agindex)
		{
			uint ret = FreeType.FTGetNextCharNative(face, charCode, agindex);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Next_Char<br/>		/// <br/>		/// :<br/>		/// Return the next character code in the current charmap of a given face<br/>		/// following the value `char_code`, as well as the corresponding glyph<br/>		/// index.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// char_code ::<br/>		/// The starting character code.<br/>		/// <br/>		/// :<br/>		/// agindex ::<br/>		/// Glyph index of next character code.  0~if charmap is empty.<br/>		/// <br/>		/// <br/>		/// Note that `*agindex` is set to~0 when there are no more codes in the<br/>		/// charmap.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Next_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetNextChar(this FTFace face, [NativeName(NativeNameType.Param, "char_code")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charCode, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint agindex)
		{
			fixed (uint* pagindex = &agindex)
			{
				uint ret = FreeType.FTGetNextCharNative(face, charCode, (uint*)pagindex);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_Properties<br/>		/// <br/>		/// :<br/>		/// Set or override certain (library or module-wide) properties on a<br/>		/// face-by-face basis.  Useful for finer-grained control and avoiding<br/>		/// locks on shared structures (threads can modify their own faces as they<br/>		/// see fit).<br/>		/// Contrary to <br/>		/// _Property_Set, this function uses <br/>		/// _Parameter so that<br/>		/// you can pass multiple properties to the target face in one call.  Note<br/>		/// that only a subset of the available properties can be controlled.<br/>		/// * <br/>		/// _PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the<br/>		/// property `no-stem-darkening` provided by the 'autofit', 'cff',<br/>		/// 'type1', and 't1cid' modules; see <br/>		/// -stem-darkening).<br/>		/// * <br/>		/// _PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding<br/>		/// to function <br/>		/// _Library_SetLcdFilterWeights).<br/>		/// * <br/>		/// _PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID<br/>		/// 'random' operator, corresponding to the `random-seed` property<br/>		/// provided by the 'cff', 'type1', and 't1cid' modules; see<br/>		/// <br/>		/// -seed).<br/>		/// Pass `NULL` as `data` in <br/>		/// _Parameter for a given tag to reset the<br/>		/// option and use the library or module default again.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// num_properties ::<br/>		/// The number of properties that follow.<br/>		/// properties ::<br/>		/// A handle to an <br/>		/// _Parameter array with `num_properties` elements.<br/>		/// <br/>		/// <br/>		/// Here is an example that sets three properties.  You must define<br/>		/// `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples<br/>		/// work.<br/>		/// ```<br/>		/// FT_Parameter         property1;<br/>		/// FT_Bool              darken_stems = 1;<br/>		/// FT_Parameter         property2;<br/>		/// FT_LcdFiveTapFilter  custom_weight =<br/>		/// { 0x11, 0x44, 0x56, 0x44, 0x11 };<br/>		/// FT_Parameter         property3;<br/>		/// FT_Int32             random_seed = 314159265;<br/>		/// FT_Parameter         properties[3] = { property1,<br/>		/// property2,<br/>		/// property3 };<br/>		/// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;<br/>		/// property1.data = <br/>		/// &darken<br/>		/// _stems;<br/>		/// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>		/// property2.data = custom_weight;<br/>		/// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;<br/>		/// property3.data = <br/>		/// &random<br/>		/// _seed;<br/>		/// FT_Face_Properties( face, 3, properties );<br/>		/// ```<br/>		/// The next example resets a single property to its default value.<br/>		/// ```<br/>		/// FT_Parameter  property;<br/>		/// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>		/// property.data = NULL;<br/>		/// FT_Face_Properties( face, 1, <br/>		/// &property<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_Properties")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Properties(this FTFace face, [NativeName(NativeNameType.Param, "num_properties")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numProperties, [NativeName(NativeNameType.Param, "properties")] [NativeName(NativeNameType.Type, "FT_Parameter*")] FTParameter* properties)
		{
			int ret = FreeType.FTFacePropertiesNative(face, numProperties, properties);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_Properties<br/>		/// <br/>		/// :<br/>		/// Set or override certain (library or module-wide) properties on a<br/>		/// face-by-face basis.  Useful for finer-grained control and avoiding<br/>		/// locks on shared structures (threads can modify their own faces as they<br/>		/// see fit).<br/>		/// Contrary to <br/>		/// _Property_Set, this function uses <br/>		/// _Parameter so that<br/>		/// you can pass multiple properties to the target face in one call.  Note<br/>		/// that only a subset of the available properties can be controlled.<br/>		/// * <br/>		/// _PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the<br/>		/// property `no-stem-darkening` provided by the 'autofit', 'cff',<br/>		/// 'type1', and 't1cid' modules; see <br/>		/// -stem-darkening).<br/>		/// * <br/>		/// _PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding<br/>		/// to function <br/>		/// _Library_SetLcdFilterWeights).<br/>		/// * <br/>		/// _PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID<br/>		/// 'random' operator, corresponding to the `random-seed` property<br/>		/// provided by the 'cff', 'type1', and 't1cid' modules; see<br/>		/// <br/>		/// -seed).<br/>		/// Pass `NULL` as `data` in <br/>		/// _Parameter for a given tag to reset the<br/>		/// option and use the library or module default again.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// num_properties ::<br/>		/// The number of properties that follow.<br/>		/// properties ::<br/>		/// A handle to an <br/>		/// _Parameter array with `num_properties` elements.<br/>		/// <br/>		/// <br/>		/// Here is an example that sets three properties.  You must define<br/>		/// `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples<br/>		/// work.<br/>		/// ```<br/>		/// FT_Parameter         property1;<br/>		/// FT_Bool              darken_stems = 1;<br/>		/// FT_Parameter         property2;<br/>		/// FT_LcdFiveTapFilter  custom_weight =<br/>		/// { 0x11, 0x44, 0x56, 0x44, 0x11 };<br/>		/// FT_Parameter         property3;<br/>		/// FT_Int32             random_seed = 314159265;<br/>		/// FT_Parameter         properties[3] = { property1,<br/>		/// property2,<br/>		/// property3 };<br/>		/// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;<br/>		/// property1.data = <br/>		/// &darken<br/>		/// _stems;<br/>		/// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>		/// property2.data = custom_weight;<br/>		/// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;<br/>		/// property3.data = <br/>		/// &random<br/>		/// _seed;<br/>		/// FT_Face_Properties( face, 3, properties );<br/>		/// ```<br/>		/// The next example resets a single property to its default value.<br/>		/// ```<br/>		/// FT_Parameter  property;<br/>		/// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>		/// property.data = NULL;<br/>		/// FT_Face_Properties( face, 1, <br/>		/// &property<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_Properties")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int Properties(this FTFace face, [NativeName(NativeNameType.Param, "num_properties")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numProperties, [NativeName(NativeNameType.Param, "properties")] [NativeName(NativeNameType.Type, "FT_Parameter*")] ref FTParameter properties)
		{
			fixed (FTParameter* pproperties = &properties)
			{
				int ret = FreeType.FTFacePropertiesNative(face, numProperties, (FTParameter*)pproperties);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Name_Index<br/>		/// <br/>		/// :<br/>		/// Return the glyph index of a given glyph name.  This only works<br/>		/// for those faces where <br/>		/// _HAS_GLYPH_NAMES returns true.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// glyph_name ::<br/>		/// The glyph name.<br/>		/// <br/>		/// <br/>		/// This function has limited capabilities if the config macro<br/>		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>		/// It then works only for fonts that actually embed glyph names (which<br/>		/// many recent OpenType fonts do not).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Name_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetNameIndex(this FTFace face, [NativeName(NativeNameType.Param, "glyph_name")] [NativeName(NativeNameType.Type, "const FT_String*")] byte* glyphName)
		{
			uint ret = FreeType.FTGetNameIndexNative(face, glyphName);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Name_Index<br/>		/// <br/>		/// :<br/>		/// Return the glyph index of a given glyph name.  This only works<br/>		/// for those faces where <br/>		/// _HAS_GLYPH_NAMES returns true.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// glyph_name ::<br/>		/// The glyph name.<br/>		/// <br/>		/// <br/>		/// This function has limited capabilities if the config macro<br/>		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>		/// It then works only for fonts that actually embed glyph names (which<br/>		/// many recent OpenType fonts do not).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Name_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetNameIndex(this FTFace face, [NativeName(NativeNameType.Param, "glyph_name")] [NativeName(NativeNameType.Type, "const FT_String*")] ref byte glyphName)
		{
			fixed (byte* pglyphName = &glyphName)
			{
				uint ret = FreeType.FTGetNameIndexNative(face, (byte*)pglyphName);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Glyph_Name<br/>		/// <br/>		/// :<br/>		/// Retrieve the ASCII name of a given glyph in a face.  This only works<br/>		/// for those faces where <br/>		/// _HAS_GLYPH_NAMES returns true.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to a source face object.<br/>		/// glyph_index ::<br/>		/// The glyph index.<br/>		/// buffer_max ::<br/>		/// The maximum number of bytes available in the buffer.<br/>		/// <br/>		/// :<br/>		/// buffer ::<br/>		/// A pointer to a target buffer where the name is copied to.<br/>		/// <br/>		/// <br/>		/// The glyph name is truncated to fit within the buffer if it is too<br/>		/// long.  The returned string is always zero-terminated.<br/>		/// Be aware that FreeType reorders glyph indices internally so that glyph<br/>		/// index~0 always corresponds to the 'missing glyph' (called '.notdef').<br/>		/// This function has limited capabilities if the config macro<br/>		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>		/// It then works only for fonts that actually embed glyph names (which<br/>		/// many recent OpenType fonts do not).<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Glyph_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetGlyphName(this FTFace face, [NativeName(NativeNameType.Param, "glyph_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint glyphIndex, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Pointer")] FTPointer buffer, [NativeName(NativeNameType.Param, "buffer_max")] [NativeName(NativeNameType.Type, "FT_UInt")] uint bufferMax)
		{
			int ret = FreeType.FTGetGlyphNameNative(face, glyphIndex, buffer, bufferMax);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Postscript_Name<br/>		/// <br/>		/// :<br/>		/// Retrieve the ASCII PostScript name of a given face, if available.<br/>		/// This only works with PostScript, TrueType, and OpenType fonts.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// <br/>		/// For variation fonts, this string changes if you select a different<br/>		/// instance, and you have to call `FT_Get_PostScript_Name` again to<br/>		/// retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating<br/>		/// PostScript Names for Fonts Using OpenType Font Variations'.<br/>		/// https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html<br/>		/// [Since 2.9] Special PostScript names for named instances are only<br/>		/// returned if the named instance is set with <br/>		/// _Set_Named_Instance (and<br/>		/// the font has corresponding entries in its 'fvar' table or is the<br/>		/// default named instance).  If <br/>		/// _IS_VARIATION returns true, the<br/>		/// algorithmically derived PostScript name is provided, not looking up<br/>		/// special entries for named instances.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Postscript_Name")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetPostscriptName(this FTFace face)
		{
			byte* ret = FreeType.FTGetPostscriptNameNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Postscript_Name<br/>		/// <br/>		/// :<br/>		/// Retrieve the ASCII PostScript name of a given face, if available.<br/>		/// This only works with PostScript, TrueType, and OpenType fonts.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// <br/>		/// For variation fonts, this string changes if you select a different<br/>		/// instance, and you have to call `FT_Get_PostScript_Name` again to<br/>		/// retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating<br/>		/// PostScript Names for Fonts Using OpenType Font Variations'.<br/>		/// https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html<br/>		/// [Since 2.9] Special PostScript names for named instances are only<br/>		/// returned if the named instance is set with <br/>		/// _Set_Named_Instance (and<br/>		/// the font has corresponding entries in its 'fvar' table or is the<br/>		/// default named instance).  If <br/>		/// _IS_VARIATION returns true, the<br/>		/// algorithmically derived PostScript name is provided, not looking up<br/>		/// special entries for named instances.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Postscript_Name")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string GetPostscriptNameS(this FTFace face)
		{
			string ret = Utils.DecodeStringUTF8(FreeType.FTGetPostscriptNameNative(face));
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_FSType_Flags<br/>		/// <br/>		/// :<br/>		/// Return the `fsType` flags for a font.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_FSType_Flags")]
		[return: NativeName(NativeNameType.Type, "FT_UShort")]
		public static ushort GetFsTypeFlags(this FTFace face)
		{
			ushort ret = FreeType.FTGetFSTypeFlagsNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetCharVariantIndex<br/>		/// <br/>		/// :<br/>		/// Return the glyph index of a given character code as modified by the<br/>		/// variation selector.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// charcode ::<br/>		/// The character code point in Unicode.<br/>		/// variantSelector ::<br/>		/// The Unicode code point of the variation selector.<br/>		/// <br/>		/// <br/>		/// This function is only meaningful if<br/>		/// a) the font has a variation selector cmap sub table, and<br/>		/// b) the current charmap has a Unicode encoding.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIndex")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetCharVariantIndex(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint ret = FreeType.FTFaceGetCharVariantIndexNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetCharVariantIsDefault<br/>		/// <br/>		/// :<br/>		/// Check whether this variation of this Unicode character is the one to<br/>		/// be found in the charmap.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// charcode ::<br/>		/// The character codepoint in Unicode.<br/>		/// variantSelector ::<br/>		/// The Unicode codepoint of the variation selector.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIsDefault")]
		[return: NativeName(NativeNameType.Type, "FT_Int")]
		public static int GetCharVariantIsDefault(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			int ret = FreeType.FTFaceGetCharVariantIsDefaultNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetVariantSelectors<br/>		/// <br/>		/// :<br/>		/// Return a zero-terminated list of Unicode variation selectors found in<br/>		/// the font.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetVariantSelectors")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		public static uint* GetVariantSelectors(this FTFace face)
		{
			uint* ret = FreeType.FTFaceGetVariantSelectorsNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetVariantsOfChar<br/>		/// <br/>		/// :<br/>		/// Return a zero-terminated list of Unicode variation selectors found for<br/>		/// the specified character code.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// charcode ::<br/>		/// The character codepoint in Unicode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetVariantsOfChar")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		public static uint* GetVariantsOfChar(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode)
		{
			uint* ret = FreeType.FTFaceGetVariantsOfCharNative(face, charcode);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_GetCharsOfVariant<br/>		/// <br/>		/// :<br/>		/// Return a zero-terminated list of Unicode character codes found for the<br/>		/// specified variation selector.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A handle to the source face object.<br/>		/// variantSelector ::<br/>		/// The variation selector code point in Unicode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_GetCharsOfVariant")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32*")]
		public static uint* GetCharsOfVariant(this FTFace face, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint* ret = FreeType.FTFaceGetCharsOfVariantNative(face, variantSelector);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_CheckTrueTypePatents<br/>		/// <br/>		/// :<br/>		/// Deprecated, does nothing.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A face handle.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_CheckTrueTypePatents")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte CheckTrueTypePatents(this FTFace face)
		{
			byte ret = FreeType.FTFaceCheckTrueTypePatentsNative(face);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Face_SetUnpatentedHinting<br/>		/// <br/>		/// :<br/>		/// Deprecated, does nothing.<br/>		/// <br/>		/// :<br/>		/// face ::<br/>		/// A face handle.<br/>		/// value ::<br/>		/// New boolean setting.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Face_SetUnpatentedHinting")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte SetUnpatentedHinting(this FTFace face, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "FT_Bool")] byte value)
		{
			byte ret = FreeType.FTFaceSetUnpatentedHintingNative(face, value);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Render_Glyph<br/>		/// <br/>		/// :<br/>		/// Convert a given glyph image to a bitmap.  It does so by inspecting the<br/>		/// glyph image format, finding the relevant renderer, and invoking it.<br/>		/// <br/>		/// :<br/>		/// slot ::<br/>		/// A handle to the glyph slot containing the image to convert.<br/>		/// <br/>		/// :<br/>		/// render_mode ::<br/>		/// The render mode used to render the glyph image into a bitmap.  See<br/>		/// <br/>		/// _Render_Mode for a list of possible values.<br/>		/// If <br/>		/// _RENDER_MODE_NORMAL is used, a previous call of <br/>		/// _Load_Glyph<br/>		/// with flag <br/>		/// _LOAD_COLOR makes `FT_Render_Glyph` provide a default<br/>		/// blending of colored glyph layers associated with the current glyph<br/>		/// slot (provided the font contains such layers) instead of rendering<br/>		/// the glyph slot's outline.  This is an experimental feature; see<br/>		/// <br/>		/// _LOAD_COLOR for more information.<br/>		/// <br/>		/// <br/>		/// On high-DPI screens like on smartphones and tablets, the pixels are so<br/>		/// small that their chance of being completely covered and therefore<br/>		/// completely black are fairly good.  On the low-DPI screens, however,<br/>		/// the situation is different.  The pixels are too large for most of the<br/>		/// details of a glyph and shades of gray are the norm rather than the<br/>		/// exception.<br/>		/// This is relevant because all our screens have a second problem: they<br/>		/// are not linear.  1~+~1 is not~2.  Twice the value does not result in<br/>		/// twice the brightness.  When a pixel is only 50% covered, the coverage<br/>		/// map says 50% black, and this translates to a pixel value of 128 when<br/>		/// you use 8~bits per channel (0-255).  However, this does not translate<br/>		/// to 50% brightness for that pixel on our sRGB and gamma~2.2 screens.<br/>		/// Due to their non-linearity, they dwell longer in the darks and only a<br/>		/// pixel value of about 186 results in 50% brightness -- 128 ends up too<br/>		/// dark on both bright and dark backgrounds.  The net result is that dark<br/>		/// text looks burnt-out, pixely and blotchy on bright background, bright<br/>		/// text too frail on dark backgrounds, and colored text on colored<br/>		/// background (for example, red on green) seems to have dark halos or<br/>		/// 'dirt' around it.  The situation is especially ugly for diagonal stems<br/>		/// like in 'w' glyph shapes where the quality of FreeType's anti-aliasing<br/>		/// depends on the correct display of grays.  On high-DPI screens where<br/>		/// smaller, fully black pixels reign supreme, this doesn't matter, but on<br/>		/// our low-DPI screens with all the gray shades, it does.  0% and 100%<br/>		/// brightness are the same things in linear and non-linear space, just<br/>		/// all the shades in-between aren't.<br/>		/// The blending function for placing text over a background is<br/>		/// ```<br/>		/// dst = alpha * src + (1 - alpha) * dst    ,<br/>		/// ```<br/>		/// which is known as the OVER operator.<br/>		/// To correctly composite an anti-aliased pixel of a glyph onto a<br/>		/// surface,<br/>		/// 1. take the foreground and background colors (e.g., in sRGB space)<br/>		/// and apply gamma to get them in a linear space,<br/>		/// 2. use OVER to blend the two linear colors using the glyph pixel<br/>		/// as the alpha value (remember, the glyph bitmap is an alpha coverage<br/>		/// bitmap), and<br/>		/// 3. apply inverse gamma to the blended pixel and write it back to<br/>		/// the image.<br/>		/// Internal testing at Adobe found that a target inverse gamma of~1.8 for<br/>		/// step~3 gives good results across a wide range of displays with an sRGB<br/>		/// gamma curve or a similar one.<br/>		/// This process can cost performance.  There is an approximation that<br/>		/// does not need to know about the background color; see<br/>		/// https://bel.fi/alankila/lcd/ and<br/>		/// https://bel.fi/alankila/lcd/alpcor.html for details.<br/>		/// **ATTENTION**: Linear blending is even more important when dealing<br/>		/// with subpixel-rendered glyphs to prevent color-fringing!  A<br/>		/// subpixel-rendered glyph must first be filtered with a filter that<br/>		/// gives equal weight to the three color primaries and does not exceed a<br/>		/// sum of 0x100, see section <br/>		/// _rendering.  Then the only difference to<br/>		/// gray linear blending is that subpixel-rendered linear blending is done<br/>		/// 3~times per pixel: red foreground subpixel to red background subpixel<br/>		/// and so on for green and blue.<br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Render_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int RenderGlyph(this FTGlyphSlot slot, [NativeName(NativeNameType.Param, "render_mode")] [NativeName(NativeNameType.Type, "FT_Render_Mode")] FTRenderMode renderMode)
		{
			int ret = FreeType.FTRenderGlyphNative(slot, renderMode);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, parg2, pTransform);
			return ret;
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, parg2, pTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, parg2, pTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, parg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, parg2, pTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, parg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, parg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, parg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* pparg2 = &parg2)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, (int*)pparg2, pTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg2 = &parg2)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, (int*)pparg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg2 = &parg2)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, (int*)pparg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg2 = &parg2)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, (int*)pparg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (int* pparg2 = &parg2)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, (int*)pparg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, (int*)pparg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (int* pparg2 = &parg2)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, pTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (FTMatrix* ppTransform = &pTransform)
			{
				int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, parg2, (FTMatrix*)ppTransform);
				return ret;
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, parg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, parg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* pparg2 = &parg2)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_SubGlyph_Info<br/>		/// <br/>		/// :<br/>		/// Retrieve a description of a given subglyph.  Only use it if<br/>		/// `glyph->format` is <br/>		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>		/// otherwise.<br/>		/// <br/>		/// :<br/>		/// glyph ::<br/>		/// The source glyph slot.<br/>		/// sub_index ::<br/>		/// The index of the subglyph.  Must be less than<br/>		/// `glyph->num_subglyphs`.<br/>		/// <br/>		/// :<br/>		/// p_index ::<br/>		/// The glyph index of the subglyph.<br/>		/// p_flags ::<br/>		/// The subglyph flags, see <br/>		/// _SUBGLYPH_FLAG_XXX.<br/>		/// p_arg1 ::<br/>		/// The subglyph's first argument (if any).<br/>		/// p_arg2 ::<br/>		/// The subglyph's second argument (if any).<br/>		/// p_transform ::<br/>		/// The subglyph transformation (if any).<br/>		/// <br/>		/// <br/>		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetSubGlyphInfo(this FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt*")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int*")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix*")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (int* pparg2 = &parg2)
						{
							fixed (FTMatrix* ppTransform = &pTransform)
							{
								int ret = FreeType.FTGetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>		/// ************************************************************************<br/>		/// <br/>		/// FT_Get_Charmap_Index<br/>		/// <br/>		/// :<br/>		/// Retrieve index of a given charmap.<br/>		/// <br/>		/// :<br/>		/// charmap ::<br/>		/// A handle to a charmap.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "FT_Get_Charmap_Index")]
		[return: NativeName(NativeNameType.Type, "FT_Int")]
		public static int GetCharmapIndex(this FTCharMap charmap)
		{
			int ret = FreeType.FTGetCharmapIndexNative(charmap);
			return ret;
		}

	}
}
