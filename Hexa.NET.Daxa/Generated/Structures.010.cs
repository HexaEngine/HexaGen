// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Daxa
{

	[NativeName(NativeNameType.StructOrClass, "daxa_f64mat3x3")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaF64Mat3X3
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_f64vec3")]
		public DaxaF64Vec3 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_f64vec3")]
		public DaxaF64Vec3 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_f64vec3")]
		public DaxaF64Vec3 Z;

		public unsafe DaxaF64Mat3X3(DaxaF64Vec3 x = default, DaxaF64Vec3 y = default, DaxaF64Vec3 z = default)
		{
			X = x;
			Y = y;
			Z = z;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_f64mat3x4")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaF64Mat3X4
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_f64vec4")]
		public DaxaF64Vec4 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_f64vec4")]
		public DaxaF64Vec4 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_f64vec4")]
		public DaxaF64Vec4 Z;

		public unsafe DaxaF64Mat3X4(DaxaF64Vec4 x = default, DaxaF64Vec4 y = default, DaxaF64Vec4 z = default)
		{
			X = x;
			Y = y;
			Z = z;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_f32mat4x2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaF32Mat4X2
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_f32vec2")]
		public Vector2 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_f32vec2")]
		public Vector2 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_f32vec2")]
		public Vector2 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_f32vec2")]
		public Vector2 W;

		public unsafe DaxaF32Mat4X2(Vector2 x = default, Vector2 y = default, Vector2 z = default, Vector2 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_f32mat4x3")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaF32Mat4X3
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_f32vec3")]
		public Vector3 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_f32vec3")]
		public Vector3 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_f32vec3")]
		public Vector3 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_f32vec3")]
		public Vector3 W;

		public unsafe DaxaF32Mat4X3(Vector3 x = default, Vector3 y = default, Vector3 z = default, Vector3 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_f32mat4x4")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaF32Mat4X4
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_f32vec4")]
		public Vector4 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_f32vec4")]
		public Vector4 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_f32vec4")]
		public Vector4 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_f32vec4")]
		public Vector4 W;

		public unsafe DaxaF32Mat4X4(Vector4 x = default, Vector4 y = default, Vector4 z = default, Vector4 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_f64mat4x2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaF64Mat4X2
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_f64vec2")]
		public DaxaF64Vec2 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_f64vec2")]
		public DaxaF64Vec2 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_f64vec2")]
		public DaxaF64Vec2 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_f64vec2")]
		public DaxaF64Vec2 W;

		public unsafe DaxaF64Mat4X2(DaxaF64Vec2 x = default, DaxaF64Vec2 y = default, DaxaF64Vec2 z = default, DaxaF64Vec2 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_f64mat4x3")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaF64Mat4X3
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_f64vec3")]
		public DaxaF64Vec3 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_f64vec3")]
		public DaxaF64Vec3 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_f64vec3")]
		public DaxaF64Vec3 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_f64vec3")]
		public DaxaF64Vec3 W;

		public unsafe DaxaF64Mat4X3(DaxaF64Vec3 x = default, DaxaF64Vec3 y = default, DaxaF64Vec3 z = default, DaxaF64Vec3 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_f64mat4x4")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaF64Mat4X4
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_f64vec4")]
		public DaxaF64Vec4 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_f64vec4")]
		public DaxaF64Vec4 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_f64vec4")]
		public DaxaF64Vec4 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_f64vec4")]
		public DaxaF64Vec4 W;

		public unsafe DaxaF64Mat4X4(DaxaF64Vec4 x = default, DaxaF64Vec4 y = default, DaxaF64Vec4 z = default, DaxaF64Vec4 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_i32mat2x2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaI32Mat2X2
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_i32vec2")]
		public DaxaI32Vec2 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_i32vec2")]
		public DaxaI32Vec2 Y;

		public unsafe DaxaI32Mat2X2(DaxaI32Vec2 x = default, DaxaI32Vec2 y = default)
		{
			X = x;
			Y = y;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_i32mat2x3")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaI32Mat2X3
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_i32vec3")]
		public DaxaI32Vec3 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_i32vec3")]
		public DaxaI32Vec3 Y;

		public unsafe DaxaI32Mat2X3(DaxaI32Vec3 x = default, DaxaI32Vec3 y = default)
		{
			X = x;
			Y = y;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_i32mat2x4")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaI32Mat2X4
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_i32vec4")]
		public DaxaI32Vec4 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_i32vec4")]
		public DaxaI32Vec4 Y;

		public unsafe DaxaI32Mat2X4(DaxaI32Vec4 x = default, DaxaI32Vec4 y = default)
		{
			X = x;
			Y = y;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_u32mat2x2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaU32Mat2X2
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_u32vec2")]
		public DaxaU32Vec2 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_u32vec2")]
		public DaxaU32Vec2 Y;

		public unsafe DaxaU32Mat2X2(DaxaU32Vec2 x = default, DaxaU32Vec2 y = default)
		{
			X = x;
			Y = y;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_u32mat2x3")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaU32Mat2X3
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_u32vec3")]
		public DaxaU32Vec3 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_u32vec3")]
		public DaxaU32Vec3 Y;

		public unsafe DaxaU32Mat2X3(DaxaU32Vec3 x = default, DaxaU32Vec3 y = default)
		{
			X = x;
			Y = y;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_u32mat2x4")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaU32Mat2X4
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_u32vec4")]
		public DaxaU32Vec4 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_u32vec4")]
		public DaxaU32Vec4 Y;

		public unsafe DaxaU32Mat2X4(DaxaU32Vec4 x = default, DaxaU32Vec4 y = default)
		{
			X = x;
			Y = y;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_i32mat3x2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaI32Mat3X2
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_i32vec2")]
		public DaxaI32Vec2 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_i32vec2")]
		public DaxaI32Vec2 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_i32vec2")]
		public DaxaI32Vec2 Z;

		public unsafe DaxaI32Mat3X2(DaxaI32Vec2 x = default, DaxaI32Vec2 y = default, DaxaI32Vec2 z = default)
		{
			X = x;
			Y = y;
			Z = z;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_i32mat3x3")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaI32Mat3X3
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_i32vec3")]
		public DaxaI32Vec3 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_i32vec3")]
		public DaxaI32Vec3 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_i32vec3")]
		public DaxaI32Vec3 Z;

		public unsafe DaxaI32Mat3X3(DaxaI32Vec3 x = default, DaxaI32Vec3 y = default, DaxaI32Vec3 z = default)
		{
			X = x;
			Y = y;
			Z = z;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_i32mat3x4")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaI32Mat3X4
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_i32vec4")]
		public DaxaI32Vec4 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_i32vec4")]
		public DaxaI32Vec4 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_i32vec4")]
		public DaxaI32Vec4 Z;

		public unsafe DaxaI32Mat3X4(DaxaI32Vec4 x = default, DaxaI32Vec4 y = default, DaxaI32Vec4 z = default)
		{
			X = x;
			Y = y;
			Z = z;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_u32mat3x2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaU32Mat3X2
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_u32vec2")]
		public DaxaU32Vec2 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_u32vec2")]
		public DaxaU32Vec2 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_u32vec2")]
		public DaxaU32Vec2 Z;

		public unsafe DaxaU32Mat3X2(DaxaU32Vec2 x = default, DaxaU32Vec2 y = default, DaxaU32Vec2 z = default)
		{
			X = x;
			Y = y;
			Z = z;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_u32mat3x3")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaU32Mat3X3
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_u32vec3")]
		public DaxaU32Vec3 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_u32vec3")]
		public DaxaU32Vec3 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_u32vec3")]
		public DaxaU32Vec3 Z;

		public unsafe DaxaU32Mat3X3(DaxaU32Vec3 x = default, DaxaU32Vec3 y = default, DaxaU32Vec3 z = default)
		{
			X = x;
			Y = y;
			Z = z;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_u32mat3x4")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaU32Mat3X4
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_u32vec4")]
		public DaxaU32Vec4 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_u32vec4")]
		public DaxaU32Vec4 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_u32vec4")]
		public DaxaU32Vec4 Z;

		public unsafe DaxaU32Mat3X4(DaxaU32Vec4 x = default, DaxaU32Vec4 y = default, DaxaU32Vec4 z = default)
		{
			X = x;
			Y = y;
			Z = z;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_i32mat4x2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaI32Mat4X2
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_i32vec2")]
		public DaxaI32Vec2 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_i32vec2")]
		public DaxaI32Vec2 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_i32vec2")]
		public DaxaI32Vec2 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_i32vec2")]
		public DaxaI32Vec2 W;

		public unsafe DaxaI32Mat4X2(DaxaI32Vec2 x = default, DaxaI32Vec2 y = default, DaxaI32Vec2 z = default, DaxaI32Vec2 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_i32mat4x3")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaI32Mat4X3
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_i32vec3")]
		public DaxaI32Vec3 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_i32vec3")]
		public DaxaI32Vec3 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_i32vec3")]
		public DaxaI32Vec3 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_i32vec3")]
		public DaxaI32Vec3 W;

		public unsafe DaxaI32Mat4X3(DaxaI32Vec3 x = default, DaxaI32Vec3 y = default, DaxaI32Vec3 z = default, DaxaI32Vec3 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_i32mat4x4")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaI32Mat4X4
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_i32vec4")]
		public DaxaI32Vec4 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_i32vec4")]
		public DaxaI32Vec4 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_i32vec4")]
		public DaxaI32Vec4 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_i32vec4")]
		public DaxaI32Vec4 W;

		public unsafe DaxaI32Mat4X4(DaxaI32Vec4 x = default, DaxaI32Vec4 y = default, DaxaI32Vec4 z = default, DaxaI32Vec4 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_u32mat4x2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaU32Mat4X2
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_u32vec2")]
		public DaxaU32Vec2 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_u32vec2")]
		public DaxaU32Vec2 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_u32vec2")]
		public DaxaU32Vec2 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_u32vec2")]
		public DaxaU32Vec2 W;

		public unsafe DaxaU32Mat4X2(DaxaU32Vec2 x = default, DaxaU32Vec2 y = default, DaxaU32Vec2 z = default, DaxaU32Vec2 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_u32mat4x3")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaU32Mat4X3
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_u32vec3")]
		public DaxaU32Vec3 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_u32vec3")]
		public DaxaU32Vec3 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_u32vec3")]
		public DaxaU32Vec3 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_u32vec3")]
		public DaxaU32Vec3 W;

		public unsafe DaxaU32Mat4X3(DaxaU32Vec3 x = default, DaxaU32Vec3 y = default, DaxaU32Vec3 z = default, DaxaU32Vec3 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_u32mat4x4")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaU32Mat4X4
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "daxa_u32vec4")]
		public DaxaU32Vec4 X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "daxa_u32vec4")]
		public DaxaU32Vec4 Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "daxa_u32vec4")]
		public DaxaU32Vec4 Z;
		[NativeName(NativeNameType.Field, "w")]
		[NativeName(NativeNameType.Type, "daxa_u32vec4")]
		public DaxaU32Vec4 W;

		public unsafe DaxaU32Mat4X4(DaxaU32Vec4 x = default, DaxaU32Vec4 y = default, DaxaU32Vec4 z = default, DaxaU32Vec4 w = default)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}


	}

	/// <summary>
	/// ABI: Must stay compatible with 'VkAccelerationStructureInstanceKHR'<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "daxa_BlasInstanceData")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBlasInstanceData
	{
		[NativeName(NativeNameType.Field, "transform")]
		[NativeName(NativeNameType.Type, "daxa_f32mat3x4")]
		public DaxaF32Mat3X4 Transform;
		[NativeName(NativeNameType.Field, "instance_custom_index")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint InstanceCustomIndex;
		[NativeName(NativeNameType.Field, "mask")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Mask;
		[NativeName(NativeNameType.Field, "instance_shader_binding_table_record_offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint InstanceShaderBindingTableRecordOffset;
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Flags;
		[NativeName(NativeNameType.Field, "blas_device_address")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong BlasDeviceAddress;

		public unsafe DaxaBlasInstanceData(DaxaF32Mat3X4 transform = default, uint instanceCustomIndex = default, uint mask = default, uint instanceShaderBindingTableRecordOffset = default, uint flags = default, ulong blasDeviceAddress = default)
		{
			Transform = transform;
			InstanceCustomIndex = instanceCustomIndex;
			Mask = mask;
			InstanceShaderBindingTableRecordOffset = instanceShaderBindingTableRecordOffset;
			Flags = flags;
			BlasDeviceAddress = blasDeviceAddress;
		}


	}


	[NativeName(NativeNameType.StructOrClass, "daxa_ImageMipArraySlice")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageMipArraySlice
	{
		[NativeName(NativeNameType.Field, "base_mip_level")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint BaseMipLevel;
		[NativeName(NativeNameType.Field, "level_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint LevelCount;
		[NativeName(NativeNameType.Field, "base_array_layer")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint BaseArrayLayer;
		[NativeName(NativeNameType.Field, "layer_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint LayerCount;

		public unsafe DaxaImageMipArraySlice(uint baseMipLevel = default, uint levelCount = default, uint baseArrayLayer = default, uint layerCount = default)
		{
			BaseMipLevel = baseMipLevel;
			LevelCount = levelCount;
			BaseArrayLayer = baseArrayLayer;
			LayerCount = layerCount;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ImageArraySlice")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageArraySlice
	{
		[NativeName(NativeNameType.Field, "mip_level")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MipLevel;
		[NativeName(NativeNameType.Field, "base_array_layer")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint BaseArrayLayer;
		[NativeName(NativeNameType.Field, "layer_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint LayerCount;

		public unsafe DaxaImageArraySlice(uint mipLevel = default, uint baseArrayLayer = default, uint layerCount = default)
		{
			MipLevel = mipLevel;
			BaseArrayLayer = baseArrayLayer;
			LayerCount = layerCount;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ImageSlice")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageSlice
	{
		[NativeName(NativeNameType.Field, "mip_level")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MipLevel;
		[NativeName(NativeNameType.Field, "array_layer")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint ArrayLayer;

		public unsafe DaxaImageSlice(uint mipLevel = default, uint arrayLayer = default)
		{
			MipLevel = mipLevel;
			ArrayLayer = arrayLayer;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_MemoryBlockInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaMemoryBlockInfo
	{
		[NativeName(NativeNameType.Field, "requirements")]
		[NativeName(NativeNameType.Type, "VkMemoryRequirements")]
		public VkMemoryRequirements Requirements;
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "daxa_MemoryFlags")]
		public uint Flags;

		public unsafe DaxaMemoryBlockInfo(VkMemoryRequirements requirements = default, uint flags = default)
		{
			Requirements = requirements;
			Flags = flags;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_TimelineQueryPoolInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaTimelineQueryPoolInfo
	{
		[NativeName(NativeNameType.Field, "query_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint QueryCount;
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaTimelineQueryPoolInfo(uint queryCount = default, DaxaSmallString name = default)
		{
			QueryCount = queryCount;
			Name = name;
		}


	}

	/// <summary>
	/// <br/>
	/// Provided for informative purpose, e.g. to gather statistics about number of<br/>
	/// allocations or total amount of memory allocated in Vulkan.<br/>
	/// Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDeviceMemoryCallbacks")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDeviceMemoryCallbacks
	{
		/// <summary>
		/// Optional, can be null.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pfnAllocate")]
		[NativeName(NativeNameType.Type, "PFN_vmaAllocateDeviceMemoryFunction")]
		public unsafe void* PfnAllocate;
		/// <summary>
		/// Optional, can be null.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pfnFree")]
		[NativeName(NativeNameType.Type, "PFN_vmaFreeDeviceMemoryFunction")]
		public unsafe void* PfnFree;
		/// <summary>
		/// Optional, can be null.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;


		public unsafe VmaDeviceMemoryCallbacks(PFNVmaAllocateDeviceMemoryFunction pfnAllocate = default, PFNVmaFreeDeviceMemoryFunction pfnFree = default, void* pUserData = default)
		{
			PfnAllocate = (void*)Marshal.GetFunctionPointerForDelegate(pfnAllocate);
			PfnFree = (void*)Marshal.GetFunctionPointerForDelegate(pfnFree);
			PUserData = pUserData;
		}


	}

	/// <summary>
	/// <br/>
	/// Used in VmaAllocatorCreateInfo::pVulkanFunctions.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaVulkanFunctions")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaVulkanFunctions
	{
		/// <summary>
		/// Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetInstanceProcAddr")]
		[NativeName(NativeNameType.Type, "PFN_vkGetInstanceProcAddr")]
		public unsafe void* VkGetInstanceProcAddr;
		/// <summary>
		/// Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetDeviceProcAddr")]
		[NativeName(NativeNameType.Type, "PFN_vkGetDeviceProcAddr")]
		public unsafe void* VkGetDeviceProcAddr;
		[NativeName(NativeNameType.Field, "vkGetPhysicalDeviceProperties")]
		[NativeName(NativeNameType.Type, "PFN_vkGetPhysicalDeviceProperties")]
		public unsafe void* VkGetPhysicalDeviceProperties;
		[NativeName(NativeNameType.Field, "vkGetPhysicalDeviceMemoryProperties")]
		[NativeName(NativeNameType.Type, "PFN_vkGetPhysicalDeviceMemoryProperties")]
		public unsafe void* VkGetPhysicalDeviceMemoryProperties;
		[NativeName(NativeNameType.Field, "vkAllocateMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkAllocateMemory")]
		public unsafe void* VkAllocateMemory;
		[NativeName(NativeNameType.Field, "vkFreeMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkFreeMemory")]
		public unsafe void* VkFreeMemory;
		[NativeName(NativeNameType.Field, "vkMapMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkMapMemory")]
		public unsafe void* VkMapMemory;
		[NativeName(NativeNameType.Field, "vkUnmapMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkUnmapMemory")]
		public unsafe void* VkUnmapMemory;
		[NativeName(NativeNameType.Field, "vkFlushMappedMemoryRanges")]
		[NativeName(NativeNameType.Type, "PFN_vkFlushMappedMemoryRanges")]
		public unsafe void* VkFlushMappedMemoryRanges;
		[NativeName(NativeNameType.Field, "vkInvalidateMappedMemoryRanges")]
		[NativeName(NativeNameType.Type, "PFN_vkInvalidateMappedMemoryRanges")]
		public unsafe void* VkInvalidateMappedMemoryRanges;
		[NativeName(NativeNameType.Field, "vkBindBufferMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkBindBufferMemory")]
		public unsafe void* VkBindBufferMemory;
		[NativeName(NativeNameType.Field, "vkBindImageMemory")]
		[NativeName(NativeNameType.Type, "PFN_vkBindImageMemory")]
		public unsafe void* VkBindImageMemory;
		[NativeName(NativeNameType.Field, "vkGetBufferMemoryRequirements")]
		[NativeName(NativeNameType.Type, "PFN_vkGetBufferMemoryRequirements")]
		public unsafe void* VkGetBufferMemoryRequirements;
		[NativeName(NativeNameType.Field, "vkGetImageMemoryRequirements")]
		[NativeName(NativeNameType.Type, "PFN_vkGetImageMemoryRequirements")]
		public unsafe void* VkGetImageMemoryRequirements;
		[NativeName(NativeNameType.Field, "vkCreateBuffer")]
		[NativeName(NativeNameType.Type, "PFN_vkCreateBuffer")]
		public unsafe void* VkCreateBuffer;
		[NativeName(NativeNameType.Field, "vkDestroyBuffer")]
		[NativeName(NativeNameType.Type, "PFN_vkDestroyBuffer")]
		public unsafe void* VkDestroyBuffer;
		[NativeName(NativeNameType.Field, "vkCreateImage")]
		[NativeName(NativeNameType.Type, "PFN_vkCreateImage")]
		public unsafe void* VkCreateImage;
		[NativeName(NativeNameType.Field, "vkDestroyImage")]
		[NativeName(NativeNameType.Type, "PFN_vkDestroyImage")]
		public unsafe void* VkDestroyImage;
		[NativeName(NativeNameType.Field, "vkCmdCopyBuffer")]
		[NativeName(NativeNameType.Type, "PFN_vkCmdCopyBuffer")]
		public unsafe void* VkCmdCopyBuffer;
		/// <summary>
		/// Fetch "vkGetBufferMemoryRequirements2" on Vulkan >= 1.1, fetch "vkGetBufferMemoryRequirements2KHR" when using VK_KHR_dedicated_allocation extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetBufferMemoryRequirements2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkGetBufferMemoryRequirements2KHR")]
		public unsafe void* VkGetBufferMemoryRequirements2KHR;
		/// <summary>
		/// Fetch "vkGetImageMemoryRequirements2" on Vulkan >= 1.1, fetch "vkGetImageMemoryRequirements2KHR" when using VK_KHR_dedicated_allocation extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetImageMemoryRequirements2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkGetImageMemoryRequirements2KHR")]
		public unsafe void* VkGetImageMemoryRequirements2KHR;
		/// <summary>
		/// Fetch "vkBindBufferMemory2" on Vulkan >= 1.1, fetch "vkBindBufferMemory2KHR" when using VK_KHR_bind_memory2 extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkBindBufferMemory2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkBindBufferMemory2KHR")]
		public unsafe void* VkBindBufferMemory2KHR;
		/// <summary>
		/// Fetch "vkBindImageMemory2" on Vulkan >= 1.1, fetch "vkBindImageMemory2KHR" when using VK_KHR_bind_memory2 extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkBindImageMemory2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkBindImageMemory2KHR")]
		public unsafe void* VkBindImageMemory2KHR;
		/// <summary>
		/// Fetch from "vkGetPhysicalDeviceMemoryProperties2" on Vulkan >= 1.1, but you can also fetch it from "vkGetPhysicalDeviceMemoryProperties2KHR" if you enabled extension VK_KHR_get_physical_device_properties2.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetPhysicalDeviceMemoryProperties2KHR")]
		[NativeName(NativeNameType.Type, "PFN_vkGetPhysicalDeviceMemoryProperties2KHR")]
		public unsafe void* VkGetPhysicalDeviceMemoryProperties2KHR;
		/// <summary>
		/// Fetch from "vkGetDeviceBufferMemoryRequirements" on Vulkan >= 1.3, but you can also fetch it from "vkGetDeviceBufferMemoryRequirementsKHR" if you enabled extension VK_KHR_maintenance4.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetDeviceBufferMemoryRequirements")]
		[NativeName(NativeNameType.Type, "PFN_vkGetDeviceBufferMemoryRequirementsKHR")]
		public unsafe void* VkGetDeviceBufferMemoryRequirements;
		/// <summary>
		/// Fetch from "vkGetDeviceImageMemoryRequirements" on Vulkan >= 1.3, but you can also fetch it from "vkGetDeviceImageMemoryRequirementsKHR" if you enabled extension VK_KHR_maintenance4.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vkGetDeviceImageMemoryRequirements")]
		[NativeName(NativeNameType.Type, "PFN_vkGetDeviceImageMemoryRequirementsKHR")]
		public unsafe void* VkGetDeviceImageMemoryRequirements;

		public unsafe VmaVulkanFunctions(PFNVkGetInstanceProcAddr vkGetInstanceProcAddr = default, PFNVkGetDeviceProcAddr vkGetDeviceProcAddr = default, PFNVkGetPhysicalDeviceProperties vkGetPhysicalDeviceProperties = default, PFNVkGetPhysicalDeviceMemoryProperties vkGetPhysicalDeviceMemoryProperties = default, PFNVkAllocateMemory vkAllocateMemory = default, PFNVkFreeMemory vkFreeMemory = default, PFNVkMapMemory vkMapMemory = default, PFNVkUnmapMemory vkUnmapMemory = default, PFNVkFlushMappedMemoryRanges vkFlushMappedMemoryRanges = default, PFNVkInvalidateMappedMemoryRanges vkInvalidateMappedMemoryRanges = default, PFNVkBindBufferMemory vkBindBufferMemory = default, PFNVkBindImageMemory vkBindImageMemory = default, PFNVkGetBufferMemoryRequirements vkGetBufferMemoryRequirements = default, PFNVkGetImageMemoryRequirements vkGetImageMemoryRequirements = default, PFNVkCreateBuffer vkCreateBuffer = default, PFNVkDestroyBuffer vkDestroyBuffer = default, PFNVkCreateImage vkCreateImage = default, PFNVkDestroyImage vkDestroyImage = default, PFNVkCmdCopyBuffer vkCmdCopyBuffer = default, PFNVkGetBufferMemoryRequirements2KHR vkGetBufferMemoryRequirements2KHR = default, PFNVkGetImageMemoryRequirements2KHR vkGetImageMemoryRequirements2KHR = default, PFNVkBindBufferMemory2KHR vkBindBufferMemory2KHR = default, PFNVkBindImageMemory2KHR vkBindImageMemory2KHR = default, PFNVkGetPhysicalDeviceMemoryProperties2KHR vkGetPhysicalDeviceMemoryProperties2KHR = default, PFNVkGetDeviceBufferMemoryRequirementsKHR vkGetDeviceBufferMemoryRequirements = default, PFNVkGetDeviceImageMemoryRequirementsKHR vkGetDeviceImageMemoryRequirements = default)
		{
			VkGetInstanceProcAddr = (void*)Marshal.GetFunctionPointerForDelegate(vkGetInstanceProcAddr);
			VkGetDeviceProcAddr = (void*)Marshal.GetFunctionPointerForDelegate(vkGetDeviceProcAddr);
			VkGetPhysicalDeviceProperties = (void*)Marshal.GetFunctionPointerForDelegate(vkGetPhysicalDeviceProperties);
			VkGetPhysicalDeviceMemoryProperties = (void*)Marshal.GetFunctionPointerForDelegate(vkGetPhysicalDeviceMemoryProperties);
			VkAllocateMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkAllocateMemory);
			VkFreeMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkFreeMemory);
			VkMapMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkMapMemory);
			VkUnmapMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkUnmapMemory);
			VkFlushMappedMemoryRanges = (void*)Marshal.GetFunctionPointerForDelegate(vkFlushMappedMemoryRanges);
			VkInvalidateMappedMemoryRanges = (void*)Marshal.GetFunctionPointerForDelegate(vkInvalidateMappedMemoryRanges);
			VkBindBufferMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkBindBufferMemory);
			VkBindImageMemory = (void*)Marshal.GetFunctionPointerForDelegate(vkBindImageMemory);
			VkGetBufferMemoryRequirements = (void*)Marshal.GetFunctionPointerForDelegate(vkGetBufferMemoryRequirements);
			VkGetImageMemoryRequirements = (void*)Marshal.GetFunctionPointerForDelegate(vkGetImageMemoryRequirements);
			VkCreateBuffer = (void*)Marshal.GetFunctionPointerForDelegate(vkCreateBuffer);
			VkDestroyBuffer = (void*)Marshal.GetFunctionPointerForDelegate(vkDestroyBuffer);
			VkCreateImage = (void*)Marshal.GetFunctionPointerForDelegate(vkCreateImage);
			VkDestroyImage = (void*)Marshal.GetFunctionPointerForDelegate(vkDestroyImage);
			VkCmdCopyBuffer = (void*)Marshal.GetFunctionPointerForDelegate(vkCmdCopyBuffer);
			VkGetBufferMemoryRequirements2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkGetBufferMemoryRequirements2KHR);
			VkGetImageMemoryRequirements2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkGetImageMemoryRequirements2KHR);
			VkBindBufferMemory2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkBindBufferMemory2KHR);
			VkBindImageMemory2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkBindImageMemory2KHR);
			VkGetPhysicalDeviceMemoryProperties2KHR = (void*)Marshal.GetFunctionPointerForDelegate(vkGetPhysicalDeviceMemoryProperties2KHR);
			VkGetDeviceBufferMemoryRequirements = (void*)Marshal.GetFunctionPointerForDelegate(vkGetDeviceBufferMemoryRequirements);
			VkGetDeviceImageMemoryRequirements = (void*)Marshal.GetFunctionPointerForDelegate(vkGetDeviceImageMemoryRequirements);
		}


	}

	/// <summary>
	/// Description of a Allocator to be created.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocatorCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocatorCreateInfo
	{
		/// <summary>
		/// Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaAllocatorCreateFlags")]
		public VmaAllocatorCreateFlagBits Flags;

		/// <summary>
		/// Vulkan physical device.<br/>
		/// It must be valid throughout whole lifetime of created allocator. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "physicalDevice")]
		[NativeName(NativeNameType.Type, "VkPhysicalDevice")]
		public VkPhysicalDevice PhysicalDevice;

		/// <summary>
		/// Vulkan device.<br/>
		/// It must be valid throughout whole lifetime of created allocator. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "device")]
		[NativeName(NativeNameType.Type, "VkDevice")]
		public VkDevice Device;

		/// <summary>
		/// Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional.<br/>
		/// Set to 0 to use default, which is currently 256 MiB. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "preferredLargeHeapBlockSize")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong PreferredLargeHeapBlockSize;

		/// <summary>
		/// Custom CPU memory allocation callbacks. Optional.<br/>
		/// Optional, can be null. When specified, will also be used for all CPU-side memory allocations. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pAllocationCallbacks")]
		[NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")]
		public unsafe VkAllocationCallbacks* PAllocationCallbacks;

		/// <summary>
		/// Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional.<br/>
		/// Optional, can be null. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pDeviceMemoryCallbacks")]
		[NativeName(NativeNameType.Type, "const VmaDeviceMemoryCallbacks*")]
		public unsafe VmaDeviceMemoryCallbacks* PDeviceMemoryCallbacks;

		/// <summary>
		/// <br/>
		/// If not NULL, it must be a pointer to an array of<br/>
		/// `VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on<br/>
		/// maximum number of bytes that can be allocated out of particular Vulkan memory<br/>
		/// heap.<br/>
		/// Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that<br/>
		/// heap. This is also the default in case of `pHeapSizeLimit` = NULL.<br/>
		/// If there is a limit defined for a heap:<br/>
		/// - If user tries to allocate more memory from that heap using this allocator,<br/>
		/// the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`.<br/>
		/// - If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the<br/>
		/// value of this limit will be reported instead when using vmaGetMemoryProperties().<br/>
		/// Warning! Using this feature may not be equivalent to installing a GPU with<br/>
		/// smaller amount of memory, because graphics driver doesn't necessary fail new<br/>
		/// allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is<br/>
		/// exceeded. It may return success and just silently migrate some device memory<br/>
		/// blocks to system RAM. This driver behavior can also be controlled using<br/>
		/// VK_AMD_memory_overallocation_behavior extension.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pHeapSizeLimit")]
		[NativeName(NativeNameType.Type, "const VkDeviceSize*")]
		public unsafe ulong* PHeapSizeLimit;

		/// <summary>
		/// <br/>
		/// For details see [Pointers to Vulkan functions](<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pVulkanFunctions")]
		[NativeName(NativeNameType.Type, "const VmaVulkanFunctions*")]
		public unsafe VmaVulkanFunctions* PVulkanFunctions;

		/// <summary>
		/// <br/>
		/// Starting from version 3.0.0 this member is no longer optional, it must be set!<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "instance")]
		[NativeName(NativeNameType.Type, "VkInstance")]
		public VkInstance Instance;

		/// <summary>
		/// <br/>
		/// It must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like: `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`.<br/>
		/// The patch version number specified is ignored. Only the major and minor versions are considered.<br/>
		/// Only versions 1.0, 1.1, 1.2, 1.3 are supported by the current implementation.<br/>
		/// Leaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`.<br/>
		/// It must match the Vulkan version used by the application and supported on the selected physical device,<br/>
		/// so it must be no higher than `VkApplicationInfo::apiVersion` passed to `vkCreateInstance`<br/>
		/// and no higher than `VkPhysicalDeviceProperties::apiVersion` found on the physical device used.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "vulkanApiVersion")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint VulkanApiVersion;

		/// <summary>
		/// <br/>
		/// If not NULL, it must be a pointer to an array of `VkPhysicalDeviceMemoryProperties::memoryTypeCount`<br/>
		/// elements, defining external memory handle types of particular Vulkan memory type,<br/>
		/// to be passed using `VkExportMemoryAllocateInfoKHR`.<br/>
		/// Any of the elements may be equal to 0, which means not to use `VkExportMemoryAllocateInfoKHR` on this memory type.<br/>
		/// This is also the default in case of `pTypeExternalMemoryHandleTypes` = NULL.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pTypeExternalMemoryHandleTypes")]
		[NativeName(NativeNameType.Type, "const VkExternalMemoryHandleTypeFlagsKHR*")]
		public unsafe VkExternalMemoryHandleTypeFlagBits* PTypeExternalMemoryHandleTypes;


		public unsafe VmaAllocatorCreateInfo(VmaAllocatorCreateFlagBits flags = default, VkPhysicalDevice physicalDevice = default, VkDevice device = default, ulong preferredLargeHeapBlockSize = default, VkAllocationCallbacks* pAllocationCallbacks = default, VmaDeviceMemoryCallbacks* pDeviceMemoryCallbacks = default, ulong* pHeapSizeLimit = default, VmaVulkanFunctions* pVulkanFunctions = default, VkInstance instance = default, uint vulkanApiVersion = default, VkExternalMemoryHandleTypeFlagBits* pTypeExternalMemoryHandleTypes = default)
		{
			Flags = flags;
			PhysicalDevice = physicalDevice;
			Device = device;
			PreferredLargeHeapBlockSize = preferredLargeHeapBlockSize;
			PAllocationCallbacks = pAllocationCallbacks;
			PDeviceMemoryCallbacks = pDeviceMemoryCallbacks;
			PHeapSizeLimit = pHeapSizeLimit;
			PVulkanFunctions = pVulkanFunctions;
			Instance = instance;
			VulkanApiVersion = vulkanApiVersion;
			PTypeExternalMemoryHandleTypes = pTypeExternalMemoryHandleTypes;
		}


	}

	/// <summary>
	/// Information about existing #VmaAllocator object.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocatorInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocatorInfo
	{
		/// <summary>
		/// <br/>
		/// This is the same value as has been passed through VmaAllocatorCreateInfo::instance.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "instance")]
		[NativeName(NativeNameType.Type, "VkInstance")]
		public VkInstance Instance;

		/// <summary>
		/// <br/>
		/// This is the same value as has been passed through VmaAllocatorCreateInfo::physicalDevice.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "physicalDevice")]
		[NativeName(NativeNameType.Type, "VkPhysicalDevice")]
		public VkPhysicalDevice PhysicalDevice;

		/// <summary>
		/// <br/>
		/// This is the same value as has been passed through VmaAllocatorCreateInfo::device.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "device")]
		[NativeName(NativeNameType.Type, "VkDevice")]
		public VkDevice Device;


		public unsafe VmaAllocatorInfo(VkInstance instance = default, VkPhysicalDevice physicalDevice = default, VkDevice device = default)
		{
			Instance = instance;
			PhysicalDevice = physicalDevice;
			Device = device;
		}


	}

	/// <summary>
	/// <br/>
	/// These are fast to calculate.<br/>
	/// See functions: vmaGetHeapBudgets(), vmaGetPoolStatistics().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaStatistics")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaStatistics
	{
		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "blockCount")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint BlockCount;

		/// <summary>
		/// <br/>
		/// Dedicated allocations have their own blocks, so each one adds 1 to `allocationCount` as well as `blockCount`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationCount")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint AllocationCount;

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "blockBytes")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BlockBytes;

		/// <summary>
		/// <br/>
		/// Always less or equal than `blockBytes`.<br/>
		/// Difference `(blockBytes - allocationBytes)` is the amount of memory allocated from Vulkan<br/>
		/// but unused by any #VmaAllocation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationBytes")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong AllocationBytes;


		public unsafe VmaStatistics(uint blockCount = default, uint allocationCount = default, ulong blockBytes = default, ulong allocationBytes = default)
		{
			BlockCount = blockCount;
			AllocationCount = allocationCount;
			BlockBytes = blockBytes;
			AllocationBytes = allocationBytes;
		}


	}

	/// <summary>
	/// <br/>
	/// These are slower to calculate. Use for debugging purposes.<br/>
	/// See functions: vmaCalculateStatistics(), vmaCalculatePoolStatistics().<br/>
	/// Previous version of the statistics API provided averages, but they have been removed<br/>
	/// because they can be easily calculated as:<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDetailedStatistics")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDetailedStatistics
	{
		/// <summary>
		/// Basic statistics.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "statistics")]
		[NativeName(NativeNameType.Type, "VmaStatistics")]
		public VmaStatistics Statistics;

		/// <summary>
		/// Number of free ranges of memory between allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "unusedRangeCount")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint UnusedRangeCount;

		/// <summary>
		/// Smallest allocation size. `VK_WHOLE_SIZE` if there are 0 allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationSizeMin")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong AllocationSizeMin;

		/// <summary>
		/// Largest allocation size. 0 if there are 0 allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationSizeMax")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong AllocationSizeMax;

		/// <summary>
		/// Smallest empty range size. `VK_WHOLE_SIZE` if there are 0 empty ranges.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "unusedRangeSizeMin")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong UnusedRangeSizeMin;

		/// <summary>
		/// Largest empty range size. 0 if there are 0 empty ranges.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "unusedRangeSizeMax")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong UnusedRangeSizeMax;


		public unsafe VmaDetailedStatistics(VmaStatistics statistics = default, uint unusedRangeCount = default, ulong allocationSizeMin = default, ulong allocationSizeMax = default, ulong unusedRangeSizeMin = default, ulong unusedRangeSizeMax = default)
		{
			Statistics = statistics;
			UnusedRangeCount = unusedRangeCount;
			AllocationSizeMin = allocationSizeMin;
			AllocationSizeMax = allocationSizeMax;
			UnusedRangeSizeMin = unusedRangeSizeMin;
			UnusedRangeSizeMax = unusedRangeSizeMax;
		}


	}

	/// <summary>
	/// <br/>
	/// These are slower to calculate. Use for debugging purposes.<br/>
	/// See function vmaCalculateStatistics().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaTotalStatistics")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaTotalStatistics
	{
		[NativeName(NativeNameType.Field, "memoryType")]
		[NativeName(NativeNameType.Type, "VmaDetailedStatistics[32]")]
		public VmaDetailedStatistics MemoryType_0;
		public VmaDetailedStatistics MemoryType_1;
		public VmaDetailedStatistics MemoryType_2;
		public VmaDetailedStatistics MemoryType_3;
		public VmaDetailedStatistics MemoryType_4;
		public VmaDetailedStatistics MemoryType_5;
		public VmaDetailedStatistics MemoryType_6;
		public VmaDetailedStatistics MemoryType_7;
		public VmaDetailedStatistics MemoryType_8;
		public VmaDetailedStatistics MemoryType_9;
		public VmaDetailedStatistics MemoryType_10;
		public VmaDetailedStatistics MemoryType_11;
		public VmaDetailedStatistics MemoryType_12;
		public VmaDetailedStatistics MemoryType_13;
		public VmaDetailedStatistics MemoryType_14;
		public VmaDetailedStatistics MemoryType_15;
		public VmaDetailedStatistics MemoryType_16;
		public VmaDetailedStatistics MemoryType_17;
		public VmaDetailedStatistics MemoryType_18;
		public VmaDetailedStatistics MemoryType_19;
		public VmaDetailedStatistics MemoryType_20;
		public VmaDetailedStatistics MemoryType_21;
		public VmaDetailedStatistics MemoryType_22;
		public VmaDetailedStatistics MemoryType_23;
		public VmaDetailedStatistics MemoryType_24;
		public VmaDetailedStatistics MemoryType_25;
		public VmaDetailedStatistics MemoryType_26;
		public VmaDetailedStatistics MemoryType_27;
		public VmaDetailedStatistics MemoryType_28;
		public VmaDetailedStatistics MemoryType_29;
		public VmaDetailedStatistics MemoryType_30;
		public VmaDetailedStatistics MemoryType_31;
		[NativeName(NativeNameType.Field, "memoryHeap")]
		[NativeName(NativeNameType.Type, "VmaDetailedStatistics[16]")]
		public VmaDetailedStatistics MemoryHeap_0;
		public VmaDetailedStatistics MemoryHeap_1;
		public VmaDetailedStatistics MemoryHeap_2;
		public VmaDetailedStatistics MemoryHeap_3;
		public VmaDetailedStatistics MemoryHeap_4;
		public VmaDetailedStatistics MemoryHeap_5;
		public VmaDetailedStatistics MemoryHeap_6;
		public VmaDetailedStatistics MemoryHeap_7;
		public VmaDetailedStatistics MemoryHeap_8;
		public VmaDetailedStatistics MemoryHeap_9;
		public VmaDetailedStatistics MemoryHeap_10;
		public VmaDetailedStatistics MemoryHeap_11;
		public VmaDetailedStatistics MemoryHeap_12;
		public VmaDetailedStatistics MemoryHeap_13;
		public VmaDetailedStatistics MemoryHeap_14;
		public VmaDetailedStatistics MemoryHeap_15;
		[NativeName(NativeNameType.Field, "total")]
		[NativeName(NativeNameType.Type, "VmaDetailedStatistics")]
		public VmaDetailedStatistics Total;

		public unsafe VmaTotalStatistics(VmaDetailedStatistics* memoryType = default, VmaDetailedStatistics* memoryHeap = default, VmaDetailedStatistics total = default)
		{
			if (memoryType != default)
			{
				MemoryType_0 = memoryType[0];
				MemoryType_1 = memoryType[1];
				MemoryType_2 = memoryType[2];
				MemoryType_3 = memoryType[3];
				MemoryType_4 = memoryType[4];
				MemoryType_5 = memoryType[5];
				MemoryType_6 = memoryType[6];
				MemoryType_7 = memoryType[7];
				MemoryType_8 = memoryType[8];
				MemoryType_9 = memoryType[9];
				MemoryType_10 = memoryType[10];
				MemoryType_11 = memoryType[11];
				MemoryType_12 = memoryType[12];
				MemoryType_13 = memoryType[13];
				MemoryType_14 = memoryType[14];
				MemoryType_15 = memoryType[15];
				MemoryType_16 = memoryType[16];
				MemoryType_17 = memoryType[17];
				MemoryType_18 = memoryType[18];
				MemoryType_19 = memoryType[19];
				MemoryType_20 = memoryType[20];
				MemoryType_21 = memoryType[21];
				MemoryType_22 = memoryType[22];
				MemoryType_23 = memoryType[23];
				MemoryType_24 = memoryType[24];
				MemoryType_25 = memoryType[25];
				MemoryType_26 = memoryType[26];
				MemoryType_27 = memoryType[27];
				MemoryType_28 = memoryType[28];
				MemoryType_29 = memoryType[29];
				MemoryType_30 = memoryType[30];
				MemoryType_31 = memoryType[31];
			}
			if (memoryHeap != default)
			{
				MemoryHeap_0 = memoryHeap[0];
				MemoryHeap_1 = memoryHeap[1];
				MemoryHeap_2 = memoryHeap[2];
				MemoryHeap_3 = memoryHeap[3];
				MemoryHeap_4 = memoryHeap[4];
				MemoryHeap_5 = memoryHeap[5];
				MemoryHeap_6 = memoryHeap[6];
				MemoryHeap_7 = memoryHeap[7];
				MemoryHeap_8 = memoryHeap[8];
				MemoryHeap_9 = memoryHeap[9];
				MemoryHeap_10 = memoryHeap[10];
				MemoryHeap_11 = memoryHeap[11];
				MemoryHeap_12 = memoryHeap[12];
				MemoryHeap_13 = memoryHeap[13];
				MemoryHeap_14 = memoryHeap[14];
				MemoryHeap_15 = memoryHeap[15];
			}
			Total = total;
		}

		public unsafe VmaTotalStatistics(Span<VmaDetailedStatistics> memoryType = default, Span<VmaDetailedStatistics> memoryHeap = default, VmaDetailedStatistics total = default)
		{
			if (memoryType != default)
			{
				MemoryType_0 = memoryType[0];
				MemoryType_1 = memoryType[1];
				MemoryType_2 = memoryType[2];
				MemoryType_3 = memoryType[3];
				MemoryType_4 = memoryType[4];
				MemoryType_5 = memoryType[5];
				MemoryType_6 = memoryType[6];
				MemoryType_7 = memoryType[7];
				MemoryType_8 = memoryType[8];
				MemoryType_9 = memoryType[9];
				MemoryType_10 = memoryType[10];
				MemoryType_11 = memoryType[11];
				MemoryType_12 = memoryType[12];
				MemoryType_13 = memoryType[13];
				MemoryType_14 = memoryType[14];
				MemoryType_15 = memoryType[15];
				MemoryType_16 = memoryType[16];
				MemoryType_17 = memoryType[17];
				MemoryType_18 = memoryType[18];
				MemoryType_19 = memoryType[19];
				MemoryType_20 = memoryType[20];
				MemoryType_21 = memoryType[21];
				MemoryType_22 = memoryType[22];
				MemoryType_23 = memoryType[23];
				MemoryType_24 = memoryType[24];
				MemoryType_25 = memoryType[25];
				MemoryType_26 = memoryType[26];
				MemoryType_27 = memoryType[27];
				MemoryType_28 = memoryType[28];
				MemoryType_29 = memoryType[29];
				MemoryType_30 = memoryType[30];
				MemoryType_31 = memoryType[31];
			}
			if (memoryHeap != default)
			{
				MemoryHeap_0 = memoryHeap[0];
				MemoryHeap_1 = memoryHeap[1];
				MemoryHeap_2 = memoryHeap[2];
				MemoryHeap_3 = memoryHeap[3];
				MemoryHeap_4 = memoryHeap[4];
				MemoryHeap_5 = memoryHeap[5];
				MemoryHeap_6 = memoryHeap[6];
				MemoryHeap_7 = memoryHeap[7];
				MemoryHeap_8 = memoryHeap[8];
				MemoryHeap_9 = memoryHeap[9];
				MemoryHeap_10 = memoryHeap[10];
				MemoryHeap_11 = memoryHeap[11];
				MemoryHeap_12 = memoryHeap[12];
				MemoryHeap_13 = memoryHeap[13];
				MemoryHeap_14 = memoryHeap[14];
				MemoryHeap_15 = memoryHeap[15];
			}
			Total = total;
		}


		public unsafe Span<VmaDetailedStatistics> MemoryType
		
		{
			get
			{
				fixed (VmaDetailedStatistics* p = &this.MemoryType_0)
				{
					return new Span<VmaDetailedStatistics>(p, 32);
				}
			}
		}
		public unsafe Span<VmaDetailedStatistics> MemoryHeap
		
		{
			get
			{
				fixed (VmaDetailedStatistics* p = &this.MemoryHeap_0)
				{
					return new Span<VmaDetailedStatistics>(p, 16);
				}
			}
		}
	}

	/// <summary>
	/// <br/>
	/// These are fast to calculate.<br/>
	/// See function vmaGetHeapBudgets().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaBudget")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaBudget
	{
		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "statistics")]
		[NativeName(NativeNameType.Type, "VmaStatistics")]
		public VmaStatistics Statistics;

		/// <summary>
		/// <br/>
		/// Fetched from system using VK_EXT_memory_budget extension if enabled.<br/>
		/// It might be different than `statistics.blockBytes` (usually higher) due to additional implicit objects<br/>
		/// also occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or<br/>
		/// `VkDeviceMemory` blocks allocated outside of this library, if any.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "usage")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Usage;

		/// <summary>
		/// <br/>
		/// Fetched from system using VK_EXT_memory_budget extension if enabled.<br/>
		/// It might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to factors<br/>
		/// external to the program, decided by the operating system.<br/>
		/// Difference `budget - usage` is the amount of additional memory that can probably<br/>
		/// be allocated without problems. Exceeding the budget may result in various problems.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "budget")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Budget;


		public unsafe VmaBudget(VmaStatistics statistics = default, ulong usage = default, ulong budget = default)
		{
			Statistics = statistics;
			Usage = usage;
			Budget = budget;
		}


	}

	/// <summary>
	/// <br/>
	/// To be used with functions like vmaCreateBuffer(), vmaCreateImage(), and many others.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocationCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocationCreateInfo
	{
		/// <summary>
		/// Use #VmaAllocationCreateFlagBits enum.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaAllocationCreateFlags")]
		public VmaAllocationCreateFlagBits Flags;

		/// <summary>
		/// <br/>
		/// You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. <br/>
		/// If `pool` is not null, this member is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "usage")]
		[NativeName(NativeNameType.Type, "VmaMemoryUsage")]
		public VmaMemoryUsage Usage;

		/// <summary>
		/// <br/>
		/// Leave 0 if you specify memory requirements in other way. <br/>
		/// If `pool` is not null, this member is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "requiredFlags")]
		[NativeName(NativeNameType.Type, "VkMemoryPropertyFlags")]
		public uint RequiredFlags;

		/// <summary>
		/// <br/>
		/// Set to 0 if no additional flags are preferred. <br/>
		/// If `pool` is not null, this member is ignored. <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "preferredFlags")]
		[NativeName(NativeNameType.Type, "VkMemoryPropertyFlags")]
		public uint PreferredFlags;

		/// <summary>
		/// <br/>
		/// Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if<br/>
		/// it meets other requirements specified by this structure, with no further<br/>
		/// restrictions on memory type index. <br/>
		/// If `pool` is not null, this member is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "memoryTypeBits")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MemoryTypeBits;

		/// <summary>
		/// <br/>
		/// Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:<br/>
		/// `usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pool")]
		[NativeName(NativeNameType.Type, "VmaPool")]
		public VmaPool Pool;

		/// <summary>
		/// <br/>
		/// If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either<br/>
		/// null or pointer to a null-terminated string. The string will be then copied to<br/>
		/// internal buffer, so it doesn't need to be valid after allocation call.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;

		/// <summary>
		/// <br/>
		/// It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object<br/>
		/// and this allocation ends up as dedicated or is explicitly forced as dedicated using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>
		/// Otherwise, it has the priority of a memory block where it is placed and this variable is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "priority")]
		[NativeName(NativeNameType.Type, "float")]
		public float Priority;


		public unsafe VmaAllocationCreateInfo(VmaAllocationCreateFlagBits flags = default, VmaMemoryUsage usage = default, uint requiredFlags = default, uint preferredFlags = default, uint memoryTypeBits = default, VmaPool pool = default, void* pUserData = default, float priority = default)
		{
			Flags = flags;
			Usage = usage;
			RequiredFlags = requiredFlags;
			PreferredFlags = preferredFlags;
			MemoryTypeBits = memoryTypeBits;
			Pool = pool;
			PUserData = pUserData;
			Priority = priority;
		}


	}

	/// <summary>
	/// Describes parameter of created #VmaPool.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaPoolCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaPoolCreateInfo
	{
		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "memoryTypeIndex")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MemoryTypeIndex;

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaPoolCreateFlags")]
		public VmaPoolCreateFlagBits Flags;

		/// <summary>
		/// <br/>
		/// Specify nonzero to set explicit, constant size of memory blocks used by this<br/>
		/// pool.<br/>
		/// Leave 0 to use default and let the library manage block sizes automatically.<br/>
		/// Sizes of particular blocks may vary.<br/>
		/// In this case, the pool will also support dedicated allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "blockSize")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BlockSize;

		/// <summary>
		/// <br/>
		/// Set to 0 to have no preallocated blocks and allow the pool be completely empty.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "minBlockCount")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong MinBlockCount;

		/// <summary>
		/// <br/>
		/// Set to 0 to use default, which is `SIZE_MAX`, which means no limit.<br/>
		/// Set to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated<br/>
		/// throughout whole lifetime of this pool.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "maxBlockCount")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong MaxBlockCount;

		/// <summary>
		/// <br/>
		/// It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object.<br/>
		/// Otherwise, this variable is ignored.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "priority")]
		[NativeName(NativeNameType.Type, "float")]
		public float Priority;

		/// <summary>
		/// <br/>
		/// Leave 0 (default) not to impose any additional alignment. If not 0, it must be a power of two.<br/>
		/// It can be useful in cases where alignment returned by Vulkan by functions like `vkGetBufferMemoryRequirements` is not enough,<br/>
		/// e.g. when doing interop with OpenGL.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "minAllocationAlignment")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong MinAllocationAlignment;

		/// <summary>
		/// <br/>
		/// Optional, can be null. If not null, it must point to a `pNext` chain of structures that can be attached to `VkMemoryAllocateInfo`.<br/>
		/// It can be useful for special needs such as adding `VkExportMemoryAllocateInfoKHR`.<br/>
		/// Structures pointed by this member must remain alive and unchanged for the whole lifetime of the custom pool.<br/>
		/// Please note that some structures, e.g. `VkMemoryPriorityAllocateInfoEXT`, `VkMemoryDedicatedAllocateInfoKHR`,<br/>
		/// can be attached automatically by this library when using other, more convenient of its features.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pMemoryAllocateNext")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PMemoryAllocateNext;


		public unsafe VmaPoolCreateInfo(uint memoryTypeIndex = default, VmaPoolCreateFlagBits flags = default, ulong blockSize = default, ulong minBlockCount = default, ulong maxBlockCount = default, float priority = default, ulong minAllocationAlignment = default, void* pMemoryAllocateNext = default)
		{
			MemoryTypeIndex = memoryTypeIndex;
			Flags = flags;
			BlockSize = blockSize;
			MinBlockCount = minBlockCount;
			MaxBlockCount = maxBlockCount;
			Priority = priority;
			MinAllocationAlignment = minAllocationAlignment;
			PMemoryAllocateNext = pMemoryAllocateNext;
		}


	}

	/// <summary>
	/// Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().<br/>
	/// There is also an extended version of this structure that carries additional parameters: #VmaAllocationInfo2.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocationInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocationInfo
	{
		/// <summary>
		/// <br/>
		/// It never changes.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "memoryType")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MemoryType;

		/// <summary>
		/// <br/>
		/// Same memory object can be shared by multiple allocations.<br/>
		/// It can change after the allocation is moved during <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "deviceMemory")]
		[NativeName(NativeNameType.Type, "VkDeviceMemory")]
		public VkDeviceMemory DeviceMemory;

		/// <summary>
		/// <br/>
		/// You usually don't need to use this offset. If you create a buffer or an image together with the allocation using e.g. function<br/>
		/// vmaCreateBuffer(), vmaCreateImage(), functions that operate on these resources refer to the beginning of the buffer or image,<br/>
		/// not entire device memory block. Functions like vmaMapMemory(), vmaBindBufferMemory() also refer to the beginning of the allocation<br/>
		/// and apply this offset automatically.<br/>
		/// It can change after the allocation is moved during <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Offset;

		/// <summary>
		/// <br/>
		/// It never changes.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;

		/// <summary>
		/// <br/>
		/// If the allocation hasn't been mapped using vmaMapMemory() and hasn't been<br/>
		/// created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value is null.<br/>
		/// It can change after call to vmaMapMemory(), vmaUnmapMemory().<br/>
		/// It can also change after the allocation is moved during <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pMappedData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PMappedData;

		/// <summary>
		/// <br/>
		/// It can change after call to vmaSetAllocationUserData() for this allocation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;

		/// <summary>
		/// <br/>
		/// It can change after call to vmaSetAllocationName() for this allocation.<br/>
		/// Another way to set custom name is to pass it in VmaAllocationCreateInfo::pUserData with<br/>
		/// additional flag #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT set [DEPRECATED].<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pName")]
		[NativeName(NativeNameType.Type, "const char*")]
		public unsafe byte* PName;


		public unsafe VmaAllocationInfo(uint memoryType = default, VkDeviceMemory deviceMemory = default, ulong offset = default, ulong size = default, void* pMappedData = default, void* pUserData = default, byte* pName = default)
		{
			MemoryType = memoryType;
			DeviceMemory = deviceMemory;
			Offset = offset;
			Size = size;
			PMappedData = pMappedData;
			PUserData = pUserData;
			PName = pName;
		}


	}

	/// <summary>
	/// Extended parameters of a #VmaAllocation object that can be retrieved using function vmaGetAllocationInfo2().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaAllocationInfo2")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaAllocationInfo2
	{
		/// <summary>
		/// <br/>
		/// If you need only these, you can use function vmaGetAllocationInfo() and structure #VmaAllocationInfo instead.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationInfo")]
		[NativeName(NativeNameType.Type, "VmaAllocationInfo")]
		public VmaAllocationInfo AllocationInfo;

		/// <summary>
		/// <br/>
		/// In case of an allocation with dedicated memory, it will be equal to `allocationInfo.size`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "blockSize")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BlockSize;

		/// <summary>
		/// <br/>
		/// When `VK_TRUE`, it also means `VkMemoryDedicatedAllocateInfo` was used when creating the allocation<br/>
		/// (if VK_KHR_dedicated_allocation extension or Vulkan version >= 1.1 is enabled).<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "dedicatedMemory")]
		[NativeName(NativeNameType.Type, "VkBool32")]
		public uint DedicatedMemory;


		public unsafe VmaAllocationInfo2(VmaAllocationInfo allocationInfo = default, ulong blockSize = default, uint dedicatedMemory = default)
		{
			AllocationInfo = allocationInfo;
			BlockSize = blockSize;
			DedicatedMemory = dedicatedMemory;
		}


	}

	/// <summary>
	/// <br/>
	/// To be used with function vmaBeginDefragmentation().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDefragmentationInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDefragmentationInfo
	{
		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaDefragmentationFlags")]
		public VmaDefragmentationFlagBits Flags;

		/// <summary>
		/// <br/>
		/// If null then default pools will undergo defragmentation process.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pool")]
		[NativeName(NativeNameType.Type, "VmaPool")]
		public VmaPool Pool;

		/// <summary>
		/// <br/>
		/// `0` means no limit.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "maxBytesPerPass")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong MaxBytesPerPass;

		/// <summary>
		/// <br/>
		/// `0` means no limit.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "maxAllocationsPerPass")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MaxAllocationsPerPass;

		/// <summary>
		/// <br/>
		/// Have to return true for breaking current defragmentation pass.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pfnBreakCallback")]
		[NativeName(NativeNameType.Type, "PFN_vmaCheckDefragmentationBreakFunction")]
		public unsafe void* PfnBreakCallback;
		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pBreakCallbackUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PBreakCallbackUserData;


		public unsafe VmaDefragmentationInfo(VmaDefragmentationFlagBits flags = default, VmaPool pool = default, ulong maxBytesPerPass = default, uint maxAllocationsPerPass = default, PFNVmaCheckDefragmentationBreakFunction pfnBreakCallback = default, void* pBreakCallbackUserData = default)
		{
			Flags = flags;
			Pool = pool;
			MaxBytesPerPass = maxBytesPerPass;
			MaxAllocationsPerPass = maxAllocationsPerPass;
			PfnBreakCallback = (void*)Marshal.GetFunctionPointerForDelegate(pfnBreakCallback);
			PBreakCallbackUserData = pBreakCallbackUserData;
		}


	}

	/// <summary>
	/// Single move of an allocation to be done for defragmentation.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDefragmentationMove")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDefragmentationMove
	{
		/// <summary>
		/// Operation to be performed on the allocation by vmaEndDefragmentationPass(). Default value is #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY. You can modify it.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "operation")]
		[NativeName(NativeNameType.Type, "VmaDefragmentationMoveOperation")]
		public VmaDefragmentationMoveOperation Operation;

		/// <summary>
		/// Allocation that should be moved.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "srcAllocation")]
		[NativeName(NativeNameType.Type, "VmaAllocation")]
		public VmaAllocation SrcAllocation;

		/// <summary>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "dstTmpAllocation")]
		[NativeName(NativeNameType.Type, "VmaAllocation")]
		public VmaAllocation DstTmpAllocation;


		public unsafe VmaDefragmentationMove(VmaDefragmentationMoveOperation operation = default, VmaAllocation srcAllocation = default, VmaAllocation dstTmpAllocation = default)
		{
			Operation = operation;
			SrcAllocation = srcAllocation;
			DstTmpAllocation = dstTmpAllocation;
		}


	}

	/// <summary>
	/// <br/>
	/// To be used with function vmaBeginDefragmentationPass().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDefragmentationPassMoveInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDefragmentationPassMoveInfo
	{
		/// <summary>
		/// Number of elements in the `pMoves` array.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "moveCount")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MoveCount;

		/// <summary>
		/// <br/>
		/// Pointer to an array of `moveCount` elements, owned by VMA, created in vmaBeginDefragmentationPass(), destroyed in vmaEndDefragmentationPass().<br/>
		/// For each element, you should:<br/>
		/// 1. Create a new buffer/image in the place pointed by VmaDefragmentationMove::dstMemory + VmaDefragmentationMove::dstOffset.<br/>
		/// 2. Copy data from the VmaDefragmentationMove::srcAllocation e.g. using `vkCmdCopyBuffer`, `vkCmdCopyImage`.<br/>
		/// 3. Make sure these commands finished executing on the GPU.<br/>
		/// 4. Destroy the old buffer/image.<br/>
		/// Only then you can finish defragmentation pass by calling vmaEndDefragmentationPass().<br/>
		/// After this call, the allocation will point to the new place in memory.<br/>
		/// Alternatively, if you cannot move specific allocation, you can set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE.<br/>
		/// Alternatively, if you decide you want to completely remove the allocation:<br/>
		/// 1. Destroy its buffer/image.<br/>
		/// 2. Set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY.<br/>
		/// Then, after vmaEndDefragmentationPass() the allocation will be freed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pMoves")]
		[NativeName(NativeNameType.Type, "VmaDefragmentationMove*")]
		public unsafe VmaDefragmentationMove* PMoves;


		public unsafe VmaDefragmentationPassMoveInfo(uint moveCount = default, VmaDefragmentationMove* pMoves = default)
		{
			MoveCount = moveCount;
			PMoves = pMoves;
		}


	}

	/// <summary>
	/// Statistics returned for defragmentation process in function vmaEndDefragmentation().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaDefragmentationStats")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaDefragmentationStats
	{
		/// <summary>
		/// Total number of bytes that have been copied while moving allocations to different places.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "bytesMoved")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BytesMoved;

		/// <summary>
		/// Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "bytesFreed")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong BytesFreed;

		/// <summary>
		/// Number of allocations that have been moved to different places.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocationsMoved")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint AllocationsMoved;

		/// <summary>
		/// Number of empty `VkDeviceMemory` objects that have been released to the system.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "deviceMemoryBlocksFreed")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint DeviceMemoryBlocksFreed;


		public unsafe VmaDefragmentationStats(ulong bytesMoved = default, ulong bytesFreed = default, uint allocationsMoved = default, uint deviceMemoryBlocksFreed = default)
		{
			BytesMoved = bytesMoved;
			BytesFreed = bytesFreed;
			AllocationsMoved = allocationsMoved;
			DeviceMemoryBlocksFreed = deviceMemoryBlocksFreed;
		}


	}

	/// <summary>
	/// Parameters of created #VmaVirtualBlock object to be passed to vmaCreateVirtualBlock().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaVirtualBlockCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaVirtualBlockCreateInfo
	{
		/// <summary>
		/// <br/>
		/// Sizes can be expressed in bytes or any units you want as long as you are consistent in using them.<br/>
		/// For example, if you allocate from some array of structures, 1 can mean single instance of entire structure.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaVirtualBlockCreateFlags")]
		public VmaVirtualBlockCreateFlagBits Flags;

		/// <summary>
		/// <br/>
		/// Optional, can be null. When specified, they will be used for all CPU-side memory allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pAllocationCallbacks")]
		[NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")]
		public unsafe VkAllocationCallbacks* PAllocationCallbacks;


		public unsafe VmaVirtualBlockCreateInfo(ulong size = default, VmaVirtualBlockCreateFlagBits flags = default, VkAllocationCallbacks* pAllocationCallbacks = default)
		{
			Size = size;
			Flags = flags;
			PAllocationCallbacks = pAllocationCallbacks;
		}


	}

	/// <summary>
	/// Parameters of created virtual allocation to be passed to vmaVirtualAllocate().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaVirtualAllocationCreateInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaVirtualAllocationCreateInfo
	{
		/// <summary>
		/// <br/>
		/// Cannot be zero.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;

		/// <summary>
		/// <br/>
		/// Must be power of two. Special value 0 has the same meaning as 1 - means no special alignment is required, so allocation can start at any offset.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "alignment")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Alignment;

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "VmaVirtualAllocationCreateFlags")]
		public VmaVirtualAllocationCreateFlagBits Flags;

		/// <summary>
		/// <br/>
		/// It can be any value and can be used for user-defined purposes. It can be fetched or changed later.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;


		public unsafe VmaVirtualAllocationCreateInfo(ulong size = default, ulong alignment = default, VmaVirtualAllocationCreateFlagBits flags = default, void* pUserData = default)
		{
			Size = size;
			Alignment = alignment;
			Flags = flags;
			PUserData = pUserData;
		}


	}

	/// <summary>
	/// Parameters of an existing virtual allocation, returned by vmaGetVirtualAllocationInfo().<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "VmaVirtualAllocationInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct VmaVirtualAllocationInfo
	{
		/// <summary>
		/// <br/>
		/// Offset at which the allocation was made.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Offset;

		/// <summary>
		/// <br/>
		/// Same value as passed in VmaVirtualAllocationCreateInfo::size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkDeviceSize")]
		public ulong Size;

		/// <summary>
		/// <br/>
		/// Same value as passed in VmaVirtualAllocationCreateInfo::pUserData or to vmaSetVirtualAllocationUserData().<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "pUserData")]
		[NativeName(NativeNameType.Type, "void*")]
		public unsafe void* PUserData;


		public unsafe VmaVirtualAllocationInfo(ulong offset = default, ulong size = default, void* pUserData = default)
		{
			Offset = offset;
			Size = size;
			PUserData = pUserData;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_DeviceAddress")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDeviceAddress
	{
		[NativeName(NativeNameType.Field, "address")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong Address;

		public unsafe DaxaDeviceAddress(ulong address = default)
		{
			Address = address;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BufferInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBufferInfo
	{
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong Size;
		/// <summary>
		/// Ignored when allocating with a memory block.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocate_info")]
		[NativeName(NativeNameType.Type, "daxa_MemoryFlags")]
		public uint AllocateInfo;

		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaBufferInfo(ulong size = default, uint allocateInfo = default, DaxaSmallString name = default)
		{
			Size = size;
			AllocateInfo = allocateInfo;
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ImageInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageInfo
	{
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "daxa_ImageFlags")]
		public uint Flags;
		[NativeName(NativeNameType.Field, "dimensions")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Dimensions;
		[NativeName(NativeNameType.Field, "format")]
		[NativeName(NativeNameType.Type, "VkFormat")]
		public VkFormat Format;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "VkExtent3D")]
		public VkExtent3D Size;
		[NativeName(NativeNameType.Field, "mip_level_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MipLevelCount;
		[NativeName(NativeNameType.Field, "array_layer_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint ArrayLayerCount;
		[NativeName(NativeNameType.Field, "sample_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint SampleCount;
		[NativeName(NativeNameType.Field, "usage")]
		[NativeName(NativeNameType.Type, "daxa_ImageUsageFlags")]
		public uint Usage;
		/// <summary>
		/// Ignored when allocating with a memory block.<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "allocate_info")]
		[NativeName(NativeNameType.Type, "daxa_MemoryFlags")]
		public uint AllocateInfo;

		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaImageInfo(uint flags = default, uint dimensions = default, VkFormat format = default, VkExtent3D size = default, uint mipLevelCount = default, uint arrayLayerCount = default, uint sampleCount = default, uint usage = default, uint allocateInfo = default, DaxaSmallString name = default)
		{
			Flags = flags;
			Dimensions = dimensions;
			Format = format;
			Size = size;
			MipLevelCount = mipLevelCount;
			ArrayLayerCount = arrayLayerCount;
			SampleCount = sampleCount;
			Usage = usage;
			AllocateInfo = allocateInfo;
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ImageViewInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageViewInfo
	{
		[NativeName(NativeNameType.Field, "type")]
		[NativeName(NativeNameType.Type, "VkImageViewType")]
		public VkImageViewType Type;
		[NativeName(NativeNameType.Field, "format")]
		[NativeName(NativeNameType.Type, "VkFormat")]
		public VkFormat Format;
		[NativeName(NativeNameType.Field, "image")]
		[NativeName(NativeNameType.Type, "daxa_ImageId")]
		public DaxaImageId Image;
		[NativeName(NativeNameType.Field, "slice")]
		[NativeName(NativeNameType.Type, "daxa_ImageMipArraySlice")]
		public DaxaImageMipArraySlice Slice;
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaImageViewInfo(VkImageViewType type = default, VkFormat format = default, DaxaImageId image = default, DaxaImageMipArraySlice slice = default, DaxaSmallString name = default)
		{
			Type = type;
			Format = format;
			Image = image;
			Slice = slice;
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_SamplerInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaSamplerInfo
	{
		[NativeName(NativeNameType.Field, "magnification_filter")]
		[NativeName(NativeNameType.Type, "VkFilter")]
		public VkFilter MagnificationFilter;
		[NativeName(NativeNameType.Field, "minification_filter")]
		[NativeName(NativeNameType.Type, "VkFilter")]
		public VkFilter MinificationFilter;
		[NativeName(NativeNameType.Field, "mipmap_filter")]
		[NativeName(NativeNameType.Type, "VkFilter")]
		public VkFilter MipmapFilter;
		[NativeName(NativeNameType.Field, "reduction_mode")]
		[NativeName(NativeNameType.Type, "VkSamplerReductionMode")]
		public VkSamplerReductionMode ReductionMode;
		[NativeName(NativeNameType.Field, "address_mode_u")]
		[NativeName(NativeNameType.Type, "VkSamplerAddressMode")]
		public VkSamplerAddressMode AddressModeU;
		[NativeName(NativeNameType.Field, "address_mode_v")]
		[NativeName(NativeNameType.Type, "VkSamplerAddressMode")]
		public VkSamplerAddressMode AddressModeV;
		[NativeName(NativeNameType.Field, "address_mode_w")]
		[NativeName(NativeNameType.Type, "VkSamplerAddressMode")]
		public VkSamplerAddressMode AddressModeW;
		[NativeName(NativeNameType.Field, "mip_lod_bias")]
		[NativeName(NativeNameType.Type, "float")]
		public float MipLodBias;
		[NativeName(NativeNameType.Field, "enable_anisotropy")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte EnableAnisotropy;
		[NativeName(NativeNameType.Field, "max_anisotropy")]
		[NativeName(NativeNameType.Type, "float")]
		public float MaxAnisotropy;
		[NativeName(NativeNameType.Field, "enable_compare")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte EnableCompare;
		[NativeName(NativeNameType.Field, "compare_op")]
		[NativeName(NativeNameType.Type, "VkCompareOp")]
		public VkCompareOp CompareOp;
		[NativeName(NativeNameType.Field, "min_lod")]
		[NativeName(NativeNameType.Type, "float")]
		public float MinLod;
		[NativeName(NativeNameType.Field, "max_lod")]
		[NativeName(NativeNameType.Type, "float")]
		public float MaxLod;
		[NativeName(NativeNameType.Field, "border_color")]
		[NativeName(NativeNameType.Type, "VkBorderColor")]
		public VkBorderColor BorderColor;
		[NativeName(NativeNameType.Field, "enable_unnormalized_coordinates")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte EnableUnnormalizedCoordinates;
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaSamplerInfo(VkFilter magnificationFilter = default, VkFilter minificationFilter = default, VkFilter mipmapFilter = default, VkSamplerReductionMode reductionMode = default, VkSamplerAddressMode addressModeU = default, VkSamplerAddressMode addressModeV = default, VkSamplerAddressMode addressModeW = default, float mipLodBias = default, byte enableAnisotropy = default, float maxAnisotropy = default, byte enableCompare = default, VkCompareOp compareOp = default, float minLod = default, float maxLod = default, VkBorderColor borderColor = default, byte enableUnnormalizedCoordinates = default, DaxaSmallString name = default)
		{
			MagnificationFilter = magnificationFilter;
			MinificationFilter = minificationFilter;
			MipmapFilter = mipmapFilter;
			ReductionMode = reductionMode;
			AddressModeU = addressModeU;
			AddressModeV = addressModeV;
			AddressModeW = addressModeW;
			MipLodBias = mipLodBias;
			EnableAnisotropy = enableAnisotropy;
			MaxAnisotropy = maxAnisotropy;
			EnableCompare = enableCompare;
			CompareOp = compareOp;
			MinLod = minLod;
			MaxLod = maxLod;
			BorderColor = borderColor;
			EnableUnnormalizedCoordinates = enableUnnormalizedCoordinates;
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BlasTriangleGeometryInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBlasTriangleGeometryInfo
	{
		[NativeName(NativeNameType.Field, "vertex_format")]
		[NativeName(NativeNameType.Type, "VkFormat")]
		public VkFormat VertexFormat;
		[NativeName(NativeNameType.Field, "vertex_data")]
		[NativeName(NativeNameType.Type, "daxa_DeviceAddress")]
		public DaxaDeviceAddress VertexData;
		[NativeName(NativeNameType.Field, "vertex_stride")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong VertexStride;
		[NativeName(NativeNameType.Field, "max_vertex")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MaxVertex;
		[NativeName(NativeNameType.Field, "index_type")]
		[NativeName(NativeNameType.Type, "VkIndexType")]
		public VkIndexType IndexType;
		[NativeName(NativeNameType.Field, "index_data")]
		[NativeName(NativeNameType.Type, "daxa_DeviceAddress")]
		public DaxaDeviceAddress IndexData;
		[NativeName(NativeNameType.Field, "transform_data")]
		[NativeName(NativeNameType.Type, "daxa_DeviceAddress")]
		public DaxaDeviceAddress TransformData;
		[NativeName(NativeNameType.Field, "count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Count;
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "daxa_GeometryFlags")]
		public int Flags;

		public unsafe DaxaBlasTriangleGeometryInfo(VkFormat vertexFormat = default, DaxaDeviceAddress vertexData = default, ulong vertexStride = default, uint maxVertex = default, VkIndexType indexType = default, DaxaDeviceAddress indexData = default, DaxaDeviceAddress transformData = default, uint count = default, int flags = default)
		{
			VertexFormat = vertexFormat;
			VertexData = vertexData;
			VertexStride = vertexStride;
			MaxVertex = maxVertex;
			IndexType = indexType;
			IndexData = indexData;
			TransformData = transformData;
			Count = count;
			Flags = flags;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BlasAabbGeometryInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBlasAabbGeometryInfo
	{
		[NativeName(NativeNameType.Field, "data")]
		[NativeName(NativeNameType.Type, "daxa_DeviceAddress")]
		public DaxaDeviceAddress Data;
		[NativeName(NativeNameType.Field, "stride")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong Stride;
		[NativeName(NativeNameType.Field, "count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Count;
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "daxa_GeometryFlags")]
		public int Flags;

		public unsafe DaxaBlasAabbGeometryInfo(DaxaDeviceAddress data = default, ulong stride = default, uint count = default, int flags = default)
		{
			Data = data;
			Stride = stride;
			Count = count;
			Flags = flags;
		}


	}

	/// <summary>
	/// Instances are defines as VkAccelerationStructureInstanceKHR;<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "daxa_TlasInstanceInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaTlasInstanceInfo
	{
		[NativeName(NativeNameType.Field, "data")]
		[NativeName(NativeNameType.Type, "daxa_DeviceAddress")]
		public DaxaDeviceAddress Data;
		[NativeName(NativeNameType.Field, "count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Count;
		[NativeName(NativeNameType.Field, "is_data_array_of_pointers")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte IsDataArrayOfPointers;
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "daxa_GeometryFlags")]
		public int Flags;

		public unsafe DaxaTlasInstanceInfo(DaxaDeviceAddress data = default, uint count = default, byte isDataArrayOfPointers = default, int flags = default)
		{
			Data = data;
			Count = count;
			IsDataArrayOfPointers = isDataArrayOfPointers;
			Flags = flags;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BlasTriangleGeometryInfoSpan")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBlasTriangleGeometryInfoSpan
	{
		[NativeName(NativeNameType.Field, "triangles")]
		[NativeName(NativeNameType.Type, "const daxa_BlasTriangleGeometryInfo*")]
		public unsafe DaxaBlasTriangleGeometryInfo* Triangles;
		[NativeName(NativeNameType.Field, "count")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong Count;

		public unsafe DaxaBlasTriangleGeometryInfoSpan(DaxaBlasTriangleGeometryInfo* triangles = default, ulong count = default)
		{
			Triangles = triangles;
			Count = count;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BlasAabbsGeometryInfoSpan")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBlasAabbsGeometryInfoSpan
	{
		[NativeName(NativeNameType.Field, "aabbs")]
		[NativeName(NativeNameType.Type, "const daxa_BlasAabbGeometryInfo*")]
		public unsafe DaxaBlasAabbGeometryInfo* Aabbs;
		[NativeName(NativeNameType.Field, "count")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong Count;

		public unsafe DaxaBlasAabbsGeometryInfoSpan(DaxaBlasAabbGeometryInfo* aabbs = default, ulong count = default)
		{
			Aabbs = aabbs;
			Count = count;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BlasGeometryInfoSpansUnion")]
	[StructLayout(LayoutKind.Explicit)]
	public partial struct DaxaBlasGeometryInfoSpansUnion
	{
		[NativeName(NativeNameType.Field, "triangles")]
		[NativeName(NativeNameType.Type, "daxa_BlasTriangleGeometryInfoSpan")]
		[FieldOffset(0)]
		public DaxaBlasTriangleGeometryInfoSpan Triangles;
		[NativeName(NativeNameType.Field, "aabbs")]
		[NativeName(NativeNameType.Type, "daxa_BlasAabbsGeometryInfoSpan")]
		[FieldOffset(0)]
		public DaxaBlasAabbsGeometryInfoSpan Aabbs;

		public unsafe DaxaBlasGeometryInfoSpansUnion(DaxaBlasTriangleGeometryInfoSpan triangles = default, DaxaBlasAabbsGeometryInfoSpan aabbs = default)
		{
			Triangles = triangles;
			Aabbs = aabbs;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_TlasBuildInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaTlasBuildInfo
	{
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "daxa_BuildAcclelerationStructureFlags")]
		public uint Flags;
		[NativeName(NativeNameType.Field, "update")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte Update;
		[NativeName(NativeNameType.Field, "src_tlas")]
		[NativeName(NativeNameType.Type, "daxa_TlasId")]
		public DaxaTlasId SrcTlas;
		[NativeName(NativeNameType.Field, "dst_tlas")]
		[NativeName(NativeNameType.Type, "daxa_TlasId")]
		public DaxaTlasId DstTlas;
		[NativeName(NativeNameType.Field, "instances")]
		[NativeName(NativeNameType.Type, "const daxa_TlasInstanceInfo*")]
		public unsafe DaxaTlasInstanceInfo* Instances;
		[NativeName(NativeNameType.Field, "instance_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint InstanceCount;
		[NativeName(NativeNameType.Field, "scratch_data")]
		[NativeName(NativeNameType.Type, "daxa_DeviceAddress")]
		public DaxaDeviceAddress ScratchData;

		public unsafe DaxaTlasBuildInfo(uint flags = default, byte update = default, DaxaTlasId srcTlas = default, DaxaTlasId dstTlas = default, DaxaTlasInstanceInfo* instances = default, uint instanceCount = default, DaxaDeviceAddress scratchData = default)
		{
			Flags = flags;
			Update = update;
			SrcTlas = srcTlas;
			DstTlas = dstTlas;
			Instances = instances;
			InstanceCount = instanceCount;
			ScratchData = scratchData;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BlasBuildInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBlasBuildInfo
	{
		[NativeName(NativeNameType.StructOrClass, "daxa_BlasBuildInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct GeometriesUnion
		{
			[NativeName(NativeNameType.Field, "values")]
			[NativeName(NativeNameType.Type, "daxa_BlasGeometryInfoSpansUnion")]
			public DaxaBlasGeometryInfoSpansUnion Values;
			[NativeName(NativeNameType.Field, "index")]
			[NativeName(NativeNameType.Type, "uint8_t")]
			public byte Index;

			public unsafe GeometriesUnion(DaxaBlasGeometryInfoSpansUnion values = default, byte index = default)
			{
				Values = values;
				Index = index;
			}


		}

		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "daxa_BuildAcclelerationStructureFlags")]
		public uint Flags;
		[NativeName(NativeNameType.Field, "update")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte Update;
		[NativeName(NativeNameType.Field, "src_blas")]
		[NativeName(NativeNameType.Type, "daxa_BlasId")]
		public DaxaBlasId SrcBlas;
		[NativeName(NativeNameType.Field, "dst_blas")]
		[NativeName(NativeNameType.Type, "daxa_BlasId")]
		public DaxaBlasId DstBlas;
		[NativeName(NativeNameType.Field, "geometries")]
		[NativeName(NativeNameType.Type, "")]
		public GeometriesUnion Geometries;
		[NativeName(NativeNameType.Field, "scratch_data")]
		[NativeName(NativeNameType.Type, "daxa_DeviceAddress")]
		public DaxaDeviceAddress ScratchData;

		public unsafe DaxaBlasBuildInfo(uint flags = default, byte update = default, DaxaBlasId srcBlas = default, DaxaBlasId dstBlas = default, GeometriesUnion geometries = default, DaxaDeviceAddress scratchData = default)
		{
			Flags = flags;
			Update = update;
			SrcBlas = srcBlas;
			DstBlas = dstBlas;
			Geometries = geometries;
			ScratchData = scratchData;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_TlasInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaTlasInfo
	{
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong Size;
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaTlasInfo(ulong size = default, DaxaSmallString name = default)
		{
			Size = size;
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BlasInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBlasInfo
	{
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong Size;
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaBlasInfo(ulong size = default, DaxaSmallString name = default)
		{
			Size = size;
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_Access")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaAccess
	{
		[NativeName(NativeNameType.Field, "stages")]
		[NativeName(NativeNameType.Type, "VkPipelineStageFlags2")]
		public uint Stages;
		[NativeName(NativeNameType.Field, "access_type")]
		[NativeName(NativeNameType.Type, "VkAccessFlags2")]
		public uint AccessType;

		public unsafe DaxaAccess(uint stages = default, uint accessType = default)
		{
			Stages = stages;
			AccessType = accessType;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_MemoryBarrierInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaMemoryBarrierInfo
	{
		[NativeName(NativeNameType.Field, "src_access")]
		[NativeName(NativeNameType.Type, "daxa_Access")]
		public DaxaAccess SrcAccess;
		[NativeName(NativeNameType.Field, "dst_access")]
		[NativeName(NativeNameType.Type, "daxa_Access")]
		public DaxaAccess DstAccess;

		public unsafe DaxaMemoryBarrierInfo(DaxaAccess srcAccess = default, DaxaAccess dstAccess = default)
		{
			SrcAccess = srcAccess;
			DstAccess = dstAccess;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ImageMemoryBarrierInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageMemoryBarrierInfo
	{
		[NativeName(NativeNameType.Field, "src_access")]
		[NativeName(NativeNameType.Type, "daxa_Access")]
		public DaxaAccess SrcAccess;
		[NativeName(NativeNameType.Field, "dst_access")]
		[NativeName(NativeNameType.Type, "daxa_Access")]
		public DaxaAccess DstAccess;
		[NativeName(NativeNameType.Field, "src_layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout SrcLayout;
		[NativeName(NativeNameType.Field, "dst_layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout DstLayout;
		[NativeName(NativeNameType.Field, "image_slice")]
		[NativeName(NativeNameType.Type, "daxa_ImageMipArraySlice")]
		public DaxaImageMipArraySlice ImageSlice;
		[NativeName(NativeNameType.Field, "image_id")]
		[NativeName(NativeNameType.Type, "daxa_ImageId")]
		public DaxaImageId ImageId;

		public unsafe DaxaImageMemoryBarrierInfo(DaxaAccess srcAccess = default, DaxaAccess dstAccess = default, DaxaImageLayout srcLayout = default, DaxaImageLayout dstLayout = default, DaxaImageMipArraySlice imageSlice = default, DaxaImageId imageId = default)
		{
			SrcAccess = srcAccess;
			DstAccess = dstAccess;
			SrcLayout = srcLayout;
			DstLayout = dstLayout;
			ImageSlice = imageSlice;
			ImageId = imageId;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BinarySemaphoreInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBinarySemaphoreInfo
	{
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaBinarySemaphoreInfo(DaxaSmallString name = default)
		{
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_TimelineSemaphoreInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaTimelineSemaphoreInfo
	{
		[NativeName(NativeNameType.Field, "initial_value")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong InitialValue;
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaTimelineSemaphoreInfo(ulong initialValue = default, DaxaSmallString name = default)
		{
			InitialValue = initialValue;
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_EventInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaEventInfo
	{
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaEventInfo(DaxaSmallString name = default)
		{
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_EventSignalInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaEventSignalInfo
	{
		[NativeName(NativeNameType.Field, "memory_barriers")]
		[NativeName(NativeNameType.Type, "const daxa_MemoryBarrierInfo*")]
		public unsafe DaxaMemoryBarrierInfo* MemoryBarriers;
		[NativeName(NativeNameType.Field, "memory_barrier_count")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong MemoryBarrierCount;
		[NativeName(NativeNameType.Field, "image_memory_barriers")]
		[NativeName(NativeNameType.Type, "const daxa_ImageMemoryBarrierInfo*")]
		public unsafe DaxaImageMemoryBarrierInfo* ImageMemoryBarriers;
		[NativeName(NativeNameType.Field, "image_memory_barrier_count")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong ImageMemoryBarrierCount;
		[NativeName(NativeNameType.Field, "event")]
		[NativeName(NativeNameType.Type, "daxa_Event*")]
		public unsafe DaxaEvent* Event;

		public unsafe DaxaEventSignalInfo(DaxaMemoryBarrierInfo* memoryBarriers = default, ulong memoryBarrierCount = default, DaxaImageMemoryBarrierInfo* imageMemoryBarriers = default, ulong imageMemoryBarrierCount = default, DaxaEvent* evnt = default)
		{
			MemoryBarriers = memoryBarriers;
			MemoryBarrierCount = memoryBarrierCount;
			ImageMemoryBarriers = imageMemoryBarriers;
			ImageMemoryBarrierCount = imageMemoryBarrierCount;
			Event = evnt;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_TimelinePair")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaTimelinePair
	{
		[NativeName(NativeNameType.Field, "semaphore")]
		[NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")]
		public DaxaTimelineSemaphore Semaphore;
		[NativeName(NativeNameType.Field, "value")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong Value;

		public unsafe DaxaTimelinePair(DaxaTimelineSemaphore semaphore = default, ulong value = default)
		{
			Semaphore = semaphore;
			Value = value;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ShaderInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaShaderInfo
	{
		[NativeName(NativeNameType.StructOrClass, "daxa_ShaderInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct RequiredSubgroupSizeUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "uint32_t")]
			public uint Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe RequiredSubgroupSizeUnion(uint value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.Field, "byte_code")]
		[NativeName(NativeNameType.Type, "const uint32_t*")]
		public unsafe uint* ByteCode;
		[NativeName(NativeNameType.Field, "byte_code_size")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint ByteCodeSize;
		[NativeName(NativeNameType.Field, "create_flags")]
		[NativeName(NativeNameType.Type, "VkPipelineShaderStageCreateFlags")]
		public uint CreateFlags;
		[NativeName(NativeNameType.Field, "required_subgroup_size")]
		[NativeName(NativeNameType.Type, "")]
		public RequiredSubgroupSizeUnion RequiredSubgroupSize;
		[NativeName(NativeNameType.Field, "entry_point")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString EntryPoint;

		public unsafe DaxaShaderInfo(uint* byteCode = default, uint byteCodeSize = default, uint createFlags = default, RequiredSubgroupSizeUnion requiredSubgroupSize = default, DaxaSmallString entryPoint = default)
		{
			ByteCode = byteCode;
			ByteCodeSize = byteCodeSize;
			CreateFlags = createFlags;
			RequiredSubgroupSize = requiredSubgroupSize;
			EntryPoint = entryPoint;
		}


	}

	/// <summary>
	/// RAY TRACING PIPELINE<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingShaderInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaRayTracingShaderInfo
	{
		[NativeName(NativeNameType.Field, "info")]
		[NativeName(NativeNameType.Type, "daxa_ShaderInfo")]
		public DaxaShaderInfo Info;

		public unsafe DaxaRayTracingShaderInfo(DaxaShaderInfo info = default)
		{
			Info = info;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingShaderGroupInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaRayTracingShaderGroupInfo
	{
		/// <summary>
		/// TODO: daxa types?<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "type")]
		[NativeName(NativeNameType.Type, "VkRayTracingShaderGroupTypeKHR")]
		public VkRayTracingShaderGroupTypeKHR Type;

		[NativeName(NativeNameType.Field, "general_shader_index")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint GeneralShaderIndex;
		[NativeName(NativeNameType.Field, "closest_hit_shader_index")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint ClosestHitShaderIndex;
		[NativeName(NativeNameType.Field, "any_hit_shader_index")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint AnyHitShaderIndex;
		[NativeName(NativeNameType.Field, "intersection_shader_index")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint IntersectionShaderIndex;

		public unsafe DaxaRayTracingShaderGroupInfo(VkRayTracingShaderGroupTypeKHR type = default, uint generalShaderIndex = default, uint closestHitShaderIndex = default, uint anyHitShaderIndex = default, uint intersectionShaderIndex = default)
		{
			Type = type;
			GeneralShaderIndex = generalShaderIndex;
			ClosestHitShaderIndex = closestHitShaderIndex;
			AnyHitShaderIndex = anyHitShaderIndex;
			IntersectionShaderIndex = intersectionShaderIndex;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingPipelineInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaRayTracingPipelineInfo
	{
		[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct RayGenStagesUnion
		{
			[NativeName(NativeNameType.Field, "data")]
			[NativeName(NativeNameType.Type, "const daxa_RayTracingShaderInfo*")]
			public unsafe DaxaRayTracingShaderInfo* Data;
			[NativeName(NativeNameType.Field, "size")]
			[NativeName(NativeNameType.Type, "size_t")]
			public ulong Size;

			public unsafe RayGenStagesUnion(DaxaRayTracingShaderInfo* data = default, ulong size = default)
			{
				Data = data;
				Size = size;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct MissStagesUnion
		{
			[NativeName(NativeNameType.Field, "data")]
			[NativeName(NativeNameType.Type, "const daxa_RayTracingShaderInfo*")]
			public unsafe DaxaRayTracingShaderInfo* Data;
			[NativeName(NativeNameType.Field, "size")]
			[NativeName(NativeNameType.Type, "size_t")]
			public ulong Size;

			public unsafe MissStagesUnion(DaxaRayTracingShaderInfo* data = default, ulong size = default)
			{
				Data = data;
				Size = size;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct CallableStagesUnion
		{
			[NativeName(NativeNameType.Field, "data")]
			[NativeName(NativeNameType.Type, "const daxa_RayTracingShaderInfo*")]
			public unsafe DaxaRayTracingShaderInfo* Data;
			[NativeName(NativeNameType.Field, "size")]
			[NativeName(NativeNameType.Type, "size_t")]
			public ulong Size;

			public unsafe CallableStagesUnion(DaxaRayTracingShaderInfo* data = default, ulong size = default)
			{
				Data = data;
				Size = size;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct IntersectionStagesUnion
		{
			[NativeName(NativeNameType.Field, "data")]
			[NativeName(NativeNameType.Type, "const daxa_RayTracingShaderInfo*")]
			public unsafe DaxaRayTracingShaderInfo* Data;
			[NativeName(NativeNameType.Field, "size")]
			[NativeName(NativeNameType.Type, "size_t")]
			public ulong Size;

			public unsafe IntersectionStagesUnion(DaxaRayTracingShaderInfo* data = default, ulong size = default)
			{
				Data = data;
				Size = size;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct ClosestHitStagesUnion
		{
			[NativeName(NativeNameType.Field, "data")]
			[NativeName(NativeNameType.Type, "const daxa_RayTracingShaderInfo*")]
			public unsafe DaxaRayTracingShaderInfo* Data;
			[NativeName(NativeNameType.Field, "size")]
			[NativeName(NativeNameType.Type, "size_t")]
			public ulong Size;

			public unsafe ClosestHitStagesUnion(DaxaRayTracingShaderInfo* data = default, ulong size = default)
			{
				Data = data;
				Size = size;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct AnyHitStagesUnion
		{
			[NativeName(NativeNameType.Field, "data")]
			[NativeName(NativeNameType.Type, "const daxa_RayTracingShaderInfo*")]
			public unsafe DaxaRayTracingShaderInfo* Data;
			[NativeName(NativeNameType.Field, "size")]
			[NativeName(NativeNameType.Type, "size_t")]
			public ulong Size;

			public unsafe AnyHitStagesUnion(DaxaRayTracingShaderInfo* data = default, ulong size = default)
			{
				Data = data;
				Size = size;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RayTracingPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct ShaderGroupsUnion
		{
			[NativeName(NativeNameType.Field, "data")]
			[NativeName(NativeNameType.Type, "const daxa_RayTracingShaderGroupInfo*")]
			public unsafe DaxaRayTracingShaderGroupInfo* Data;
			[NativeName(NativeNameType.Field, "size")]
			[NativeName(NativeNameType.Type, "size_t")]
			public ulong Size;

			public unsafe ShaderGroupsUnion(DaxaRayTracingShaderGroupInfo* data = default, ulong size = default)
			{
				Data = data;
				Size = size;
			}


		}

		[NativeName(NativeNameType.Field, "ray_gen_stages")]
		[NativeName(NativeNameType.Type, "")]
		public RayGenStagesUnion RayGenStages;
		[NativeName(NativeNameType.Field, "miss_stages")]
		[NativeName(NativeNameType.Type, "")]
		public MissStagesUnion MissStages;
		[NativeName(NativeNameType.Field, "callable_stages")]
		[NativeName(NativeNameType.Type, "")]
		public CallableStagesUnion CallableStages;
		[NativeName(NativeNameType.Field, "intersection_stages")]
		[NativeName(NativeNameType.Type, "")]
		public IntersectionStagesUnion IntersectionStages;
		[NativeName(NativeNameType.Field, "closest_hit_stages")]
		[NativeName(NativeNameType.Type, "")]
		public ClosestHitStagesUnion ClosestHitStages;
		[NativeName(NativeNameType.Field, "any_hit_stages")]
		[NativeName(NativeNameType.Type, "")]
		public AnyHitStagesUnion AnyHitStages;
		[NativeName(NativeNameType.Field, "shader_groups")]
		[NativeName(NativeNameType.Type, "")]
		public ShaderGroupsUnion ShaderGroups;
		[NativeName(NativeNameType.Field, "max_ray_recursion_depth")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MaxRayRecursionDepth;
		[NativeName(NativeNameType.Field, "push_constant_size")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint PushConstantSize;
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaRayTracingPipelineInfo(RayGenStagesUnion rayGenStages = default, MissStagesUnion missStages = default, CallableStagesUnion callableStages = default, IntersectionStagesUnion intersectionStages = default, ClosestHitStagesUnion closestHitStages = default, AnyHitStagesUnion anyHitStages = default, ShaderGroupsUnion shaderGroups = default, uint maxRayRecursionDepth = default, uint pushConstantSize = default, DaxaSmallString name = default)
		{
			RayGenStages = rayGenStages;
			MissStages = missStages;
			CallableStages = callableStages;
			IntersectionStages = intersectionStages;
			ClosestHitStages = closestHitStages;
			AnyHitStages = anyHitStages;
			ShaderGroups = shaderGroups;
			MaxRayRecursionDepth = maxRayRecursionDepth;
			PushConstantSize = pushConstantSize;
			Name = name;
		}


	}

	/// <summary>
	/// COMPUTE PIPELINE<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "daxa_ComputePipelineInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaComputePipelineInfo
	{
		[NativeName(NativeNameType.Field, "shader_info")]
		[NativeName(NativeNameType.Type, "daxa_ShaderInfo")]
		public DaxaShaderInfo ShaderInfo;
		[NativeName(NativeNameType.Field, "push_constant_size")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint PushConstantSize;
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaComputePipelineInfo(DaxaShaderInfo shaderInfo = default, uint pushConstantSize = default, DaxaSmallString name = default)
		{
			ShaderInfo = shaderInfo;
			PushConstantSize = pushConstantSize;
			Name = name;
		}


	}

	/// <summary>
	/// RASTER PIPELINE<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "daxa_DepthTestInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDepthTestInfo
	{
		[NativeName(NativeNameType.Field, "depth_attachment_format")]
		[NativeName(NativeNameType.Type, "VkFormat")]
		public VkFormat DepthAttachmentFormat;
		[NativeName(NativeNameType.Field, "enable_depth_write")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte EnableDepthWrite;
		[NativeName(NativeNameType.Field, "depth_test_compare_op")]
		[NativeName(NativeNameType.Type, "VkCompareOp")]
		public VkCompareOp DepthTestCompareOp;
		[NativeName(NativeNameType.Field, "min_depth_bounds")]
		[NativeName(NativeNameType.Type, "float")]
		public float MinDepthBounds;
		[NativeName(NativeNameType.Field, "max_depth_bounds")]
		[NativeName(NativeNameType.Type, "float")]
		public float MaxDepthBounds;

		public unsafe DaxaDepthTestInfo(VkFormat depthAttachmentFormat = default, byte enableDepthWrite = default, VkCompareOp depthTestCompareOp = default, float minDepthBounds = default, float maxDepthBounds = default)
		{
			DepthAttachmentFormat = depthAttachmentFormat;
			EnableDepthWrite = enableDepthWrite;
			DepthTestCompareOp = depthTestCompareOp;
			MinDepthBounds = minDepthBounds;
			MaxDepthBounds = maxDepthBounds;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ConservativeRasterInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaConservativeRasterInfo
	{
		[NativeName(NativeNameType.Field, "mode")]
		[NativeName(NativeNameType.Type, "VkConservativeRasterizationModeEXT")]
		public VkConservativeRasterizationModeEXT Mode;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "float")]
		public float Size;

		public unsafe DaxaConservativeRasterInfo(VkConservativeRasterizationModeEXT mode = default, float size = default)
		{
			Mode = mode;
			Size = size;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_RasterizerInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaRasterizerInfo
	{
		[NativeName(NativeNameType.StructOrClass, "daxa_RasterizerInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct ConservativeRasterInfoUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_ConservativeRasterInfo")]
			public DaxaConservativeRasterInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe ConservativeRasterInfoUnion(DaxaConservativeRasterInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RasterizerInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct StaticStateSampleCountUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "VkSampleCountFlagBits")]
			public VkSampleCountFlagBits Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe StaticStateSampleCountUnion(VkSampleCountFlagBits value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.Field, "primitive_topology")]
		[NativeName(NativeNameType.Type, "VkPrimitiveTopology")]
		public VkPrimitiveTopology PrimitiveTopology;
		[NativeName(NativeNameType.Field, "primitive_restart_enable")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte PrimitiveRestartEnable;
		[NativeName(NativeNameType.Field, "polygon_mode")]
		[NativeName(NativeNameType.Type, "VkPolygonMode")]
		public VkPolygonMode PolygonMode;
		[NativeName(NativeNameType.Field, "face_culling")]
		[NativeName(NativeNameType.Type, "VkCullModeFlags")]
		public uint FaceCulling;
		[NativeName(NativeNameType.Field, "front_face_winding")]
		[NativeName(NativeNameType.Type, "VkFrontFace")]
		public VkFrontFace FrontFaceWinding;
		[NativeName(NativeNameType.Field, "depth_clamp_enable")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte DepthClampEnable;
		[NativeName(NativeNameType.Field, "rasterizer_discard_enable")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte RasterizerDiscardEnable;
		[NativeName(NativeNameType.Field, "depth_bias_enable")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte DepthBiasEnable;
		[NativeName(NativeNameType.Field, "depth_bias_constant_factor")]
		[NativeName(NativeNameType.Type, "float")]
		public float DepthBiasConstantFactor;
		[NativeName(NativeNameType.Field, "depth_bias_clamp")]
		[NativeName(NativeNameType.Type, "float")]
		public float DepthBiasClamp;
		[NativeName(NativeNameType.Field, "depth_bias_slope_factor")]
		[NativeName(NativeNameType.Type, "float")]
		public float DepthBiasSlopeFactor;
		[NativeName(NativeNameType.Field, "line_width")]
		[NativeName(NativeNameType.Type, "float")]
		public float LineWidth;
		[NativeName(NativeNameType.Field, "conservative_raster_info")]
		[NativeName(NativeNameType.Type, "")]
		public ConservativeRasterInfoUnion ConservativeRasterInfo;
		[NativeName(NativeNameType.Field, "static_state_sample_count")]
		[NativeName(NativeNameType.Type, "")]
		public StaticStateSampleCountUnion StaticStateSampleCount;

		public unsafe DaxaRasterizerInfo(VkPrimitiveTopology primitiveTopology = default, byte primitiveRestartEnable = default, VkPolygonMode polygonMode = default, uint faceCulling = default, VkFrontFace frontFaceWinding = default, byte depthClampEnable = default, byte rasterizerDiscardEnable = default, byte depthBiasEnable = default, float depthBiasConstantFactor = default, float depthBiasClamp = default, float depthBiasSlopeFactor = default, float lineWidth = default, ConservativeRasterInfoUnion conservativeRasterInfo = default, StaticStateSampleCountUnion staticStateSampleCount = default)
		{
			PrimitiveTopology = primitiveTopology;
			PrimitiveRestartEnable = primitiveRestartEnable;
			PolygonMode = polygonMode;
			FaceCulling = faceCulling;
			FrontFaceWinding = frontFaceWinding;
			DepthClampEnable = depthClampEnable;
			RasterizerDiscardEnable = rasterizerDiscardEnable;
			DepthBiasEnable = depthBiasEnable;
			DepthBiasConstantFactor = depthBiasConstantFactor;
			DepthBiasClamp = depthBiasClamp;
			DepthBiasSlopeFactor = depthBiasSlopeFactor;
			LineWidth = lineWidth;
			ConservativeRasterInfo = conservativeRasterInfo;
			StaticStateSampleCount = staticStateSampleCount;
		}


	}

	/// <summary>
	/// should be moved in c++ from types to pipeline.hpp.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "daxa_BlendInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBlendInfo
	{
		[NativeName(NativeNameType.Field, "src_color_blend_factor")]
		[NativeName(NativeNameType.Type, "VkBlendFactor")]
		public VkBlendFactor SrcColorBlendFactor;
		[NativeName(NativeNameType.Field, "dst_color_blend_factor")]
		[NativeName(NativeNameType.Type, "VkBlendFactor")]
		public VkBlendFactor DstColorBlendFactor;
		[NativeName(NativeNameType.Field, "color_blend_op")]
		[NativeName(NativeNameType.Type, "VkBlendOp")]
		public VkBlendOp ColorBlendOp;
		[NativeName(NativeNameType.Field, "src_alpha_blend_factor")]
		[NativeName(NativeNameType.Type, "VkBlendFactor")]
		public VkBlendFactor SrcAlphaBlendFactor;
		[NativeName(NativeNameType.Field, "dst_alpha_blend_factor")]
		[NativeName(NativeNameType.Type, "VkBlendFactor")]
		public VkBlendFactor DstAlphaBlendFactor;
		[NativeName(NativeNameType.Field, "alpha_blend_op")]
		[NativeName(NativeNameType.Type, "VkBlendOp")]
		public VkBlendOp AlphaBlendOp;
		[NativeName(NativeNameType.Field, "color_write_mask")]
		[NativeName(NativeNameType.Type, "VkColorComponentFlags")]
		public uint ColorWriteMask;

		public unsafe DaxaBlendInfo(VkBlendFactor srcColorBlendFactor = default, VkBlendFactor dstColorBlendFactor = default, VkBlendOp colorBlendOp = default, VkBlendFactor srcAlphaBlendFactor = default, VkBlendFactor dstAlphaBlendFactor = default, VkBlendOp alphaBlendOp = default, uint colorWriteMask = default)
		{
			SrcColorBlendFactor = srcColorBlendFactor;
			DstColorBlendFactor = dstColorBlendFactor;
			ColorBlendOp = colorBlendOp;
			SrcAlphaBlendFactor = srcAlphaBlendFactor;
			DstAlphaBlendFactor = dstAlphaBlendFactor;
			AlphaBlendOp = alphaBlendOp;
			ColorWriteMask = colorWriteMask;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_RenderAttachment")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaRenderAttachment
	{
		[NativeName(NativeNameType.StructOrClass, "daxa_RenderAttachment::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct BlendUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_BlendInfo")]
			public DaxaBlendInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe BlendUnion(DaxaBlendInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.Field, "format")]
		[NativeName(NativeNameType.Type, "VkFormat")]
		public VkFormat Format;
		[NativeName(NativeNameType.Field, "blend")]
		[NativeName(NativeNameType.Type, "")]
		public BlendUnion Blend;

		public unsafe DaxaRenderAttachment(VkFormat format = default, BlendUnion blend = default)
		{
			Format = format;
			Blend = blend;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_TesselationInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaTesselationInfo
	{
		[NativeName(NativeNameType.Field, "control_points")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint ControlPoints;
		[NativeName(NativeNameType.Field, "origin")]
		[NativeName(NativeNameType.Type, "VkTessellationDomainOrigin")]
		public VkTessellationDomainOrigin Origin;

		public unsafe DaxaTesselationInfo(uint controlPoints = default, VkTessellationDomainOrigin origin = default)
		{
			ControlPoints = controlPoints;
			Origin = origin;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaRasterPipelineInfo
	{
		[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct MeshShaderInfoUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_ShaderInfo")]
			public DaxaShaderInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe MeshShaderInfoUnion(DaxaShaderInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct VertexShaderInfoUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_ShaderInfo")]
			public DaxaShaderInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe VertexShaderInfoUnion(DaxaShaderInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct TesselationControlShaderInfoUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_ShaderInfo")]
			public DaxaShaderInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe TesselationControlShaderInfoUnion(DaxaShaderInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct TesselationEvaluationShaderInfoUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_ShaderInfo")]
			public DaxaShaderInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe TesselationEvaluationShaderInfoUnion(DaxaShaderInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct FragmentShaderInfoUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_ShaderInfo")]
			public DaxaShaderInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe FragmentShaderInfoUnion(DaxaShaderInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct TaskShaderInfoUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_ShaderInfo")]
			public DaxaShaderInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe TaskShaderInfoUnion(DaxaShaderInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct ColorAttachmentsUnion
		{
			[NativeName(NativeNameType.Field, "data")]
			[NativeName(NativeNameType.Type, "daxa_RenderAttachment[8]")]
			public DaxaRenderAttachment Data_0;
			public DaxaRenderAttachment Data_1;
			public DaxaRenderAttachment Data_2;
			public DaxaRenderAttachment Data_3;
			public DaxaRenderAttachment Data_4;
			public DaxaRenderAttachment Data_5;
			public DaxaRenderAttachment Data_6;
			public DaxaRenderAttachment Data_7;
			[NativeName(NativeNameType.Field, "size")]
			[NativeName(NativeNameType.Type, "uint8_t")]
			public byte Size;

			public unsafe ColorAttachmentsUnion(DaxaRenderAttachment* data = default, byte size = default)
			{
				if (data != default)
				{
					Data_0 = data[0];
					Data_1 = data[1];
					Data_2 = data[2];
					Data_3 = data[3];
					Data_4 = data[4];
					Data_5 = data[5];
					Data_6 = data[6];
					Data_7 = data[7];
				}
				Size = size;
			}

			public unsafe ColorAttachmentsUnion(Span<DaxaRenderAttachment> data = default, byte size = default)
			{
				if (data != default)
				{
					Data_0 = data[0];
					Data_1 = data[1];
					Data_2 = data[2];
					Data_3 = data[3];
					Data_4 = data[4];
					Data_5 = data[5];
					Data_6 = data[6];
					Data_7 = data[7];
				}
				Size = size;
			}


			public unsafe Span<DaxaRenderAttachment> Data
			
			{
				get
				{
					fixed (DaxaRenderAttachment* p = &this.Data_0)
					{
						return new Span<DaxaRenderAttachment>(p, 8);
					}
				}
			}
		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct DepthTestUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_DepthTestInfo")]
			public DaxaDepthTestInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe DepthTestUnion(DaxaDepthTestInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RasterPipelineInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct TesselationUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_TesselationInfo")]
			public DaxaTesselationInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe TesselationUnion(DaxaTesselationInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.Field, "mesh_shader_info")]
		[NativeName(NativeNameType.Type, "")]
		public MeshShaderInfoUnion MeshShaderInfo;
		[NativeName(NativeNameType.Field, "vertex_shader_info")]
		[NativeName(NativeNameType.Type, "")]
		public VertexShaderInfoUnion VertexShaderInfo;
		[NativeName(NativeNameType.Field, "tesselation_control_shader_info")]
		[NativeName(NativeNameType.Type, "")]
		public TesselationControlShaderInfoUnion TesselationControlShaderInfo;
		[NativeName(NativeNameType.Field, "tesselation_evaluation_shader_info")]
		[NativeName(NativeNameType.Type, "")]
		public TesselationEvaluationShaderInfoUnion TesselationEvaluationShaderInfo;
		[NativeName(NativeNameType.Field, "fragment_shader_info")]
		[NativeName(NativeNameType.Type, "")]
		public FragmentShaderInfoUnion FragmentShaderInfo;
		[NativeName(NativeNameType.Field, "task_shader_info")]
		[NativeName(NativeNameType.Type, "")]
		public TaskShaderInfoUnion TaskShaderInfo;
		[NativeName(NativeNameType.Field, "color_attachments")]
		[NativeName(NativeNameType.Type, "")]
		public ColorAttachmentsUnion ColorAttachments;
		[NativeName(NativeNameType.Field, "depth_test")]
		[NativeName(NativeNameType.Type, "")]
		public DepthTestUnion DepthTest;
		[NativeName(NativeNameType.Field, "tesselation")]
		[NativeName(NativeNameType.Type, "")]
		public TesselationUnion Tesselation;
		[NativeName(NativeNameType.Field, "raster")]
		[NativeName(NativeNameType.Type, "daxa_RasterizerInfo")]
		public DaxaRasterizerInfo Raster;
		[NativeName(NativeNameType.Field, "push_constant_size")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint PushConstantSize;
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaRasterPipelineInfo(MeshShaderInfoUnion meshShaderInfo = default, VertexShaderInfoUnion vertexShaderInfo = default, TesselationControlShaderInfoUnion tesselationControlShaderInfo = default, TesselationEvaluationShaderInfoUnion tesselationEvaluationShaderInfo = default, FragmentShaderInfoUnion fragmentShaderInfo = default, TaskShaderInfoUnion taskShaderInfo = default, ColorAttachmentsUnion colorAttachments = default, DepthTestUnion depthTest = default, TesselationUnion tesselation = default, DaxaRasterizerInfo raster = default, uint pushConstantSize = default, DaxaSmallString name = default)
		{
			MeshShaderInfo = meshShaderInfo;
			VertexShaderInfo = vertexShaderInfo;
			TesselationControlShaderInfo = tesselationControlShaderInfo;
			TesselationEvaluationShaderInfo = tesselationEvaluationShaderInfo;
			FragmentShaderInfo = fragmentShaderInfo;
			TaskShaderInfo = taskShaderInfo;
			ColorAttachments = colorAttachments;
			DepthTest = depthTest;
			Tesselation = tesselation;
			Raster = raster;
			PushConstantSize = pushConstantSize;
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_PushConstantInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaPushConstantInfo
	{
		[NativeName(NativeNameType.Field, "data")]
		[NativeName(NativeNameType.Type, "const void*")]
		public unsafe void* Data;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong Size;
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Offset;

		public unsafe DaxaPushConstantInfo(void* data = default, ulong size = default, uint offset = default)
		{
			Data = data;
			Size = size;
			Offset = offset;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_CommandRecorderInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaCommandRecorderInfo
	{
		[NativeName(NativeNameType.Field, "name")]
		[NativeName(NativeNameType.Type, "daxa_SmallString")]
		public DaxaSmallString Name;

		public unsafe DaxaCommandRecorderInfo(DaxaSmallString name = default)
		{
			Name = name;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ImageBlitInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageBlitInfo
	{
		[NativeName(NativeNameType.Field, "src_image")]
		[NativeName(NativeNameType.Type, "daxa_ImageId")]
		public DaxaImageId SrcImage;
		[NativeName(NativeNameType.Field, "src_image_layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout SrcImageLayout;
		[NativeName(NativeNameType.Field, "dst_image")]
		[NativeName(NativeNameType.Type, "daxa_ImageId")]
		public DaxaImageId DstImage;
		[NativeName(NativeNameType.Field, "dst_image_layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout DstImageLayout;
		[NativeName(NativeNameType.Field, "src_slice")]
		[NativeName(NativeNameType.Type, "daxa_ImageArraySlice")]
		public DaxaImageArraySlice SrcSlice;
		[NativeName(NativeNameType.Field, "src_offsets")]
		[NativeName(NativeNameType.Type, "VkOffset3D[2]")]
		public VkOffset3D SrcOffsets_0;
		public VkOffset3D SrcOffsets_1;
		[NativeName(NativeNameType.Field, "dst_slice")]
		[NativeName(NativeNameType.Type, "daxa_ImageArraySlice")]
		public DaxaImageArraySlice DstSlice;
		[NativeName(NativeNameType.Field, "dst_offsets")]
		[NativeName(NativeNameType.Type, "VkOffset3D[2]")]
		public VkOffset3D DstOffsets_0;
		public VkOffset3D DstOffsets_1;
		[NativeName(NativeNameType.Field, "filter")]
		[NativeName(NativeNameType.Type, "VkFilter")]
		public VkFilter Filter;

		public unsafe DaxaImageBlitInfo(DaxaImageId srcImage = default, DaxaImageLayout srcImageLayout = default, DaxaImageId dstImage = default, DaxaImageLayout dstImageLayout = default, DaxaImageArraySlice srcSlice = default, VkOffset3D* srcOffsets = default, DaxaImageArraySlice dstSlice = default, VkOffset3D* dstOffsets = default, VkFilter filter = default)
		{
			SrcImage = srcImage;
			SrcImageLayout = srcImageLayout;
			DstImage = dstImage;
			DstImageLayout = dstImageLayout;
			SrcSlice = srcSlice;
			if (srcOffsets != default)
			{
				SrcOffsets_0 = srcOffsets[0];
				SrcOffsets_1 = srcOffsets[1];
			}
			DstSlice = dstSlice;
			if (dstOffsets != default)
			{
				DstOffsets_0 = dstOffsets[0];
				DstOffsets_1 = dstOffsets[1];
			}
			Filter = filter;
		}

		public unsafe DaxaImageBlitInfo(DaxaImageId srcImage = default, DaxaImageLayout srcImageLayout = default, DaxaImageId dstImage = default, DaxaImageLayout dstImageLayout = default, DaxaImageArraySlice srcSlice = default, Span<VkOffset3D> srcOffsets = default, DaxaImageArraySlice dstSlice = default, Span<VkOffset3D> dstOffsets = default, VkFilter filter = default)
		{
			SrcImage = srcImage;
			SrcImageLayout = srcImageLayout;
			DstImage = dstImage;
			DstImageLayout = dstImageLayout;
			SrcSlice = srcSlice;
			if (srcOffsets != default)
			{
				SrcOffsets_0 = srcOffsets[0];
				SrcOffsets_1 = srcOffsets[1];
			}
			DstSlice = dstSlice;
			if (dstOffsets != default)
			{
				DstOffsets_0 = dstOffsets[0];
				DstOffsets_1 = dstOffsets[1];
			}
			Filter = filter;
		}


		public unsafe Span<VkOffset3D> SrcOffsets
		
		{
			get
			{
				fixed (VkOffset3D* p = &this.SrcOffsets_0)
				{
					return new Span<VkOffset3D>(p, 2);
				}
			}
		}
		public unsafe Span<VkOffset3D> DstOffsets
		
		{
			get
			{
				fixed (VkOffset3D* p = &this.DstOffsets_0)
				{
					return new Span<VkOffset3D>(p, 2);
				}
			}
		}
	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BufferCopyInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBufferCopyInfo
	{
		[NativeName(NativeNameType.Field, "src_buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId SrcBuffer;
		[NativeName(NativeNameType.Field, "dst_buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId DstBuffer;
		[NativeName(NativeNameType.Field, "src_offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong SrcOffset;
		[NativeName(NativeNameType.Field, "dst_offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong DstOffset;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong Size;

		public unsafe DaxaBufferCopyInfo(DaxaBufferId srcBuffer = default, DaxaBufferId dstBuffer = default, ulong srcOffset = default, ulong dstOffset = default, ulong size = default)
		{
			SrcBuffer = srcBuffer;
			DstBuffer = dstBuffer;
			SrcOffset = srcOffset;
			DstOffset = dstOffset;
			Size = size;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BufferImageCopyInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBufferImageCopyInfo
	{
		[NativeName(NativeNameType.Field, "buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId Buffer;
		[NativeName(NativeNameType.Field, "buffer_offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong BufferOffset;
		[NativeName(NativeNameType.Field, "image")]
		[NativeName(NativeNameType.Type, "daxa_ImageId")]
		public DaxaImageId Image;
		[NativeName(NativeNameType.Field, "image_layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout ImageLayout;
		[NativeName(NativeNameType.Field, "image_slice")]
		[NativeName(NativeNameType.Type, "daxa_ImageArraySlice")]
		public DaxaImageArraySlice ImageSlice;
		[NativeName(NativeNameType.Field, "image_offset")]
		[NativeName(NativeNameType.Type, "VkOffset3D")]
		public VkOffset3D ImageOffset;
		[NativeName(NativeNameType.Field, "image_extent")]
		[NativeName(NativeNameType.Type, "VkExtent3D")]
		public VkExtent3D ImageExtent;

		public unsafe DaxaBufferImageCopyInfo(DaxaBufferId buffer = default, ulong bufferOffset = default, DaxaImageId image = default, DaxaImageLayout imageLayout = default, DaxaImageArraySlice imageSlice = default, VkOffset3D imageOffset = default, VkExtent3D imageExtent = default)
		{
			Buffer = buffer;
			BufferOffset = bufferOffset;
			Image = image;
			ImageLayout = imageLayout;
			ImageSlice = imageSlice;
			ImageOffset = imageOffset;
			ImageExtent = imageExtent;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ImageBufferCopyInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageBufferCopyInfo
	{
		[NativeName(NativeNameType.Field, "image")]
		[NativeName(NativeNameType.Type, "daxa_ImageId")]
		public DaxaImageId Image;
		[NativeName(NativeNameType.Field, "image_layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout ImageLayout;
		[NativeName(NativeNameType.Field, "image_slice")]
		[NativeName(NativeNameType.Type, "daxa_ImageArraySlice")]
		public DaxaImageArraySlice ImageSlice;
		[NativeName(NativeNameType.Field, "image_offset")]
		[NativeName(NativeNameType.Type, "VkOffset3D")]
		public VkOffset3D ImageOffset;
		[NativeName(NativeNameType.Field, "image_extent")]
		[NativeName(NativeNameType.Type, "VkExtent3D")]
		public VkExtent3D ImageExtent;
		[NativeName(NativeNameType.Field, "buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId Buffer;
		[NativeName(NativeNameType.Field, "buffer_offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong BufferOffset;

		public unsafe DaxaImageBufferCopyInfo(DaxaImageId image = default, DaxaImageLayout imageLayout = default, DaxaImageArraySlice imageSlice = default, VkOffset3D imageOffset = default, VkExtent3D imageExtent = default, DaxaBufferId buffer = default, ulong bufferOffset = default)
		{
			Image = image;
			ImageLayout = imageLayout;
			ImageSlice = imageSlice;
			ImageOffset = imageOffset;
			ImageExtent = imageExtent;
			Buffer = buffer;
			BufferOffset = bufferOffset;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ImageCopyInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageCopyInfo
	{
		[NativeName(NativeNameType.Field, "src_image")]
		[NativeName(NativeNameType.Type, "daxa_ImageId")]
		public DaxaImageId SrcImage;
		[NativeName(NativeNameType.Field, "src_image_layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout SrcImageLayout;
		[NativeName(NativeNameType.Field, "dst_image")]
		[NativeName(NativeNameType.Type, "daxa_ImageId")]
		public DaxaImageId DstImage;
		[NativeName(NativeNameType.Field, "dst_image_layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout DstImageLayout;
		[NativeName(NativeNameType.Field, "src_slice")]
		[NativeName(NativeNameType.Type, "daxa_ImageArraySlice")]
		public DaxaImageArraySlice SrcSlice;
		[NativeName(NativeNameType.Field, "src_offset")]
		[NativeName(NativeNameType.Type, "VkOffset3D")]
		public VkOffset3D SrcOffset;
		[NativeName(NativeNameType.Field, "dst_slice")]
		[NativeName(NativeNameType.Type, "daxa_ImageArraySlice")]
		public DaxaImageArraySlice DstSlice;
		[NativeName(NativeNameType.Field, "dst_offset")]
		[NativeName(NativeNameType.Type, "VkOffset3D")]
		public VkOffset3D DstOffset;
		[NativeName(NativeNameType.Field, "extent")]
		[NativeName(NativeNameType.Type, "VkExtent3D")]
		public VkExtent3D Extent;

		public unsafe DaxaImageCopyInfo(DaxaImageId srcImage = default, DaxaImageLayout srcImageLayout = default, DaxaImageId dstImage = default, DaxaImageLayout dstImageLayout = default, DaxaImageArraySlice srcSlice = default, VkOffset3D srcOffset = default, DaxaImageArraySlice dstSlice = default, VkOffset3D dstOffset = default, VkExtent3D extent = default)
		{
			SrcImage = srcImage;
			SrcImageLayout = srcImageLayout;
			DstImage = dstImage;
			DstImageLayout = dstImageLayout;
			SrcSlice = srcSlice;
			SrcOffset = srcOffset;
			DstSlice = dstSlice;
			DstOffset = dstOffset;
			Extent = extent;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ImageClearInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaImageClearInfo
	{
		[NativeName(NativeNameType.StructOrClass, "daxa_ImageClearInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct ClearValueUnion
		{
			/// <summary>
			/// Make sure this stays abi compatible with daxa::ClearValue<br/>
			/// </summary>
			[NativeName(NativeNameType.Field, "values")]
			[NativeName(NativeNameType.Type, "VkClearValue")]
			public VkClearValue Values;

			[NativeName(NativeNameType.Field, "index")]
			[NativeName(NativeNameType.Type, "uint8_t")]
			public byte Index;

			public unsafe ClearValueUnion(VkClearValue values = default, byte index = default)
			{
				Values = values;
				Index = index;
			}


		}

		[NativeName(NativeNameType.Field, "image_layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout ImageLayout;
		/// <summary>
		/// Make sure this stays abi compatible with daxa::ClearValue<br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "clear_value")]
		[NativeName(NativeNameType.Type, "")]
		public ClearValueUnion ClearValue;

		[NativeName(NativeNameType.Field, "image")]
		[NativeName(NativeNameType.Type, "daxa_ImageId")]
		public DaxaImageId Image;
		[NativeName(NativeNameType.Field, "dst_slice")]
		[NativeName(NativeNameType.Type, "daxa_ImageMipArraySlice")]
		public DaxaImageMipArraySlice DstSlice;

		public unsafe DaxaImageClearInfo(DaxaImageLayout imageLayout = default, ClearValueUnion clearValue = default, DaxaImageId image = default, DaxaImageMipArraySlice dstSlice = default)
		{
			ImageLayout = imageLayout;
			ClearValue = clearValue;
			Image = image;
			DstSlice = dstSlice;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_BufferClearInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaBufferClearInfo
	{
		[NativeName(NativeNameType.Field, "buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId Buffer;
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong Offset;
		[NativeName(NativeNameType.Field, "size")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong Size;
		[NativeName(NativeNameType.Field, "clear_value")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint ClearValue;

		public unsafe DaxaBufferClearInfo(DaxaBufferId buffer = default, ulong offset = default, ulong size = default, uint clearValue = default)
		{
			Buffer = buffer;
			Offset = offset;
			Size = size;
			ClearValue = clearValue;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_AttachmentResolveInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaAttachmentResolveInfo
	{
		[NativeName(NativeNameType.Field, "mode")]
		[NativeName(NativeNameType.Type, "VkResolveModeFlagBits")]
		public VkResolveModeFlagBits Mode;
		[NativeName(NativeNameType.Field, "image")]
		[NativeName(NativeNameType.Type, "daxa_ImageViewId")]
		public DaxaImageViewId Image;
		[NativeName(NativeNameType.Field, "layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout Layout;

		public unsafe DaxaAttachmentResolveInfo(VkResolveModeFlagBits mode = default, DaxaImageViewId image = default, DaxaImageLayout layout = default)
		{
			Mode = mode;
			Image = image;
			Layout = layout;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_RenderAttachmentInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaRenderAttachmentInfo
	{
		[NativeName(NativeNameType.StructOrClass, "daxa_RenderAttachmentInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct ClearValueUnion
		{
			[NativeName(NativeNameType.Field, "values")]
			[NativeName(NativeNameType.Type, "VkClearValue")]
			public VkClearValue Values;
			[NativeName(NativeNameType.Field, "index")]
			[NativeName(NativeNameType.Type, "uint8_t")]
			public byte Index;

			public unsafe ClearValueUnion(VkClearValue values = default, byte index = default)
			{
				Values = values;
				Index = index;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RenderAttachmentInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct ResolveUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_AttachmentResolveInfo")]
			public DaxaAttachmentResolveInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe ResolveUnion(DaxaAttachmentResolveInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.Field, "image_view")]
		[NativeName(NativeNameType.Type, "daxa_ImageViewId")]
		public DaxaImageViewId ImageView;
		[NativeName(NativeNameType.Field, "layout")]
		[NativeName(NativeNameType.Type, "daxa_ImageLayout")]
		public DaxaImageLayout Layout;
		[NativeName(NativeNameType.Field, "load_op")]
		[NativeName(NativeNameType.Type, "VkAttachmentLoadOp")]
		public VkAttachmentLoadOp LoadOp;
		[NativeName(NativeNameType.Field, "store_op")]
		[NativeName(NativeNameType.Type, "VkAttachmentStoreOp")]
		public VkAttachmentStoreOp StoreOp;
		[NativeName(NativeNameType.Field, "clear_value")]
		[NativeName(NativeNameType.Type, "")]
		public ClearValueUnion ClearValue;
		[NativeName(NativeNameType.Field, "resolve")]
		[NativeName(NativeNameType.Type, "")]
		public ResolveUnion Resolve;

		public unsafe DaxaRenderAttachmentInfo(DaxaImageViewId imageView = default, DaxaImageLayout layout = default, VkAttachmentLoadOp loadOp = default, VkAttachmentStoreOp storeOp = default, ClearValueUnion clearValue = default, ResolveUnion resolve = default)
		{
			ImageView = imageView;
			Layout = layout;
			LoadOp = loadOp;
			StoreOp = storeOp;
			ClearValue = clearValue;
			Resolve = resolve;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_RenderPassBeginInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaRenderPassBeginInfo
	{
		[NativeName(NativeNameType.StructOrClass, "daxa_RenderPassBeginInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct ColorAttachmentsUnion
		{
			[NativeName(NativeNameType.Field, "data")]
			[NativeName(NativeNameType.Type, "daxa_RenderAttachmentInfo[8]")]
			public DaxaRenderAttachmentInfo Data_0;
			public DaxaRenderAttachmentInfo Data_1;
			public DaxaRenderAttachmentInfo Data_2;
			public DaxaRenderAttachmentInfo Data_3;
			public DaxaRenderAttachmentInfo Data_4;
			public DaxaRenderAttachmentInfo Data_5;
			public DaxaRenderAttachmentInfo Data_6;
			public DaxaRenderAttachmentInfo Data_7;
			[NativeName(NativeNameType.Field, "size")]
			[NativeName(NativeNameType.Type, "uint8_t")]
			public byte Size;

			public unsafe ColorAttachmentsUnion(DaxaRenderAttachmentInfo* data = default, byte size = default)
			{
				if (data != default)
				{
					Data_0 = data[0];
					Data_1 = data[1];
					Data_2 = data[2];
					Data_3 = data[3];
					Data_4 = data[4];
					Data_5 = data[5];
					Data_6 = data[6];
					Data_7 = data[7];
				}
				Size = size;
			}

			public unsafe ColorAttachmentsUnion(Span<DaxaRenderAttachmentInfo> data = default, byte size = default)
			{
				if (data != default)
				{
					Data_0 = data[0];
					Data_1 = data[1];
					Data_2 = data[2];
					Data_3 = data[3];
					Data_4 = data[4];
					Data_5 = data[5];
					Data_6 = data[6];
					Data_7 = data[7];
				}
				Size = size;
			}


			public unsafe Span<DaxaRenderAttachmentInfo> Data
			
			{
				get
				{
					fixed (DaxaRenderAttachmentInfo* p = &this.Data_0)
					{
						return new Span<DaxaRenderAttachmentInfo>(p, 8);
					}
				}
			}
		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RenderPassBeginInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct DepthAttachmentUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_RenderAttachmentInfo")]
			public DaxaRenderAttachmentInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe DepthAttachmentUnion(DaxaRenderAttachmentInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.StructOrClass, "daxa_RenderPassBeginInfo::")]
		[StructLayout(LayoutKind.Sequential)]
		public partial struct StencilAttachmentUnion
		{
			[NativeName(NativeNameType.Field, "value")]
			[NativeName(NativeNameType.Type, "daxa_RenderAttachmentInfo")]
			public DaxaRenderAttachmentInfo Value;
			[NativeName(NativeNameType.Field, "has_value")]
			[NativeName(NativeNameType.Type, "daxa_Bool8")]
			public byte HasValue;

			public unsafe StencilAttachmentUnion(DaxaRenderAttachmentInfo value = default, byte hasValue = default)
			{
				Value = value;
				HasValue = hasValue;
			}


		}

		[NativeName(NativeNameType.Field, "color_attachments")]
		[NativeName(NativeNameType.Type, "")]
		public ColorAttachmentsUnion ColorAttachments;
		[NativeName(NativeNameType.Field, "depth_attachment")]
		[NativeName(NativeNameType.Type, "")]
		public DepthAttachmentUnion DepthAttachment;
		[NativeName(NativeNameType.Field, "stencil_attachment")]
		[NativeName(NativeNameType.Type, "")]
		public StencilAttachmentUnion StencilAttachment;
		[NativeName(NativeNameType.Field, "render_area")]
		[NativeName(NativeNameType.Type, "VkRect2D")]
		public VkRect2D RenderArea;

		public unsafe DaxaRenderPassBeginInfo(ColorAttachmentsUnion colorAttachments = default, DepthAttachmentUnion depthAttachment = default, StencilAttachmentUnion stencilAttachment = default, VkRect2D renderArea = default)
		{
			ColorAttachments = colorAttachments;
			DepthAttachment = depthAttachment;
			StencilAttachment = stencilAttachment;
			RenderArea = renderArea;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_TraceRaysInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaTraceRaysInfo
	{
		[NativeName(NativeNameType.Field, "width")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Width;
		[NativeName(NativeNameType.Field, "height")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Height;
		[NativeName(NativeNameType.Field, "depth")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Depth;
		[NativeName(NativeNameType.Field, "raygen_handle_offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint RaygenHandleOffset;
		[NativeName(NativeNameType.Field, "miss_handle_offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MissHandleOffset;
		[NativeName(NativeNameType.Field, "hit_handle_offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint HitHandleOffset;
		[NativeName(NativeNameType.Field, "callable_handle_offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint CallableHandleOffset;

		public unsafe DaxaTraceRaysInfo(uint width = default, uint height = default, uint depth = default, uint raygenHandleOffset = default, uint missHandleOffset = default, uint hitHandleOffset = default, uint callableHandleOffset = default)
		{
			Width = width;
			Height = height;
			Depth = depth;
			RaygenHandleOffset = raygenHandleOffset;
			MissHandleOffset = missHandleOffset;
			HitHandleOffset = hitHandleOffset;
			CallableHandleOffset = callableHandleOffset;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_TraceRaysIndirectInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaTraceRaysIndirectInfo
	{
		[NativeName(NativeNameType.Field, "indirect_device_address")]
		[NativeName(NativeNameType.Type, "uint64_t")]
		public ulong IndirectDeviceAddress;
		[NativeName(NativeNameType.Field, "raygen_handle_offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint RaygenHandleOffset;
		[NativeName(NativeNameType.Field, "miss_handle_offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MissHandleOffset;
		[NativeName(NativeNameType.Field, "hit_handle_offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint HitHandleOffset;
		[NativeName(NativeNameType.Field, "callable_handle_offset")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint CallableHandleOffset;

		public unsafe DaxaTraceRaysIndirectInfo(ulong indirectDeviceAddress = default, uint raygenHandleOffset = default, uint missHandleOffset = default, uint hitHandleOffset = default, uint callableHandleOffset = default)
		{
			IndirectDeviceAddress = indirectDeviceAddress;
			RaygenHandleOffset = raygenHandleOffset;
			MissHandleOffset = missHandleOffset;
			HitHandleOffset = hitHandleOffset;
			CallableHandleOffset = callableHandleOffset;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_DispatchInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDispatchInfo
	{
		[NativeName(NativeNameType.Field, "x")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint X;
		[NativeName(NativeNameType.Field, "y")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Y;
		[NativeName(NativeNameType.Field, "z")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Z;

		public unsafe DaxaDispatchInfo(uint x = default, uint y = default, uint z = default)
		{
			X = x;
			Y = y;
			Z = z;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_DispatchIndirectInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDispatchIndirectInfo
	{
		[NativeName(NativeNameType.Field, "indirect_buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId IndirectBuffer;
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong Offset;

		public unsafe DaxaDispatchIndirectInfo(DaxaBufferId indirectBuffer = default, ulong offset = default)
		{
			IndirectBuffer = indirectBuffer;
			Offset = offset;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_DrawMeshTasksIndirectInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDrawMeshTasksIndirectInfo
	{
		[NativeName(NativeNameType.Field, "indirect_buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId IndirectBuffer;
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong Offset;
		[NativeName(NativeNameType.Field, "draw_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint DrawCount;
		[NativeName(NativeNameType.Field, "stride")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Stride;

		public unsafe DaxaDrawMeshTasksIndirectInfo(DaxaBufferId indirectBuffer = default, ulong offset = default, uint drawCount = default, uint stride = default)
		{
			IndirectBuffer = indirectBuffer;
			Offset = offset;
			DrawCount = drawCount;
			Stride = stride;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_DrawMeshTasksIndirectCountInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDrawMeshTasksIndirectCountInfo
	{
		[NativeName(NativeNameType.Field, "indirect_buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId IndirectBuffer;
		[NativeName(NativeNameType.Field, "offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong Offset;
		[NativeName(NativeNameType.Field, "count_buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId CountBuffer;
		[NativeName(NativeNameType.Field, "count_offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong CountOffset;
		[NativeName(NativeNameType.Field, "max_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MaxCount;
		[NativeName(NativeNameType.Field, "stride")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Stride;

		public unsafe DaxaDrawMeshTasksIndirectCountInfo(DaxaBufferId indirectBuffer = default, ulong offset = default, DaxaBufferId countBuffer = default, ulong countOffset = default, uint maxCount = default, uint stride = default)
		{
			IndirectBuffer = indirectBuffer;
			Offset = offset;
			CountBuffer = countBuffer;
			CountOffset = countOffset;
			MaxCount = maxCount;
			Stride = stride;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_DrawInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDrawInfo
	{
		[NativeName(NativeNameType.Field, "vertex_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint VertexCount;
		[NativeName(NativeNameType.Field, "instance_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint InstanceCount;
		[NativeName(NativeNameType.Field, "first_vertex")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint FirstVertex;
		[NativeName(NativeNameType.Field, "first_instance")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint FirstInstance;

		public unsafe DaxaDrawInfo(uint vertexCount = default, uint instanceCount = default, uint firstVertex = default, uint firstInstance = default)
		{
			VertexCount = vertexCount;
			InstanceCount = instanceCount;
			FirstVertex = firstVertex;
			FirstInstance = firstInstance;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_DrawIndexedInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDrawIndexedInfo
	{
		[NativeName(NativeNameType.Field, "index_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint IndexCount;
		[NativeName(NativeNameType.Field, "instance_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint InstanceCount;
		[NativeName(NativeNameType.Field, "first_index")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint FirstIndex;
		[NativeName(NativeNameType.Field, "vertex_offset")]
		[NativeName(NativeNameType.Type, "int32_t")]
		public int VertexOffset;
		[NativeName(NativeNameType.Field, "first_instance")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint FirstInstance;

		public unsafe DaxaDrawIndexedInfo(uint indexCount = default, uint instanceCount = default, uint firstIndex = default, int vertexOffset = default, uint firstInstance = default)
		{
			IndexCount = indexCount;
			InstanceCount = instanceCount;
			FirstIndex = firstIndex;
			VertexOffset = vertexOffset;
			FirstInstance = firstInstance;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_DrawIndirectInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDrawIndirectInfo
	{
		[NativeName(NativeNameType.Field, "indirect_buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId IndirectBuffer;
		[NativeName(NativeNameType.Field, "indirect_buffer_offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong IndirectBufferOffset;
		[NativeName(NativeNameType.Field, "draw_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint DrawCount;
		[NativeName(NativeNameType.Field, "draw_command_stride")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint DrawCommandStride;
		[NativeName(NativeNameType.Field, "is_indexed")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte IsIndexed;

		public unsafe DaxaDrawIndirectInfo(DaxaBufferId indirectBuffer = default, ulong indirectBufferOffset = default, uint drawCount = default, uint drawCommandStride = default, byte isIndexed = default)
		{
			IndirectBuffer = indirectBuffer;
			IndirectBufferOffset = indirectBufferOffset;
			DrawCount = drawCount;
			DrawCommandStride = drawCommandStride;
			IsIndexed = isIndexed;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_DrawIndirectCountInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaDrawIndirectCountInfo
	{
		[NativeName(NativeNameType.Field, "indirect_buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId IndirectBuffer;
		[NativeName(NativeNameType.Field, "indirect_buffer_offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong IndirectBufferOffset;
		[NativeName(NativeNameType.Field, "count_buffer")]
		[NativeName(NativeNameType.Type, "daxa_BufferId")]
		public DaxaBufferId CountBuffer;
		[NativeName(NativeNameType.Field, "count_buffer_offset")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong CountBufferOffset;
		[NativeName(NativeNameType.Field, "max_draw_count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint MaxDrawCount;
		[NativeName(NativeNameType.Field, "draw_command_stride")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint DrawCommandStride;
		[NativeName(NativeNameType.Field, "is_indexed")]
		[NativeName(NativeNameType.Type, "daxa_Bool8")]
		public byte IsIndexed;

		public unsafe DaxaDrawIndirectCountInfo(DaxaBufferId indirectBuffer = default, ulong indirectBufferOffset = default, DaxaBufferId countBuffer = default, ulong countBufferOffset = default, uint maxDrawCount = default, uint drawCommandStride = default, byte isIndexed = default)
		{
			IndirectBuffer = indirectBuffer;
			IndirectBufferOffset = indirectBufferOffset;
			CountBuffer = countBuffer;
			CountBufferOffset = countBufferOffset;
			MaxDrawCount = maxDrawCount;
			DrawCommandStride = drawCommandStride;
			IsIndexed = isIndexed;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ResetEventsInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaResetEventsInfo
	{
		[NativeName(NativeNameType.Field, "event")]
		[NativeName(NativeNameType.Type, "daxa_Event*")]
		public unsafe DaxaEvent* Event;
		[NativeName(NativeNameType.Field, "stage")]
		[NativeName(NativeNameType.Type, "VkPipelineStageFlags")]
		public uint Stage;

		public unsafe DaxaResetEventsInfo(DaxaEvent* evnt = default, uint stage = default)
		{
			Event = evnt;
			Stage = stage;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_WaitEventsInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaWaitEventsInfo
	{
		[NativeName(NativeNameType.Field, "events")]
		[NativeName(NativeNameType.Type, "daxa_Event*")]
		public unsafe DaxaEvent* Events;
		[NativeName(NativeNameType.Field, "event_count")]
		[NativeName(NativeNameType.Type, "size_t")]
		public ulong EventCount;

		public unsafe DaxaWaitEventsInfo(DaxaEvent* events = default, ulong eventCount = default)
		{
			Events = events;
			EventCount = eventCount;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_WriteTimestampInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaWriteTimestampInfo
	{
		[NativeName(NativeNameType.Field, "query_pool")]
		[NativeName(NativeNameType.Type, "daxa_TimelineQueryPool*")]
		public unsafe DaxaTimelineQueryPool* QueryPool;
		[NativeName(NativeNameType.Field, "pipeline_stage")]
		[NativeName(NativeNameType.Type, "VkPipelineStageFlags2")]
		public uint PipelineStage;
		[NativeName(NativeNameType.Field, "query_index")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint QueryIndex;

		public unsafe DaxaWriteTimestampInfo(DaxaTimelineQueryPool* queryPool = default, uint pipelineStage = default, uint queryIndex = default)
		{
			QueryPool = queryPool;
			PipelineStage = pipelineStage;
			QueryIndex = queryIndex;
		}


	}

	[NativeName(NativeNameType.StructOrClass, "daxa_ResetTimestampsInfo")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct DaxaResetTimestampsInfo
	{
		[NativeName(NativeNameType.Field, "query_pool")]
		[NativeName(NativeNameType.Type, "daxa_TimelineQueryPool*")]
		public unsafe DaxaTimelineQueryPool* QueryPool;
		[NativeName(NativeNameType.Field, "start_index")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint StartIndex;
		[NativeName(NativeNameType.Field, "count")]
		[NativeName(NativeNameType.Type, "uint32_t")]
		public uint Count;

		public unsafe DaxaResetTimestampsInfo(DaxaTimelineQueryPool* queryPool = default, uint startIndex = default, uint count = default)
		{
			QueryPool = queryPool;
			StartIndex = startIndex;
			Count = count;
		}


	}
}
