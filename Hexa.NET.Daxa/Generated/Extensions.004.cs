// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Daxa
{
	public static unsafe partial class Extensions
	{

		[NativeName(NativeNameType.Func, "daxa_cmd_wait_events")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdWaitEvents(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "infos")] [NativeName(NativeNameType.Type, "const daxa_EventWaitInfo*")] DaxaEventSignalInfo* infos, [NativeName(NativeNameType.Param, "info_count")] [NativeName(NativeNameType.Type, "size_t")] nuint infoCount)
		{
			Daxa.DaxaCmdWaitEventsNative(cmdEnc, infos, infoCount);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_wait_events")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdWaitEvents(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "infos")] [NativeName(NativeNameType.Type, "const daxa_EventWaitInfo*")] ref DaxaEventSignalInfo infos, [NativeName(NativeNameType.Param, "info_count")] [NativeName(NativeNameType.Type, "size_t")] nuint infoCount)
		{
			fixed (DaxaEventSignalInfo* pinfos = &infos)
			{
				Daxa.DaxaCmdWaitEventsNative(cmdEnc, (DaxaEventSignalInfo*)pinfos, infoCount);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_wait_event")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdWaitEvent(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_EventWaitInfo*")] DaxaEventSignalInfo* info)
		{
			Daxa.DaxaCmdWaitEventNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_wait_event")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdWaitEvent(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_EventWaitInfo*")] ref DaxaEventSignalInfo info)
		{
			fixed (DaxaEventSignalInfo* pinfo = &info)
			{
				Daxa.DaxaCmdWaitEventNative(cmdEnc, (DaxaEventSignalInfo*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_reset_event")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdResetEvent(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_ResetEventInfo*")] DaxaResetEventInfo* info)
		{
			Daxa.DaxaCmdResetEventNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_reset_event")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdResetEvent(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_ResetEventInfo*")] ref DaxaResetEventInfo info)
		{
			fixed (DaxaResetEventInfo* pinfo = &info)
			{
				Daxa.DaxaCmdResetEventNative(cmdEnc, (DaxaResetEventInfo*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_push_constant")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdPushConstant(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_PushConstantInfo*")] DaxaPushConstantInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdPushConstantNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_push_constant")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdPushConstant(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_PushConstantInfo*")] ref DaxaPushConstantInfo info)
		{
			fixed (DaxaPushConstantInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdPushConstantNative(cmdEnc, (DaxaPushConstantInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_ray_tracing_pipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdSetRayTracingPipeline(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RayTracingPipeline")] DaxaRayTracingPipeline pipeline)
		{
			Daxa.DaxaCmdSetRayTracingPipelineNative(cmdEnc, pipeline);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_compute_pipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdSetComputePipeline(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_ComputePipeline")] DaxaComputePipeline pipeline)
		{
			Daxa.DaxaCmdSetComputePipelineNative(cmdEnc, pipeline);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_raster_pipeline")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdSetRasterPipeline(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RasterPipeline")] DaxaRasterPipeline pipeline)
		{
			Daxa.DaxaCmdSetRasterPipelineNative(cmdEnc, pipeline);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_dispatch")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDispatch(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DispatchInfo*")] DaxaDispatchInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdDispatchNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_dispatch")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDispatch(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DispatchInfo*")] ref DaxaDispatchInfo info)
		{
			fixed (DaxaDispatchInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdDispatchNative(cmdEnc, (DaxaDispatchInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_dispatch_indirect")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDispatchIndirect(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DispatchIndirectInfo*")] DaxaDispatchIndirectInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdDispatchIndirectNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_dispatch_indirect")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDispatchIndirect(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DispatchIndirectInfo*")] ref DaxaDispatchIndirectInfo info)
		{
			fixed (DaxaDispatchIndirectInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdDispatchIndirectNative(cmdEnc, (DaxaDispatchIndirectInfo*)pinfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_cmd_destroy_buffer_deferred")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDestroyBufferDeferred(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_BufferId")] DaxaBufferId id)
		{
			DaxaResult ret = Daxa.DaxaCmdDestroyBufferDeferredNative(cmdEnc, id);
			return ret;
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_cmd_destroy_image_deferred")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDestroyImageDeferred(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageId")] DaxaImageId id)
		{
			DaxaResult ret = Daxa.DaxaCmdDestroyImageDeferredNative(cmdEnc, id);
			return ret;
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_cmd_destroy_image_view_deferred")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDestroyImageViewDeferred(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageViewId")] DaxaImageViewId id)
		{
			DaxaResult ret = Daxa.DaxaCmdDestroyImageViewDeferredNative(cmdEnc, id);
			return ret;
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_cmd_destroy_sampler_deferred")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDestroySamplerDeferred(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_SamplerId")] DaxaSamplerId id)
		{
			DaxaResult ret = Daxa.DaxaCmdDestroySamplerDeferredNative(cmdEnc, id);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_trace_rays")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdTraceRays(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_TraceRaysInfo*")] DaxaTraceRaysInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdTraceRaysNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_trace_rays")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdTraceRays(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_TraceRaysInfo*")] ref DaxaTraceRaysInfo info)
		{
			fixed (DaxaTraceRaysInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdTraceRaysNative(cmdEnc, (DaxaTraceRaysInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_trace_rays_indirect")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdTraceRaysIndirect(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_TraceRaysIndirectInfo*")] DaxaTraceRaysIndirectInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdTraceRaysIndirectNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_trace_rays_indirect")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdTraceRaysIndirect(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_TraceRaysIndirectInfo*")] ref DaxaTraceRaysIndirectInfo info)
		{
			fixed (DaxaTraceRaysIndirectInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdTraceRaysIndirectNative(cmdEnc, (DaxaTraceRaysIndirectInfo*)pinfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_cmd_begin_renderpass")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdBeginRenderpass(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_RenderPassBeginInfo*")] DaxaRenderPassBeginInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdBeginRenderpassNative(cmdEnc, info);
			return ret;
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_cmd_begin_renderpass")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdBeginRenderpass(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_RenderPassBeginInfo*")] ref DaxaRenderPassBeginInfo info)
		{
			fixed (DaxaRenderPassBeginInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdBeginRenderpassNative(cmdEnc, (DaxaRenderPassBeginInfo*)pinfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_cmd_end_renderpass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdEndRenderpass(this DaxaCommandRecorder cmdEnc)
		{
			Daxa.DaxaCmdEndRenderpassNative(cmdEnc);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_viewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdSetViewport(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const VkViewport*")] VkViewport* info)
		{
			Daxa.DaxaCmdSetViewportNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_viewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdSetViewport(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const VkViewport*")] ref VkViewport info)
		{
			fixed (VkViewport* pinfo = &info)
			{
				Daxa.DaxaCmdSetViewportNative(cmdEnc, (VkViewport*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_scissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdSetScissor(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const VkRect2D*")] VkRect2D* info)
		{
			Daxa.DaxaCmdSetScissorNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_scissor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdSetScissor(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const VkRect2D*")] ref VkRect2D info)
		{
			fixed (VkRect2D* pinfo = &info)
			{
				Daxa.DaxaCmdSetScissorNative(cmdEnc, (VkRect2D*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_depth_bias")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdSetDepthBias(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DepthBiasInfo*")] DaxaDepthBiasInfo* info)
		{
			Daxa.DaxaCmdSetDepthBiasNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_depth_bias")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdSetDepthBias(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DepthBiasInfo*")] ref DaxaDepthBiasInfo info)
		{
			fixed (DaxaDepthBiasInfo* pinfo = &info)
			{
				Daxa.DaxaCmdSetDepthBiasNative(cmdEnc, (DaxaDepthBiasInfo*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_index_buffer")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdSetIndexBuffer(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_SetIndexBufferInfo*")] DaxaSetIndexBufferInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdSetIndexBufferNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_index_buffer")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdSetIndexBuffer(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_SetIndexBufferInfo*")] ref DaxaSetIndexBufferInfo info)
		{
			fixed (DaxaSetIndexBufferInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdSetIndexBufferNative(cmdEnc, (DaxaSetIndexBufferInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdDraw(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawInfo*")] DaxaDrawInfo* info)
		{
			Daxa.DaxaCmdDrawNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdDraw(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawInfo*")] ref DaxaDrawInfo info)
		{
			fixed (DaxaDrawInfo* pinfo = &info)
			{
				Daxa.DaxaCmdDrawNative(cmdEnc, (DaxaDrawInfo*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_indexed")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdDrawIndexed(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawIndexedInfo*")] DaxaDrawIndexedInfo* info)
		{
			Daxa.DaxaCmdDrawIndexedNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_indexed")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdDrawIndexed(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawIndexedInfo*")] ref DaxaDrawIndexedInfo info)
		{
			fixed (DaxaDrawIndexedInfo* pinfo = &info)
			{
				Daxa.DaxaCmdDrawIndexedNative(cmdEnc, (DaxaDrawIndexedInfo*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_indirect")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDrawIndirect(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawIndirectInfo*")] DaxaDrawIndirectInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdDrawIndirectNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_indirect")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDrawIndirect(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawIndirectInfo*")] ref DaxaDrawIndirectInfo info)
		{
			fixed (DaxaDrawIndirectInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdDrawIndirectNative(cmdEnc, (DaxaDrawIndirectInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_indirect_count")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDrawIndirectCount(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawIndirectCountInfo*")] DaxaDrawIndirectCountInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdDrawIndirectCountNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_indirect_count")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDrawIndirectCount(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawIndirectCountInfo*")] ref DaxaDrawIndirectCountInfo info)
		{
			fixed (DaxaDrawIndirectCountInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdDrawIndirectCountNative(cmdEnc, (DaxaDrawIndirectCountInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_mesh_tasks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdDrawMeshTasks(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "uint32_t")] uint x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "uint32_t")] uint y, [NativeName(NativeNameType.Param, "z")] [NativeName(NativeNameType.Type, "uint32_t")] uint z)
		{
			Daxa.DaxaCmdDrawMeshTasksNative(cmdEnc, x, y, z);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_mesh_tasks_indirect")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDrawMeshTasksIndirect(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawMeshTasksIndirectInfo*")] DaxaDrawMeshTasksIndirectInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdDrawMeshTasksIndirectNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_mesh_tasks_indirect")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDrawMeshTasksIndirect(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawMeshTasksIndirectInfo*")] ref DaxaDrawMeshTasksIndirectInfo info)
		{
			fixed (DaxaDrawMeshTasksIndirectInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdDrawMeshTasksIndirectNative(cmdEnc, (DaxaDrawMeshTasksIndirectInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_mesh_tasks_indirect_count")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDrawMeshTasksIndirectCount(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawMeshTasksIndirectCountInfo*")] DaxaDrawMeshTasksIndirectCountInfo* info)
		{
			DaxaResult ret = Daxa.DaxaCmdDrawMeshTasksIndirectCountNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_draw_mesh_tasks_indirect_count")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdDrawMeshTasksIndirectCount(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DrawMeshTasksIndirectCountInfo*")] ref DaxaDrawMeshTasksIndirectCountInfo info)
		{
			fixed (DaxaDrawMeshTasksIndirectCountInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaCmdDrawMeshTasksIndirectCountNative(cmdEnc, (DaxaDrawMeshTasksIndirectCountInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_write_timestamp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdWriteTimestamp(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_WriteTimestampInfo*")] DaxaWriteTimestampInfo* info)
		{
			Daxa.DaxaCmdWriteTimestampNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_write_timestamp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdWriteTimestamp(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_WriteTimestampInfo*")] ref DaxaWriteTimestampInfo info)
		{
			fixed (DaxaWriteTimestampInfo* pinfo = &info)
			{
				Daxa.DaxaCmdWriteTimestampNative(cmdEnc, (DaxaWriteTimestampInfo*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_reset_timestamps")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdResetTimestamps(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_ResetTimestampsInfo*")] DaxaResetTimestampsInfo* info)
		{
			Daxa.DaxaCmdResetTimestampsNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_reset_timestamps")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdResetTimestamps(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_ResetTimestampsInfo*")] ref DaxaResetTimestampsInfo info)
		{
			fixed (DaxaResetTimestampsInfo* pinfo = &info)
			{
				Daxa.DaxaCmdResetTimestampsNative(cmdEnc, (DaxaResetTimestampsInfo*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_begin_label")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdBeginLabel(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_CommandLabelInfo*")] DaxaCommandLabelInfo* info)
		{
			Daxa.DaxaCmdBeginLabelNative(cmdEnc, info);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_begin_label")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdBeginLabel(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_CommandLabelInfo*")] ref DaxaCommandLabelInfo info)
		{
			fixed (DaxaCommandLabelInfo* pinfo = &info)
			{
				Daxa.DaxaCmdBeginLabelNative(cmdEnc, (DaxaCommandLabelInfo*)pinfo);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_end_label")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdEndLabel(this DaxaCommandRecorder cmdEnc)
		{
			Daxa.DaxaCmdEndLabelNative(cmdEnc);
		}

		/// <summary>/// Is called by all other commands. Flushes internal pipeline barrier list to actual vulkan call.<br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_cmd_flush_barriers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CmdFlushBarriers(this DaxaCommandRecorder cmdEnc)
		{
			Daxa.DaxaCmdFlushBarriersNative(cmdEnc);
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_complete_current_commands")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdCompleteCurrentCommands(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "out_executable_cmds")] [NativeName(NativeNameType.Type, "daxa_ExecutableCommandList*")] DaxaExecutableCommandList* outExecutableCmds)
		{
			DaxaResult ret = Daxa.DaxaCmdCompleteCurrentCommandsNative(cmdEnc, outExecutableCmds);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_complete_current_commands")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CmdCompleteCurrentCommands(this DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "out_executable_cmds")] [NativeName(NativeNameType.Type, "daxa_ExecutableCommandList*")] ref DaxaExecutableCommandList outExecutableCmds)
		{
			fixed (DaxaExecutableCommandList* poutExecutableCmds = &outExecutableCmds)
			{
				DaxaResult ret = Daxa.DaxaCmdCompleteCurrentCommandsNative(cmdEnc, (DaxaExecutableCommandList*)poutExecutableCmds);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_CommandRecorderInfo*")]
		public static DaxaCommandRecorderInfo* CmdInfo(this DaxaCommandRecorder cmdEnc)
		{
			DaxaCommandRecorderInfo* ret = Daxa.DaxaCmdInfoNative(cmdEnc);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_get_vk_command_buffer")]
		[return: NativeName(NativeNameType.Type, "VkCommandBuffer")]
		public static VkCommandBuffer CmdGetVkCommandBuffer(this DaxaCommandRecorder cmdEnc)
		{
			VkCommandBuffer ret = Daxa.DaxaCmdGetVkCommandBufferNative(cmdEnc);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_get_vk_command_pool")]
		[return: NativeName(NativeNameType.Type, "VkCommandPool")]
		public static VkCommandPool CmdGetVkCommandPool(this DaxaCommandRecorder cmdEnc)
		{
			VkCommandPool ret = Daxa.DaxaCmdGetVkCommandPoolNative(cmdEnc);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_destroy_command_recorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyCommandRecorder(this DaxaCommandRecorder cmdEnc)
		{
			Daxa.DaxaDestroyCommandRecorderNative(cmdEnc);
		}

		[NativeName(NativeNameType.Func, "daxa_executable_commands_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong CommandsIncRefcnt(this DaxaExecutableCommandList executableCommands)
		{
			ulong ret = Daxa.DaxaExecutableCommandsIncRefcntNative(executableCommands);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_executable_commands_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong CommandsDecRefcnt(this DaxaExecutableCommandList executableCommands)
		{
			ulong ret = Daxa.DaxaExecutableCommandsDecRefcntNative(executableCommands);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_instance_create_device")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CreateDevice(this DaxaInstance instance, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DeviceInfo*")] DaxaDeviceInfo* info, [NativeName(NativeNameType.Param, "out_device")] [NativeName(NativeNameType.Type, "daxa_Device*")] DaxaDevice* outDevice)
		{
			DaxaResult ret = Daxa.DaxaInstanceCreateDeviceNative(instance, info, outDevice);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_instance_create_device")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CreateDevice(this DaxaInstance instance, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DeviceInfo*")] ref DaxaDeviceInfo info, [NativeName(NativeNameType.Param, "out_device")] [NativeName(NativeNameType.Type, "daxa_Device*")] DaxaDevice* outDevice)
		{
			fixed (DaxaDeviceInfo* pinfo = &info)
			{
				DaxaResult ret = Daxa.DaxaInstanceCreateDeviceNative(instance, (DaxaDeviceInfo*)pinfo, outDevice);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_instance_create_device")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CreateDevice(this DaxaInstance instance, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DeviceInfo*")] DaxaDeviceInfo* info, [NativeName(NativeNameType.Param, "out_device")] [NativeName(NativeNameType.Type, "daxa_Device*")] ref DaxaDevice outDevice)
		{
			fixed (DaxaDevice* poutDevice = &outDevice)
			{
				DaxaResult ret = Daxa.DaxaInstanceCreateDeviceNative(instance, info, (DaxaDevice*)poutDevice);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_instance_create_device")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult CreateDevice(this DaxaInstance instance, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_DeviceInfo*")] ref DaxaDeviceInfo info, [NativeName(NativeNameType.Param, "out_device")] [NativeName(NativeNameType.Type, "daxa_Device*")] ref DaxaDevice outDevice)
		{
			fixed (DaxaDeviceInfo* pinfo = &info)
			{
				fixed (DaxaDevice* poutDevice = &outDevice)
				{
					DaxaResult ret = Daxa.DaxaInstanceCreateDeviceNative(instance, (DaxaDeviceInfo*)pinfo, (DaxaDevice*)poutDevice);
					return ret;
				}
			}
		}

		/// <summary>/// Returns previous ref count.<br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_instance_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong IncRefcnt(this DaxaInstance instance)
		{
			ulong ret = Daxa.DaxaInstanceIncRefcntNative(instance);
			return ret;
		}

		/// <summary>/// Returns previous ref count.<br/>/// </summary>		[NativeName(NativeNameType.Func, "daxa_instance_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DecRefcnt(this DaxaInstance instance)
		{
			ulong ret = Daxa.DaxaInstanceDecRefcntNative(instance);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_instance_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_InstanceInfo*")]
		public static DaxaInstanceInfo* Info(this DaxaInstance instance)
		{
			DaxaInstanceInfo* ret = Daxa.DaxaInstanceInfoNative(instance);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_instance_get_vk_instance")]
		[return: NativeName(NativeNameType.Type, "VkInstance")]
		public static VkInstance GetVkInstance(this DaxaInstance instance)
		{
			VkInstance ret = Daxa.DaxaInstanceGetVkInstanceNative(instance);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_ray_tracing_pipeline_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_RayTracingPipelineInfo*")]
		public static DaxaRayTracingPipelineInfo* Info(this DaxaRayTracingPipeline rayTracingPipeline)
		{
			DaxaRayTracingPipelineInfo* ret = Daxa.DaxaRayTracingPipelineInfoNative(rayTracingPipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_ray_tracing_pipeline_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong IncRefcnt(this DaxaRayTracingPipeline pipeline)
		{
			ulong ret = Daxa.DaxaRayTracingPipelineIncRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_ray_tracing_pipeline_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DecRefcnt(this DaxaRayTracingPipeline pipeline)
		{
			ulong ret = Daxa.DaxaRayTracingPipelineDecRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_compute_pipeline_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_ComputePipelineInfo*")]
		public static DaxaComputePipelineInfo* Info(this DaxaComputePipeline computePipeline)
		{
			DaxaComputePipelineInfo* ret = Daxa.DaxaComputePipelineInfoNative(computePipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_compute_pipeline_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong IncRefcnt(this DaxaComputePipeline pipeline)
		{
			ulong ret = Daxa.DaxaComputePipelineIncRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_compute_pipeline_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DecRefcnt(this DaxaComputePipeline pipeline)
		{
			ulong ret = Daxa.DaxaComputePipelineDecRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_raster_pipeline_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_RasterPipelineInfo*")]
		public static DaxaRasterPipelineInfo* Info(this DaxaRasterPipeline rasterPipeline)
		{
			DaxaRasterPipelineInfo* ret = Daxa.DaxaRasterPipelineInfoNative(rasterPipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_raster_pipeline_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong IncRefcnt(this DaxaRasterPipeline pipeline)
		{
			ulong ret = Daxa.DaxaRasterPipelineIncRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_raster_pipeline_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DecRefcnt(this DaxaRasterPipeline pipeline)
		{
			ulong ret = Daxa.DaxaRasterPipelineDecRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_get_surface_extent")]
		[return: NativeName(NativeNameType.Type, "VkExtent2D")]
		public static VkExtent2D SwpGetSurfaceExtent(this DaxaSwapchain swapchain)
		{
			VkExtent2D ret = Daxa.DaxaSwpGetSurfaceExtentNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_get_format")]
		[return: NativeName(NativeNameType.Type, "VkFormat")]
		public static VkFormat SwpGetFormat(this DaxaSwapchain swapchain)
		{
			VkFormat ret = Daxa.DaxaSwpGetFormatNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_resize")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult SwpResize(this DaxaSwapchain swapchain)
		{
			DaxaResult ret = Daxa.DaxaSwpResizeNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_set_present_mode")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult SwpSetPresentMode(this DaxaSwapchain swapchain, [NativeName(NativeNameType.Param, "present_mode")] [NativeName(NativeNameType.Type, "VkPresentModeKHR")] VkPresentModeKHR presentMode)
		{
			DaxaResult ret = Daxa.DaxaSwpSetPresentModeNative(swapchain, presentMode);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_acquire_next_image")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult SwpAcquireNextImage(this DaxaSwapchain swapchain, [NativeName(NativeNameType.Param, "out_image_id")] [NativeName(NativeNameType.Type, "daxa_ImageId*")] DaxaImageId* outImageId)
		{
			DaxaResult ret = Daxa.DaxaSwpAcquireNextImageNative(swapchain, outImageId);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_acquire_next_image")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult SwpAcquireNextImage(this DaxaSwapchain swapchain, [NativeName(NativeNameType.Param, "out_image_id")] [NativeName(NativeNameType.Type, "daxa_ImageId*")] ref DaxaImageId outImageId)
		{
			fixed (DaxaImageId* poutImageId = &outImageId)
			{
				DaxaResult ret = Daxa.DaxaSwpAcquireNextImageNative(swapchain, (DaxaImageId*)poutImageId);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_swp_current_acquire_semaphore")]
		[return: NativeName(NativeNameType.Type, "daxa_BinarySemaphore*")]
		public static DaxaBinarySemaphore* SwpCurrentAcquireSemaphore(this DaxaSwapchain swapchain)
		{
			DaxaBinarySemaphore* ret = Daxa.DaxaSwpCurrentAcquireSemaphoreNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_current_present_semaphore")]
		[return: NativeName(NativeNameType.Type, "daxa_BinarySemaphore*")]
		public static DaxaBinarySemaphore* SwpCurrentPresentSemaphore(this DaxaSwapchain swapchain)
		{
			DaxaBinarySemaphore* ret = Daxa.DaxaSwpCurrentPresentSemaphoreNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_current_cpu_timeline_value")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong SwpCurrentCpuTimelineValue(this DaxaSwapchain swapchain)
		{
			ulong ret = Daxa.DaxaSwpCurrentCpuTimelineValueNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_gpu_timeline_semaphore")]
		[return: NativeName(NativeNameType.Type, "daxa_TimelineSemaphore*")]
		public static DaxaTimelineSemaphore* SwpGpuTimelineSemaphore(this DaxaSwapchain swapchain)
		{
			DaxaTimelineSemaphore* ret = Daxa.DaxaSwpGpuTimelineSemaphoreNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_SwapchainInfo*")]
		public static DaxaSwapchainInfo* SwpInfo(this DaxaSwapchain swapchain)
		{
			DaxaSwapchainInfo* ret = Daxa.DaxaSwpInfoNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_get_vk_swapchain")]
		[return: NativeName(NativeNameType.Type, "VkSwapchainKHR")]
		public static VkSwapchainKHR SwpGetVkSwapchain(this DaxaSwapchain swapchain)
		{
			VkSwapchainKHR ret = Daxa.DaxaSwpGetVkSwapchainNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_get_vk_surface")]
		[return: NativeName(NativeNameType.Type, "VkSurfaceKHR")]
		public static VkSurfaceKHR SwpGetVkSurface(this DaxaSwapchain swapchain)
		{
			VkSurfaceKHR ret = Daxa.DaxaSwpGetVkSurfaceNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong SwpIncRefcnt(this DaxaSwapchain swapchain)
		{
			ulong ret = Daxa.DaxaSwpIncRefcntNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_swp_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong SwpDecRefcnt(this DaxaSwapchain swapchain)
		{
			ulong ret = Daxa.DaxaSwpDecRefcntNative(swapchain);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_BinarySemaphoreInfo*")]
		public static DaxaBinarySemaphoreInfo* Info(this DaxaBinarySemaphore binarySemaphore)
		{
			DaxaBinarySemaphoreInfo* ret = Daxa.DaxaBinarySemaphoreInfoNative(binarySemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_get_vk_semaphore")]
		[return: NativeName(NativeNameType.Type, "VkSemaphore")]
		public static VkSemaphore GetVkSemaphore(this DaxaBinarySemaphore binarySemaphore)
		{
			VkSemaphore ret = Daxa.DaxaBinarySemaphoreGetVkSemaphoreNative(binarySemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong IncRefcnt(this DaxaBinarySemaphore binarySemaphore)
		{
			ulong ret = Daxa.DaxaBinarySemaphoreIncRefcntNative(binarySemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DecRefcnt(this DaxaBinarySemaphore binarySemaphore)
		{
			ulong ret = Daxa.DaxaBinarySemaphoreDecRefcntNative(binarySemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_TimelineSemaphoreInfo*")]
		public static DaxaTimelineSemaphoreInfo* Info(this DaxaTimelineSemaphore timelineSemaphore)
		{
			DaxaTimelineSemaphoreInfo* ret = Daxa.DaxaTimelineSemaphoreInfoNative(timelineSemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_get_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult GetValue(this DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "out_value")] [NativeName(NativeNameType.Type, "uint64_t*")] ulong* outValue)
		{
			DaxaResult ret = Daxa.DaxaTimelineSemaphoreGetValueNative(timelineSemaphore, outValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_get_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult GetValue(this DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "out_value")] [NativeName(NativeNameType.Type, "uint64_t*")] ref ulong outValue)
		{
			fixed (ulong* poutValue = &outValue)
			{
				DaxaResult ret = Daxa.DaxaTimelineSemaphoreGetValueNative(timelineSemaphore, (ulong*)poutValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_set_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult SetValue(this DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "uint64_t")] ulong value)
		{
			DaxaResult ret = Daxa.DaxaTimelineSemaphoreSetValueNative(timelineSemaphore, value);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_wait_for_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult WaitForValue(this DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "uint64_t")] ulong value, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "uint64_t")] ulong timeout)
		{
			DaxaResult ret = Daxa.DaxaTimelineSemaphoreWaitForValueNative(timelineSemaphore, value, timeout);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_get_vk_semaphore")]
		[return: NativeName(NativeNameType.Type, "VkSemaphore")]
		public static VkSemaphore GetVkSemaphore(this DaxaTimelineSemaphore timelineSemaphore)
		{
			VkSemaphore ret = Daxa.DaxaTimelineSemaphoreGetVkSemaphoreNative(timelineSemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong IncRefcnt(this DaxaTimelineSemaphore timelineSemaphore)
		{
			ulong ret = Daxa.DaxaTimelineSemaphoreIncRefcntNative(timelineSemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DecRefcnt(this DaxaTimelineSemaphore timelineSemaphore)
		{
			ulong ret = Daxa.DaxaTimelineSemaphoreDecRefcntNative(timelineSemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_event_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_EventInfo*")]
		public static DaxaEventInfo* Info(this DaxaEvent evnt)
		{
			DaxaEventInfo* ret = Daxa.DaxaEventInfoNative(evnt);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_event_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong IncRefcnt(this DaxaEvent evnt)
		{
			ulong ret = Daxa.DaxaEventIncRefcntNative(evnt);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_event_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DecRefcnt(this DaxaEvent evnt)
		{
			ulong ret = Daxa.DaxaEventDecRefcntNative(evnt);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_TimelineQueryPoolInfo*")]
		public static DaxaTimelineQueryPoolInfo* Info(this DaxaTimelineQueryPool timelineQueryPool)
		{
			DaxaTimelineQueryPoolInfo* ret = Daxa.DaxaTimelineQueryPoolInfoNative(timelineQueryPool);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_query_results")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult Results(this DaxaTimelineQueryPool timelineQueryPool, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "uint32_t")] uint start, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "uint32_t")] uint count, [NativeName(NativeNameType.Param, "out_results")] [NativeName(NativeNameType.Type, "uint64_t*")] ulong* outResults)
		{
			DaxaResult ret = Daxa.DaxaTimelineQueryPoolQueryResultsNative(timelineQueryPool, start, count, outResults);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_query_results")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult Results(this DaxaTimelineQueryPool timelineQueryPool, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "uint32_t")] uint start, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "uint32_t")] uint count, [NativeName(NativeNameType.Param, "out_results")] [NativeName(NativeNameType.Type, "uint64_t*")] ref ulong outResults)
		{
			fixed (ulong* poutResults = &outResults)
			{
				DaxaResult ret = Daxa.DaxaTimelineQueryPoolQueryResultsNative(timelineQueryPool, start, count, (ulong*)poutResults);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong IncRefcnt(this DaxaTimelineQueryPool timelineQueryPool)
		{
			ulong ret = Daxa.DaxaTimelineQueryPoolIncRefcntNative(timelineQueryPool);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DecRefcnt(this DaxaTimelineQueryPool timelineQueryPool)
		{
			ulong ret = Daxa.DaxaTimelineQueryPoolDecRefcntNative(timelineQueryPool);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_memory_block_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_MemoryBlockInfo*")]
		public static DaxaMemoryBlockInfo* Info(this DaxaMemoryBlock memoryBlock)
		{
			DaxaMemoryBlockInfo* ret = Daxa.DaxaMemoryBlockInfoNative(memoryBlock);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_memory_block_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong IncRefcnt(this DaxaMemoryBlock memoryBlock)
		{
			ulong ret = Daxa.DaxaMemoryBlockIncRefcntNative(memoryBlock);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_memory_block_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DecRefcnt(this DaxaMemoryBlock memoryBlock)
		{
			ulong ret = Daxa.DaxaMemoryBlockDecRefcntNative(memoryBlock);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_memory_block_get_vma_allocation")]
		[return: NativeName(NativeNameType.Type, "VmaAllocation")]
		public static VmaAllocation GetVmaAllocation(this DaxaMemoryBlock memoryBlock)
		{
			VmaAllocation ret = Daxa.DaxaMemoryBlockGetVmaAllocationNative(memoryBlock);
			return ret;
		}

		/// <summary>/// Destroys allocator object.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyAllocator")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyAllocator(this VmaAllocator allocator)
		{
			Daxa.VmaDestroyAllocatorNative(allocator);
		}

		/// <summary>/// <br/>/// It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to<br/>/// `VkPhysicalDevice`, `VkDevice` etc. every time using this function.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocatorInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocatorInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pAllocatorInfo")] [NativeName(NativeNameType.Type, "VmaAllocatorInfo*")] VmaAllocatorInfo* pAllocatorInfo)
		{
			Daxa.VmaGetAllocatorInfoNative(allocator, pAllocatorInfo);
		}

		/// <summary>/// <br/>/// It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to<br/>/// `VkPhysicalDevice`, `VkDevice` etc. every time using this function.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocatorInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocatorInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pAllocatorInfo")] [NativeName(NativeNameType.Type, "VmaAllocatorInfo*")] ref VmaAllocatorInfo pAllocatorInfo)
		{
			fixed (VmaAllocatorInfo* ppAllocatorInfo = &pAllocatorInfo)
			{
				Daxa.VmaGetAllocatorInfoNative(allocator, (VmaAllocatorInfo*)ppAllocatorInfo);
			}
		}

		/// <summary>/// PhysicalDeviceProperties are fetched from physicalDevice by the allocator.<br/>/// You can access it here, without fetching it again on your own.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPhysicalDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPhysicalDeviceProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceProperties**")] VkPhysicalDeviceProperties** ppPhysicalDeviceProperties)
		{
			Daxa.VmaGetPhysicalDevicePropertiesNative(allocator, ppPhysicalDeviceProperties);
		}

		/// <summary>/// PhysicalDeviceProperties are fetched from physicalDevice by the allocator.<br/>/// You can access it here, without fetching it again on your own.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPhysicalDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPhysicalDeviceProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceProperties**")] ref VkPhysicalDeviceProperties* ppPhysicalDeviceProperties)
		{
			fixed (VkPhysicalDeviceProperties** pppPhysicalDeviceProperties = &ppPhysicalDeviceProperties)
			{
				Daxa.VmaGetPhysicalDevicePropertiesNative(allocator, (VkPhysicalDeviceProperties**)pppPhysicalDeviceProperties);
			}
		}

		/// <summary>/// PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.<br/>/// You can access it here, without fetching it again on your own.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceMemoryProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceMemoryProperties**")] VkPhysicalDeviceMemoryProperties** ppPhysicalDeviceMemoryProperties)
		{
			Daxa.VmaGetMemoryPropertiesNative(allocator, ppPhysicalDeviceMemoryProperties);
		}

		/// <summary>/// PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.<br/>/// You can access it here, without fetching it again on your own.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceMemoryProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceMemoryProperties**")] ref VkPhysicalDeviceMemoryProperties* ppPhysicalDeviceMemoryProperties)
		{
			fixed (VkPhysicalDeviceMemoryProperties** pppPhysicalDeviceMemoryProperties = &ppPhysicalDeviceMemoryProperties)
			{
				Daxa.VmaGetMemoryPropertiesNative(allocator, (VkPhysicalDeviceMemoryProperties**)pppPhysicalDeviceMemoryProperties);
			}
		}

		/// <summary>/// This is just a convenience function. Same information can be obtained using<br/>/// vmaGetMemoryProperties().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryTypeProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryTypeProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeIndex, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] uint* pFlags)
		{
			Daxa.VmaGetMemoryTypePropertiesNative(allocator, memoryTypeIndex, pFlags);
		}

		/// <summary>/// This is just a convenience function. Same information can be obtained using<br/>/// vmaGetMemoryProperties().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryTypeProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetMemoryTypeProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeIndex, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] ref uint pFlags)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				Daxa.VmaGetMemoryTypePropertiesNative(allocator, memoryTypeIndex, (uint*)ppFlags);
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetCurrentFrameIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetCurrentFrameIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "frameIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint frameIndex)
		{
			Daxa.VmaSetCurrentFrameIndexNative(allocator, frameIndex);
		}

		/// <summary>/// <br/>/// This function is called "calculate" not "get" because it has to traverse all<br/>/// internal data structures, so it may be quite slow. Use it for debugging purposes.<br/>/// For faster but more brief statistics suitable to be called every frame or every allocation,<br/>/// use vmaGetHeapBudgets().<br/>/// Note that when using allocator from multiple threads, returned information may immediately<br/>/// become outdated.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculateStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaTotalStatistics*")] VmaTotalStatistics* pStats)
		{
			Daxa.VmaCalculateStatisticsNative(allocator, pStats);
		}

		/// <summary>/// <br/>/// This function is called "calculate" not "get" because it has to traverse all<br/>/// internal data structures, so it may be quite slow. Use it for debugging purposes.<br/>/// For faster but more brief statistics suitable to be called every frame or every allocation,<br/>/// use vmaGetHeapBudgets().<br/>/// Note that when using allocator from multiple threads, returned information may immediately<br/>/// become outdated.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculateStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaTotalStatistics*")] ref VmaTotalStatistics pStats)
		{
			fixed (VmaTotalStatistics* ppStats = &pStats)
			{
				Daxa.VmaCalculateStatisticsNative(allocator, (VmaTotalStatistics*)ppStats);
			}
		}

		/// <summary>/// <br/>/// This function is called "get" not "calculate" because it is very fast, suitable to be called<br/>/// every frame or every allocation. For more detailed statistics use vmaCalculateStatistics().<br/>/// Note that when using allocator from multiple threads, returned information may immediately<br/>/// become outdated.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetHeapBudgets")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetHeapBudgets(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBudgets")] [NativeName(NativeNameType.Type, "VmaBudget*")] VmaBudget* pBudgets)
		{
			Daxa.VmaGetHeapBudgetsNative(allocator, pBudgets);
		}

		/// <summary>/// <br/>/// This function is called "get" not "calculate" because it is very fast, suitable to be called<br/>/// every frame or every allocation. For more detailed statistics use vmaCalculateStatistics().<br/>/// Note that when using allocator from multiple threads, returned information may immediately<br/>/// become outdated.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetHeapBudgets")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetHeapBudgets(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBudgets")] [NativeName(NativeNameType.Type, "VmaBudget*")] ref VmaBudget pBudgets)
		{
			fixed (VmaBudget* ppBudgets = &pBudgets)
			{
				Daxa.VmaGetHeapBudgetsNative(allocator, (VmaBudget*)ppBudgets);
			}
		}

		/// <summary>/// This algorithm tries to find a memory type that:<br/>/// - Is allowed by memoryTypeBits.<br/>/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>/// - Matches intended usage.<br/>/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			VkResult ret = Daxa.VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, pAllocationCreateInfo, pMemoryTypeIndex);
			return ret;
		}

		/// <summary>/// This algorithm tries to find a memory type that:<br/>/// - Is allowed by memoryTypeBits.<br/>/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>/// - Matches intended usage.<br/>/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = Daxa.VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// This algorithm tries to find a memory type that:<br/>/// - Is allowed by memoryTypeBits.<br/>/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>/// - Matches intended usage.<br/>/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
			{
				VkResult ret = Daxa.VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// This algorithm tries to find a memory type that:<br/>/// - Is allowed by memoryTypeBits.<br/>/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>/// - Matches intended usage.<br/>/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndex(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = Daxa.VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			VkResult ret = Daxa.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
			return ret;
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				VkResult ret = Daxa.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = Daxa.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					VkResult ret = Daxa.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
			{
				VkResult ret = Daxa.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = Daxa.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = Daxa.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForBufferInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
					{
						VkResult ret = Daxa.VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
						return ret;
					}
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			VkResult ret = Daxa.VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
			return ret;
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				VkResult ret = Daxa.VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = Daxa.VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					VkResult ret = Daxa.VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
			{
				VkResult ret = Daxa.VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = Daxa.VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = Daxa.VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FindMemoryTypeIndexForImageInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
					{
						VkResult ret = Daxa.VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreatePool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] VmaPoolCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] VmaPool* pPool)
		{
			VkResult ret = Daxa.VmaCreatePoolNative(allocator, pCreateInfo, pPool);
			return ret;
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreatePool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] ref VmaPoolCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] VmaPool* pPool)
		{
			fixed (VmaPoolCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = Daxa.VmaCreatePoolNative(allocator, (VmaPoolCreateInfo*)ppCreateInfo, pPool);
				return ret;
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreatePool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] VmaPoolCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] ref VmaPool pPool)
		{
			fixed (VmaPool* ppPool = &pPool)
			{
				VkResult ret = Daxa.VmaCreatePoolNative(allocator, pCreateInfo, (VmaPool*)ppPool);
				return ret;
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreatePool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] ref VmaPoolCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] ref VmaPool pPool)
		{
			fixed (VmaPoolCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaPool* ppPool = &pPool)
				{
					VkResult ret = Daxa.VmaCreatePoolNative(allocator, (VmaPoolCreateInfo*)ppCreateInfo, (VmaPool*)ppPool);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyPool")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyPool(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool)
		{
			Daxa.VmaDestroyPoolNative(allocator, pool);
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPoolStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] VmaStatistics* pPoolStats)
		{
			Daxa.VmaGetPoolStatisticsNative(allocator, pool, pPoolStats);
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPoolStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] ref VmaStatistics pPoolStats)
		{
			fixed (VmaStatistics* ppPoolStats = &pPoolStats)
			{
				Daxa.VmaGetPoolStatisticsNative(allocator, pool, (VmaStatistics*)ppPoolStats);
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculatePoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculatePoolStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] VmaDetailedStatistics* pPoolStats)
		{
			Daxa.VmaCalculatePoolStatisticsNative(allocator, pool, pPoolStats);
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculatePoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void CalculatePoolStatistics(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] ref VmaDetailedStatistics pPoolStats)
		{
			fixed (VmaDetailedStatistics* ppPoolStats = &pPoolStats)
			{
				Daxa.VmaCalculatePoolStatisticsNative(allocator, pool, (VmaDetailedStatistics*)ppPoolStats);
			}
		}

		/// <summary>/// <br/>/// Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,<br/>/// `VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is<br/>/// `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<br/>/// Possible return values:<br/>/// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.<br/>/// - `VK_SUCCESS` - corruption detection has been performed and succeeded.<br/>/// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.<br/>/// `VMA_ASSERT` is also fired in that case.<br/>/// - Other value: Error returned by Vulkan, e.g. memory mapping failure.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCheckPoolCorruption")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CheckPoolCorruption(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool)
		{
			VkResult ret = Daxa.VmaCheckPoolCorruptionNative(allocator, pool);
			return ret;
		}

		/// <summary>/// <br/>/// After the call `ppName` is either null or points to an internally-owned null-terminated string<br/>/// containing name of the pool that was previously set. The pointer becomes invalid when the pool is<br/>/// destroyed or its name is changed using vmaSetPoolName().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "ppName")] [NativeName(NativeNameType.Type, "const char**")] byte** ppName)
		{
			Daxa.VmaGetPoolNameNative(allocator, pool, ppName);
		}

		/// <summary>/// <br/>/// After the call `ppName` is either null or points to an internally-owned null-terminated string<br/>/// containing name of the pool that was previously set. The pointer becomes invalid when the pool is<br/>/// destroyed or its name is changed using vmaSetPoolName().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "ppName")] [NativeName(NativeNameType.Type, "const char**")] ref byte* ppName)
		{
			fixed (byte** pppName = &ppName)
			{
				Daxa.VmaGetPoolNameNative(allocator, pool, (byte**)pppName);
			}
		}

		/// <summary>/// <br/>/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] byte* pName)
		{
			Daxa.VmaSetPoolNameNative(allocator, pool, pName);
		}

		/// <summary>/// <br/>/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] ref byte pName)
		{
			fixed (byte* ppName = &pName)
			{
				Daxa.VmaSetPoolNameNative(allocator, pool, (byte*)ppName);
			}
		}

		/// <summary>/// <br/>/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetPoolName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] string pName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Daxa.VmaSetPoolNameNative(allocator, pool, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = Daxa.VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = Daxa.VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = Daxa.VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = Daxa.VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = Daxa.VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = Daxa.VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = Daxa.VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = Daxa.VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = Daxa.VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult AllocateMemoryForImage(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemory")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "const VmaAllocation")] VmaAllocation allocation)
		{
			Daxa.VmaFreeMemoryNative(allocator, allocation);
		}

		/// <summary>/// <br/>/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>/// vmaAllocateMemoryPages() and other functions.<br/>/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* pAllocations)
		{
			Daxa.VmaFreeMemoryPagesNative(allocator, allocationCount, pAllocations);
		}

		/// <summary>/// <br/>/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>/// vmaAllocateMemoryPages() and other functions.<br/>/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* pAllocations)
		{
			Daxa.VmaFreeMemoryPagesNative(allocator, allocationCount, pAllocations);
		}

		/// <summary>/// <br/>/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>/// vmaAllocateMemoryPages() and other functions.<br/>/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation pAllocations)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				Daxa.VmaFreeMemoryPagesNative(allocator, allocationCount, (VmaAllocation*)ppAllocations);
			}
		}

		/// <summary>/// <br/>/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>/// vmaAllocateMemoryPages() and other functions.<br/>/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeMemoryPages(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation pAllocations)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				Daxa.VmaFreeMemoryPagesNative(allocator, allocationCount, (VmaAllocation*)ppAllocations);
			}
		}

		/// <summary>/// <br/>/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>/// Although this function doesn't lock any mutex, so it should be quite efficient,<br/>/// you should avoid calling it too often.<br/>/// You can retrieve same VmaAllocationInfo structure while creating your resource, from function<br/>/// vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change<br/>/// (e.g. due to defragmentation).<br/>/// There is also a new function vmaGetAllocationInfo2() that offers extended information<br/>/// about the allocation, returned using new structure #VmaAllocationInfo2.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			Daxa.VmaGetAllocationInfoNative(allocator, allocation, pAllocationInfo);
		}

		/// <summary>/// <br/>/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>/// Although this function doesn't lock any mutex, so it should be quite efficient,<br/>/// you should avoid calling it too often.<br/>/// You can retrieve same VmaAllocationInfo structure while creating your resource, from function<br/>/// vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change<br/>/// (e.g. due to defragmentation).<br/>/// There is also a new function vmaGetAllocationInfo2() that offers extended information<br/>/// about the allocation, returned using new structure #VmaAllocationInfo2.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationInfo(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				Daxa.VmaGetAllocationInfoNative(allocator, allocation, (VmaAllocationInfo*)ppAllocationInfo);
			}
		}

		/// <summary>/// <br/>/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>/// Extended parameters in structure #VmaAllocationInfo2 include memory block size<br/>/// and a flag telling whether the allocation has dedicated memory.<br/>/// It can be useful e.g. for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo2")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationInfo2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo2*")] VmaAllocationInfo2* pAllocationInfo)
		{
			Daxa.VmaGetAllocationInfo2Native(allocator, allocation, pAllocationInfo);
		}

		/// <summary>/// <br/>/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>/// Extended parameters in structure #VmaAllocationInfo2 include memory block size<br/>/// and a flag telling whether the allocation has dedicated memory.<br/>/// It can be useful e.g. for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo2")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationInfo2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo2*")] ref VmaAllocationInfo2 pAllocationInfo)
		{
			fixed (VmaAllocationInfo2* ppAllocationInfo = &pAllocationInfo)
			{
				Daxa.VmaGetAllocationInfo2Native(allocator, allocation, (VmaAllocationInfo2*)ppAllocationInfo);
			}
		}

		/// <summary>/// <br/>/// The value of pointer `pUserData` is copied to allocation's `pUserData`.<br/>/// It is opaque, so you can use it however you want - e.g.<br/>/// as a pointer, ordinal number or some handle to you own data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAllocationUserData(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pUserData")] [NativeName(NativeNameType.Type, "void*")] void* pUserData)
		{
			Daxa.VmaSetAllocationUserDataNative(allocator, allocation, pUserData);
		}

		/// <summary>/// <br/>/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>/// makes local copy of the string and sets it as allocation's `pName`. String<br/>/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>/// you can free it after this call. String previously pointed by allocation's<br/>/// `pName` is freed from memory.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAllocationName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] byte* pName)
		{
			Daxa.VmaSetAllocationNameNative(allocator, allocation, pName);
		}

		/// <summary>/// <br/>/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>/// makes local copy of the string and sets it as allocation's `pName`. String<br/>/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>/// you can free it after this call. String previously pointed by allocation's<br/>/// `pName` is freed from memory.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAllocationName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] ref byte pName)
		{
			fixed (byte* ppName = &pName)
			{
				Daxa.VmaSetAllocationNameNative(allocator, allocation, (byte*)ppName);
			}
		}

		/// <summary>/// <br/>/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>/// makes local copy of the string and sets it as allocation's `pName`. String<br/>/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>/// you can free it after this call. String previously pointed by allocation's<br/>/// `pName` is freed from memory.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAllocationName(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] string pName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Daxa.VmaSetAllocationNameNative(allocator, allocation, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>/// This is just a convenience function. Same information can be obtained using<br/>/// vmaGetAllocationInfo() + vmaGetMemoryProperties().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationMemoryProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] uint* pFlags)
		{
			Daxa.VmaGetAllocationMemoryPropertiesNative(allocator, allocation, pFlags);
		}

		/// <summary>/// This is just a convenience function. Same information can be obtained using<br/>/// vmaGetAllocationInfo() + vmaGetMemoryProperties().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetAllocationMemoryProperties(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] ref uint pFlags)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				Daxa.VmaGetAllocationMemoryPropertiesNative(allocator, allocation, (uint*)ppFlags);
			}
		}

		/// <summary>/// <br/>/// Maps memory represented by given allocation to make it accessible to CPU code.<br/>/// When succeeded, `*ppData` contains pointer to first byte of this memory.<br/>/// Mapping is internally reference-counted and synchronized, so despite raw Vulkan<br/>/// function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`<br/>/// multiple times simultaneously, it is safe to call this function on allocations<br/>/// assigned to the same memory block. Actual Vulkan memory will be mapped on first<br/>/// mapping and unmapped on last unmapping.<br/>/// If the function succeeded, you must call vmaUnmapMemory() to unmap the<br/>/// allocation when mapping is no longer needed or before freeing the allocation, at<br/>/// the latest.<br/>/// It also safe to call this function multiple times on the same allocation. You<br/>/// must call vmaUnmapMemory() same number of times as you called vmaMapMemory().<br/>/// It is also safe to call this function on allocation created with<br/>/// #VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.<br/>/// You must still call vmaUnmapMemory() same number of times as you called<br/>/// vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the<br/>/// "0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.<br/>/// This function fails when used on allocation made in memory type that is not<br/>/// `HOST_VISIBLE`.<br/>/// This function doesn't automatically flush or invalidate caches.<br/>/// If the allocation is made from a memory types that is not `HOST_COHERENT`,<br/>/// you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaMapMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult MapMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "ppData")] [NativeName(NativeNameType.Type, "void**")] void** ppData)
		{
			VkResult ret = Daxa.VmaMapMemoryNative(allocator, allocation, ppData);
			return ret;
		}

		/// <summary>/// <br/>/// For details, see description of vmaMapMemory().<br/>/// This function doesn't automatically flush or invalidate caches.<br/>/// If the allocation is made from a memory types that is not `HOST_COHERENT`,<br/>/// you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaUnmapMemory")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void UnmapMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation)
		{
			Daxa.VmaUnmapMemoryNative(allocator, allocation);
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation.<br/>/// It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`.<br/>/// Unmap operation doesn't do that automatically.<br/>/// - `offset` must be relative to the beginning of allocation.<br/>/// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.<br/>/// - `offset` and `size` don't have to be aligned.<br/>/// They are internally rounded down/up to multiply of `nonCoherentAtomSize`.<br/>/// - If `size` is 0, this call is ignored.<br/>/// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,<br/>/// this call is ignored.<br/>/// Warning! `offset` and `size` are relative to the contents of given `allocation`.<br/>/// If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.<br/>/// Do not pass allocation's offset as `offset`!!!<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FlushAllocation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			VkResult ret = Daxa.VmaFlushAllocationNative(allocator, allocation, offset, size);
			return ret;
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation.<br/>/// It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`.<br/>/// Map operation doesn't do that automatically.<br/>/// - `offset` must be relative to the beginning of allocation.<br/>/// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.<br/>/// - `offset` and `size` don't have to be aligned.<br/>/// They are internally rounded down/up to multiply of `nonCoherentAtomSize`.<br/>/// - If `size` is 0, this call is ignored.<br/>/// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,<br/>/// this call is ignored.<br/>/// Warning! `offset` and `size` are relative to the contents of given `allocation`.<br/>/// If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.<br/>/// Do not pass allocation's offset as `offset`!!!<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if<br/>/// it is called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult InvalidateAllocation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			VkResult ret = Daxa.VmaInvalidateAllocationNative(allocator, allocation, offset, size);
			return ret;
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			VkResult ret = Daxa.VmaFlushAllocationsNative(allocator, allocationCount, allocations, offsets, sizes);
			return ret;
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				VkResult ret = Daxa.VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, sizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				VkResult ret = Daxa.VmaFlushAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, sizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					VkResult ret = Daxa.VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, sizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* psizes = &sizes)
			{
				VkResult ret = Daxa.VmaFlushAllocationsNative(allocator, allocationCount, allocations, offsets, (ulong*)psizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* psizes = &sizes)
				{
					VkResult ret = Daxa.VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				fixed (ulong* psizes = &sizes)
				{
					VkResult ret = Daxa.VmaFlushAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult FlushAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					fixed (ulong* psizes = &sizes)
					{
						VkResult ret = Daxa.VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, (ulong*)psizes);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			VkResult ret = Daxa.VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, offsets, sizes);
			return ret;
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				VkResult ret = Daxa.VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, sizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				VkResult ret = Daxa.VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, sizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					VkResult ret = Daxa.VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, sizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* psizes = &sizes)
			{
				VkResult ret = Daxa.VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, offsets, (ulong*)psizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* psizes = &sizes)
				{
					VkResult ret = Daxa.VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				fixed (ulong* psizes = &sizes)
				{
					VkResult ret = Daxa.VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult InvalidateAllocations(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					fixed (ulong* psizes = &sizes)
					{
						VkResult ret = Daxa.VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, (ulong*)psizes);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This is a convenience function that allows to copy data from a host pointer to an allocation easily.<br/>/// Same behavior can be achieved by calling vmaMapMemory(), `memcpy()`, vmaUnmapMemory(), vmaFlushAllocation().<br/>/// This function can be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag.<br/>/// It can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or<br/>/// #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.<br/>/// Otherwise, the function will fail and generate a Validation Layers error.<br/>/// `dstAllocationLocalOffset` is relative to the contents of given `dstAllocation`.<br/>/// If you mean whole allocation, you should pass 0.<br/>/// Do not pass allocation's offset within device memory block this parameter!<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCopyMemoryToAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CopyMemoryToAllocation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pSrcHostPointer")] [NativeName(NativeNameType.Type, "const void*")] void* pSrcHostPointer, [NativeName(NativeNameType.Param, "dstAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation dstAllocation, [NativeName(NativeNameType.Param, "dstAllocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong dstAllocationLocalOffset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			VkResult ret = Daxa.VmaCopyMemoryToAllocationNative(allocator, pSrcHostPointer, dstAllocation, dstAllocationLocalOffset, size);
			return ret;
		}

		/// <summary>/// <br/>/// This is a convenience function that allows to copy data from an allocation to a host pointer easily.<br/>/// Same behavior can be achieved by calling vmaInvalidateAllocation(), vmaMapMemory(), `memcpy()`, vmaUnmapMemory().<br/>/// This function should be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`<br/>/// and `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` flag.<br/>/// It can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.<br/>/// Otherwise, the function may fail and generate a Validation Layers error.<br/>/// It may also work very slowly when reading from an uncached memory.<br/>/// `srcAllocationLocalOffset` is relative to the contents of given `srcAllocation`.<br/>/// If you mean whole allocation, you should pass 0.<br/>/// Do not pass allocation's offset within device memory block as this parameter!<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCopyAllocationToMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CopyAllocationToMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "srcAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation srcAllocation, [NativeName(NativeNameType.Param, "srcAllocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong srcAllocationLocalOffset, [NativeName(NativeNameType.Param, "pDstHostPointer")] [NativeName(NativeNameType.Type, "void*")] void* pDstHostPointer, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			VkResult ret = Daxa.VmaCopyAllocationToMemoryNative(allocator, srcAllocation, srcAllocationLocalOffset, pDstHostPointer, size);
			return ret;
		}

		/// <summary>/// <br/>/// Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,<br/>/// `VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are<br/>/// `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<br/>/// Possible return values:<br/>/// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.<br/>/// - `VK_SUCCESS` - corruption detection has been performed and succeeded.<br/>/// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.<br/>/// `VMA_ASSERT` is also fired in that case.<br/>/// - Other value: Error returned by Vulkan, e.g. memory mapping failure.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCheckCorruption")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CheckCorruption(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits)
		{
			VkResult ret = Daxa.VmaCheckCorruptionNative(allocator, memoryTypeBits);
			return ret;
		}

		/// <summary>/// <br/>/// For more information about defragmentation, see documentation chapter:<br/>/// [Defragmentation](<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BeginDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] VmaDefragmentationInfo* pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] VmaDefragmentationContext* pContext)
		{
			VkResult ret = Daxa.VmaBeginDefragmentationNative(allocator, pInfo, pContext);
			return ret;
		}

		/// <summary>/// <br/>/// For more information about defragmentation, see documentation chapter:<br/>/// [Defragmentation](<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BeginDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] ref VmaDefragmentationInfo pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] VmaDefragmentationContext* pContext)
		{
			fixed (VmaDefragmentationInfo* ppInfo = &pInfo)
			{
				VkResult ret = Daxa.VmaBeginDefragmentationNative(allocator, (VmaDefragmentationInfo*)ppInfo, pContext);
				return ret;
			}
		}

		/// <summary>/// <br/>/// For more information about defragmentation, see documentation chapter:<br/>/// [Defragmentation](<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BeginDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] VmaDefragmentationInfo* pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] ref VmaDefragmentationContext pContext)
		{
			fixed (VmaDefragmentationContext* ppContext = &pContext)
			{
				VkResult ret = Daxa.VmaBeginDefragmentationNative(allocator, pInfo, (VmaDefragmentationContext*)ppContext);
				return ret;
			}
		}

		/// <summary>/// <br/>/// For more information about defragmentation, see documentation chapter:<br/>/// [Defragmentation](<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BeginDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] ref VmaDefragmentationInfo pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] ref VmaDefragmentationContext pContext)
		{
			fixed (VmaDefragmentationInfo* ppInfo = &pInfo)
			{
				fixed (VmaDefragmentationContext* ppContext = &pContext)
				{
					VkResult ret = Daxa.VmaBeginDefragmentationNative(allocator, (VmaDefragmentationInfo*)ppInfo, (VmaDefragmentationContext*)ppContext);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Use this function to finish defragmentation started by vmaBeginDefragmentation().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDefragmentationStats*")] VmaDefragmentationStats* pStats)
		{
			Daxa.VmaEndDefragmentationNative(allocator, context, pStats);
		}

		/// <summary>/// <br/>/// Use this function to finish defragmentation started by vmaBeginDefragmentation().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void EndDefragmentation(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDefragmentationStats*")] ref VmaDefragmentationStats pStats)
		{
			fixed (VmaDefragmentationStats* ppStats = &pStats)
			{
				Daxa.VmaEndDefragmentationNative(allocator, context, (VmaDefragmentationStats*)ppStats);
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BeginDefragmentationPass(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] VmaDefragmentationPassMoveInfo* pPassInfo)
		{
			VkResult ret = Daxa.VmaBeginDefragmentationPassNative(allocator, context, pPassInfo);
			return ret;
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BeginDefragmentationPass(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] ref VmaDefragmentationPassMoveInfo pPassInfo)
		{
			fixed (VmaDefragmentationPassMoveInfo* ppPassInfo = &pPassInfo)
			{
				VkResult ret = Daxa.VmaBeginDefragmentationPassNative(allocator, context, (VmaDefragmentationPassMoveInfo*)ppPassInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.<br/>/// Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.<br/>/// After this call:<br/>/// - Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY<br/>/// (which is the default) will be pointing to the new destination place.<br/>/// - Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY<br/>/// will be freed.<br/>/// If no more moves are possible you can end whole defragmentation.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult EndDefragmentationPass(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] VmaDefragmentationPassMoveInfo* pPassInfo)
		{
			VkResult ret = Daxa.VmaEndDefragmentationPassNative(allocator, context, pPassInfo);
			return ret;
		}

		/// <summary>/// <br/>/// Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.<br/>/// Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.<br/>/// After this call:<br/>/// - Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY<br/>/// (which is the default) will be pointing to the new destination place.<br/>/// - Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY<br/>/// will be freed.<br/>/// If no more moves are possible you can end whole defragmentation.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult EndDefragmentationPass(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] ref VmaDefragmentationPassMoveInfo pPassInfo)
		{
			fixed (VmaDefragmentationPassMoveInfo* ppPassInfo = &pPassInfo)
			{
				VkResult ret = Daxa.VmaEndDefragmentationPassNative(allocator, context, (VmaDefragmentationPassMoveInfo*)ppPassInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Binds specified buffer to region of memory represented by specified allocation.<br/>/// Gets `VkDeviceMemory` handle and offset from the allocation.<br/>/// If you want to create a buffer, allocate memory for it and bind them together separately,<br/>/// you should use this function for binding instead of standard `vkBindBufferMemory()`,<br/>/// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple<br/>/// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously<br/>/// (which is illegal in Vulkan).<br/>/// It is recommended to use function vmaCreateBuffer() instead of this one.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBindBufferMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BindBufferMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer)
		{
			VkResult ret = Daxa.VmaBindBufferMemoryNative(allocator, allocation, buffer);
			return ret;
		}

		/// <summary>/// <br/>/// This function is similar to vmaBindBufferMemory(), but it provides additional parameters.<br/>/// If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag<br/>/// or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBindBufferMemory2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BindBufferMemory2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pNext")] [NativeName(NativeNameType.Type, "const void*")] void* pNext)
		{
			VkResult ret = Daxa.VmaBindBufferMemory2Native(allocator, allocation, allocationLocalOffset, buffer, pNext);
			return ret;
		}

		/// <summary>/// <br/>/// Binds specified image to region of memory represented by specified allocation.<br/>/// Gets `VkDeviceMemory` handle and offset from the allocation.<br/>/// If you want to create an image, allocate memory for it and bind them together separately,<br/>/// you should use this function for binding instead of standard `vkBindImageMemory()`,<br/>/// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple<br/>/// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously<br/>/// (which is illegal in Vulkan).<br/>/// It is recommended to use function vmaCreateImage() instead of this one.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBindImageMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BindImageMemory(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image)
		{
			VkResult ret = Daxa.VmaBindImageMemoryNative(allocator, allocation, image);
			return ret;
		}

		/// <summary>/// <br/>/// This function is similar to vmaBindImageMemory(), but it provides additional parameters.<br/>/// If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag<br/>/// or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBindImageMemory2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult BindImageMemory2(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pNext")] [NativeName(NativeNameType.Type, "const void*")] void* pNext)
		{
			VkResult ret = Daxa.VmaBindImageMemory2Native(allocator, allocation, allocationLocalOffset, image, pNext);
			return ret;
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult CreateBuffer(this VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = Daxa.VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}
	}
}
