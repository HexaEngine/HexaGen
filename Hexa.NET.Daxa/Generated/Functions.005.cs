// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Daxa
{
	public unsafe partial class Daxa
	{

		/// <summary>
		/// This is just a convenience function. Same information can be obtained using<br/>
		/// vmaGetAllocationInfo() + vmaGetMemoryProperties().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetAllocationMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetAllocationMemoryProperties")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetAllocationMemoryPropertiesNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] uint* pFlags);

		/// <summary>/// This is just a convenience function. Same information can be obtained using<br/>/// vmaGetAllocationInfo() + vmaGetMemoryProperties().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetAllocationMemoryProperties([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] uint* pFlags)
		{
			VmaGetAllocationMemoryPropertiesNative(allocator, allocation, pFlags);
		}

		/// <summary>/// This is just a convenience function. Same information can be obtained using<br/>/// vmaGetAllocationInfo() + vmaGetMemoryProperties().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetAllocationMemoryProperties([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] ref uint pFlags)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				VmaGetAllocationMemoryPropertiesNative(allocator, allocation, (uint*)ppFlags);
			}
		}

		/// <summary>
		/// <br/>
		/// Maps memory represented by given allocation to make it accessible to CPU code.<br/>
		/// When succeeded, `*ppData` contains pointer to first byte of this memory.<br/>
		/// Mapping is internally reference-counted and synchronized, so despite raw Vulkan<br/>
		/// function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`<br/>
		/// multiple times simultaneously, it is safe to call this function on allocations<br/>
		/// assigned to the same memory block. Actual Vulkan memory will be mapped on first<br/>
		/// mapping and unmapped on last unmapping.<br/>
		/// If the function succeeded, you must call vmaUnmapMemory() to unmap the<br/>
		/// allocation when mapping is no longer needed or before freeing the allocation, at<br/>
		/// the latest.<br/>
		/// It also safe to call this function multiple times on the same allocation. You<br/>
		/// must call vmaUnmapMemory() same number of times as you called vmaMapMemory().<br/>
		/// It is also safe to call this function on allocation created with<br/>
		/// #VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.<br/>
		/// You must still call vmaUnmapMemory() same number of times as you called<br/>
		/// vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the<br/>
		/// "0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.<br/>
		/// This function fails when used on allocation made in memory type that is not<br/>
		/// `HOST_VISIBLE`.<br/>
		/// This function doesn't automatically flush or invalidate caches.<br/>
		/// If the allocation is made from a memory types that is not `HOST_COHERENT`,<br/>
		/// you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaMapMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaMapMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaMapMemoryNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "ppData")] [NativeName(NativeNameType.Type, "void**")] void** ppData);

		/// <summary>/// <br/>/// Maps memory represented by given allocation to make it accessible to CPU code.<br/>/// When succeeded, `*ppData` contains pointer to first byte of this memory.<br/>/// Mapping is internally reference-counted and synchronized, so despite raw Vulkan<br/>/// function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`<br/>/// multiple times simultaneously, it is safe to call this function on allocations<br/>/// assigned to the same memory block. Actual Vulkan memory will be mapped on first<br/>/// mapping and unmapped on last unmapping.<br/>/// If the function succeeded, you must call vmaUnmapMemory() to unmap the<br/>/// allocation when mapping is no longer needed or before freeing the allocation, at<br/>/// the latest.<br/>/// It also safe to call this function multiple times on the same allocation. You<br/>/// must call vmaUnmapMemory() same number of times as you called vmaMapMemory().<br/>/// It is also safe to call this function on allocation created with<br/>/// #VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time.<br/>/// You must still call vmaUnmapMemory() same number of times as you called<br/>/// vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the<br/>/// "0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag.<br/>/// This function fails when used on allocation made in memory type that is not<br/>/// `HOST_VISIBLE`.<br/>/// This function doesn't automatically flush or invalidate caches.<br/>/// If the allocation is made from a memory types that is not `HOST_COHERENT`,<br/>/// you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaMapMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaMapMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "ppData")] [NativeName(NativeNameType.Type, "void**")] void** ppData)
		{
			VkResult ret = VmaMapMemoryNative(allocator, allocation, ppData);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// For details, see description of vmaMapMemory().<br/>
		/// This function doesn't automatically flush or invalidate caches.<br/>
		/// If the allocation is made from a memory types that is not `HOST_COHERENT`,<br/>
		/// you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaUnmapMemory")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaUnmapMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaUnmapMemoryNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation);

		/// <summary>/// <br/>/// For details, see description of vmaMapMemory().<br/>/// This function doesn't automatically flush or invalidate caches.<br/>/// If the allocation is made from a memory types that is not `HOST_COHERENT`,<br/>/// you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaUnmapMemory")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaUnmapMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation)
		{
			VmaUnmapMemoryNative(allocator, allocation);
		}

		/// <summary>
		/// <br/>
		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation.<br/>
		/// It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`.<br/>
		/// Unmap operation doesn't do that automatically.<br/>
		/// - `offset` must be relative to the beginning of allocation.<br/>
		/// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.<br/>
		/// - `offset` and `size` don't have to be aligned.<br/>
		/// They are internally rounded down/up to multiply of `nonCoherentAtomSize`.<br/>
		/// - If `size` is 0, this call is ignored.<br/>
		/// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,<br/>
		/// this call is ignored.<br/>
		/// Warning! `offset` and `size` are relative to the contents of given `allocation`.<br/>
		/// If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.<br/>
		/// Do not pass allocation's offset as `offset`!!!<br/>
		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>
		/// called, otherwise `VK_SUCCESS`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaFlushAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaFlushAllocation")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaFlushAllocationNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size);

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation.<br/>/// It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`.<br/>/// Unmap operation doesn't do that automatically.<br/>/// - `offset` must be relative to the beginning of allocation.<br/>/// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.<br/>/// - `offset` and `size` don't have to be aligned.<br/>/// They are internally rounded down/up to multiply of `nonCoherentAtomSize`.<br/>/// - If `size` is 0, this call is ignored.<br/>/// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,<br/>/// this call is ignored.<br/>/// Warning! `offset` and `size` are relative to the contents of given `allocation`.<br/>/// If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.<br/>/// Do not pass allocation's offset as `offset`!!!<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFlushAllocation([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			VkResult ret = VmaFlushAllocationNative(allocator, allocation, offset, size);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation.<br/>
		/// It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`.<br/>
		/// Map operation doesn't do that automatically.<br/>
		/// - `offset` must be relative to the beginning of allocation.<br/>
		/// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.<br/>
		/// - `offset` and `size` don't have to be aligned.<br/>
		/// They are internally rounded down/up to multiply of `nonCoherentAtomSize`.<br/>
		/// - If `size` is 0, this call is ignored.<br/>
		/// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,<br/>
		/// this call is ignored.<br/>
		/// Warning! `offset` and `size` are relative to the contents of given `allocation`.<br/>
		/// If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.<br/>
		/// Do not pass allocation's offset as `offset`!!!<br/>
		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if<br/>
		/// it is called, otherwise `VK_SUCCESS`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaInvalidateAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaInvalidateAllocation")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaInvalidateAllocationNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size);

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation.<br/>/// It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`.<br/>/// Map operation doesn't do that automatically.<br/>/// - `offset` must be relative to the beginning of allocation.<br/>/// - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.<br/>/// - `offset` and `size` don't have to be aligned.<br/>/// They are internally rounded down/up to multiply of `nonCoherentAtomSize`.<br/>/// - If `size` is 0, this call is ignored.<br/>/// - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,<br/>/// this call is ignored.<br/>/// Warning! `offset` and `size` are relative to the contents of given `allocation`.<br/>/// If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively.<br/>/// Do not pass allocation's offset as `offset`!!!<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if<br/>/// it is called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaInvalidateAllocation([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			VkResult ret = VmaInvalidateAllocationNative(allocator, allocation, offset, size);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>
		/// For more information, see documentation of vmaFlushAllocation().<br/>
		/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>
		/// called, otherwise `VK_SUCCESS`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaFlushAllocations")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaFlushAllocationsNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes);

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFlushAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			VkResult ret = VmaFlushAllocationsNative(allocator, allocationCount, allocations, offsets, sizes);
			return ret;
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFlushAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				VkResult ret = VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, sizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFlushAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				VkResult ret = VmaFlushAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, sizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFlushAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					VkResult ret = VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, sizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFlushAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* psizes = &sizes)
			{
				VkResult ret = VmaFlushAllocationsNative(allocator, allocationCount, allocations, offsets, (ulong*)psizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFlushAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* psizes = &sizes)
				{
					VkResult ret = VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFlushAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				fixed (ulong* psizes = &sizes)
				{
					VkResult ret = VmaFlushAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaFlushAllocation().<br/>/// This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFlushAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFlushAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					fixed (ulong* psizes = &sizes)
					{
						VkResult ret = VmaFlushAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, (ulong*)psizes);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>
		/// For more information, see documentation of vmaInvalidateAllocation().<br/>
		/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>
		/// called, otherwise `VK_SUCCESS`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaInvalidateAllocations")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaInvalidateAllocationsNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes);

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaInvalidateAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			VkResult ret = VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, offsets, sizes);
			return ret;
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaInvalidateAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				VkResult ret = VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, sizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaInvalidateAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				VkResult ret = VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, sizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaInvalidateAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					VkResult ret = VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, sizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaInvalidateAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* psizes = &sizes)
			{
				VkResult ret = VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, offsets, (ulong*)psizes);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaInvalidateAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ulong* offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* psizes = &sizes)
				{
					VkResult ret = VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, offsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaInvalidateAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (ulong* poffsets = &offsets)
			{
				fixed (ulong* psizes = &sizes)
				{
					VkResult ret = VmaInvalidateAllocationsNative(allocator, allocationCount, allocations, (ulong*)poffsets, (ulong*)psizes);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations.<br/>/// For more information, see documentation of vmaInvalidateAllocation().<br/>/// This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is<br/>/// called, otherwise `VK_SUCCESS`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaInvalidateAllocations")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaInvalidateAllocations([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint allocationCount, [NativeName(NativeNameType.Param, "allocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation allocations, [NativeName(NativeNameType.Param, "offsets")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong offsets, [NativeName(NativeNameType.Param, "sizes")] [NativeName(NativeNameType.Type, "const VkDeviceSize*")] ref ulong sizes)
		{
			fixed (VmaAllocation* pallocations = &allocations)
			{
				fixed (ulong* poffsets = &offsets)
				{
					fixed (ulong* psizes = &sizes)
					{
						VkResult ret = VmaInvalidateAllocationsNative(allocator, allocationCount, (VmaAllocation*)pallocations, (ulong*)poffsets, (ulong*)psizes);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This is a convenience function that allows to copy data from a host pointer to an allocation easily.<br/>
		/// Same behavior can be achieved by calling vmaMapMemory(), `memcpy()`, vmaUnmapMemory(), vmaFlushAllocation().<br/>
		/// This function can be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag.<br/>
		/// It can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or<br/>
		/// #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.<br/>
		/// Otherwise, the function will fail and generate a Validation Layers error.<br/>
		/// `dstAllocationLocalOffset` is relative to the contents of given `dstAllocation`.<br/>
		/// If you mean whole allocation, you should pass 0.<br/>
		/// Do not pass allocation's offset within device memory block this parameter!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCopyMemoryToAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCopyMemoryToAllocation")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCopyMemoryToAllocationNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pSrcHostPointer")] [NativeName(NativeNameType.Type, "const void*")] void* pSrcHostPointer, [NativeName(NativeNameType.Param, "dstAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation dstAllocation, [NativeName(NativeNameType.Param, "dstAllocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong dstAllocationLocalOffset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size);

		/// <summary>/// <br/>/// This is a convenience function that allows to copy data from a host pointer to an allocation easily.<br/>/// Same behavior can be achieved by calling vmaMapMemory(), `memcpy()`, vmaUnmapMemory(), vmaFlushAllocation().<br/>/// This function can be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` flag.<br/>/// It can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or<br/>/// #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.<br/>/// Otherwise, the function will fail and generate a Validation Layers error.<br/>/// `dstAllocationLocalOffset` is relative to the contents of given `dstAllocation`.<br/>/// If you mean whole allocation, you should pass 0.<br/>/// Do not pass allocation's offset within device memory block this parameter!<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCopyMemoryToAllocation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCopyMemoryToAllocation([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pSrcHostPointer")] [NativeName(NativeNameType.Type, "const void*")] void* pSrcHostPointer, [NativeName(NativeNameType.Param, "dstAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation dstAllocation, [NativeName(NativeNameType.Param, "dstAllocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong dstAllocationLocalOffset, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			VkResult ret = VmaCopyMemoryToAllocationNative(allocator, pSrcHostPointer, dstAllocation, dstAllocationLocalOffset, size);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This is a convenience function that allows to copy data from an allocation to a host pointer easily.<br/>
		/// Same behavior can be achieved by calling vmaInvalidateAllocation(), vmaMapMemory(), `memcpy()`, vmaUnmapMemory().<br/>
		/// This function should be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`<br/>
		/// and `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` flag.<br/>
		/// It can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.<br/>
		/// Otherwise, the function may fail and generate a Validation Layers error.<br/>
		/// It may also work very slowly when reading from an uncached memory.<br/>
		/// `srcAllocationLocalOffset` is relative to the contents of given `srcAllocation`.<br/>
		/// If you mean whole allocation, you should pass 0.<br/>
		/// Do not pass allocation's offset within device memory block as this parameter!<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCopyAllocationToMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCopyAllocationToMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCopyAllocationToMemoryNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "srcAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation srcAllocation, [NativeName(NativeNameType.Param, "srcAllocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong srcAllocationLocalOffset, [NativeName(NativeNameType.Param, "pDstHostPointer")] [NativeName(NativeNameType.Type, "void*")] void* pDstHostPointer, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size);

		/// <summary>/// <br/>/// This is a convenience function that allows to copy data from an allocation to a host pointer easily.<br/>/// Same behavior can be achieved by calling vmaInvalidateAllocation(), vmaMapMemory(), `memcpy()`, vmaUnmapMemory().<br/>/// This function should be called only for allocations created in a memory type that has `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`<br/>/// and `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` flag.<br/>/// It can be ensured e.g. by using #VMA_MEMORY_USAGE_AUTO and #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.<br/>/// Otherwise, the function may fail and generate a Validation Layers error.<br/>/// It may also work very slowly when reading from an uncached memory.<br/>/// `srcAllocationLocalOffset` is relative to the contents of given `srcAllocation`.<br/>/// If you mean whole allocation, you should pass 0.<br/>/// Do not pass allocation's offset within device memory block as this parameter!<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCopyAllocationToMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCopyAllocationToMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "srcAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation srcAllocation, [NativeName(NativeNameType.Param, "srcAllocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong srcAllocationLocalOffset, [NativeName(NativeNameType.Param, "pDstHostPointer")] [NativeName(NativeNameType.Type, "void*")] void* pDstHostPointer, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong size)
		{
			VkResult ret = VmaCopyAllocationToMemoryNative(allocator, srcAllocation, srcAllocationLocalOffset, pDstHostPointer, size);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,<br/>
		/// `VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are<br/>
		/// `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<br/>
		/// Possible return values:<br/>
		/// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.<br/>
		/// - `VK_SUCCESS` - corruption detection has been performed and succeeded.<br/>
		/// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.<br/>
		/// `VMA_ASSERT` is also fired in that case.<br/>
		/// - Other value: Error returned by Vulkan, e.g. memory mapping failure.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCheckCorruption")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCheckCorruption")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCheckCorruptionNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits);

		/// <summary>/// <br/>/// Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,<br/>/// `VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are<br/>/// `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<br/>/// Possible return values:<br/>/// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.<br/>/// - `VK_SUCCESS` - corruption detection has been performed and succeeded.<br/>/// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.<br/>/// `VMA_ASSERT` is also fired in that case.<br/>/// - Other value: Error returned by Vulkan, e.g. memory mapping failure.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCheckCorruption")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCheckCorruption([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits)
		{
			VkResult ret = VmaCheckCorruptionNative(allocator, memoryTypeBits);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// For more information about defragmentation, see documentation chapter:<br/>
		/// [Defragmentation](<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaBeginDefragmentation")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaBeginDefragmentationNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] VmaDefragmentationInfo* pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] VmaDefragmentationContext* pContext);

		/// <summary>/// <br/>/// For more information about defragmentation, see documentation chapter:<br/>/// [Defragmentation](<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBeginDefragmentation([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] VmaDefragmentationInfo* pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] VmaDefragmentationContext* pContext)
		{
			VkResult ret = VmaBeginDefragmentationNative(allocator, pInfo, pContext);
			return ret;
		}

		/// <summary>/// <br/>/// For more information about defragmentation, see documentation chapter:<br/>/// [Defragmentation](<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBeginDefragmentation([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] ref VmaDefragmentationInfo pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] VmaDefragmentationContext* pContext)
		{
			fixed (VmaDefragmentationInfo* ppInfo = &pInfo)
			{
				VkResult ret = VmaBeginDefragmentationNative(allocator, (VmaDefragmentationInfo*)ppInfo, pContext);
				return ret;
			}
		}

		/// <summary>/// <br/>/// For more information about defragmentation, see documentation chapter:<br/>/// [Defragmentation](<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBeginDefragmentation([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] VmaDefragmentationInfo* pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] ref VmaDefragmentationContext pContext)
		{
			fixed (VmaDefragmentationContext* ppContext = &pContext)
			{
				VkResult ret = VmaBeginDefragmentationNative(allocator, pInfo, (VmaDefragmentationContext*)ppContext);
				return ret;
			}
		}

		/// <summary>/// <br/>/// For more information about defragmentation, see documentation chapter:<br/>/// [Defragmentation](<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentation")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBeginDefragmentation([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VmaDefragmentationInfo*")] ref VmaDefragmentationInfo pInfo, [NativeName(NativeNameType.Param, "pContext")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext*")] ref VmaDefragmentationContext pContext)
		{
			fixed (VmaDefragmentationInfo* ppInfo = &pInfo)
			{
				fixed (VmaDefragmentationContext* ppContext = &pContext)
				{
					VkResult ret = VmaBeginDefragmentationNative(allocator, (VmaDefragmentationInfo*)ppInfo, (VmaDefragmentationContext*)ppContext);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Use this function to finish defragmentation started by vmaBeginDefragmentation().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaEndDefragmentation")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaEndDefragmentation")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaEndDefragmentationNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDefragmentationStats*")] VmaDefragmentationStats* pStats);

		/// <summary>/// <br/>/// Use this function to finish defragmentation started by vmaBeginDefragmentation().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaEndDefragmentation([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDefragmentationStats*")] VmaDefragmentationStats* pStats)
		{
			VmaEndDefragmentationNative(allocator, context, pStats);
		}

		/// <summary>/// <br/>/// Use this function to finish defragmentation started by vmaBeginDefragmentation().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaEndDefragmentation([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDefragmentationStats*")] ref VmaDefragmentationStats pStats)
		{
			fixed (VmaDefragmentationStats* ppStats = &pStats)
			{
				VmaEndDefragmentationNative(allocator, context, (VmaDefragmentationStats*)ppStats);
			}
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaBeginDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaBeginDefragmentationPass")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaBeginDefragmentationPassNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] VmaDefragmentationPassMoveInfo* pPassInfo);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBeginDefragmentationPass([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] VmaDefragmentationPassMoveInfo* pPassInfo)
		{
			VkResult ret = VmaBeginDefragmentationPassNative(allocator, context, pPassInfo);
			return ret;
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBeginDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBeginDefragmentationPass([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] ref VmaDefragmentationPassMoveInfo pPassInfo)
		{
			fixed (VmaDefragmentationPassMoveInfo* ppPassInfo = &pPassInfo)
			{
				VkResult ret = VmaBeginDefragmentationPassNative(allocator, context, (VmaDefragmentationPassMoveInfo*)ppPassInfo);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.<br/>
		/// Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.<br/>
		/// After this call:<br/>
		/// - Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY<br/>
		/// (which is the default) will be pointing to the new destination place.<br/>
		/// - Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY<br/>
		/// will be freed.<br/>
		/// If no more moves are possible you can end whole defragmentation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaEndDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaEndDefragmentationPass")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaEndDefragmentationPassNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] VmaDefragmentationPassMoveInfo* pPassInfo);

		/// <summary>/// <br/>/// Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.<br/>/// Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.<br/>/// After this call:<br/>/// - Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY<br/>/// (which is the default) will be pointing to the new destination place.<br/>/// - Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY<br/>/// will be freed.<br/>/// If no more moves are possible you can end whole defragmentation.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaEndDefragmentationPass([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] VmaDefragmentationPassMoveInfo* pPassInfo)
		{
			VkResult ret = VmaEndDefragmentationPassNative(allocator, context, pPassInfo);
			return ret;
		}

		/// <summary>/// <br/>/// Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.<br/>/// Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`.<br/>/// After this call:<br/>/// - Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY<br/>/// (which is the default) will be pointing to the new destination place.<br/>/// - Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY<br/>/// will be freed.<br/>/// If no more moves are possible you can end whole defragmentation.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaEndDefragmentationPass")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaEndDefragmentationPass([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "VmaDefragmentationContext")] VmaDefragmentationContext context, [NativeName(NativeNameType.Param, "pPassInfo")] [NativeName(NativeNameType.Type, "VmaDefragmentationPassMoveInfo*")] ref VmaDefragmentationPassMoveInfo pPassInfo)
		{
			fixed (VmaDefragmentationPassMoveInfo* ppPassInfo = &pPassInfo)
			{
				VkResult ret = VmaEndDefragmentationPassNative(allocator, context, (VmaDefragmentationPassMoveInfo*)ppPassInfo);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// Binds specified buffer to region of memory represented by specified allocation.<br/>
		/// Gets `VkDeviceMemory` handle and offset from the allocation.<br/>
		/// If you want to create a buffer, allocate memory for it and bind them together separately,<br/>
		/// you should use this function for binding instead of standard `vkBindBufferMemory()`,<br/>
		/// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple<br/>
		/// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously<br/>
		/// (which is illegal in Vulkan).<br/>
		/// It is recommended to use function vmaCreateBuffer() instead of this one.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaBindBufferMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaBindBufferMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaBindBufferMemoryNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer);

		/// <summary>/// <br/>/// Binds specified buffer to region of memory represented by specified allocation.<br/>/// Gets `VkDeviceMemory` handle and offset from the allocation.<br/>/// If you want to create a buffer, allocate memory for it and bind them together separately,<br/>/// you should use this function for binding instead of standard `vkBindBufferMemory()`,<br/>/// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple<br/>/// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously<br/>/// (which is illegal in Vulkan).<br/>/// It is recommended to use function vmaCreateBuffer() instead of this one.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBindBufferMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBindBufferMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer)
		{
			VkResult ret = VmaBindBufferMemoryNative(allocator, allocation, buffer);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function is similar to vmaBindBufferMemory(), but it provides additional parameters.<br/>
		/// If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag<br/>
		/// or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaBindBufferMemory2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaBindBufferMemory2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaBindBufferMemory2Native([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pNext")] [NativeName(NativeNameType.Type, "const void*")] void* pNext);

		/// <summary>/// <br/>/// This function is similar to vmaBindBufferMemory(), but it provides additional parameters.<br/>/// If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag<br/>/// or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBindBufferMemory2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBindBufferMemory2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pNext")] [NativeName(NativeNameType.Type, "const void*")] void* pNext)
		{
			VkResult ret = VmaBindBufferMemory2Native(allocator, allocation, allocationLocalOffset, buffer, pNext);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// Binds specified image to region of memory represented by specified allocation.<br/>
		/// Gets `VkDeviceMemory` handle and offset from the allocation.<br/>
		/// If you want to create an image, allocate memory for it and bind them together separately,<br/>
		/// you should use this function for binding instead of standard `vkBindImageMemory()`,<br/>
		/// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple<br/>
		/// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously<br/>
		/// (which is illegal in Vulkan).<br/>
		/// It is recommended to use function vmaCreateImage() instead of this one.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaBindImageMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaBindImageMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaBindImageMemoryNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image);

		/// <summary>/// <br/>/// Binds specified image to region of memory represented by specified allocation.<br/>/// Gets `VkDeviceMemory` handle and offset from the allocation.<br/>/// If you want to create an image, allocate memory for it and bind them together separately,<br/>/// you should use this function for binding instead of standard `vkBindImageMemory()`,<br/>/// because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple<br/>/// allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously<br/>/// (which is illegal in Vulkan).<br/>/// It is recommended to use function vmaCreateImage() instead of this one.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBindImageMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBindImageMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image)
		{
			VkResult ret = VmaBindImageMemoryNative(allocator, allocation, image);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function is similar to vmaBindImageMemory(), but it provides additional parameters.<br/>
		/// If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag<br/>
		/// or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaBindImageMemory2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaBindImageMemory2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaBindImageMemory2Native([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pNext")] [NativeName(NativeNameType.Type, "const void*")] void* pNext);

		/// <summary>/// <br/>/// This function is similar to vmaBindImageMemory(), but it provides additional parameters.<br/>/// If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag<br/>/// or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBindImageMemory2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaBindImageMemory2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pNext")] [NativeName(NativeNameType.Type, "const void*")] void* pNext)
		{
			VkResult ret = VmaBindImageMemory2Native(allocator, allocation, allocationLocalOffset, image, pNext);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function automatically:<br/>
		/// -# Creates buffer.<br/>
		/// -# Allocates appropriate memory for it.<br/>
		/// -# Binds the buffer with the memory.<br/>
		/// If any of these operations fail, buffer and allocation are not created,<br/>
		/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>
		/// If the function succeeded, you must destroy both buffer and allocation when you<br/>
		/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>
		/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>
		/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>
		/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>
		/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>
		/// and if dedicated allocation is possible<br/>
		/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>
		/// allocation for this buffer, just like when using<br/>
		/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreateBuffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreateBufferNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo);

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateBufferNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Allocates appropriate memory for it.<br/>/// -# Binds the buffer with the memory.<br/>/// If any of these operations fail, buffer and allocation are not created,<br/>/// returned value is negative error code, `*pBuffer` and `*pAllocation` are null.<br/>/// If the function succeeded, you must destroy both buffer and allocation when you<br/>/// no longer need them using either convenience function vmaDestroyBuffer() or<br/>/// separately, using `vkDestroyBuffer()` and vmaFreeMemory().<br/>/// If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,<br/>/// VK_KHR_dedicated_allocation extension is used internally to query driver whether<br/>/// it requires or prefers the new buffer to have dedicated allocation. If yes,<br/>/// and if dedicated allocation is possible<br/>/// (#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated<br/>/// allocation for this buffer, just like when using<br/>/// #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
							{
								VkResult ret = VmaCreateBufferNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>
		/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>
		/// for interop with OpenGL.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreateBufferWithAlignment")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreateBufferWithAlignmentNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo);

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, pAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, pBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,<br/>/// minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g.<br/>/// for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateBufferWithAlignment")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateBufferWithAlignment([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "minAlignment")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong minAlignment, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkBuffer* ppBuffer = &pBuffer)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
							{
								VkResult ret = VmaCreateBufferWithAlignmentNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, minAlignment, (VkBuffer*)ppBuffer, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This function automatically:<br/>
		/// -# Creates buffer.<br/>
		/// -# Binds the buffer with the supplied memory.<br/>
		/// If any of these operations fail, buffer is not created,<br/>
		/// returned value is negative error code and `*pBuffer` is null.<br/>
		/// If the function succeeded, you must destroy the buffer when you<br/>
		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>
		/// allocation you can use convenience function vmaDestroyBuffer().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreateAliasingBuffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreateAliasingBufferNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer);

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Binds the buffer with the supplied memory.<br/>/// If any of these operations fail, buffer is not created,<br/>/// returned value is negative error code and `*pBuffer` is null.<br/>/// If the function succeeded, you must destroy the buffer when you<br/>/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>/// allocation you can use convenience function vmaDestroyBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer)
		{
			VkResult ret = VmaCreateAliasingBufferNative(allocator, allocation, pBufferCreateInfo, pBuffer);
			return ret;
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Binds the buffer with the supplied memory.<br/>/// If any of these operations fail, buffer is not created,<br/>/// returned value is negative error code and `*pBuffer` is null.<br/>/// If the function succeeded, you must destroy the buffer when you<br/>/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>/// allocation you can use convenience function vmaDestroyBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				VkResult ret = VmaCreateAliasingBufferNative(allocator, allocation, (VkBufferCreateInfo*)ppBufferCreateInfo, pBuffer);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Binds the buffer with the supplied memory.<br/>/// If any of these operations fail, buffer is not created,<br/>/// returned value is negative error code and `*pBuffer` is null.<br/>/// If the function succeeded, you must destroy the buffer when you<br/>/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>/// allocation you can use convenience function vmaDestroyBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				VkResult ret = VmaCreateAliasingBufferNative(allocator, allocation, pBufferCreateInfo, (VkBuffer*)ppBuffer);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Binds the buffer with the supplied memory.<br/>/// If any of these operations fail, buffer is not created,<br/>/// returned value is negative error code and `*pBuffer` is null.<br/>/// If the function succeeded, you must destroy the buffer when you<br/>/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>/// allocation you can use convenience function vmaDestroyBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					VkResult ret = VmaCreateAliasingBufferNative(allocator, allocation, (VkBufferCreateInfo*)ppBufferCreateInfo, (VkBuffer*)ppBuffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This function automatically:<br/>
		/// -# Creates buffer.<br/>
		/// -# Binds the buffer with the supplied memory.<br/>
		/// If any of these operations fail, buffer is not created,<br/>
		/// returned value is negative error code and `*pBuffer` is null.<br/>
		/// If the function succeeded, you must destroy the buffer when you<br/>
		/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>
		/// allocation you can use convenience function vmaDestroyBuffer().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreateAliasingBuffer2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreateAliasingBuffer2Native([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer);

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Binds the buffer with the supplied memory.<br/>/// If any of these operations fail, buffer is not created,<br/>/// returned value is negative error code and `*pBuffer` is null.<br/>/// If the function succeeded, you must destroy the buffer when you<br/>/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>/// allocation you can use convenience function vmaDestroyBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingBuffer2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer)
		{
			VkResult ret = VmaCreateAliasingBuffer2Native(allocator, allocation, allocationLocalOffset, pBufferCreateInfo, pBuffer);
			return ret;
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Binds the buffer with the supplied memory.<br/>/// If any of these operations fail, buffer is not created,<br/>/// returned value is negative error code and `*pBuffer` is null.<br/>/// If the function succeeded, you must destroy the buffer when you<br/>/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>/// allocation you can use convenience function vmaDestroyBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingBuffer2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] VkBuffer* pBuffer)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				VkResult ret = VmaCreateAliasingBuffer2Native(allocator, allocation, allocationLocalOffset, (VkBufferCreateInfo*)ppBufferCreateInfo, pBuffer);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Binds the buffer with the supplied memory.<br/>/// If any of these operations fail, buffer is not created,<br/>/// returned value is negative error code and `*pBuffer` is null.<br/>/// If the function succeeded, you must destroy the buffer when you<br/>/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>/// allocation you can use convenience function vmaDestroyBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingBuffer2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer)
		{
			fixed (VkBuffer* ppBuffer = &pBuffer)
			{
				VkResult ret = VmaCreateAliasingBuffer2Native(allocator, allocation, allocationLocalOffset, pBufferCreateInfo, (VkBuffer*)ppBuffer);
				return ret;
			}
		}

		/// <summary>/// <br/>/// This function automatically:<br/>/// -# Creates buffer.<br/>/// -# Binds the buffer with the supplied memory.<br/>/// If any of these operations fail, buffer is not created,<br/>/// returned value is negative error code and `*pBuffer` is null.<br/>/// If the function succeeded, you must destroy the buffer when you<br/>/// no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding<br/>/// allocation you can use convenience function vmaDestroyBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingBuffer2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingBuffer2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pBuffer")] [NativeName(NativeNameType.Type, "VkBuffer*")] ref VkBuffer pBuffer)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VkBuffer* ppBuffer = &pBuffer)
				{
					VkResult ret = VmaCreateAliasingBuffer2Native(allocator, allocation, allocationLocalOffset, (VkBufferCreateInfo*)ppBufferCreateInfo, (VkBuffer*)ppBuffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This is just a convenience function equivalent to:<br/>
		/// It is safe to pass null as buffer and/or allocation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaDestroyBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaDestroyBuffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaDestroyBufferNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation);

		/// <summary>/// <br/>/// This is just a convenience function equivalent to:<br/>/// It is safe to pass null as buffer and/or allocation.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyBuffer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaDestroyBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation)
		{
			VmaDestroyBufferNative(allocator, buffer, allocation);
		}

		/// <summary>
		/// Function similar to vmaCreateBuffer().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreateImage")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreateImageNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo);

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pImage, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pImage, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkImage* ppImage = &pImage)
					{
						VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, pAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkImage* ppImage = &pImage)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, pAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkImage* ppImage = &pImage)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaCreateImageNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// Function similar to vmaCreateBuffer().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (VkImage* ppImage = &pImage)
					{
						fixed (VmaAllocation* ppAllocation = &pAllocation)
						{
							fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
							{
								VkResult ret = VmaCreateImageNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (VkImage*)ppImage, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Function similar to vmaCreateAliasingBuffer() but for images.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreateAliasingImage")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreateAliasingImageNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage);

		/// <summary>/// Function similar to vmaCreateAliasingBuffer() but for images.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage)
		{
			VkResult ret = VmaCreateAliasingImageNative(allocator, allocation, pImageCreateInfo, pImage);
			return ret;
		}

		/// <summary>/// Function similar to vmaCreateAliasingBuffer() but for images.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				VkResult ret = VmaCreateAliasingImageNative(allocator, allocation, (VkImageCreateInfo*)ppImageCreateInfo, pImage);
				return ret;
			}
		}

		/// <summary>/// Function similar to vmaCreateAliasingBuffer() but for images.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				VkResult ret = VmaCreateAliasingImageNative(allocator, allocation, pImageCreateInfo, (VkImage*)ppImage);
				return ret;
			}
		}

		/// <summary>/// Function similar to vmaCreateAliasingBuffer() but for images.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					VkResult ret = VmaCreateAliasingImageNative(allocator, allocation, (VkImageCreateInfo*)ppImageCreateInfo, (VkImage*)ppImage);
					return ret;
				}
			}
		}

		/// <summary>
		/// Function similar to vmaCreateAliasingBuffer2() but for images.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreateAliasingImage2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreateAliasingImage2Native([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage);

		/// <summary>/// Function similar to vmaCreateAliasingBuffer2() but for images.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingImage2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage)
		{
			VkResult ret = VmaCreateAliasingImage2Native(allocator, allocation, allocationLocalOffset, pImageCreateInfo, pImage);
			return ret;
		}

		/// <summary>/// Function similar to vmaCreateAliasingBuffer2() but for images.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingImage2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] VkImage* pImage)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				VkResult ret = VmaCreateAliasingImage2Native(allocator, allocation, allocationLocalOffset, (VkImageCreateInfo*)ppImageCreateInfo, pImage);
				return ret;
			}
		}

		/// <summary>/// Function similar to vmaCreateAliasingBuffer2() but for images.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingImage2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage)
		{
			fixed (VkImage* ppImage = &pImage)
			{
				VkResult ret = VmaCreateAliasingImage2Native(allocator, allocation, allocationLocalOffset, pImageCreateInfo, (VkImage*)ppImage);
				return ret;
			}
		}

		/// <summary>/// Function similar to vmaCreateAliasingBuffer2() but for images.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAliasingImage2")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAliasingImage2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "allocationLocalOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong allocationLocalOffset, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pImage")] [NativeName(NativeNameType.Type, "VkImage*")] ref VkImage pImage)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VkImage* ppImage = &pImage)
				{
					VkResult ret = VmaCreateAliasingImage2Native(allocator, allocation, allocationLocalOffset, (VkImageCreateInfo*)ppImageCreateInfo, (VkImage*)ppImage);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This is just a convenience function equivalent to:<br/>
		/// It is safe to pass null as image and/or allocation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaDestroyImage")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaDestroyImage")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaDestroyImageNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation);

		/// <summary>/// <br/>/// This is just a convenience function equivalent to:<br/>/// It is safe to pass null as image and/or allocation.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyImage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaDestroyImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation)
		{
			VmaDestroyImageNative(allocator, image, allocation);
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreateVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreateVirtualBlock")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreateVirtualBlockNative([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualBlockCreateInfo*")] VmaVirtualBlockCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pVirtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock*")] VmaVirtualBlock* pVirtualBlock);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateVirtualBlock([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualBlockCreateInfo*")] VmaVirtualBlockCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pVirtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock*")] VmaVirtualBlock* pVirtualBlock)
		{
			VkResult ret = VmaCreateVirtualBlockNative(pCreateInfo, pVirtualBlock);
			return ret;
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateVirtualBlock([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualBlockCreateInfo*")] ref VmaVirtualBlockCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pVirtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock*")] VmaVirtualBlock* pVirtualBlock)
		{
			fixed (VmaVirtualBlockCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VmaCreateVirtualBlockNative((VmaVirtualBlockCreateInfo*)ppCreateInfo, pVirtualBlock);
				return ret;
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateVirtualBlock([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualBlockCreateInfo*")] VmaVirtualBlockCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pVirtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock*")] ref VmaVirtualBlock pVirtualBlock)
		{
			fixed (VmaVirtualBlock* ppVirtualBlock = &pVirtualBlock)
			{
				VkResult ret = VmaCreateVirtualBlockNative(pCreateInfo, (VmaVirtualBlock*)ppVirtualBlock);
				return ret;
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateVirtualBlock([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualBlockCreateInfo*")] ref VmaVirtualBlockCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pVirtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock*")] ref VmaVirtualBlock pVirtualBlock)
		{
			fixed (VmaVirtualBlockCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaVirtualBlock* ppVirtualBlock = &pVirtualBlock)
				{
					VkResult ret = VmaCreateVirtualBlockNative((VmaVirtualBlockCreateInfo*)ppCreateInfo, (VmaVirtualBlock*)ppVirtualBlock);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Please note that you should consciously handle virtual allocations that could remain unfreed in the block.<br/>
		/// You should either free them individually using vmaVirtualFree() or call vmaClearVirtualBlock()<br/>
		/// if you are sure this is what you want. If you do neither, an assert is called.<br/>
		/// If you keep pointers to some additional metadata associated with your virtual allocations in their `pUserData`,<br/>
		/// don't forget to free them.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaDestroyVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaDestroyVirtualBlock")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaDestroyVirtualBlockNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock);

		/// <summary>/// <br/>/// Please note that you should consciously handle virtual allocations that could remain unfreed in the block.<br/>/// You should either free them individually using vmaVirtualFree() or call vmaClearVirtualBlock()<br/>/// if you are sure this is what you want. If you do neither, an assert is called.<br/>/// If you keep pointers to some additional metadata associated with your virtual allocations in their `pUserData`,<br/>/// don't forget to free them.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaDestroyVirtualBlock([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock)
		{
			VmaDestroyVirtualBlockNative(virtualBlock);
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaIsVirtualBlockEmpty")]
		[return: NativeName(NativeNameType.Type, "VkBool32")]
		[LibraryImport(LibName, EntryPoint = "vmaIsVirtualBlockEmpty")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint VmaIsVirtualBlockEmptyNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaIsVirtualBlockEmpty")]
		[return: NativeName(NativeNameType.Type, "VkBool32")]
		public static uint VmaIsVirtualBlockEmpty([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock)
		{
			uint ret = VmaIsVirtualBlockEmptyNative(virtualBlock);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetVirtualAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetVirtualAllocationInfo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetVirtualAllocationInfoNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation, [NativeName(NativeNameType.Param, "pVirtualAllocInfo")] [NativeName(NativeNameType.Type, "VmaVirtualAllocationInfo*")] VmaVirtualAllocationInfo* pVirtualAllocInfo);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetVirtualAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetVirtualAllocationInfo([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation, [NativeName(NativeNameType.Param, "pVirtualAllocInfo")] [NativeName(NativeNameType.Type, "VmaVirtualAllocationInfo*")] VmaVirtualAllocationInfo* pVirtualAllocInfo)
		{
			VmaGetVirtualAllocationInfoNative(virtualBlock, allocation, pVirtualAllocInfo);
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetVirtualAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetVirtualAllocationInfo([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation, [NativeName(NativeNameType.Param, "pVirtualAllocInfo")] [NativeName(NativeNameType.Type, "VmaVirtualAllocationInfo*")] ref VmaVirtualAllocationInfo pVirtualAllocInfo)
		{
			fixed (VmaVirtualAllocationInfo* ppVirtualAllocInfo = &pVirtualAllocInfo)
			{
				VmaGetVirtualAllocationInfoNative(virtualBlock, allocation, (VmaVirtualAllocationInfo*)ppVirtualAllocInfo);
			}
		}

		/// <summary>
		/// <br/>
		/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>
		/// (despite the function doesn't ever allocate actual GPU memory).<br/>
		/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaVirtualAllocate")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaVirtualAllocateNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] VmaVirtualAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] VmaVirtualAllocation* pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ulong* pOffset);

		/// <summary>/// <br/>/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>/// (despite the function doesn't ever allocate actual GPU memory).<br/>/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaVirtualAllocate([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] VmaVirtualAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] VmaVirtualAllocation* pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ulong* pOffset)
		{
			VkResult ret = VmaVirtualAllocateNative(virtualBlock, pCreateInfo, pAllocation, pOffset);
			return ret;
		}

		/// <summary>/// <br/>/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>/// (despite the function doesn't ever allocate actual GPU memory).<br/>/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaVirtualAllocate([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] ref VmaVirtualAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] VmaVirtualAllocation* pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ulong* pOffset)
		{
			fixed (VmaVirtualAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VmaVirtualAllocateNative(virtualBlock, (VmaVirtualAllocationCreateInfo*)ppCreateInfo, pAllocation, pOffset);
				return ret;
			}
		}

		/// <summary>/// <br/>/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>/// (despite the function doesn't ever allocate actual GPU memory).<br/>/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaVirtualAllocate([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] VmaVirtualAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] ref VmaVirtualAllocation pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ulong* pOffset)
		{
			fixed (VmaVirtualAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = VmaVirtualAllocateNative(virtualBlock, pCreateInfo, (VmaVirtualAllocation*)ppAllocation, pOffset);
				return ret;
			}
		}

		/// <summary>/// <br/>/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>/// (despite the function doesn't ever allocate actual GPU memory).<br/>/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaVirtualAllocate([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] ref VmaVirtualAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] ref VmaVirtualAllocation pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ulong* pOffset)
		{
			fixed (VmaVirtualAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaVirtualAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaVirtualAllocateNative(virtualBlock, (VmaVirtualAllocationCreateInfo*)ppCreateInfo, (VmaVirtualAllocation*)ppAllocation, pOffset);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>/// (despite the function doesn't ever allocate actual GPU memory).<br/>/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaVirtualAllocate([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] VmaVirtualAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] VmaVirtualAllocation* pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ref ulong pOffset)
		{
			fixed (ulong* ppOffset = &pOffset)
			{
				VkResult ret = VmaVirtualAllocateNative(virtualBlock, pCreateInfo, pAllocation, (ulong*)ppOffset);
				return ret;
			}
		}

		/// <summary>/// <br/>/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>/// (despite the function doesn't ever allocate actual GPU memory).<br/>/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaVirtualAllocate([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] ref VmaVirtualAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] VmaVirtualAllocation* pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ref ulong pOffset)
		{
			fixed (VmaVirtualAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (ulong* ppOffset = &pOffset)
				{
					VkResult ret = VmaVirtualAllocateNative(virtualBlock, (VmaVirtualAllocationCreateInfo*)ppCreateInfo, pAllocation, (ulong*)ppOffset);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>/// (despite the function doesn't ever allocate actual GPU memory).<br/>/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaVirtualAllocate([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] VmaVirtualAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] ref VmaVirtualAllocation pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ref ulong pOffset)
		{
			fixed (VmaVirtualAllocation* ppAllocation = &pAllocation)
			{
				fixed (ulong* ppOffset = &pOffset)
				{
					VkResult ret = VmaVirtualAllocateNative(virtualBlock, pCreateInfo, (VmaVirtualAllocation*)ppAllocation, (ulong*)ppOffset);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned<br/>/// (despite the function doesn't ever allocate actual GPU memory).<br/>/// `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualAllocate")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaVirtualAllocate([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaVirtualAllocationCreateInfo*")] ref VmaVirtualAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation*")] ref VmaVirtualAllocation pAllocation, [NativeName(NativeNameType.Param, "pOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize*")] ref ulong pOffset)
		{
			fixed (VmaVirtualAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaVirtualAllocation* ppAllocation = &pAllocation)
				{
					fixed (ulong* ppOffset = &pOffset)
					{
						VkResult ret = VmaVirtualAllocateNative(virtualBlock, (VmaVirtualAllocationCreateInfo*)ppCreateInfo, (VmaVirtualAllocation*)ppAllocation, (ulong*)ppOffset);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// It is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaVirtualFree")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaVirtualFree")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaVirtualFreeNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation);

		/// <summary>/// <br/>/// It is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaVirtualFree")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaVirtualFree([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation)
		{
			VmaVirtualFreeNative(virtualBlock, allocation);
		}

		/// <summary>
		/// <br/>
		/// You must either call this function or free each virtual allocation individually with vmaVirtualFree()<br/>
		/// before destroying a virtual block. Otherwise, an assert is called.<br/>
		/// If you keep pointer to some additional metadata associated with your virtual allocation in its `pUserData`,<br/>
		/// don't forget to free it as well.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaClearVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaClearVirtualBlock")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaClearVirtualBlockNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock);

		/// <summary>/// <br/>/// You must either call this function or free each virtual allocation individually with vmaVirtualFree()<br/>/// before destroying a virtual block. Otherwise, an assert is called.<br/>/// If you keep pointer to some additional metadata associated with your virtual allocation in its `pUserData`,<br/>/// don't forget to free it as well.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaClearVirtualBlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaClearVirtualBlock([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock)
		{
			VmaClearVirtualBlockNative(virtualBlock);
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaSetVirtualAllocationUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaSetVirtualAllocationUserData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaSetVirtualAllocationUserDataNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation, [NativeName(NativeNameType.Param, "pUserData")] [NativeName(NativeNameType.Type, "void*")] void* pUserData);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetVirtualAllocationUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaSetVirtualAllocationUserData([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaVirtualAllocation")] VmaVirtualAllocation allocation, [NativeName(NativeNameType.Param, "pUserData")] [NativeName(NativeNameType.Type, "void*")] void* pUserData)
		{
			VmaSetVirtualAllocationUserDataNative(virtualBlock, allocation, pUserData);
		}

		/// <summary>
		/// <br/>
		/// This function is fast to call. For more detailed statistics, see vmaCalculateVirtualBlockStatistics().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetVirtualBlockStatistics")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetVirtualBlockStatisticsNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] VmaStatistics* pStats);

		/// <summary>/// <br/>/// This function is fast to call. For more detailed statistics, see vmaCalculateVirtualBlockStatistics().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetVirtualBlockStatistics([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] VmaStatistics* pStats)
		{
			VmaGetVirtualBlockStatisticsNative(virtualBlock, pStats);
		}

		/// <summary>/// <br/>/// This function is fast to call. For more detailed statistics, see vmaCalculateVirtualBlockStatistics().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetVirtualBlockStatistics([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] ref VmaStatistics pStats)
		{
			fixed (VmaStatistics* ppStats = &pStats)
			{
				VmaGetVirtualBlockStatisticsNative(virtualBlock, (VmaStatistics*)ppStats);
			}
		}

		/// <summary>
		/// <br/>
		/// This function is slow to call. Use for debugging purposes.<br/>
		/// For less detailed statistics, see vmaGetVirtualBlockStatistics().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCalculateVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaCalculateVirtualBlockStatistics")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaCalculateVirtualBlockStatisticsNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] VmaDetailedStatistics* pStats);

		/// <summary>/// <br/>/// This function is slow to call. Use for debugging purposes.<br/>/// For less detailed statistics, see vmaGetVirtualBlockStatistics().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaCalculateVirtualBlockStatistics([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] VmaDetailedStatistics* pStats)
		{
			VmaCalculateVirtualBlockStatisticsNative(virtualBlock, pStats);
		}

		/// <summary>/// <br/>/// This function is slow to call. Use for debugging purposes.<br/>/// For less detailed statistics, see vmaGetVirtualBlockStatistics().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateVirtualBlockStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaCalculateVirtualBlockStatistics([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] ref VmaDetailedStatistics pStats)
		{
			fixed (VmaDetailedStatistics* ppStats = &pStats)
			{
				VmaCalculateVirtualBlockStatisticsNative(virtualBlock, (VmaDetailedStatistics*)ppStats);
			}
		}

		/// <summary>
		/// <br/>
		/// Returned string must be freed using vmaFreeVirtualBlockStatsString().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaBuildVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaBuildVirtualBlockStatsString")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaBuildVirtualBlockStatsStringNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] byte** ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] uint detailedMap);

		/// <summary>/// <br/>/// Returned string must be freed using vmaFreeVirtualBlockStatsString().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBuildVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaBuildVirtualBlockStatsString([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] byte** ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] uint detailedMap)
		{
			VmaBuildVirtualBlockStatsStringNative(virtualBlock, ppStatsString, detailedMap);
		}

		/// <summary>/// <br/>/// Returned string must be freed using vmaFreeVirtualBlockStatsString().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBuildVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaBuildVirtualBlockStatsString([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] ref byte* ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] uint detailedMap)
		{
			fixed (byte** pppStatsString = &ppStatsString)
			{
				VmaBuildVirtualBlockStatsStringNative(virtualBlock, (byte**)pppStatsString, detailedMap);
			}
		}

		/// <summary>
		/// Frees a string returned by vmaBuildVirtualBlockStatsString().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaFreeVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaFreeVirtualBlockStatsString")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaFreeVirtualBlockStatsStringNative([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] byte* pStatsString);

		/// <summary>/// Frees a string returned by vmaBuildVirtualBlockStatsString().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeVirtualBlockStatsString([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] byte* pStatsString)
		{
			VmaFreeVirtualBlockStatsStringNative(virtualBlock, pStatsString);
		}

		/// <summary>/// Frees a string returned by vmaBuildVirtualBlockStatsString().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeVirtualBlockStatsString([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] ref byte pStatsString)
		{
			fixed (byte* ppStatsString = &pStatsString)
			{
				VmaFreeVirtualBlockStatsStringNative(virtualBlock, (byte*)ppStatsString);
			}
		}

		/// <summary>/// Frees a string returned by vmaBuildVirtualBlockStatsString().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeVirtualBlockStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeVirtualBlockStatsString([NativeName(NativeNameType.Param, "virtualBlock")] [NativeName(NativeNameType.Type, "VmaVirtualBlock")] VmaVirtualBlock virtualBlock, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] ref string pStatsString)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pStatsString != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pStatsString);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pStatsString, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VmaFreeVirtualBlockStatsStringNative(virtualBlock, pStr0);
			pStatsString = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaBuildStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaBuildStatsString")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaBuildStatsStringNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] byte** ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] uint detailedMap);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBuildStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaBuildStatsString([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] byte** ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] uint detailedMap)
		{
			VmaBuildStatsStringNative(allocator, ppStatsString, detailedMap);
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaBuildStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaBuildStatsString([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppStatsString")] [NativeName(NativeNameType.Type, "char**")] ref byte* ppStatsString, [NativeName(NativeNameType.Param, "detailedMap")] [NativeName(NativeNameType.Type, "VkBool32")] uint detailedMap)
		{
			fixed (byte** pppStatsString = &ppStatsString)
			{
				VmaBuildStatsStringNative(allocator, (byte**)pppStatsString, detailedMap);
			}
		}

		[NativeName(NativeNameType.Func, "vmaFreeStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaFreeStatsString")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaFreeStatsStringNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] byte* pStatsString);

		[NativeName(NativeNameType.Func, "vmaFreeStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeStatsString([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] byte* pStatsString)
		{
			VmaFreeStatsStringNative(allocator, pStatsString);
		}

		[NativeName(NativeNameType.Func, "vmaFreeStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeStatsString([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] ref byte pStatsString)
		{
			fixed (byte* ppStatsString = &pStatsString)
			{
				VmaFreeStatsStringNative(allocator, (byte*)ppStatsString);
			}
		}

		[NativeName(NativeNameType.Func, "vmaFreeStatsString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeStatsString([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStatsString")] [NativeName(NativeNameType.Type, "char*")] ref string pStatsString)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pStatsString != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pStatsString);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pStatsString, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VmaFreeStatsStringNative(allocator, pStr0);
			pStatsString = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		[NativeName(NativeNameType.Func, "daxa_default_view")]
		[return: NativeName(NativeNameType.Type, "daxa_ImageViewId")]
		[LibraryImport(LibName, EntryPoint = "daxa_default_view")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaImageViewId DaxaDefaultViewNative([NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "daxa_ImageId")] DaxaImageId image);

		[NativeName(NativeNameType.Func, "daxa_default_view")]
		[return: NativeName(NativeNameType.Type, "daxa_ImageViewId")]
		public static DaxaImageViewId DaxaDefaultView([NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "daxa_ImageId")] DaxaImageId image)
		{
			DaxaImageViewId ret = DaxaDefaultViewNative(image);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_index_of_buffer")]
		[return: NativeName(NativeNameType.Type, "uint32_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_index_of_buffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint DaxaIndexOfBufferNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_BufferId")] DaxaBufferId id);

		[NativeName(NativeNameType.Func, "daxa_index_of_buffer")]
		[return: NativeName(NativeNameType.Type, "uint32_t")]
		public static uint DaxaIndexOfBuffer([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_BufferId")] DaxaBufferId id)
		{
			uint ret = DaxaIndexOfBufferNative(id);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_index_of_image")]
		[return: NativeName(NativeNameType.Type, "uint32_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_index_of_image")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint DaxaIndexOfImageNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageId")] DaxaImageId id);

		[NativeName(NativeNameType.Func, "daxa_index_of_image")]
		[return: NativeName(NativeNameType.Type, "uint32_t")]
		public static uint DaxaIndexOfImage([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageId")] DaxaImageId id)
		{
			uint ret = DaxaIndexOfImageNative(id);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_index_of_image_view")]
		[return: NativeName(NativeNameType.Type, "uint32_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_index_of_image_view")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint DaxaIndexOfImageViewNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageViewId")] DaxaImageViewId id);

		[NativeName(NativeNameType.Func, "daxa_index_of_image_view")]
		[return: NativeName(NativeNameType.Type, "uint32_t")]
		public static uint DaxaIndexOfImageView([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageViewId")] DaxaImageViewId id)
		{
			uint ret = DaxaIndexOfImageViewNative(id);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_index_of_sampler")]
		[return: NativeName(NativeNameType.Type, "uint32_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_index_of_sampler")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial uint DaxaIndexOfSamplerNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_SamplerId")] DaxaSamplerId id);

		[NativeName(NativeNameType.Func, "daxa_index_of_sampler")]
		[return: NativeName(NativeNameType.Type, "uint32_t")]
		public static uint DaxaIndexOfSampler([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_SamplerId")] DaxaSamplerId id)
		{
			uint ret = DaxaIndexOfSamplerNative(id);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_version_of_buffer")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_version_of_buffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaVersionOfBufferNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_BufferId")] DaxaBufferId id);

		[NativeName(NativeNameType.Func, "daxa_version_of_buffer")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaVersionOfBuffer([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_BufferId")] DaxaBufferId id)
		{
			ulong ret = DaxaVersionOfBufferNative(id);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_version_of_image")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_version_of_image")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaVersionOfImageNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageId")] DaxaImageId id);

		[NativeName(NativeNameType.Func, "daxa_version_of_image")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaVersionOfImage([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageId")] DaxaImageId id)
		{
			ulong ret = DaxaVersionOfImageNative(id);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_version_of_image_view")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_version_of_image_view")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaVersionOfImageViewNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageViewId")] DaxaImageViewId id);

		[NativeName(NativeNameType.Func, "daxa_version_of_image_view")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaVersionOfImageView([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_ImageViewId")] DaxaImageViewId id)
		{
			ulong ret = DaxaVersionOfImageViewNative(id);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_version_of_sampler")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_version_of_sampler")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaVersionOfSamplerNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_SamplerId")] DaxaSamplerId id);

		[NativeName(NativeNameType.Func, "daxa_version_of_sampler")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaVersionOfSampler([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "daxa_SamplerId")] DaxaSamplerId id)
		{
			ulong ret = DaxaVersionOfSamplerNative(id);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_memory_block_get_vma_allocation")]
		[return: NativeName(NativeNameType.Type, "VmaAllocation")]
		[LibraryImport(LibName, EntryPoint = "daxa_memory_block_get_vma_allocation")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VmaAllocation DaxaMemoryBlockGetVmaAllocationNative([NativeName(NativeNameType.Param, "memory_block")] [NativeName(NativeNameType.Type, "daxa_MemoryBlock")] DaxaMemoryBlock memoryBlock);

		[NativeName(NativeNameType.Func, "daxa_memory_block_get_vma_allocation")]
		[return: NativeName(NativeNameType.Type, "VmaAllocation")]
		public static VmaAllocation DaxaMemoryBlockGetVmaAllocation([NativeName(NativeNameType.Param, "memory_block")] [NativeName(NativeNameType.Type, "daxa_MemoryBlock")] DaxaMemoryBlock memoryBlock)
		{
			VmaAllocation ret = DaxaMemoryBlockGetVmaAllocationNative(memoryBlock);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_BinarySemaphoreInfo*")]
		[LibraryImport(LibName, EntryPoint = "daxa_binary_semaphore_info")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaBinarySemaphoreInfo* DaxaBinarySemaphoreInfoNative([NativeName(NativeNameType.Param, "binary_semaphore")] [NativeName(NativeNameType.Type, "daxa_BinarySemaphore")] DaxaBinarySemaphore binarySemaphore);

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_BinarySemaphoreInfo*")]
		public static DaxaBinarySemaphoreInfo* DaxaBinarySemaphoreInfo([NativeName(NativeNameType.Param, "binary_semaphore")] [NativeName(NativeNameType.Type, "daxa_BinarySemaphore")] DaxaBinarySemaphore binarySemaphore)
		{
			DaxaBinarySemaphoreInfo* ret = DaxaBinarySemaphoreInfoNative(binarySemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_get_vk_semaphore")]
		[return: NativeName(NativeNameType.Type, "VkSemaphore")]
		[LibraryImport(LibName, EntryPoint = "daxa_binary_semaphore_get_vk_semaphore")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkSemaphore DaxaBinarySemaphoreGetVkSemaphoreNative([NativeName(NativeNameType.Param, "binary_semaphore")] [NativeName(NativeNameType.Type, "daxa_BinarySemaphore")] DaxaBinarySemaphore binarySemaphore);

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_get_vk_semaphore")]
		[return: NativeName(NativeNameType.Type, "VkSemaphore")]
		public static VkSemaphore DaxaBinarySemaphoreGetVkSemaphore([NativeName(NativeNameType.Param, "binary_semaphore")] [NativeName(NativeNameType.Type, "daxa_BinarySemaphore")] DaxaBinarySemaphore binarySemaphore)
		{
			VkSemaphore ret = DaxaBinarySemaphoreGetVkSemaphoreNative(binarySemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_binary_semaphore_inc_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaBinarySemaphoreIncRefcntNative([NativeName(NativeNameType.Param, "binary_semaphore")] [NativeName(NativeNameType.Type, "daxa_BinarySemaphore")] DaxaBinarySemaphore binarySemaphore);

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaBinarySemaphoreIncRefcnt([NativeName(NativeNameType.Param, "binary_semaphore")] [NativeName(NativeNameType.Type, "daxa_BinarySemaphore")] DaxaBinarySemaphore binarySemaphore)
		{
			ulong ret = DaxaBinarySemaphoreIncRefcntNative(binarySemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_binary_semaphore_dec_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaBinarySemaphoreDecRefcntNative([NativeName(NativeNameType.Param, "binary_semaphore")] [NativeName(NativeNameType.Type, "daxa_BinarySemaphore")] DaxaBinarySemaphore binarySemaphore);

		[NativeName(NativeNameType.Func, "daxa_binary_semaphore_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaBinarySemaphoreDecRefcnt([NativeName(NativeNameType.Param, "binary_semaphore")] [NativeName(NativeNameType.Type, "daxa_BinarySemaphore")] DaxaBinarySemaphore binarySemaphore)
		{
			ulong ret = DaxaBinarySemaphoreDecRefcntNative(binarySemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_TimelineSemaphoreInfo*")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_semaphore_info")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaTimelineSemaphoreInfo* DaxaTimelineSemaphoreInfoNative([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore);

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_TimelineSemaphoreInfo*")]
		public static DaxaTimelineSemaphoreInfo* DaxaTimelineSemaphoreInfo([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore)
		{
			DaxaTimelineSemaphoreInfo* ret = DaxaTimelineSemaphoreInfoNative(timelineSemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_get_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_semaphore_get_value")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaResult DaxaTimelineSemaphoreGetValueNative([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "out_value")] [NativeName(NativeNameType.Type, "uint64_t*")] ulong* outValue);

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_get_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaTimelineSemaphoreGetValue([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "out_value")] [NativeName(NativeNameType.Type, "uint64_t*")] ulong* outValue)
		{
			DaxaResult ret = DaxaTimelineSemaphoreGetValueNative(timelineSemaphore, outValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_get_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaTimelineSemaphoreGetValue([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "out_value")] [NativeName(NativeNameType.Type, "uint64_t*")] ref ulong outValue)
		{
			fixed (ulong* poutValue = &outValue)
			{
				DaxaResult ret = DaxaTimelineSemaphoreGetValueNative(timelineSemaphore, (ulong*)poutValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_set_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_semaphore_set_value")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaResult DaxaTimelineSemaphoreSetValueNative([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "uint64_t")] ulong value);

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_set_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaTimelineSemaphoreSetValue([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "uint64_t")] ulong value)
		{
			DaxaResult ret = DaxaTimelineSemaphoreSetValueNative(timelineSemaphore, value);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_wait_for_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_semaphore_wait_for_value")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaResult DaxaTimelineSemaphoreWaitForValueNative([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "uint64_t")] ulong value, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "uint64_t")] ulong timeout);

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_wait_for_value")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaTimelineSemaphoreWaitForValue([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "uint64_t")] ulong value, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "uint64_t")] ulong timeout)
		{
			DaxaResult ret = DaxaTimelineSemaphoreWaitForValueNative(timelineSemaphore, value, timeout);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_get_vk_semaphore")]
		[return: NativeName(NativeNameType.Type, "VkSemaphore")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_semaphore_get_vk_semaphore")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkSemaphore DaxaTimelineSemaphoreGetVkSemaphoreNative([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore);

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_get_vk_semaphore")]
		[return: NativeName(NativeNameType.Type, "VkSemaphore")]
		public static VkSemaphore DaxaTimelineSemaphoreGetVkSemaphore([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore)
		{
			VkSemaphore ret = DaxaTimelineSemaphoreGetVkSemaphoreNative(timelineSemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_semaphore_inc_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaTimelineSemaphoreIncRefcntNative([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore);

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaTimelineSemaphoreIncRefcnt([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore)
		{
			ulong ret = DaxaTimelineSemaphoreIncRefcntNative(timelineSemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_semaphore_dec_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaTimelineSemaphoreDecRefcntNative([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore);

		[NativeName(NativeNameType.Func, "daxa_timeline_semaphore_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaTimelineSemaphoreDecRefcnt([NativeName(NativeNameType.Param, "timeline_semaphore")] [NativeName(NativeNameType.Type, "daxa_TimelineSemaphore")] DaxaTimelineSemaphore timelineSemaphore)
		{
			ulong ret = DaxaTimelineSemaphoreDecRefcntNative(timelineSemaphore);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_event_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_EventInfo*")]
		[LibraryImport(LibName, EntryPoint = "daxa_event_info")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaEventInfo* DaxaEventInfoNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "daxa_Event")] DaxaEvent evnt);

		[NativeName(NativeNameType.Func, "daxa_event_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_EventInfo*")]
		public static DaxaEventInfo* DaxaEventInfo([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "daxa_Event")] DaxaEvent evnt)
		{
			DaxaEventInfo* ret = DaxaEventInfoNative(evnt);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_event_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_event_inc_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaEventIncRefcntNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "daxa_Event")] DaxaEvent evnt);

		[NativeName(NativeNameType.Func, "daxa_event_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaEventIncRefcnt([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "daxa_Event")] DaxaEvent evnt)
		{
			ulong ret = DaxaEventIncRefcntNative(evnt);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_event_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_event_dec_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaEventDecRefcntNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "daxa_Event")] DaxaEvent evnt);

		[NativeName(NativeNameType.Func, "daxa_event_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaEventDecRefcnt([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "daxa_Event")] DaxaEvent evnt)
		{
			ulong ret = DaxaEventDecRefcntNative(evnt);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_ray_tracing_pipeline_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_RayTracingPipelineInfo*")]
		[LibraryImport(LibName, EntryPoint = "daxa_ray_tracing_pipeline_info")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaRayTracingPipelineInfo* DaxaRayTracingPipelineInfoNative([NativeName(NativeNameType.Param, "ray_tracing_pipeline")] [NativeName(NativeNameType.Type, "daxa_RayTracingPipeline")] DaxaRayTracingPipeline rayTracingPipeline);

		[NativeName(NativeNameType.Func, "daxa_ray_tracing_pipeline_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_RayTracingPipelineInfo*")]
		public static DaxaRayTracingPipelineInfo* DaxaRayTracingPipelineInfo([NativeName(NativeNameType.Param, "ray_tracing_pipeline")] [NativeName(NativeNameType.Type, "daxa_RayTracingPipeline")] DaxaRayTracingPipeline rayTracingPipeline)
		{
			DaxaRayTracingPipelineInfo* ret = DaxaRayTracingPipelineInfoNative(rayTracingPipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_ray_tracing_pipeline_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_ray_tracing_pipeline_inc_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaRayTracingPipelineIncRefcntNative([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RayTracingPipeline")] DaxaRayTracingPipeline pipeline);

		[NativeName(NativeNameType.Func, "daxa_ray_tracing_pipeline_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaRayTracingPipelineIncRefcnt([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RayTracingPipeline")] DaxaRayTracingPipeline pipeline)
		{
			ulong ret = DaxaRayTracingPipelineIncRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_ray_tracing_pipeline_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_ray_tracing_pipeline_dec_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaRayTracingPipelineDecRefcntNative([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RayTracingPipeline")] DaxaRayTracingPipeline pipeline);

		[NativeName(NativeNameType.Func, "daxa_ray_tracing_pipeline_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaRayTracingPipelineDecRefcnt([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RayTracingPipeline")] DaxaRayTracingPipeline pipeline)
		{
			ulong ret = DaxaRayTracingPipelineDecRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_compute_pipeline_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_ComputePipelineInfo*")]
		[LibraryImport(LibName, EntryPoint = "daxa_compute_pipeline_info")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaComputePipelineInfo* DaxaComputePipelineInfoNative([NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "daxa_ComputePipeline")] DaxaComputePipeline computePipeline);

		[NativeName(NativeNameType.Func, "daxa_compute_pipeline_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_ComputePipelineInfo*")]
		public static DaxaComputePipelineInfo* DaxaComputePipelineInfo([NativeName(NativeNameType.Param, "compute_pipeline")] [NativeName(NativeNameType.Type, "daxa_ComputePipeline")] DaxaComputePipeline computePipeline)
		{
			DaxaComputePipelineInfo* ret = DaxaComputePipelineInfoNative(computePipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_compute_pipeline_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_compute_pipeline_inc_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaComputePipelineIncRefcntNative([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_ComputePipeline")] DaxaComputePipeline pipeline);

		[NativeName(NativeNameType.Func, "daxa_compute_pipeline_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaComputePipelineIncRefcnt([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_ComputePipeline")] DaxaComputePipeline pipeline)
		{
			ulong ret = DaxaComputePipelineIncRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_compute_pipeline_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_compute_pipeline_dec_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaComputePipelineDecRefcntNative([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_ComputePipeline")] DaxaComputePipeline pipeline);

		[NativeName(NativeNameType.Func, "daxa_compute_pipeline_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaComputePipelineDecRefcnt([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_ComputePipeline")] DaxaComputePipeline pipeline)
		{
			ulong ret = DaxaComputePipelineDecRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_raster_pipeline_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_RasterPipelineInfo*")]
		[LibraryImport(LibName, EntryPoint = "daxa_raster_pipeline_info")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaRasterPipelineInfo* DaxaRasterPipelineInfoNative([NativeName(NativeNameType.Param, "raster_pipeline")] [NativeName(NativeNameType.Type, "daxa_RasterPipeline")] DaxaRasterPipeline rasterPipeline);

		[NativeName(NativeNameType.Func, "daxa_raster_pipeline_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_RasterPipelineInfo*")]
		public static DaxaRasterPipelineInfo* DaxaRasterPipelineInfo([NativeName(NativeNameType.Param, "raster_pipeline")] [NativeName(NativeNameType.Type, "daxa_RasterPipeline")] DaxaRasterPipeline rasterPipeline)
		{
			DaxaRasterPipelineInfo* ret = DaxaRasterPipelineInfoNative(rasterPipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_raster_pipeline_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_raster_pipeline_inc_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaRasterPipelineIncRefcntNative([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RasterPipeline")] DaxaRasterPipeline pipeline);

		[NativeName(NativeNameType.Func, "daxa_raster_pipeline_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaRasterPipelineIncRefcnt([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RasterPipeline")] DaxaRasterPipeline pipeline)
		{
			ulong ret = DaxaRasterPipelineIncRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_raster_pipeline_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_raster_pipeline_dec_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaRasterPipelineDecRefcntNative([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RasterPipeline")] DaxaRasterPipeline pipeline);

		[NativeName(NativeNameType.Func, "daxa_raster_pipeline_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaRasterPipelineDecRefcnt([NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "daxa_RasterPipeline")] DaxaRasterPipeline pipeline)
		{
			ulong ret = DaxaRasterPipelineDecRefcntNative(pipeline);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_set_rasterization_samples")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		[LibraryImport(LibName, EntryPoint = "daxa_cmd_set_rasterization_samples")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaResult DaxaCmdSetRasterizationSamplesNative([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "samples")] [NativeName(NativeNameType.Type, "VkSampleCountFlagBits")] VkSampleCountFlagBits samples);

		[NativeName(NativeNameType.Func, "daxa_cmd_set_rasterization_samples")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaCmdSetRasterizationSamples([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "samples")] [NativeName(NativeNameType.Type, "VkSampleCountFlagBits")] VkSampleCountFlagBits samples)
		{
			DaxaResult ret = DaxaCmdSetRasterizationSamplesNative(cmdEnc, samples);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_copy_buffer_to_buffer")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		[LibraryImport(LibName, EntryPoint = "daxa_cmd_copy_buffer_to_buffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaResult DaxaCmdCopyBufferToBufferNative([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_BufferCopyInfo*")] DaxaBufferCopyInfo* info);

		[NativeName(NativeNameType.Func, "daxa_cmd_copy_buffer_to_buffer")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaCmdCopyBufferToBuffer([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_BufferCopyInfo*")] DaxaBufferCopyInfo* info)
		{
			DaxaResult ret = DaxaCmdCopyBufferToBufferNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_copy_buffer_to_buffer")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaCmdCopyBufferToBuffer([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_BufferCopyInfo*")] ref DaxaBufferCopyInfo info)
		{
			fixed (DaxaBufferCopyInfo* pinfo = &info)
			{
				DaxaResult ret = DaxaCmdCopyBufferToBufferNative(cmdEnc, (DaxaBufferCopyInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_copy_buffer_to_image")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		[LibraryImport(LibName, EntryPoint = "daxa_cmd_copy_buffer_to_image")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaResult DaxaCmdCopyBufferToImageNative([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_BufferImageCopyInfo*")] DaxaBufferImageCopyInfo* info);

		[NativeName(NativeNameType.Func, "daxa_cmd_copy_buffer_to_image")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaCmdCopyBufferToImage([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_BufferImageCopyInfo*")] DaxaBufferImageCopyInfo* info)
		{
			DaxaResult ret = DaxaCmdCopyBufferToImageNative(cmdEnc, info);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_copy_buffer_to_image")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaCmdCopyBufferToImage([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_BufferImageCopyInfo*")] ref DaxaBufferImageCopyInfo info)
		{
			fixed (DaxaBufferImageCopyInfo* pinfo = &info)
			{
				DaxaResult ret = DaxaCmdCopyBufferToImageNative(cmdEnc, (DaxaBufferImageCopyInfo*)pinfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_cmd_copy_image_to_buffer")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		[LibraryImport(LibName, EntryPoint = "daxa_cmd_copy_image_to_buffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaResult DaxaCmdCopyImageToBufferNative([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_ImageBufferCopyInfo*")] DaxaImageBufferCopyInfo* info);

		[NativeName(NativeNameType.Func, "daxa_cmd_copy_image_to_buffer")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaCmdCopyImageToBuffer([NativeName(NativeNameType.Param, "cmd_enc")] [NativeName(NativeNameType.Type, "daxa_CommandRecorder")] DaxaCommandRecorder cmdEnc, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "const daxa_ImageBufferCopyInfo*")] DaxaImageBufferCopyInfo* info)
		{
			DaxaResult ret = DaxaCmdCopyImageToBufferNative(cmdEnc, info);
			return ret;
		}
	}
}
