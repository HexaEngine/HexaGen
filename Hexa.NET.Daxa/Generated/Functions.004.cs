// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Daxa
{
	public unsafe partial class Daxa
	{

		[NativeName(NativeNameType.Func, "vkCmdSetRepresentativeFragmentTestEnableNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdSetRepresentativeFragmentTestEnableNV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdSetRepresentativeFragmentTestEnableNVNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "representativeFragmentTestEnable")] [NativeName(NativeNameType.Type, "VkBool32")] uint representativeFragmentTestEnable);

		[NativeName(NativeNameType.Func, "vkCmdSetRepresentativeFragmentTestEnableNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdSetRepresentativeFragmentTestEnableNV([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "representativeFragmentTestEnable")] [NativeName(NativeNameType.Type, "VkBool32")] uint representativeFragmentTestEnable)
		{
			VkCmdSetRepresentativeFragmentTestEnableNVNative(commandBuffer, representativeFragmentTestEnable);
		}

		[NativeName(NativeNameType.Func, "vkCmdSetCoverageReductionModeNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdSetCoverageReductionModeNV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdSetCoverageReductionModeNVNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "coverageReductionMode")] [NativeName(NativeNameType.Type, "VkCoverageReductionModeNV")] VkCoverageReductionModeNV coverageReductionMode);

		[NativeName(NativeNameType.Func, "vkCmdSetCoverageReductionModeNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdSetCoverageReductionModeNV([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "coverageReductionMode")] [NativeName(NativeNameType.Type, "VkCoverageReductionModeNV")] VkCoverageReductionModeNV coverageReductionMode)
		{
			VkCmdSetCoverageReductionModeNVNative(commandBuffer, coverageReductionMode);
		}

		[NativeName(NativeNameType.Func, "vkGetShaderModuleIdentifierEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkGetShaderModuleIdentifierEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkGetShaderModuleIdentifierEXTNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "shaderModule")] [NativeName(NativeNameType.Type, "VkShaderModule")] VkShaderModule shaderModule, [NativeName(NativeNameType.Param, "pIdentifier")] [NativeName(NativeNameType.Type, "VkShaderModuleIdentifierEXT*")] VkShaderModuleIdentifierEXT* pIdentifier);

		[NativeName(NativeNameType.Func, "vkGetShaderModuleIdentifierEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetShaderModuleIdentifierEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "shaderModule")] [NativeName(NativeNameType.Type, "VkShaderModule")] VkShaderModule shaderModule, [NativeName(NativeNameType.Param, "pIdentifier")] [NativeName(NativeNameType.Type, "VkShaderModuleIdentifierEXT*")] VkShaderModuleIdentifierEXT* pIdentifier)
		{
			VkGetShaderModuleIdentifierEXTNative(device, shaderModule, pIdentifier);
		}

		[NativeName(NativeNameType.Func, "vkGetShaderModuleIdentifierEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetShaderModuleIdentifierEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "shaderModule")] [NativeName(NativeNameType.Type, "VkShaderModule")] VkShaderModule shaderModule, [NativeName(NativeNameType.Param, "pIdentifier")] [NativeName(NativeNameType.Type, "VkShaderModuleIdentifierEXT*")] ref VkShaderModuleIdentifierEXT pIdentifier)
		{
			fixed (VkShaderModuleIdentifierEXT* ppIdentifier = &pIdentifier)
			{
				VkGetShaderModuleIdentifierEXTNative(device, shaderModule, (VkShaderModuleIdentifierEXT*)ppIdentifier);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetShaderModuleCreateInfoIdentifierEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkGetShaderModuleCreateInfoIdentifierEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkGetShaderModuleCreateInfoIdentifierEXTNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkShaderModuleCreateInfo*")] VkShaderModuleCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pIdentifier")] [NativeName(NativeNameType.Type, "VkShaderModuleIdentifierEXT*")] VkShaderModuleIdentifierEXT* pIdentifier);

		[NativeName(NativeNameType.Func, "vkGetShaderModuleCreateInfoIdentifierEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetShaderModuleCreateInfoIdentifierEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkShaderModuleCreateInfo*")] VkShaderModuleCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pIdentifier")] [NativeName(NativeNameType.Type, "VkShaderModuleIdentifierEXT*")] VkShaderModuleIdentifierEXT* pIdentifier)
		{
			VkGetShaderModuleCreateInfoIdentifierEXTNative(device, pCreateInfo, pIdentifier);
		}

		[NativeName(NativeNameType.Func, "vkGetShaderModuleCreateInfoIdentifierEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetShaderModuleCreateInfoIdentifierEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkShaderModuleCreateInfo*")] ref VkShaderModuleCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pIdentifier")] [NativeName(NativeNameType.Type, "VkShaderModuleIdentifierEXT*")] VkShaderModuleIdentifierEXT* pIdentifier)
		{
			fixed (VkShaderModuleCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkGetShaderModuleCreateInfoIdentifierEXTNative(device, (VkShaderModuleCreateInfo*)ppCreateInfo, pIdentifier);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetShaderModuleCreateInfoIdentifierEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetShaderModuleCreateInfoIdentifierEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkShaderModuleCreateInfo*")] VkShaderModuleCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pIdentifier")] [NativeName(NativeNameType.Type, "VkShaderModuleIdentifierEXT*")] ref VkShaderModuleIdentifierEXT pIdentifier)
		{
			fixed (VkShaderModuleIdentifierEXT* ppIdentifier = &pIdentifier)
			{
				VkGetShaderModuleCreateInfoIdentifierEXTNative(device, pCreateInfo, (VkShaderModuleIdentifierEXT*)ppIdentifier);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetShaderModuleCreateInfoIdentifierEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetShaderModuleCreateInfoIdentifierEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkShaderModuleCreateInfo*")] ref VkShaderModuleCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pIdentifier")] [NativeName(NativeNameType.Type, "VkShaderModuleIdentifierEXT*")] ref VkShaderModuleIdentifierEXT pIdentifier)
		{
			fixed (VkShaderModuleCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VkShaderModuleIdentifierEXT* ppIdentifier = &pIdentifier)
				{
					VkGetShaderModuleCreateInfoIdentifierEXTNative(device, (VkShaderModuleCreateInfo*)ppCreateInfo, (VkShaderModuleIdentifierEXT*)ppIdentifier);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkGetPhysicalDeviceOpticalFlowImageFormatsNVNative([NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "pOpticalFlowImageFormatInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowImageFormatInfoNV*")] VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, [NativeName(NativeNameType.Param, "pFormatCount")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pFormatCount, [NativeName(NativeNameType.Param, "pImageFormatProperties")] [NativeName(NativeNameType.Type, "VkOpticalFlowImageFormatPropertiesNV*")] VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties);

		[NativeName(NativeNameType.Func, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetPhysicalDeviceOpticalFlowImageFormatsNV([NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "pOpticalFlowImageFormatInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowImageFormatInfoNV*")] VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, [NativeName(NativeNameType.Param, "pFormatCount")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pFormatCount, [NativeName(NativeNameType.Param, "pImageFormatProperties")] [NativeName(NativeNameType.Type, "VkOpticalFlowImageFormatPropertiesNV*")] VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties)
		{
			VkResult ret = VkGetPhysicalDeviceOpticalFlowImageFormatsNVNative(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetPhysicalDeviceOpticalFlowImageFormatsNV([NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "pOpticalFlowImageFormatInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowImageFormatInfoNV*")] ref VkOpticalFlowImageFormatInfoNV pOpticalFlowImageFormatInfo, [NativeName(NativeNameType.Param, "pFormatCount")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pFormatCount, [NativeName(NativeNameType.Param, "pImageFormatProperties")] [NativeName(NativeNameType.Type, "VkOpticalFlowImageFormatPropertiesNV*")] VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties)
		{
			fixed (VkOpticalFlowImageFormatInfoNV* ppOpticalFlowImageFormatInfo = &pOpticalFlowImageFormatInfo)
			{
				VkResult ret = VkGetPhysicalDeviceOpticalFlowImageFormatsNVNative(physicalDevice, (VkOpticalFlowImageFormatInfoNV*)ppOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetPhysicalDeviceOpticalFlowImageFormatsNV([NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "pOpticalFlowImageFormatInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowImageFormatInfoNV*")] VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, [NativeName(NativeNameType.Param, "pFormatCount")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pFormatCount, [NativeName(NativeNameType.Param, "pImageFormatProperties")] [NativeName(NativeNameType.Type, "VkOpticalFlowImageFormatPropertiesNV*")] VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties)
		{
			fixed (uint* ppFormatCount = &pFormatCount)
			{
				VkResult ret = VkGetPhysicalDeviceOpticalFlowImageFormatsNVNative(physicalDevice, pOpticalFlowImageFormatInfo, (uint*)ppFormatCount, pImageFormatProperties);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetPhysicalDeviceOpticalFlowImageFormatsNV([NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "pOpticalFlowImageFormatInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowImageFormatInfoNV*")] ref VkOpticalFlowImageFormatInfoNV pOpticalFlowImageFormatInfo, [NativeName(NativeNameType.Param, "pFormatCount")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pFormatCount, [NativeName(NativeNameType.Param, "pImageFormatProperties")] [NativeName(NativeNameType.Type, "VkOpticalFlowImageFormatPropertiesNV*")] VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties)
		{
			fixed (VkOpticalFlowImageFormatInfoNV* ppOpticalFlowImageFormatInfo = &pOpticalFlowImageFormatInfo)
			{
				fixed (uint* ppFormatCount = &pFormatCount)
				{
					VkResult ret = VkGetPhysicalDeviceOpticalFlowImageFormatsNVNative(physicalDevice, (VkOpticalFlowImageFormatInfoNV*)ppOpticalFlowImageFormatInfo, (uint*)ppFormatCount, pImageFormatProperties);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetPhysicalDeviceOpticalFlowImageFormatsNV([NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "pOpticalFlowImageFormatInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowImageFormatInfoNV*")] VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, [NativeName(NativeNameType.Param, "pFormatCount")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pFormatCount, [NativeName(NativeNameType.Param, "pImageFormatProperties")] [NativeName(NativeNameType.Type, "VkOpticalFlowImageFormatPropertiesNV*")] ref VkOpticalFlowImageFormatPropertiesNV pImageFormatProperties)
		{
			fixed (VkOpticalFlowImageFormatPropertiesNV* ppImageFormatProperties = &pImageFormatProperties)
			{
				VkResult ret = VkGetPhysicalDeviceOpticalFlowImageFormatsNVNative(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, (VkOpticalFlowImageFormatPropertiesNV*)ppImageFormatProperties);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetPhysicalDeviceOpticalFlowImageFormatsNV([NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "pOpticalFlowImageFormatInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowImageFormatInfoNV*")] ref VkOpticalFlowImageFormatInfoNV pOpticalFlowImageFormatInfo, [NativeName(NativeNameType.Param, "pFormatCount")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pFormatCount, [NativeName(NativeNameType.Param, "pImageFormatProperties")] [NativeName(NativeNameType.Type, "VkOpticalFlowImageFormatPropertiesNV*")] ref VkOpticalFlowImageFormatPropertiesNV pImageFormatProperties)
		{
			fixed (VkOpticalFlowImageFormatInfoNV* ppOpticalFlowImageFormatInfo = &pOpticalFlowImageFormatInfo)
			{
				fixed (VkOpticalFlowImageFormatPropertiesNV* ppImageFormatProperties = &pImageFormatProperties)
				{
					VkResult ret = VkGetPhysicalDeviceOpticalFlowImageFormatsNVNative(physicalDevice, (VkOpticalFlowImageFormatInfoNV*)ppOpticalFlowImageFormatInfo, pFormatCount, (VkOpticalFlowImageFormatPropertiesNV*)ppImageFormatProperties);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetPhysicalDeviceOpticalFlowImageFormatsNV([NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "pOpticalFlowImageFormatInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowImageFormatInfoNV*")] VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, [NativeName(NativeNameType.Param, "pFormatCount")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pFormatCount, [NativeName(NativeNameType.Param, "pImageFormatProperties")] [NativeName(NativeNameType.Type, "VkOpticalFlowImageFormatPropertiesNV*")] ref VkOpticalFlowImageFormatPropertiesNV pImageFormatProperties)
		{
			fixed (uint* ppFormatCount = &pFormatCount)
			{
				fixed (VkOpticalFlowImageFormatPropertiesNV* ppImageFormatProperties = &pImageFormatProperties)
				{
					VkResult ret = VkGetPhysicalDeviceOpticalFlowImageFormatsNVNative(physicalDevice, pOpticalFlowImageFormatInfo, (uint*)ppFormatCount, (VkOpticalFlowImageFormatPropertiesNV*)ppImageFormatProperties);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetPhysicalDeviceOpticalFlowImageFormatsNV([NativeName(NativeNameType.Param, "physicalDevice")] [NativeName(NativeNameType.Type, "VkPhysicalDevice")] VkPhysicalDevice physicalDevice, [NativeName(NativeNameType.Param, "pOpticalFlowImageFormatInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowImageFormatInfoNV*")] ref VkOpticalFlowImageFormatInfoNV pOpticalFlowImageFormatInfo, [NativeName(NativeNameType.Param, "pFormatCount")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pFormatCount, [NativeName(NativeNameType.Param, "pImageFormatProperties")] [NativeName(NativeNameType.Type, "VkOpticalFlowImageFormatPropertiesNV*")] ref VkOpticalFlowImageFormatPropertiesNV pImageFormatProperties)
		{
			fixed (VkOpticalFlowImageFormatInfoNV* ppOpticalFlowImageFormatInfo = &pOpticalFlowImageFormatInfo)
			{
				fixed (uint* ppFormatCount = &pFormatCount)
				{
					fixed (VkOpticalFlowImageFormatPropertiesNV* ppImageFormatProperties = &pImageFormatProperties)
					{
						VkResult ret = VkGetPhysicalDeviceOpticalFlowImageFormatsNVNative(physicalDevice, (VkOpticalFlowImageFormatInfoNV*)ppOpticalFlowImageFormatInfo, (uint*)ppFormatCount, (VkOpticalFlowImageFormatPropertiesNV*)ppImageFormatProperties);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkCreateOpticalFlowSessionNV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkCreateOpticalFlowSessionNVNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowSessionCreateInfoNV*")] VkOpticalFlowSessionCreateInfoNV* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pSession")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV*")] VkOpticalFlowSessionNV* pSession);

		[NativeName(NativeNameType.Func, "vkCreateOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowSessionCreateInfoNV*")] VkOpticalFlowSessionCreateInfoNV* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pSession")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV*")] VkOpticalFlowSessionNV* pSession)
		{
			VkResult ret = VkCreateOpticalFlowSessionNVNative(device, pCreateInfo, pAllocator, pSession);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCreateOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowSessionCreateInfoNV*")] ref VkOpticalFlowSessionCreateInfoNV pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pSession")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV*")] VkOpticalFlowSessionNV* pSession)
		{
			fixed (VkOpticalFlowSessionCreateInfoNV* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VkCreateOpticalFlowSessionNVNative(device, (VkOpticalFlowSessionCreateInfoNV*)ppCreateInfo, pAllocator, pSession);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowSessionCreateInfoNV*")] VkOpticalFlowSessionCreateInfoNV* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pSession")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV*")] VkOpticalFlowSessionNV* pSession)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				VkResult ret = VkCreateOpticalFlowSessionNVNative(device, pCreateInfo, (VkAllocationCallbacks*)ppAllocator, pSession);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowSessionCreateInfoNV*")] ref VkOpticalFlowSessionCreateInfoNV pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pSession")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV*")] VkOpticalFlowSessionNV* pSession)
		{
			fixed (VkOpticalFlowSessionCreateInfoNV* ppCreateInfo = &pCreateInfo)
			{
				fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
				{
					VkResult ret = VkCreateOpticalFlowSessionNVNative(device, (VkOpticalFlowSessionCreateInfoNV*)ppCreateInfo, (VkAllocationCallbacks*)ppAllocator, pSession);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowSessionCreateInfoNV*")] VkOpticalFlowSessionCreateInfoNV* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pSession")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV*")] ref VkOpticalFlowSessionNV pSession)
		{
			fixed (VkOpticalFlowSessionNV* ppSession = &pSession)
			{
				VkResult ret = VkCreateOpticalFlowSessionNVNative(device, pCreateInfo, pAllocator, (VkOpticalFlowSessionNV*)ppSession);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowSessionCreateInfoNV*")] ref VkOpticalFlowSessionCreateInfoNV pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pSession")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV*")] ref VkOpticalFlowSessionNV pSession)
		{
			fixed (VkOpticalFlowSessionCreateInfoNV* ppCreateInfo = &pCreateInfo)
			{
				fixed (VkOpticalFlowSessionNV* ppSession = &pSession)
				{
					VkResult ret = VkCreateOpticalFlowSessionNVNative(device, (VkOpticalFlowSessionCreateInfoNV*)ppCreateInfo, pAllocator, (VkOpticalFlowSessionNV*)ppSession);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowSessionCreateInfoNV*")] VkOpticalFlowSessionCreateInfoNV* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pSession")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV*")] ref VkOpticalFlowSessionNV pSession)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				fixed (VkOpticalFlowSessionNV* ppSession = &pSession)
				{
					VkResult ret = VkCreateOpticalFlowSessionNVNative(device, pCreateInfo, (VkAllocationCallbacks*)ppAllocator, (VkOpticalFlowSessionNV*)ppSession);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowSessionCreateInfoNV*")] ref VkOpticalFlowSessionCreateInfoNV pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pSession")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV*")] ref VkOpticalFlowSessionNV pSession)
		{
			fixed (VkOpticalFlowSessionCreateInfoNV* ppCreateInfo = &pCreateInfo)
			{
				fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
				{
					fixed (VkOpticalFlowSessionNV* ppSession = &pSession)
					{
						VkResult ret = VkCreateOpticalFlowSessionNVNative(device, (VkOpticalFlowSessionCreateInfoNV*)ppCreateInfo, (VkAllocationCallbacks*)ppAllocator, (VkOpticalFlowSessionNV*)ppSession);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkDestroyOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkDestroyOpticalFlowSessionNV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkDestroyOpticalFlowSessionNVNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "session")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV")] VkOpticalFlowSessionNV session, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator);

		[NativeName(NativeNameType.Func, "vkDestroyOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkDestroyOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "session")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV")] VkOpticalFlowSessionNV session, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator)
		{
			VkDestroyOpticalFlowSessionNVNative(device, session, pAllocator);
		}

		[NativeName(NativeNameType.Func, "vkDestroyOpticalFlowSessionNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkDestroyOpticalFlowSessionNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "session")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV")] VkOpticalFlowSessionNV session, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				VkDestroyOpticalFlowSessionNVNative(device, session, (VkAllocationCallbacks*)ppAllocator);
			}
		}

		[NativeName(NativeNameType.Func, "vkBindOpticalFlowSessionImageNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkBindOpticalFlowSessionImageNV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkBindOpticalFlowSessionImageNVNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "session")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV")] VkOpticalFlowSessionNV session, [NativeName(NativeNameType.Param, "bindingPoint")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionBindingPointNV")] VkOpticalFlowSessionBindingPointNV bindingPoint, [NativeName(NativeNameType.Param, "view")] [NativeName(NativeNameType.Type, "VkImageView")] VkImageView view, [NativeName(NativeNameType.Param, "layout")] [NativeName(NativeNameType.Type, "VkImageLayout")] VkImageLayout layout);

		[NativeName(NativeNameType.Func, "vkBindOpticalFlowSessionImageNV")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkBindOpticalFlowSessionImageNV([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "session")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV")] VkOpticalFlowSessionNV session, [NativeName(NativeNameType.Param, "bindingPoint")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionBindingPointNV")] VkOpticalFlowSessionBindingPointNV bindingPoint, [NativeName(NativeNameType.Param, "view")] [NativeName(NativeNameType.Type, "VkImageView")] VkImageView view, [NativeName(NativeNameType.Param, "layout")] [NativeName(NativeNameType.Type, "VkImageLayout")] VkImageLayout layout)
		{
			VkResult ret = VkBindOpticalFlowSessionImageNVNative(device, session, bindingPoint, view, layout);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCmdOpticalFlowExecuteNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdOpticalFlowExecuteNV")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdOpticalFlowExecuteNVNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "session")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV")] VkOpticalFlowSessionNV session, [NativeName(NativeNameType.Param, "pExecuteInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowExecuteInfoNV*")] VkOpticalFlowExecuteInfoNV* pExecuteInfo);

		[NativeName(NativeNameType.Func, "vkCmdOpticalFlowExecuteNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdOpticalFlowExecuteNV([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "session")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV")] VkOpticalFlowSessionNV session, [NativeName(NativeNameType.Param, "pExecuteInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowExecuteInfoNV*")] VkOpticalFlowExecuteInfoNV* pExecuteInfo)
		{
			VkCmdOpticalFlowExecuteNVNative(commandBuffer, session, pExecuteInfo);
		}

		[NativeName(NativeNameType.Func, "vkCmdOpticalFlowExecuteNV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdOpticalFlowExecuteNV([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "session")] [NativeName(NativeNameType.Type, "VkOpticalFlowSessionNV")] VkOpticalFlowSessionNV session, [NativeName(NativeNameType.Param, "pExecuteInfo")] [NativeName(NativeNameType.Type, "const VkOpticalFlowExecuteInfoNV*")] ref VkOpticalFlowExecuteInfoNV pExecuteInfo)
		{
			fixed (VkOpticalFlowExecuteInfoNV* ppExecuteInfo = &pExecuteInfo)
			{
				VkCmdOpticalFlowExecuteNVNative(commandBuffer, session, (VkOpticalFlowExecuteInfoNV*)ppExecuteInfo);
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateShadersEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkCreateShadersEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkCreateShadersEXTNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkShaderCreateInfoEXT*")] VkShaderCreateInfoEXT* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "VkShaderEXT*")] VkShaderEXT* pShaders);

		[NativeName(NativeNameType.Func, "vkCreateShadersEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateShadersEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkShaderCreateInfoEXT*")] VkShaderCreateInfoEXT* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "VkShaderEXT*")] VkShaderEXT* pShaders)
		{
			VkResult ret = VkCreateShadersEXTNative(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCreateShadersEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateShadersEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkShaderCreateInfoEXT*")] ref VkShaderCreateInfoEXT pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "VkShaderEXT*")] VkShaderEXT* pShaders)
		{
			fixed (VkShaderCreateInfoEXT* ppCreateInfos = &pCreateInfos)
			{
				VkResult ret = VkCreateShadersEXTNative(device, createInfoCount, (VkShaderCreateInfoEXT*)ppCreateInfos, pAllocator, pShaders);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateShadersEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateShadersEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkShaderCreateInfoEXT*")] VkShaderCreateInfoEXT* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "VkShaderEXT*")] VkShaderEXT* pShaders)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				VkResult ret = VkCreateShadersEXTNative(device, createInfoCount, pCreateInfos, (VkAllocationCallbacks*)ppAllocator, pShaders);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateShadersEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateShadersEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkShaderCreateInfoEXT*")] ref VkShaderCreateInfoEXT pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "VkShaderEXT*")] VkShaderEXT* pShaders)
		{
			fixed (VkShaderCreateInfoEXT* ppCreateInfos = &pCreateInfos)
			{
				fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
				{
					VkResult ret = VkCreateShadersEXTNative(device, createInfoCount, (VkShaderCreateInfoEXT*)ppCreateInfos, (VkAllocationCallbacks*)ppAllocator, pShaders);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateShadersEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateShadersEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkShaderCreateInfoEXT*")] VkShaderCreateInfoEXT* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "VkShaderEXT*")] ref VkShaderEXT pShaders)
		{
			fixed (VkShaderEXT* ppShaders = &pShaders)
			{
				VkResult ret = VkCreateShadersEXTNative(device, createInfoCount, pCreateInfos, pAllocator, (VkShaderEXT*)ppShaders);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateShadersEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateShadersEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkShaderCreateInfoEXT*")] ref VkShaderCreateInfoEXT pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "VkShaderEXT*")] ref VkShaderEXT pShaders)
		{
			fixed (VkShaderCreateInfoEXT* ppCreateInfos = &pCreateInfos)
			{
				fixed (VkShaderEXT* ppShaders = &pShaders)
				{
					VkResult ret = VkCreateShadersEXTNative(device, createInfoCount, (VkShaderCreateInfoEXT*)ppCreateInfos, pAllocator, (VkShaderEXT*)ppShaders);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateShadersEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateShadersEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkShaderCreateInfoEXT*")] VkShaderCreateInfoEXT* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "VkShaderEXT*")] ref VkShaderEXT pShaders)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				fixed (VkShaderEXT* ppShaders = &pShaders)
				{
					VkResult ret = VkCreateShadersEXTNative(device, createInfoCount, pCreateInfos, (VkAllocationCallbacks*)ppAllocator, (VkShaderEXT*)ppShaders);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateShadersEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateShadersEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkShaderCreateInfoEXT*")] ref VkShaderCreateInfoEXT pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "VkShaderEXT*")] ref VkShaderEXT pShaders)
		{
			fixed (VkShaderCreateInfoEXT* ppCreateInfos = &pCreateInfos)
			{
				fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
				{
					fixed (VkShaderEXT* ppShaders = &pShaders)
					{
						VkResult ret = VkCreateShadersEXTNative(device, createInfoCount, (VkShaderCreateInfoEXT*)ppCreateInfos, (VkAllocationCallbacks*)ppAllocator, (VkShaderEXT*)ppShaders);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkDestroyShaderEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkDestroyShaderEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkDestroyShaderEXTNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "VkShaderEXT")] VkShaderEXT shader, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator);

		[NativeName(NativeNameType.Func, "vkDestroyShaderEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkDestroyShaderEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "VkShaderEXT")] VkShaderEXT shader, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator)
		{
			VkDestroyShaderEXTNative(device, shader, pAllocator);
		}

		[NativeName(NativeNameType.Func, "vkDestroyShaderEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkDestroyShaderEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "VkShaderEXT")] VkShaderEXT shader, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				VkDestroyShaderEXTNative(device, shader, (VkAllocationCallbacks*)ppAllocator);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetShaderBinaryDataEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkGetShaderBinaryDataEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkGetShaderBinaryDataEXTNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "VkShaderEXT")] VkShaderEXT shader, [NativeName(NativeNameType.Param, "pDataSize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* pDataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData);

		[NativeName(NativeNameType.Func, "vkGetShaderBinaryDataEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetShaderBinaryDataEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "VkShaderEXT")] VkShaderEXT shader, [NativeName(NativeNameType.Param, "pDataSize")] [NativeName(NativeNameType.Type, "size_t*")] ulong* pDataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData)
		{
			VkResult ret = VkGetShaderBinaryDataEXTNative(device, shader, pDataSize, pData);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkGetShaderBinaryDataEXT")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetShaderBinaryDataEXT([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "shader")] [NativeName(NativeNameType.Type, "VkShaderEXT")] VkShaderEXT shader, [NativeName(NativeNameType.Param, "pDataSize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint pDataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData)
		{
			fixed (nuint* ppDataSize = &pDataSize)
			{
				VkResult ret = VkGetShaderBinaryDataEXTNative(device, shader, (ulong*)ppDataSize, pData);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBindShadersEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdBindShadersEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdBindShadersEXTNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "stageCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint stageCount, [NativeName(NativeNameType.Param, "pStages")] [NativeName(NativeNameType.Type, "const VkShaderStageFlagBits*")] VkShaderStageFlagBits* pStages, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "const VkShaderEXT*")] VkShaderEXT* pShaders);

		[NativeName(NativeNameType.Func, "vkCmdBindShadersEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBindShadersEXT([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "stageCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint stageCount, [NativeName(NativeNameType.Param, "pStages")] [NativeName(NativeNameType.Type, "const VkShaderStageFlagBits*")] VkShaderStageFlagBits* pStages, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "const VkShaderEXT*")] VkShaderEXT* pShaders)
		{
			VkCmdBindShadersEXTNative(commandBuffer, stageCount, pStages, pShaders);
		}

		[NativeName(NativeNameType.Func, "vkCmdBindShadersEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBindShadersEXT([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "stageCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint stageCount, [NativeName(NativeNameType.Param, "pStages")] [NativeName(NativeNameType.Type, "const VkShaderStageFlagBits*")] ref VkShaderStageFlagBits pStages, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "const VkShaderEXT*")] VkShaderEXT* pShaders)
		{
			fixed (VkShaderStageFlagBits* ppStages = &pStages)
			{
				VkCmdBindShadersEXTNative(commandBuffer, stageCount, (VkShaderStageFlagBits*)ppStages, pShaders);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBindShadersEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBindShadersEXT([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "stageCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint stageCount, [NativeName(NativeNameType.Param, "pStages")] [NativeName(NativeNameType.Type, "const VkShaderStageFlagBits*")] VkShaderStageFlagBits* pStages, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "const VkShaderEXT*")] ref VkShaderEXT pShaders)
		{
			fixed (VkShaderEXT* ppShaders = &pShaders)
			{
				VkCmdBindShadersEXTNative(commandBuffer, stageCount, pStages, (VkShaderEXT*)ppShaders);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBindShadersEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBindShadersEXT([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "stageCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint stageCount, [NativeName(NativeNameType.Param, "pStages")] [NativeName(NativeNameType.Type, "const VkShaderStageFlagBits*")] ref VkShaderStageFlagBits pStages, [NativeName(NativeNameType.Param, "pShaders")] [NativeName(NativeNameType.Type, "const VkShaderEXT*")] ref VkShaderEXT pShaders)
		{
			fixed (VkShaderStageFlagBits* ppStages = &pStages)
			{
				fixed (VkShaderEXT* ppShaders = &pShaders)
				{
					VkCmdBindShadersEXTNative(commandBuffer, stageCount, (VkShaderStageFlagBits*)ppStages, (VkShaderEXT*)ppShaders);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetFramebufferTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkGetFramebufferTilePropertiesQCOM")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkGetFramebufferTilePropertiesQCOMNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "framebuffer")] [NativeName(NativeNameType.Type, "VkFramebuffer")] VkFramebuffer framebuffer, [NativeName(NativeNameType.Param, "pPropertiesCount")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pPropertiesCount, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] VkTilePropertiesQCOM* pProperties);

		[NativeName(NativeNameType.Func, "vkGetFramebufferTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetFramebufferTilePropertiesQCOM([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "framebuffer")] [NativeName(NativeNameType.Type, "VkFramebuffer")] VkFramebuffer framebuffer, [NativeName(NativeNameType.Param, "pPropertiesCount")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pPropertiesCount, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] VkTilePropertiesQCOM* pProperties)
		{
			VkResult ret = VkGetFramebufferTilePropertiesQCOMNative(device, framebuffer, pPropertiesCount, pProperties);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkGetFramebufferTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetFramebufferTilePropertiesQCOM([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "framebuffer")] [NativeName(NativeNameType.Type, "VkFramebuffer")] VkFramebuffer framebuffer, [NativeName(NativeNameType.Param, "pPropertiesCount")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pPropertiesCount, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] VkTilePropertiesQCOM* pProperties)
		{
			fixed (uint* ppPropertiesCount = &pPropertiesCount)
			{
				VkResult ret = VkGetFramebufferTilePropertiesQCOMNative(device, framebuffer, (uint*)ppPropertiesCount, pProperties);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkGetFramebufferTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetFramebufferTilePropertiesQCOM([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "framebuffer")] [NativeName(NativeNameType.Type, "VkFramebuffer")] VkFramebuffer framebuffer, [NativeName(NativeNameType.Param, "pPropertiesCount")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pPropertiesCount, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] ref VkTilePropertiesQCOM pProperties)
		{
			fixed (VkTilePropertiesQCOM* ppProperties = &pProperties)
			{
				VkResult ret = VkGetFramebufferTilePropertiesQCOMNative(device, framebuffer, pPropertiesCount, (VkTilePropertiesQCOM*)ppProperties);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkGetFramebufferTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetFramebufferTilePropertiesQCOM([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "framebuffer")] [NativeName(NativeNameType.Type, "VkFramebuffer")] VkFramebuffer framebuffer, [NativeName(NativeNameType.Param, "pPropertiesCount")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pPropertiesCount, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] ref VkTilePropertiesQCOM pProperties)
		{
			fixed (uint* ppPropertiesCount = &pPropertiesCount)
			{
				fixed (VkTilePropertiesQCOM* ppProperties = &pProperties)
				{
					VkResult ret = VkGetFramebufferTilePropertiesQCOMNative(device, framebuffer, (uint*)ppPropertiesCount, (VkTilePropertiesQCOM*)ppProperties);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetDynamicRenderingTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkGetDynamicRenderingTilePropertiesQCOM")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkGetDynamicRenderingTilePropertiesQCOMNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pRenderingInfo")] [NativeName(NativeNameType.Type, "const VkRenderingInfo*")] VkRenderingInfo* pRenderingInfo, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] VkTilePropertiesQCOM* pProperties);

		[NativeName(NativeNameType.Func, "vkGetDynamicRenderingTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetDynamicRenderingTilePropertiesQCOM([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pRenderingInfo")] [NativeName(NativeNameType.Type, "const VkRenderingInfo*")] VkRenderingInfo* pRenderingInfo, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] VkTilePropertiesQCOM* pProperties)
		{
			VkResult ret = VkGetDynamicRenderingTilePropertiesQCOMNative(device, pRenderingInfo, pProperties);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkGetDynamicRenderingTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetDynamicRenderingTilePropertiesQCOM([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pRenderingInfo")] [NativeName(NativeNameType.Type, "const VkRenderingInfo*")] ref VkRenderingInfo pRenderingInfo, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] VkTilePropertiesQCOM* pProperties)
		{
			fixed (VkRenderingInfo* ppRenderingInfo = &pRenderingInfo)
			{
				VkResult ret = VkGetDynamicRenderingTilePropertiesQCOMNative(device, (VkRenderingInfo*)ppRenderingInfo, pProperties);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkGetDynamicRenderingTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetDynamicRenderingTilePropertiesQCOM([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pRenderingInfo")] [NativeName(NativeNameType.Type, "const VkRenderingInfo*")] VkRenderingInfo* pRenderingInfo, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] ref VkTilePropertiesQCOM pProperties)
		{
			fixed (VkTilePropertiesQCOM* ppProperties = &pProperties)
			{
				VkResult ret = VkGetDynamicRenderingTilePropertiesQCOMNative(device, pRenderingInfo, (VkTilePropertiesQCOM*)ppProperties);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkGetDynamicRenderingTilePropertiesQCOM")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetDynamicRenderingTilePropertiesQCOM([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pRenderingInfo")] [NativeName(NativeNameType.Type, "const VkRenderingInfo*")] ref VkRenderingInfo pRenderingInfo, [NativeName(NativeNameType.Param, "pProperties")] [NativeName(NativeNameType.Type, "VkTilePropertiesQCOM*")] ref VkTilePropertiesQCOM pProperties)
		{
			fixed (VkRenderingInfo* ppRenderingInfo = &pRenderingInfo)
			{
				fixed (VkTilePropertiesQCOM* ppProperties = &pProperties)
				{
					VkResult ret = VkGetDynamicRenderingTilePropertiesQCOMNative(device, (VkRenderingInfo*)ppRenderingInfo, (VkTilePropertiesQCOM*)ppProperties);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdSetAttachmentFeedbackLoopEnableEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdSetAttachmentFeedbackLoopEnableEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdSetAttachmentFeedbackLoopEnableEXTNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "aspectMask")] [NativeName(NativeNameType.Type, "VkImageAspectFlags")] uint aspectMask);

		[NativeName(NativeNameType.Func, "vkCmdSetAttachmentFeedbackLoopEnableEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdSetAttachmentFeedbackLoopEnableEXT([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "aspectMask")] [NativeName(NativeNameType.Type, "VkImageAspectFlags")] uint aspectMask)
		{
			VkCmdSetAttachmentFeedbackLoopEnableEXTNative(commandBuffer, aspectMask);
		}

		[NativeName(NativeNameType.Func, "vkCreateAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkCreateAccelerationStructureKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkCreateAccelerationStructureKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureCreateInfoKHR*")] VkAccelerationStructureCreateInfoKHR* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pAccelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructure);

		[NativeName(NativeNameType.Func, "vkCreateAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureCreateInfoKHR*")] VkAccelerationStructureCreateInfoKHR* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pAccelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructure)
		{
			VkResult ret = VkCreateAccelerationStructureKHRNative(device, pCreateInfo, pAllocator, pAccelerationStructure);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCreateAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureCreateInfoKHR*")] ref VkAccelerationStructureCreateInfoKHR pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pAccelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructure)
		{
			fixed (VkAccelerationStructureCreateInfoKHR* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VkCreateAccelerationStructureKHRNative(device, (VkAccelerationStructureCreateInfoKHR*)ppCreateInfo, pAllocator, pAccelerationStructure);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureCreateInfoKHR*")] VkAccelerationStructureCreateInfoKHR* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pAccelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructure)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				VkResult ret = VkCreateAccelerationStructureKHRNative(device, pCreateInfo, (VkAllocationCallbacks*)ppAllocator, pAccelerationStructure);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureCreateInfoKHR*")] ref VkAccelerationStructureCreateInfoKHR pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pAccelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructure)
		{
			fixed (VkAccelerationStructureCreateInfoKHR* ppCreateInfo = &pCreateInfo)
			{
				fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
				{
					VkResult ret = VkCreateAccelerationStructureKHRNative(device, (VkAccelerationStructureCreateInfoKHR*)ppCreateInfo, (VkAllocationCallbacks*)ppAllocator, pAccelerationStructure);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureCreateInfoKHR*")] VkAccelerationStructureCreateInfoKHR* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pAccelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR*")] ref VkAccelerationStructureKHR pAccelerationStructure)
		{
			fixed (VkAccelerationStructureKHR* ppAccelerationStructure = &pAccelerationStructure)
			{
				VkResult ret = VkCreateAccelerationStructureKHRNative(device, pCreateInfo, pAllocator, (VkAccelerationStructureKHR*)ppAccelerationStructure);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureCreateInfoKHR*")] ref VkAccelerationStructureCreateInfoKHR pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pAccelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR*")] ref VkAccelerationStructureKHR pAccelerationStructure)
		{
			fixed (VkAccelerationStructureCreateInfoKHR* ppCreateInfo = &pCreateInfo)
			{
				fixed (VkAccelerationStructureKHR* ppAccelerationStructure = &pAccelerationStructure)
				{
					VkResult ret = VkCreateAccelerationStructureKHRNative(device, (VkAccelerationStructureCreateInfoKHR*)ppCreateInfo, pAllocator, (VkAccelerationStructureKHR*)ppAccelerationStructure);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureCreateInfoKHR*")] VkAccelerationStructureCreateInfoKHR* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pAccelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR*")] ref VkAccelerationStructureKHR pAccelerationStructure)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				fixed (VkAccelerationStructureKHR* ppAccelerationStructure = &pAccelerationStructure)
				{
					VkResult ret = VkCreateAccelerationStructureKHRNative(device, pCreateInfo, (VkAllocationCallbacks*)ppAllocator, (VkAccelerationStructureKHR*)ppAccelerationStructure);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureCreateInfoKHR*")] ref VkAccelerationStructureCreateInfoKHR pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pAccelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR*")] ref VkAccelerationStructureKHR pAccelerationStructure)
		{
			fixed (VkAccelerationStructureCreateInfoKHR* ppCreateInfo = &pCreateInfo)
			{
				fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
				{
					fixed (VkAccelerationStructureKHR* ppAccelerationStructure = &pAccelerationStructure)
					{
						VkResult ret = VkCreateAccelerationStructureKHRNative(device, (VkAccelerationStructureCreateInfoKHR*)ppCreateInfo, (VkAllocationCallbacks*)ppAllocator, (VkAccelerationStructureKHR*)ppAccelerationStructure);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkDestroyAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkDestroyAccelerationStructureKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkDestroyAccelerationStructureKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR")] VkAccelerationStructureKHR accelerationStructure, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator);

		[NativeName(NativeNameType.Func, "vkDestroyAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkDestroyAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR")] VkAccelerationStructureKHR accelerationStructure, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator)
		{
			VkDestroyAccelerationStructureKHRNative(device, accelerationStructure, pAllocator);
		}

		[NativeName(NativeNameType.Func, "vkDestroyAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkDestroyAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructure")] [NativeName(NativeNameType.Type, "VkAccelerationStructureKHR")] VkAccelerationStructureKHR accelerationStructure, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				VkDestroyAccelerationStructureKHRNative(device, accelerationStructure, (VkAllocationCallbacks*)ppAllocator);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdBuildAccelerationStructuresKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdBuildAccelerationStructuresKHRNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos);

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos)
		{
			VkCmdBuildAccelerationStructuresKHRNative(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				VkCmdBuildAccelerationStructuresKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, ppBuildRangeInfos);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] ref VkAccelerationStructureBuildRangeInfoKHR* ppBuildRangeInfos)
		{
			fixed (VkAccelerationStructureBuildRangeInfoKHR** pppBuildRangeInfos = &ppBuildRangeInfos)
			{
				VkCmdBuildAccelerationStructuresKHRNative(commandBuffer, infoCount, pInfos, (VkAccelerationStructureBuildRangeInfoKHR**)pppBuildRangeInfos);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] ref VkAccelerationStructureBuildRangeInfoKHR* ppBuildRangeInfos)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				fixed (VkAccelerationStructureBuildRangeInfoKHR** pppBuildRangeInfos = &ppBuildRangeInfos)
				{
					VkCmdBuildAccelerationStructuresKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, (VkAccelerationStructureBuildRangeInfoKHR**)pppBuildRangeInfos);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdBuildAccelerationStructuresIndirectKHRNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ulong* pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] uint** ppMaxPrimitiveCounts);

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ulong* pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] uint** ppMaxPrimitiveCounts)
		{
			VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ulong* pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] uint** ppMaxPrimitiveCounts)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ref ulong pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] uint** ppMaxPrimitiveCounts)
		{
			fixed (ulong* ppIndirectDeviceAddresses = &pIndirectDeviceAddresses)
			{
				VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, pInfos, (ulong*)ppIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ref ulong pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] uint** ppMaxPrimitiveCounts)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				fixed (ulong* ppIndirectDeviceAddresses = &pIndirectDeviceAddresses)
				{
					VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, (ulong*)ppIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ulong* pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] uint** ppMaxPrimitiveCounts)
		{
			fixed (uint* ppIndirectStrides = &pIndirectStrides)
			{
				VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, (uint*)ppIndirectStrides, ppMaxPrimitiveCounts);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ulong* pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] uint** ppMaxPrimitiveCounts)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				fixed (uint* ppIndirectStrides = &pIndirectStrides)
				{
					VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, pIndirectDeviceAddresses, (uint*)ppIndirectStrides, ppMaxPrimitiveCounts);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ref ulong pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] uint** ppMaxPrimitiveCounts)
		{
			fixed (ulong* ppIndirectDeviceAddresses = &pIndirectDeviceAddresses)
			{
				fixed (uint* ppIndirectStrides = &pIndirectStrides)
				{
					VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, pInfos, (ulong*)ppIndirectDeviceAddresses, (uint*)ppIndirectStrides, ppMaxPrimitiveCounts);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ref ulong pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] uint** ppMaxPrimitiveCounts)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				fixed (ulong* ppIndirectDeviceAddresses = &pIndirectDeviceAddresses)
				{
					fixed (uint* ppIndirectStrides = &pIndirectStrides)
					{
						VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, (ulong*)ppIndirectDeviceAddresses, (uint*)ppIndirectStrides, ppMaxPrimitiveCounts);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ulong* pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] ref uint* ppMaxPrimitiveCounts)
		{
			fixed (uint** pppMaxPrimitiveCounts = &ppMaxPrimitiveCounts)
			{
				VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, (uint**)pppMaxPrimitiveCounts);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ulong* pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] ref uint* ppMaxPrimitiveCounts)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				fixed (uint** pppMaxPrimitiveCounts = &ppMaxPrimitiveCounts)
				{
					VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, pIndirectDeviceAddresses, pIndirectStrides, (uint**)pppMaxPrimitiveCounts);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ref ulong pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] ref uint* ppMaxPrimitiveCounts)
		{
			fixed (ulong* ppIndirectDeviceAddresses = &pIndirectDeviceAddresses)
			{
				fixed (uint** pppMaxPrimitiveCounts = &ppMaxPrimitiveCounts)
				{
					VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, pInfos, (ulong*)ppIndirectDeviceAddresses, pIndirectStrides, (uint**)pppMaxPrimitiveCounts);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ref ulong pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] ref uint* ppMaxPrimitiveCounts)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				fixed (ulong* ppIndirectDeviceAddresses = &pIndirectDeviceAddresses)
				{
					fixed (uint** pppMaxPrimitiveCounts = &ppMaxPrimitiveCounts)
					{
						VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, (ulong*)ppIndirectDeviceAddresses, pIndirectStrides, (uint**)pppMaxPrimitiveCounts);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ulong* pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] ref uint* ppMaxPrimitiveCounts)
		{
			fixed (uint* ppIndirectStrides = &pIndirectStrides)
			{
				fixed (uint** pppMaxPrimitiveCounts = &ppMaxPrimitiveCounts)
				{
					VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, (uint*)ppIndirectStrides, (uint**)pppMaxPrimitiveCounts);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ulong* pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] ref uint* ppMaxPrimitiveCounts)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				fixed (uint* ppIndirectStrides = &pIndirectStrides)
				{
					fixed (uint** pppMaxPrimitiveCounts = &ppMaxPrimitiveCounts)
					{
						VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, pIndirectDeviceAddresses, (uint*)ppIndirectStrides, (uint**)pppMaxPrimitiveCounts);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ref ulong pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] ref uint* ppMaxPrimitiveCounts)
		{
			fixed (ulong* ppIndirectDeviceAddresses = &pIndirectDeviceAddresses)
			{
				fixed (uint* ppIndirectStrides = &pIndirectStrides)
				{
					fixed (uint** pppMaxPrimitiveCounts = &ppMaxPrimitiveCounts)
					{
						VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, pInfos, (ulong*)ppIndirectDeviceAddresses, (uint*)ppIndirectStrides, (uint**)pppMaxPrimitiveCounts);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdBuildAccelerationStructuresIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdBuildAccelerationStructuresIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "pIndirectDeviceAddresses")] [NativeName(NativeNameType.Type, "const VkDeviceAddress*")] ref ulong pIndirectDeviceAddresses, [NativeName(NativeNameType.Param, "pIndirectStrides")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pIndirectStrides, [NativeName(NativeNameType.Param, "ppMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const const uint32_t**")] ref uint* ppMaxPrimitiveCounts)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				fixed (ulong* ppIndirectDeviceAddresses = &pIndirectDeviceAddresses)
				{
					fixed (uint* ppIndirectStrides = &pIndirectStrides)
					{
						fixed (uint** pppMaxPrimitiveCounts = &ppMaxPrimitiveCounts)
						{
							VkCmdBuildAccelerationStructuresIndirectKHRNative(commandBuffer, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, (ulong*)ppIndirectDeviceAddresses, (uint*)ppIndirectStrides, (uint**)pppMaxPrimitiveCounts);
						}
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkBuildAccelerationStructuresKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkBuildAccelerationStructuresKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos);

		[NativeName(NativeNameType.Func, "vkBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkBuildAccelerationStructuresKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos)
		{
			VkResult ret = VkBuildAccelerationStructuresKHRNative(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkBuildAccelerationStructuresKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				VkResult ret = VkBuildAccelerationStructuresKHRNative(device, deferredOperation, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, ppBuildRangeInfos);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkBuildAccelerationStructuresKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] ref VkAccelerationStructureBuildRangeInfoKHR* ppBuildRangeInfos)
		{
			fixed (VkAccelerationStructureBuildRangeInfoKHR** pppBuildRangeInfos = &ppBuildRangeInfos)
			{
				VkResult ret = VkBuildAccelerationStructuresKHRNative(device, deferredOperation, infoCount, pInfos, (VkAccelerationStructureBuildRangeInfoKHR**)pppBuildRangeInfos);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkBuildAccelerationStructuresKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkBuildAccelerationStructuresKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "infoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint infoCount, [NativeName(NativeNameType.Param, "pInfos")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pInfos, [NativeName(NativeNameType.Param, "ppBuildRangeInfos")] [NativeName(NativeNameType.Type, "const const VkAccelerationStructureBuildRangeInfoKHR**")] ref VkAccelerationStructureBuildRangeInfoKHR* ppBuildRangeInfos)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppInfos = &pInfos)
			{
				fixed (VkAccelerationStructureBuildRangeInfoKHR** pppBuildRangeInfos = &ppBuildRangeInfos)
				{
					VkResult ret = VkBuildAccelerationStructuresKHRNative(device, deferredOperation, infoCount, (VkAccelerationStructureBuildGeometryInfoKHR*)ppInfos, (VkAccelerationStructureBuildRangeInfoKHR**)pppBuildRangeInfos);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCopyAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkCopyAccelerationStructureKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkCopyAccelerationStructureKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureInfoKHR*")] VkCopyAccelerationStructureInfoKHR* pInfo);

		[NativeName(NativeNameType.Func, "vkCopyAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCopyAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureInfoKHR*")] VkCopyAccelerationStructureInfoKHR* pInfo)
		{
			VkResult ret = VkCopyAccelerationStructureKHRNative(device, deferredOperation, pInfo);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCopyAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCopyAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureInfoKHR*")] ref VkCopyAccelerationStructureInfoKHR pInfo)
		{
			fixed (VkCopyAccelerationStructureInfoKHR* ppInfo = &pInfo)
			{
				VkResult ret = VkCopyAccelerationStructureKHRNative(device, deferredOperation, (VkCopyAccelerationStructureInfoKHR*)ppInfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCopyAccelerationStructureToMemoryKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkCopyAccelerationStructureToMemoryKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkCopyAccelerationStructureToMemoryKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureToMemoryInfoKHR*")] VkCopyAccelerationStructureToMemoryInfoKHR* pInfo);

		[NativeName(NativeNameType.Func, "vkCopyAccelerationStructureToMemoryKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCopyAccelerationStructureToMemoryKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureToMemoryInfoKHR*")] VkCopyAccelerationStructureToMemoryInfoKHR* pInfo)
		{
			VkResult ret = VkCopyAccelerationStructureToMemoryKHRNative(device, deferredOperation, pInfo);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCopyAccelerationStructureToMemoryKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCopyAccelerationStructureToMemoryKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureToMemoryInfoKHR*")] ref VkCopyAccelerationStructureToMemoryInfoKHR pInfo)
		{
			fixed (VkCopyAccelerationStructureToMemoryInfoKHR* ppInfo = &pInfo)
			{
				VkResult ret = VkCopyAccelerationStructureToMemoryKHRNative(device, deferredOperation, (VkCopyAccelerationStructureToMemoryInfoKHR*)ppInfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCopyMemoryToAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkCopyMemoryToAccelerationStructureKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkCopyMemoryToAccelerationStructureKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyMemoryToAccelerationStructureInfoKHR*")] VkCopyMemoryToAccelerationStructureInfoKHR* pInfo);

		[NativeName(NativeNameType.Func, "vkCopyMemoryToAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCopyMemoryToAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyMemoryToAccelerationStructureInfoKHR*")] VkCopyMemoryToAccelerationStructureInfoKHR* pInfo)
		{
			VkResult ret = VkCopyMemoryToAccelerationStructureKHRNative(device, deferredOperation, pInfo);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCopyMemoryToAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCopyMemoryToAccelerationStructureKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyMemoryToAccelerationStructureInfoKHR*")] ref VkCopyMemoryToAccelerationStructureInfoKHR pInfo)
		{
			fixed (VkCopyMemoryToAccelerationStructureInfoKHR* ppInfo = &pInfo)
			{
				VkResult ret = VkCopyMemoryToAccelerationStructureKHRNative(device, deferredOperation, (VkCopyMemoryToAccelerationStructureInfoKHR*)ppInfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkWriteAccelerationStructuresPropertiesKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkWriteAccelerationStructuresPropertiesKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] ulong dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "size_t")] ulong stride);

		[NativeName(NativeNameType.Func, "vkWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] ulong dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "size_t")] ulong stride)
		{
			VkResult ret = VkWriteAccelerationStructuresPropertiesKHRNative(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] ref VkAccelerationStructureKHR pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] ulong dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "size_t")] ulong stride)
		{
			fixed (VkAccelerationStructureKHR* ppAccelerationStructures = &pAccelerationStructures)
			{
				VkResult ret = VkWriteAccelerationStructuresPropertiesKHRNative(device, accelerationStructureCount, (VkAccelerationStructureKHR*)ppAccelerationStructures, queryType, dataSize, pData, stride);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] nuint dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "size_t")] ulong stride)
		{
			VkResult ret = VkWriteAccelerationStructuresPropertiesKHRNative(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] ref VkAccelerationStructureKHR pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] nuint dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "size_t")] ulong stride)
		{
			fixed (VkAccelerationStructureKHR* ppAccelerationStructures = &pAccelerationStructures)
			{
				VkResult ret = VkWriteAccelerationStructuresPropertiesKHRNative(device, accelerationStructureCount, (VkAccelerationStructureKHR*)ppAccelerationStructures, queryType, dataSize, pData, stride);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] ulong dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "size_t")] nuint stride)
		{
			VkResult ret = VkWriteAccelerationStructuresPropertiesKHRNative(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] ref VkAccelerationStructureKHR pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] ulong dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "size_t")] nuint stride)
		{
			fixed (VkAccelerationStructureKHR* ppAccelerationStructures = &pAccelerationStructures)
			{
				VkResult ret = VkWriteAccelerationStructuresPropertiesKHRNative(device, accelerationStructureCount, (VkAccelerationStructureKHR*)ppAccelerationStructures, queryType, dataSize, pData, stride);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] nuint dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "size_t")] nuint stride)
		{
			VkResult ret = VkWriteAccelerationStructuresPropertiesKHRNative(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] ref VkAccelerationStructureKHR pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] nuint dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "size_t")] nuint stride)
		{
			fixed (VkAccelerationStructureKHR* ppAccelerationStructures = &pAccelerationStructures)
			{
				VkResult ret = VkWriteAccelerationStructuresPropertiesKHRNative(device, accelerationStructureCount, (VkAccelerationStructureKHR*)ppAccelerationStructures, queryType, dataSize, pData, stride);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdCopyAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdCopyAccelerationStructureKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdCopyAccelerationStructureKHRNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureInfoKHR*")] VkCopyAccelerationStructureInfoKHR* pInfo);

		[NativeName(NativeNameType.Func, "vkCmdCopyAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdCopyAccelerationStructureKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureInfoKHR*")] VkCopyAccelerationStructureInfoKHR* pInfo)
		{
			VkCmdCopyAccelerationStructureKHRNative(commandBuffer, pInfo);
		}

		[NativeName(NativeNameType.Func, "vkCmdCopyAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdCopyAccelerationStructureKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureInfoKHR*")] ref VkCopyAccelerationStructureInfoKHR pInfo)
		{
			fixed (VkCopyAccelerationStructureInfoKHR* ppInfo = &pInfo)
			{
				VkCmdCopyAccelerationStructureKHRNative(commandBuffer, (VkCopyAccelerationStructureInfoKHR*)ppInfo);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdCopyAccelerationStructureToMemoryKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdCopyAccelerationStructureToMemoryKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdCopyAccelerationStructureToMemoryKHRNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureToMemoryInfoKHR*")] VkCopyAccelerationStructureToMemoryInfoKHR* pInfo);

		[NativeName(NativeNameType.Func, "vkCmdCopyAccelerationStructureToMemoryKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdCopyAccelerationStructureToMemoryKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureToMemoryInfoKHR*")] VkCopyAccelerationStructureToMemoryInfoKHR* pInfo)
		{
			VkCmdCopyAccelerationStructureToMemoryKHRNative(commandBuffer, pInfo);
		}

		[NativeName(NativeNameType.Func, "vkCmdCopyAccelerationStructureToMemoryKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdCopyAccelerationStructureToMemoryKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyAccelerationStructureToMemoryInfoKHR*")] ref VkCopyAccelerationStructureToMemoryInfoKHR pInfo)
		{
			fixed (VkCopyAccelerationStructureToMemoryInfoKHR* ppInfo = &pInfo)
			{
				VkCmdCopyAccelerationStructureToMemoryKHRNative(commandBuffer, (VkCopyAccelerationStructureToMemoryInfoKHR*)ppInfo);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdCopyMemoryToAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdCopyMemoryToAccelerationStructureKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdCopyMemoryToAccelerationStructureKHRNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyMemoryToAccelerationStructureInfoKHR*")] VkCopyMemoryToAccelerationStructureInfoKHR* pInfo);

		[NativeName(NativeNameType.Func, "vkCmdCopyMemoryToAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdCopyMemoryToAccelerationStructureKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyMemoryToAccelerationStructureInfoKHR*")] VkCopyMemoryToAccelerationStructureInfoKHR* pInfo)
		{
			VkCmdCopyMemoryToAccelerationStructureKHRNative(commandBuffer, pInfo);
		}

		[NativeName(NativeNameType.Func, "vkCmdCopyMemoryToAccelerationStructureKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdCopyMemoryToAccelerationStructureKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkCopyMemoryToAccelerationStructureInfoKHR*")] ref VkCopyMemoryToAccelerationStructureInfoKHR pInfo)
		{
			fixed (VkCopyMemoryToAccelerationStructureInfoKHR* ppInfo = &pInfo)
			{
				VkCmdCopyMemoryToAccelerationStructureKHRNative(commandBuffer, (VkCopyMemoryToAccelerationStructureInfoKHR*)ppInfo);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureDeviceAddressKHR")]
		[return: NativeName(NativeNameType.Type, "VkDeviceAddress")]
		[LibraryImport(LibName, EntryPoint = "vkGetAccelerationStructureDeviceAddressKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong VkGetAccelerationStructureDeviceAddressKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureDeviceAddressInfoKHR*")] VkAccelerationStructureDeviceAddressInfoKHR* pInfo);

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureDeviceAddressKHR")]
		[return: NativeName(NativeNameType.Type, "VkDeviceAddress")]
		public static ulong VkGetAccelerationStructureDeviceAddressKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureDeviceAddressInfoKHR*")] VkAccelerationStructureDeviceAddressInfoKHR* pInfo)
		{
			ulong ret = VkGetAccelerationStructureDeviceAddressKHRNative(device, pInfo);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureDeviceAddressKHR")]
		[return: NativeName(NativeNameType.Type, "VkDeviceAddress")]
		public static ulong VkGetAccelerationStructureDeviceAddressKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureDeviceAddressInfoKHR*")] ref VkAccelerationStructureDeviceAddressInfoKHR pInfo)
		{
			fixed (VkAccelerationStructureDeviceAddressInfoKHR* ppInfo = &pInfo)
			{
				ulong ret = VkGetAccelerationStructureDeviceAddressKHRNative(device, (VkAccelerationStructureDeviceAddressInfoKHR*)ppInfo);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdWriteAccelerationStructuresPropertiesKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdWriteAccelerationStructuresPropertiesKHRNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "queryPool")] [NativeName(NativeNameType.Type, "VkQueryPool")] VkQueryPool queryPool, [NativeName(NativeNameType.Param, "firstQuery")] [NativeName(NativeNameType.Type, "uint32_t")] uint firstQuery);

		[NativeName(NativeNameType.Func, "vkCmdWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] VkAccelerationStructureKHR* pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "queryPool")] [NativeName(NativeNameType.Type, "VkQueryPool")] VkQueryPool queryPool, [NativeName(NativeNameType.Param, "firstQuery")] [NativeName(NativeNameType.Type, "uint32_t")] uint firstQuery)
		{
			VkCmdWriteAccelerationStructuresPropertiesKHRNative(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
		}

		[NativeName(NativeNameType.Func, "vkCmdWriteAccelerationStructuresPropertiesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdWriteAccelerationStructuresPropertiesKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "accelerationStructureCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint accelerationStructureCount, [NativeName(NativeNameType.Param, "pAccelerationStructures")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureKHR*")] ref VkAccelerationStructureKHR pAccelerationStructures, [NativeName(NativeNameType.Param, "queryType")] [NativeName(NativeNameType.Type, "VkQueryType")] VkQueryType queryType, [NativeName(NativeNameType.Param, "queryPool")] [NativeName(NativeNameType.Type, "VkQueryPool")] VkQueryPool queryPool, [NativeName(NativeNameType.Param, "firstQuery")] [NativeName(NativeNameType.Type, "uint32_t")] uint firstQuery)
		{
			fixed (VkAccelerationStructureKHR* ppAccelerationStructures = &pAccelerationStructures)
			{
				VkCmdWriteAccelerationStructuresPropertiesKHRNative(commandBuffer, accelerationStructureCount, (VkAccelerationStructureKHR*)ppAccelerationStructures, queryType, queryPool, firstQuery);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetDeviceAccelerationStructureCompatibilityKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkGetDeviceAccelerationStructureCompatibilityKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkGetDeviceAccelerationStructureCompatibilityKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pVersionInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureVersionInfoKHR*")] VkAccelerationStructureVersionInfoKHR* pVersionInfo, [NativeName(NativeNameType.Param, "pCompatibility")] [NativeName(NativeNameType.Type, "VkAccelerationStructureCompatibilityKHR*")] VkAccelerationStructureCompatibilityKHR* pCompatibility);

		[NativeName(NativeNameType.Func, "vkGetDeviceAccelerationStructureCompatibilityKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetDeviceAccelerationStructureCompatibilityKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pVersionInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureVersionInfoKHR*")] VkAccelerationStructureVersionInfoKHR* pVersionInfo, [NativeName(NativeNameType.Param, "pCompatibility")] [NativeName(NativeNameType.Type, "VkAccelerationStructureCompatibilityKHR*")] VkAccelerationStructureCompatibilityKHR* pCompatibility)
		{
			VkGetDeviceAccelerationStructureCompatibilityKHRNative(device, pVersionInfo, pCompatibility);
		}

		[NativeName(NativeNameType.Func, "vkGetDeviceAccelerationStructureCompatibilityKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetDeviceAccelerationStructureCompatibilityKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pVersionInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureVersionInfoKHR*")] ref VkAccelerationStructureVersionInfoKHR pVersionInfo, [NativeName(NativeNameType.Param, "pCompatibility")] [NativeName(NativeNameType.Type, "VkAccelerationStructureCompatibilityKHR*")] VkAccelerationStructureCompatibilityKHR* pCompatibility)
		{
			fixed (VkAccelerationStructureVersionInfoKHR* ppVersionInfo = &pVersionInfo)
			{
				VkGetDeviceAccelerationStructureCompatibilityKHRNative(device, (VkAccelerationStructureVersionInfoKHR*)ppVersionInfo, pCompatibility);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetDeviceAccelerationStructureCompatibilityKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetDeviceAccelerationStructureCompatibilityKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pVersionInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureVersionInfoKHR*")] VkAccelerationStructureVersionInfoKHR* pVersionInfo, [NativeName(NativeNameType.Param, "pCompatibility")] [NativeName(NativeNameType.Type, "VkAccelerationStructureCompatibilityKHR*")] ref VkAccelerationStructureCompatibilityKHR pCompatibility)
		{
			fixed (VkAccelerationStructureCompatibilityKHR* ppCompatibility = &pCompatibility)
			{
				VkGetDeviceAccelerationStructureCompatibilityKHRNative(device, pVersionInfo, (VkAccelerationStructureCompatibilityKHR*)ppCompatibility);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetDeviceAccelerationStructureCompatibilityKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetDeviceAccelerationStructureCompatibilityKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pVersionInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureVersionInfoKHR*")] ref VkAccelerationStructureVersionInfoKHR pVersionInfo, [NativeName(NativeNameType.Param, "pCompatibility")] [NativeName(NativeNameType.Type, "VkAccelerationStructureCompatibilityKHR*")] ref VkAccelerationStructureCompatibilityKHR pCompatibility)
		{
			fixed (VkAccelerationStructureVersionInfoKHR* ppVersionInfo = &pVersionInfo)
			{
				fixed (VkAccelerationStructureCompatibilityKHR* ppCompatibility = &pCompatibility)
				{
					VkGetDeviceAccelerationStructureCompatibilityKHRNative(device, (VkAccelerationStructureVersionInfoKHR*)ppVersionInfo, (VkAccelerationStructureCompatibilityKHR*)ppCompatibility);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureBuildSizesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkGetAccelerationStructureBuildSizesKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkGetAccelerationStructureBuildSizesKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "buildType")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildTypeKHR")] VkAccelerationStructureBuildTypeKHR buildType, [NativeName(NativeNameType.Param, "pBuildInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, [NativeName(NativeNameType.Param, "pMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pMaxPrimitiveCounts, [NativeName(NativeNameType.Param, "pSizeInfo")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildSizesInfoKHR*")] VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo);

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureBuildSizesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetAccelerationStructureBuildSizesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "buildType")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildTypeKHR")] VkAccelerationStructureBuildTypeKHR buildType, [NativeName(NativeNameType.Param, "pBuildInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, [NativeName(NativeNameType.Param, "pMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pMaxPrimitiveCounts, [NativeName(NativeNameType.Param, "pSizeInfo")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildSizesInfoKHR*")] VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo)
		{
			VkGetAccelerationStructureBuildSizesKHRNative(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureBuildSizesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetAccelerationStructureBuildSizesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "buildType")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildTypeKHR")] VkAccelerationStructureBuildTypeKHR buildType, [NativeName(NativeNameType.Param, "pBuildInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pBuildInfo, [NativeName(NativeNameType.Param, "pMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pMaxPrimitiveCounts, [NativeName(NativeNameType.Param, "pSizeInfo")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildSizesInfoKHR*")] VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppBuildInfo = &pBuildInfo)
			{
				VkGetAccelerationStructureBuildSizesKHRNative(device, buildType, (VkAccelerationStructureBuildGeometryInfoKHR*)ppBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureBuildSizesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetAccelerationStructureBuildSizesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "buildType")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildTypeKHR")] VkAccelerationStructureBuildTypeKHR buildType, [NativeName(NativeNameType.Param, "pBuildInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, [NativeName(NativeNameType.Param, "pMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pMaxPrimitiveCounts, [NativeName(NativeNameType.Param, "pSizeInfo")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildSizesInfoKHR*")] VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo)
		{
			fixed (uint* ppMaxPrimitiveCounts = &pMaxPrimitiveCounts)
			{
				VkGetAccelerationStructureBuildSizesKHRNative(device, buildType, pBuildInfo, (uint*)ppMaxPrimitiveCounts, pSizeInfo);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureBuildSizesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetAccelerationStructureBuildSizesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "buildType")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildTypeKHR")] VkAccelerationStructureBuildTypeKHR buildType, [NativeName(NativeNameType.Param, "pBuildInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pBuildInfo, [NativeName(NativeNameType.Param, "pMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pMaxPrimitiveCounts, [NativeName(NativeNameType.Param, "pSizeInfo")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildSizesInfoKHR*")] VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppBuildInfo = &pBuildInfo)
			{
				fixed (uint* ppMaxPrimitiveCounts = &pMaxPrimitiveCounts)
				{
					VkGetAccelerationStructureBuildSizesKHRNative(device, buildType, (VkAccelerationStructureBuildGeometryInfoKHR*)ppBuildInfo, (uint*)ppMaxPrimitiveCounts, pSizeInfo);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureBuildSizesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetAccelerationStructureBuildSizesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "buildType")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildTypeKHR")] VkAccelerationStructureBuildTypeKHR buildType, [NativeName(NativeNameType.Param, "pBuildInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, [NativeName(NativeNameType.Param, "pMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pMaxPrimitiveCounts, [NativeName(NativeNameType.Param, "pSizeInfo")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildSizesInfoKHR*")] ref VkAccelerationStructureBuildSizesInfoKHR pSizeInfo)
		{
			fixed (VkAccelerationStructureBuildSizesInfoKHR* ppSizeInfo = &pSizeInfo)
			{
				VkGetAccelerationStructureBuildSizesKHRNative(device, buildType, pBuildInfo, pMaxPrimitiveCounts, (VkAccelerationStructureBuildSizesInfoKHR*)ppSizeInfo);
			}
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureBuildSizesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetAccelerationStructureBuildSizesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "buildType")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildTypeKHR")] VkAccelerationStructureBuildTypeKHR buildType, [NativeName(NativeNameType.Param, "pBuildInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pBuildInfo, [NativeName(NativeNameType.Param, "pMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const uint32_t*")] uint* pMaxPrimitiveCounts, [NativeName(NativeNameType.Param, "pSizeInfo")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildSizesInfoKHR*")] ref VkAccelerationStructureBuildSizesInfoKHR pSizeInfo)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppBuildInfo = &pBuildInfo)
			{
				fixed (VkAccelerationStructureBuildSizesInfoKHR* ppSizeInfo = &pSizeInfo)
				{
					VkGetAccelerationStructureBuildSizesKHRNative(device, buildType, (VkAccelerationStructureBuildGeometryInfoKHR*)ppBuildInfo, pMaxPrimitiveCounts, (VkAccelerationStructureBuildSizesInfoKHR*)ppSizeInfo);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureBuildSizesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetAccelerationStructureBuildSizesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "buildType")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildTypeKHR")] VkAccelerationStructureBuildTypeKHR buildType, [NativeName(NativeNameType.Param, "pBuildInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, [NativeName(NativeNameType.Param, "pMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pMaxPrimitiveCounts, [NativeName(NativeNameType.Param, "pSizeInfo")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildSizesInfoKHR*")] ref VkAccelerationStructureBuildSizesInfoKHR pSizeInfo)
		{
			fixed (uint* ppMaxPrimitiveCounts = &pMaxPrimitiveCounts)
			{
				fixed (VkAccelerationStructureBuildSizesInfoKHR* ppSizeInfo = &pSizeInfo)
				{
					VkGetAccelerationStructureBuildSizesKHRNative(device, buildType, pBuildInfo, (uint*)ppMaxPrimitiveCounts, (VkAccelerationStructureBuildSizesInfoKHR*)ppSizeInfo);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetAccelerationStructureBuildSizesKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkGetAccelerationStructureBuildSizesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "buildType")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildTypeKHR")] VkAccelerationStructureBuildTypeKHR buildType, [NativeName(NativeNameType.Param, "pBuildInfo")] [NativeName(NativeNameType.Type, "const VkAccelerationStructureBuildGeometryInfoKHR*")] ref VkAccelerationStructureBuildGeometryInfoKHR pBuildInfo, [NativeName(NativeNameType.Param, "pMaxPrimitiveCounts")] [NativeName(NativeNameType.Type, "const uint32_t*")] ref uint pMaxPrimitiveCounts, [NativeName(NativeNameType.Param, "pSizeInfo")] [NativeName(NativeNameType.Type, "VkAccelerationStructureBuildSizesInfoKHR*")] ref VkAccelerationStructureBuildSizesInfoKHR pSizeInfo)
		{
			fixed (VkAccelerationStructureBuildGeometryInfoKHR* ppBuildInfo = &pBuildInfo)
			{
				fixed (uint* ppMaxPrimitiveCounts = &pMaxPrimitiveCounts)
				{
					fixed (VkAccelerationStructureBuildSizesInfoKHR* ppSizeInfo = &pSizeInfo)
					{
						VkGetAccelerationStructureBuildSizesKHRNative(device, buildType, (VkAccelerationStructureBuildGeometryInfoKHR*)ppBuildInfo, (uint*)ppMaxPrimitiveCounts, (VkAccelerationStructureBuildSizesInfoKHR*)ppSizeInfo);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdTraceRaysKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdTraceRaysKHRNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth);

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			VkCmdTraceRaysKHRNative(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				VkCmdTraceRaysKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
			{
				VkCmdTraceRaysKHRNative(commandBuffer, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
				{
					VkCmdTraceRaysKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
			{
				VkCmdTraceRaysKHRNative(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
				{
					VkCmdTraceRaysKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
				{
					VkCmdTraceRaysKHRNative(commandBuffer, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
					{
						VkCmdTraceRaysKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
			{
				VkCmdTraceRaysKHRNative(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, width, height, depth);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
				{
					VkCmdTraceRaysKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, width, height, depth);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
				{
					VkCmdTraceRaysKHRNative(commandBuffer, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, width, height, depth);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
					{
						VkCmdTraceRaysKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, width, height, depth);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
				{
					VkCmdTraceRaysKHRNative(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, width, height, depth);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
					{
						VkCmdTraceRaysKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, width, height, depth);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
					{
						VkCmdTraceRaysKHRNative(commandBuffer, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, width, height, depth);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "uint32_t")] uint width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "uint32_t")] uint height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "uint32_t")] uint depth)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
					{
						fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
						{
							VkCmdTraceRaysKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, width, height, depth);
						}
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateRayTracingPipelinesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkCreateRayTracingPipelinesKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkCreateRayTracingPipelinesKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pipelineCache")] [NativeName(NativeNameType.Type, "VkPipelineCache")] VkPipelineCache pipelineCache, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkRayTracingPipelineCreateInfoKHR*")] VkRayTracingPipelineCreateInfoKHR* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pPipelines")] [NativeName(NativeNameType.Type, "VkPipeline*")] VkPipeline* pPipelines);

		[NativeName(NativeNameType.Func, "vkCreateRayTracingPipelinesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateRayTracingPipelinesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pipelineCache")] [NativeName(NativeNameType.Type, "VkPipelineCache")] VkPipelineCache pipelineCache, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkRayTracingPipelineCreateInfoKHR*")] VkRayTracingPipelineCreateInfoKHR* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pPipelines")] [NativeName(NativeNameType.Type, "VkPipeline*")] VkPipeline* pPipelines)
		{
			VkResult ret = VkCreateRayTracingPipelinesKHRNative(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCreateRayTracingPipelinesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateRayTracingPipelinesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pipelineCache")] [NativeName(NativeNameType.Type, "VkPipelineCache")] VkPipelineCache pipelineCache, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkRayTracingPipelineCreateInfoKHR*")] ref VkRayTracingPipelineCreateInfoKHR pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pPipelines")] [NativeName(NativeNameType.Type, "VkPipeline*")] VkPipeline* pPipelines)
		{
			fixed (VkRayTracingPipelineCreateInfoKHR* ppCreateInfos = &pCreateInfos)
			{
				VkResult ret = VkCreateRayTracingPipelinesKHRNative(device, deferredOperation, pipelineCache, createInfoCount, (VkRayTracingPipelineCreateInfoKHR*)ppCreateInfos, pAllocator, pPipelines);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateRayTracingPipelinesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateRayTracingPipelinesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pipelineCache")] [NativeName(NativeNameType.Type, "VkPipelineCache")] VkPipelineCache pipelineCache, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkRayTracingPipelineCreateInfoKHR*")] VkRayTracingPipelineCreateInfoKHR* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pPipelines")] [NativeName(NativeNameType.Type, "VkPipeline*")] VkPipeline* pPipelines)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				VkResult ret = VkCreateRayTracingPipelinesKHRNative(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, (VkAllocationCallbacks*)ppAllocator, pPipelines);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateRayTracingPipelinesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateRayTracingPipelinesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pipelineCache")] [NativeName(NativeNameType.Type, "VkPipelineCache")] VkPipelineCache pipelineCache, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkRayTracingPipelineCreateInfoKHR*")] ref VkRayTracingPipelineCreateInfoKHR pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pPipelines")] [NativeName(NativeNameType.Type, "VkPipeline*")] VkPipeline* pPipelines)
		{
			fixed (VkRayTracingPipelineCreateInfoKHR* ppCreateInfos = &pCreateInfos)
			{
				fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
				{
					VkResult ret = VkCreateRayTracingPipelinesKHRNative(device, deferredOperation, pipelineCache, createInfoCount, (VkRayTracingPipelineCreateInfoKHR*)ppCreateInfos, (VkAllocationCallbacks*)ppAllocator, pPipelines);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateRayTracingPipelinesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateRayTracingPipelinesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pipelineCache")] [NativeName(NativeNameType.Type, "VkPipelineCache")] VkPipelineCache pipelineCache, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkRayTracingPipelineCreateInfoKHR*")] VkRayTracingPipelineCreateInfoKHR* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pPipelines")] [NativeName(NativeNameType.Type, "VkPipeline*")] ref VkPipeline pPipelines)
		{
			fixed (VkPipeline* ppPipelines = &pPipelines)
			{
				VkResult ret = VkCreateRayTracingPipelinesKHRNative(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, (VkPipeline*)ppPipelines);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateRayTracingPipelinesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateRayTracingPipelinesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pipelineCache")] [NativeName(NativeNameType.Type, "VkPipelineCache")] VkPipelineCache pipelineCache, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkRayTracingPipelineCreateInfoKHR*")] ref VkRayTracingPipelineCreateInfoKHR pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] VkAllocationCallbacks* pAllocator, [NativeName(NativeNameType.Param, "pPipelines")] [NativeName(NativeNameType.Type, "VkPipeline*")] ref VkPipeline pPipelines)
		{
			fixed (VkRayTracingPipelineCreateInfoKHR* ppCreateInfos = &pCreateInfos)
			{
				fixed (VkPipeline* ppPipelines = &pPipelines)
				{
					VkResult ret = VkCreateRayTracingPipelinesKHRNative(device, deferredOperation, pipelineCache, createInfoCount, (VkRayTracingPipelineCreateInfoKHR*)ppCreateInfos, pAllocator, (VkPipeline*)ppPipelines);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateRayTracingPipelinesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateRayTracingPipelinesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pipelineCache")] [NativeName(NativeNameType.Type, "VkPipelineCache")] VkPipelineCache pipelineCache, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkRayTracingPipelineCreateInfoKHR*")] VkRayTracingPipelineCreateInfoKHR* pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pPipelines")] [NativeName(NativeNameType.Type, "VkPipeline*")] ref VkPipeline pPipelines)
		{
			fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
			{
				fixed (VkPipeline* ppPipelines = &pPipelines)
				{
					VkResult ret = VkCreateRayTracingPipelinesKHRNative(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, (VkAllocationCallbacks*)ppAllocator, (VkPipeline*)ppPipelines);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCreateRayTracingPipelinesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkCreateRayTracingPipelinesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "deferredOperation")] [NativeName(NativeNameType.Type, "VkDeferredOperationKHR")] VkDeferredOperationKHR deferredOperation, [NativeName(NativeNameType.Param, "pipelineCache")] [NativeName(NativeNameType.Type, "VkPipelineCache")] VkPipelineCache pipelineCache, [NativeName(NativeNameType.Param, "createInfoCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint createInfoCount, [NativeName(NativeNameType.Param, "pCreateInfos")] [NativeName(NativeNameType.Type, "const VkRayTracingPipelineCreateInfoKHR*")] ref VkRayTracingPipelineCreateInfoKHR pCreateInfos, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "const VkAllocationCallbacks*")] ref VkAllocationCallbacks pAllocator, [NativeName(NativeNameType.Param, "pPipelines")] [NativeName(NativeNameType.Type, "VkPipeline*")] ref VkPipeline pPipelines)
		{
			fixed (VkRayTracingPipelineCreateInfoKHR* ppCreateInfos = &pCreateInfos)
			{
				fixed (VkAllocationCallbacks* ppAllocator = &pAllocator)
				{
					fixed (VkPipeline* ppPipelines = &pPipelines)
					{
						VkResult ret = VkCreateRayTracingPipelinesKHRNative(device, deferredOperation, pipelineCache, createInfoCount, (VkRayTracingPipelineCreateInfoKHR*)ppCreateInfos, (VkAllocationCallbacks*)ppAllocator, (VkPipeline*)ppPipelines);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VkGetRayTracingCaptureReplayShaderGroupHandlesKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "VkPipeline")] VkPipeline pipeline, [NativeName(NativeNameType.Param, "firstGroup")] [NativeName(NativeNameType.Type, "uint32_t")] uint firstGroup, [NativeName(NativeNameType.Param, "groupCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint groupCount, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] ulong dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData);

		[NativeName(NativeNameType.Func, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetRayTracingCaptureReplayShaderGroupHandlesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "VkPipeline")] VkPipeline pipeline, [NativeName(NativeNameType.Param, "firstGroup")] [NativeName(NativeNameType.Type, "uint32_t")] uint firstGroup, [NativeName(NativeNameType.Param, "groupCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint groupCount, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] ulong dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData)
		{
			VkResult ret = VkGetRayTracingCaptureReplayShaderGroupHandlesKHRNative(device, pipeline, firstGroup, groupCount, dataSize, pData);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VkGetRayTracingCaptureReplayShaderGroupHandlesKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "VkPipeline")] VkPipeline pipeline, [NativeName(NativeNameType.Param, "firstGroup")] [NativeName(NativeNameType.Type, "uint32_t")] uint firstGroup, [NativeName(NativeNameType.Param, "groupCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint groupCount, [NativeName(NativeNameType.Param, "dataSize")] [NativeName(NativeNameType.Type, "size_t")] nuint dataSize, [NativeName(NativeNameType.Param, "pData")] [NativeName(NativeNameType.Type, "void*")] void* pData)
		{
			VkResult ret = VkGetRayTracingCaptureReplayShaderGroupHandlesKHRNative(device, pipeline, firstGroup, groupCount, dataSize, pData);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdTraceRaysIndirectKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdTraceRaysIndirectKHRNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress);

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			VkCmdTraceRaysIndirectKHRNative(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				VkCmdTraceRaysIndirectKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
			{
				VkCmdTraceRaysIndirectKHRNative(commandBuffer, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
				{
					VkCmdTraceRaysIndirectKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
			{
				VkCmdTraceRaysIndirectKHRNative(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
				{
					VkCmdTraceRaysIndirectKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
				{
					VkCmdTraceRaysIndirectKHRNative(commandBuffer, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
					{
						VkCmdTraceRaysIndirectKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
			{
				VkCmdTraceRaysIndirectKHRNative(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, indirectDeviceAddress);
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
				{
					VkCmdTraceRaysIndirectKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, indirectDeviceAddress);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
				{
					VkCmdTraceRaysIndirectKHRNative(commandBuffer, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, indirectDeviceAddress);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
					{
						VkCmdTraceRaysIndirectKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, pHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, indirectDeviceAddress);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
				{
					VkCmdTraceRaysIndirectKHRNative(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, indirectDeviceAddress);
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
					{
						VkCmdTraceRaysIndirectKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, pMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, indirectDeviceAddress);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
					{
						VkCmdTraceRaysIndirectKHRNative(commandBuffer, pRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, indirectDeviceAddress);
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkCmdTraceRaysIndirectKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdTraceRaysIndirectKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pRaygenShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable, [NativeName(NativeNameType.Param, "pMissShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pMissShaderBindingTable, [NativeName(NativeNameType.Param, "pHitShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pHitShaderBindingTable, [NativeName(NativeNameType.Param, "pCallableShaderBindingTable")] [NativeName(NativeNameType.Type, "const VkStridedDeviceAddressRegionKHR*")] ref VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable, [NativeName(NativeNameType.Param, "indirectDeviceAddress")] [NativeName(NativeNameType.Type, "VkDeviceAddress")] ulong indirectDeviceAddress)
		{
			fixed (VkStridedDeviceAddressRegionKHR* ppRaygenShaderBindingTable = &pRaygenShaderBindingTable)
			{
				fixed (VkStridedDeviceAddressRegionKHR* ppMissShaderBindingTable = &pMissShaderBindingTable)
				{
					fixed (VkStridedDeviceAddressRegionKHR* ppHitShaderBindingTable = &pHitShaderBindingTable)
					{
						fixed (VkStridedDeviceAddressRegionKHR* ppCallableShaderBindingTable = &pCallableShaderBindingTable)
						{
							VkCmdTraceRaysIndirectKHRNative(commandBuffer, (VkStridedDeviceAddressRegionKHR*)ppRaygenShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppMissShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppHitShaderBindingTable, (VkStridedDeviceAddressRegionKHR*)ppCallableShaderBindingTable, indirectDeviceAddress);
						}
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "vkGetRayTracingShaderGroupStackSizeKHR")]
		[return: NativeName(NativeNameType.Type, "VkDeviceSize")]
		[LibraryImport(LibName, EntryPoint = "vkGetRayTracingShaderGroupStackSizeKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong VkGetRayTracingShaderGroupStackSizeKHRNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "VkPipeline")] VkPipeline pipeline, [NativeName(NativeNameType.Param, "group")] [NativeName(NativeNameType.Type, "uint32_t")] uint group, [NativeName(NativeNameType.Param, "groupShader")] [NativeName(NativeNameType.Type, "VkShaderGroupShaderKHR")] VkShaderGroupShaderKHR groupShader);

		[NativeName(NativeNameType.Func, "vkGetRayTracingShaderGroupStackSizeKHR")]
		[return: NativeName(NativeNameType.Type, "VkDeviceSize")]
		public static ulong VkGetRayTracingShaderGroupStackSizeKHR([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "VkDevice")] VkDevice device, [NativeName(NativeNameType.Param, "pipeline")] [NativeName(NativeNameType.Type, "VkPipeline")] VkPipeline pipeline, [NativeName(NativeNameType.Param, "group")] [NativeName(NativeNameType.Type, "uint32_t")] uint group, [NativeName(NativeNameType.Param, "groupShader")] [NativeName(NativeNameType.Type, "VkShaderGroupShaderKHR")] VkShaderGroupShaderKHR groupShader)
		{
			ulong ret = VkGetRayTracingShaderGroupStackSizeKHRNative(device, pipeline, group, groupShader);
			return ret;
		}

		[NativeName(NativeNameType.Func, "vkCmdSetRayTracingPipelineStackSizeKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdSetRayTracingPipelineStackSizeKHR")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdSetRayTracingPipelineStackSizeKHRNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pipelineStackSize")] [NativeName(NativeNameType.Type, "uint32_t")] uint pipelineStackSize);

		[NativeName(NativeNameType.Func, "vkCmdSetRayTracingPipelineStackSizeKHR")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdSetRayTracingPipelineStackSizeKHR([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "pipelineStackSize")] [NativeName(NativeNameType.Type, "uint32_t")] uint pipelineStackSize)
		{
			VkCmdSetRayTracingPipelineStackSizeKHRNative(commandBuffer, pipelineStackSize);
		}

		[NativeName(NativeNameType.Func, "vkCmdDrawMeshTasksEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdDrawMeshTasksEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdDrawMeshTasksEXTNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "groupCountX")] [NativeName(NativeNameType.Type, "uint32_t")] uint groupCountX, [NativeName(NativeNameType.Param, "groupCountY")] [NativeName(NativeNameType.Type, "uint32_t")] uint groupCountY, [NativeName(NativeNameType.Param, "groupCountZ")] [NativeName(NativeNameType.Type, "uint32_t")] uint groupCountZ);

		[NativeName(NativeNameType.Func, "vkCmdDrawMeshTasksEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdDrawMeshTasksEXT([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "groupCountX")] [NativeName(NativeNameType.Type, "uint32_t")] uint groupCountX, [NativeName(NativeNameType.Param, "groupCountY")] [NativeName(NativeNameType.Type, "uint32_t")] uint groupCountY, [NativeName(NativeNameType.Param, "groupCountZ")] [NativeName(NativeNameType.Type, "uint32_t")] uint groupCountZ)
		{
			VkCmdDrawMeshTasksEXTNative(commandBuffer, groupCountX, groupCountY, groupCountZ);
		}

		[NativeName(NativeNameType.Func, "vkCmdDrawMeshTasksIndirectEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdDrawMeshTasksIndirectEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdDrawMeshTasksIndirectEXTNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "drawCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint drawCount, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "uint32_t")] uint stride);

		[NativeName(NativeNameType.Func, "vkCmdDrawMeshTasksIndirectEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdDrawMeshTasksIndirectEXT([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "drawCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint drawCount, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "uint32_t")] uint stride)
		{
			VkCmdDrawMeshTasksIndirectEXTNative(commandBuffer, buffer, offset, drawCount, stride);
		}

		[NativeName(NativeNameType.Func, "vkCmdDrawMeshTasksIndirectCountEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vkCmdDrawMeshTasksIndirectCountEXT")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VkCmdDrawMeshTasksIndirectCountEXTNative([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "countBuffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer countBuffer, [NativeName(NativeNameType.Param, "countBufferOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong countBufferOffset, [NativeName(NativeNameType.Param, "maxDrawCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint maxDrawCount, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "uint32_t")] uint stride);

		[NativeName(NativeNameType.Func, "vkCmdDrawMeshTasksIndirectCountEXT")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VkCmdDrawMeshTasksIndirectCountEXT([NativeName(NativeNameType.Param, "commandBuffer")] [NativeName(NativeNameType.Type, "VkCommandBuffer")] VkCommandBuffer commandBuffer, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong offset, [NativeName(NativeNameType.Param, "countBuffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer countBuffer, [NativeName(NativeNameType.Param, "countBufferOffset")] [NativeName(NativeNameType.Type, "VkDeviceSize")] ulong countBufferOffset, [NativeName(NativeNameType.Param, "maxDrawCount")] [NativeName(NativeNameType.Type, "uint32_t")] uint maxDrawCount, [NativeName(NativeNameType.Param, "stride")] [NativeName(NativeNameType.Type, "uint32_t")] uint stride)
		{
			VkCmdDrawMeshTasksIndirectCountEXTNative(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
		}

		[NativeName(NativeNameType.Func, "daxa_memory_block_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_MemoryBlockInfo*")]
		[LibraryImport(LibName, EntryPoint = "daxa_memory_block_info")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaMemoryBlockInfo* DaxaMemoryBlockInfoNative([NativeName(NativeNameType.Param, "memory_block")] [NativeName(NativeNameType.Type, "daxa_MemoryBlock")] DaxaMemoryBlock memoryBlock);

		[NativeName(NativeNameType.Func, "daxa_memory_block_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_MemoryBlockInfo*")]
		public static DaxaMemoryBlockInfo* DaxaMemoryBlockInfo([NativeName(NativeNameType.Param, "memory_block")] [NativeName(NativeNameType.Type, "daxa_MemoryBlock")] DaxaMemoryBlock memoryBlock)
		{
			DaxaMemoryBlockInfo* ret = DaxaMemoryBlockInfoNative(memoryBlock);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_memory_block_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_memory_block_inc_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaMemoryBlockIncRefcntNative([NativeName(NativeNameType.Param, "memory_block")] [NativeName(NativeNameType.Type, "daxa_MemoryBlock")] DaxaMemoryBlock memoryBlock);

		[NativeName(NativeNameType.Func, "daxa_memory_block_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaMemoryBlockIncRefcnt([NativeName(NativeNameType.Param, "memory_block")] [NativeName(NativeNameType.Type, "daxa_MemoryBlock")] DaxaMemoryBlock memoryBlock)
		{
			ulong ret = DaxaMemoryBlockIncRefcntNative(memoryBlock);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_memory_block_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_memory_block_dec_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaMemoryBlockDecRefcntNative([NativeName(NativeNameType.Param, "memory_block")] [NativeName(NativeNameType.Type, "daxa_MemoryBlock")] DaxaMemoryBlock memoryBlock);

		[NativeName(NativeNameType.Func, "daxa_memory_block_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaMemoryBlockDecRefcnt([NativeName(NativeNameType.Param, "memory_block")] [NativeName(NativeNameType.Type, "daxa_MemoryBlock")] DaxaMemoryBlock memoryBlock)
		{
			ulong ret = DaxaMemoryBlockDecRefcntNative(memoryBlock);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_TimelineQueryPoolInfo*")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_query_pool_info")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaTimelineQueryPoolInfo* DaxaTimelineQueryPoolInfoNative([NativeName(NativeNameType.Param, "timeline_query_pool")] [NativeName(NativeNameType.Type, "daxa_TimelineQueryPool")] DaxaTimelineQueryPool timelineQueryPool);

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_info")]
		[return: NativeName(NativeNameType.Type, "const daxa_TimelineQueryPoolInfo*")]
		public static DaxaTimelineQueryPoolInfo* DaxaTimelineQueryPoolInfo([NativeName(NativeNameType.Param, "timeline_query_pool")] [NativeName(NativeNameType.Type, "daxa_TimelineQueryPool")] DaxaTimelineQueryPool timelineQueryPool)
		{
			DaxaTimelineQueryPoolInfo* ret = DaxaTimelineQueryPoolInfoNative(timelineQueryPool);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_query_results")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_query_pool_query_results")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial DaxaResult DaxaTimelineQueryPoolQueryResultsNative([NativeName(NativeNameType.Param, "timeline_query_pool")] [NativeName(NativeNameType.Type, "daxa_TimelineQueryPool")] DaxaTimelineQueryPool timelineQueryPool, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "uint32_t")] uint start, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "uint32_t")] uint count, [NativeName(NativeNameType.Param, "out_results")] [NativeName(NativeNameType.Type, "uint64_t*")] ulong* outResults);

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_query_results")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaTimelineQueryPoolQueryResults([NativeName(NativeNameType.Param, "timeline_query_pool")] [NativeName(NativeNameType.Type, "daxa_TimelineQueryPool")] DaxaTimelineQueryPool timelineQueryPool, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "uint32_t")] uint start, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "uint32_t")] uint count, [NativeName(NativeNameType.Param, "out_results")] [NativeName(NativeNameType.Type, "uint64_t*")] ulong* outResults)
		{
			DaxaResult ret = DaxaTimelineQueryPoolQueryResultsNative(timelineQueryPool, start, count, outResults);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_query_results")]
		[return: NativeName(NativeNameType.Type, "daxa_Result")]
		public static DaxaResult DaxaTimelineQueryPoolQueryResults([NativeName(NativeNameType.Param, "timeline_query_pool")] [NativeName(NativeNameType.Type, "daxa_TimelineQueryPool")] DaxaTimelineQueryPool timelineQueryPool, [NativeName(NativeNameType.Param, "start")] [NativeName(NativeNameType.Type, "uint32_t")] uint start, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "uint32_t")] uint count, [NativeName(NativeNameType.Param, "out_results")] [NativeName(NativeNameType.Type, "uint64_t*")] ref ulong outResults)
		{
			fixed (ulong* poutResults = &outResults)
			{
				DaxaResult ret = DaxaTimelineQueryPoolQueryResultsNative(timelineQueryPool, start, count, (ulong*)poutResults);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_query_pool_inc_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaTimelineQueryPoolIncRefcntNative([NativeName(NativeNameType.Param, "timeline_query_pool")] [NativeName(NativeNameType.Type, "daxa_TimelineQueryPool")] DaxaTimelineQueryPool timelineQueryPool);

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_inc_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaTimelineQueryPoolIncRefcnt([NativeName(NativeNameType.Param, "timeline_query_pool")] [NativeName(NativeNameType.Type, "daxa_TimelineQueryPool")] DaxaTimelineQueryPool timelineQueryPool)
		{
			ulong ret = DaxaTimelineQueryPoolIncRefcntNative(timelineQueryPool);
			return ret;
		}

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[LibraryImport(LibName, EntryPoint = "daxa_timeline_query_pool_dec_refcnt")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial ulong DaxaTimelineQueryPoolDecRefcntNative([NativeName(NativeNameType.Param, "timeline_query_pool")] [NativeName(NativeNameType.Type, "daxa_TimelineQueryPool")] DaxaTimelineQueryPool timelineQueryPool);

		[NativeName(NativeNameType.Func, "daxa_timeline_query_pool_dec_refcnt")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong DaxaTimelineQueryPoolDecRefcnt([NativeName(NativeNameType.Param, "timeline_query_pool")] [NativeName(NativeNameType.Type, "daxa_TimelineQueryPool")] DaxaTimelineQueryPool timelineQueryPool)
		{
			ulong ret = DaxaTimelineQueryPoolDecRefcntNative(timelineQueryPool);
			return ret;
		}

		/// <summary>
		/// Creates #VmaAllocator object.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreateAllocator")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreateAllocator")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreateAllocatorNative([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocatorCreateInfo*")] VmaAllocatorCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "VmaAllocator*")] VmaAllocator* pAllocator);

		/// <summary>/// Creates #VmaAllocator object.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAllocator")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAllocator([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocatorCreateInfo*")] VmaAllocatorCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "VmaAllocator*")] VmaAllocator* pAllocator)
		{
			VkResult ret = VmaCreateAllocatorNative(pCreateInfo, pAllocator);
			return ret;
		}

		/// <summary>/// Creates #VmaAllocator object.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAllocator")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAllocator([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocatorCreateInfo*")] ref VmaAllocatorCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "VmaAllocator*")] VmaAllocator* pAllocator)
		{
			fixed (VmaAllocatorCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VmaCreateAllocatorNative((VmaAllocatorCreateInfo*)ppCreateInfo, pAllocator);
				return ret;
			}
		}

		/// <summary>/// Creates #VmaAllocator object.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAllocator")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAllocator([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocatorCreateInfo*")] VmaAllocatorCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "VmaAllocator*")] ref VmaAllocator pAllocator)
		{
			fixed (VmaAllocator* ppAllocator = &pAllocator)
			{
				VkResult ret = VmaCreateAllocatorNative(pCreateInfo, (VmaAllocator*)ppAllocator);
				return ret;
			}
		}

		/// <summary>/// Creates #VmaAllocator object.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreateAllocator")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreateAllocator([NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocatorCreateInfo*")] ref VmaAllocatorCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocator")] [NativeName(NativeNameType.Type, "VmaAllocator*")] ref VmaAllocator pAllocator)
		{
			fixed (VmaAllocatorCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocator* ppAllocator = &pAllocator)
				{
					VkResult ret = VmaCreateAllocatorNative((VmaAllocatorCreateInfo*)ppCreateInfo, (VmaAllocator*)ppAllocator);
					return ret;
				}
			}
		}

		/// <summary>
		/// Destroys allocator object.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaDestroyAllocator")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaDestroyAllocator")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaDestroyAllocatorNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator);

		/// <summary>/// Destroys allocator object.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyAllocator")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaDestroyAllocator([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator)
		{
			VmaDestroyAllocatorNative(allocator);
		}

		/// <summary>
		/// <br/>
		/// It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to<br/>
		/// `VkPhysicalDevice`, `VkDevice` etc. every time using this function.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetAllocatorInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetAllocatorInfo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetAllocatorInfoNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pAllocatorInfo")] [NativeName(NativeNameType.Type, "VmaAllocatorInfo*")] VmaAllocatorInfo* pAllocatorInfo);

		/// <summary>/// <br/>/// It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to<br/>/// `VkPhysicalDevice`, `VkDevice` etc. every time using this function.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocatorInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetAllocatorInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pAllocatorInfo")] [NativeName(NativeNameType.Type, "VmaAllocatorInfo*")] VmaAllocatorInfo* pAllocatorInfo)
		{
			VmaGetAllocatorInfoNative(allocator, pAllocatorInfo);
		}

		/// <summary>/// <br/>/// It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to<br/>/// `VkPhysicalDevice`, `VkDevice` etc. every time using this function.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocatorInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetAllocatorInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pAllocatorInfo")] [NativeName(NativeNameType.Type, "VmaAllocatorInfo*")] ref VmaAllocatorInfo pAllocatorInfo)
		{
			fixed (VmaAllocatorInfo* ppAllocatorInfo = &pAllocatorInfo)
			{
				VmaGetAllocatorInfoNative(allocator, (VmaAllocatorInfo*)ppAllocatorInfo);
			}
		}

		/// <summary>
		/// PhysicalDeviceProperties are fetched from physicalDevice by the allocator.<br/>
		/// You can access it here, without fetching it again on your own.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetPhysicalDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetPhysicalDeviceProperties")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetPhysicalDevicePropertiesNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceProperties**")] VkPhysicalDeviceProperties** ppPhysicalDeviceProperties);

		/// <summary>/// PhysicalDeviceProperties are fetched from physicalDevice by the allocator.<br/>/// You can access it here, without fetching it again on your own.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPhysicalDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetPhysicalDeviceProperties([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceProperties**")] VkPhysicalDeviceProperties** ppPhysicalDeviceProperties)
		{
			VmaGetPhysicalDevicePropertiesNative(allocator, ppPhysicalDeviceProperties);
		}

		/// <summary>/// PhysicalDeviceProperties are fetched from physicalDevice by the allocator.<br/>/// You can access it here, without fetching it again on your own.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPhysicalDeviceProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetPhysicalDeviceProperties([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceProperties**")] ref VkPhysicalDeviceProperties* ppPhysicalDeviceProperties)
		{
			fixed (VkPhysicalDeviceProperties** pppPhysicalDeviceProperties = &ppPhysicalDeviceProperties)
			{
				VmaGetPhysicalDevicePropertiesNative(allocator, (VkPhysicalDeviceProperties**)pppPhysicalDeviceProperties);
			}
		}

		/// <summary>
		/// PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.<br/>
		/// You can access it here, without fetching it again on your own.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetMemoryProperties")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetMemoryPropertiesNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceMemoryProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceMemoryProperties**")] VkPhysicalDeviceMemoryProperties** ppPhysicalDeviceMemoryProperties);

		/// <summary>/// PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.<br/>/// You can access it here, without fetching it again on your own.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetMemoryProperties([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceMemoryProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceMemoryProperties**")] VkPhysicalDeviceMemoryProperties** ppPhysicalDeviceMemoryProperties)
		{
			VmaGetMemoryPropertiesNative(allocator, ppPhysicalDeviceMemoryProperties);
		}

		/// <summary>/// PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator.<br/>/// You can access it here, without fetching it again on your own.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetMemoryProperties([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "ppPhysicalDeviceMemoryProperties")] [NativeName(NativeNameType.Type, "const VkPhysicalDeviceMemoryProperties**")] ref VkPhysicalDeviceMemoryProperties* ppPhysicalDeviceMemoryProperties)
		{
			fixed (VkPhysicalDeviceMemoryProperties** pppPhysicalDeviceMemoryProperties = &ppPhysicalDeviceMemoryProperties)
			{
				VmaGetMemoryPropertiesNative(allocator, (VkPhysicalDeviceMemoryProperties**)pppPhysicalDeviceMemoryProperties);
			}
		}

		/// <summary>
		/// This is just a convenience function. Same information can be obtained using<br/>
		/// vmaGetMemoryProperties().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetMemoryTypeProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetMemoryTypeProperties")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetMemoryTypePropertiesNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeIndex, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] uint* pFlags);

		/// <summary>/// This is just a convenience function. Same information can be obtained using<br/>/// vmaGetMemoryProperties().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryTypeProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetMemoryTypeProperties([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeIndex, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] uint* pFlags)
		{
			VmaGetMemoryTypePropertiesNative(allocator, memoryTypeIndex, pFlags);
		}

		/// <summary>/// This is just a convenience function. Same information can be obtained using<br/>/// vmaGetMemoryProperties().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetMemoryTypeProperties")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetMemoryTypeProperties([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeIndex, [NativeName(NativeNameType.Param, "pFlags")] [NativeName(NativeNameType.Type, "VkMemoryPropertyFlags*")] ref uint pFlags)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				VmaGetMemoryTypePropertiesNative(allocator, memoryTypeIndex, (uint*)ppFlags);
			}
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaSetCurrentFrameIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaSetCurrentFrameIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaSetCurrentFrameIndexNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "frameIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint frameIndex);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetCurrentFrameIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaSetCurrentFrameIndex([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "frameIndex")] [NativeName(NativeNameType.Type, "uint32_t")] uint frameIndex)
		{
			VmaSetCurrentFrameIndexNative(allocator, frameIndex);
		}

		/// <summary>
		/// <br/>
		/// This function is called "calculate" not "get" because it has to traverse all<br/>
		/// internal data structures, so it may be quite slow. Use it for debugging purposes.<br/>
		/// For faster but more brief statistics suitable to be called every frame or every allocation,<br/>
		/// use vmaGetHeapBudgets().<br/>
		/// Note that when using allocator from multiple threads, returned information may immediately<br/>
		/// become outdated.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCalculateStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaCalculateStatistics")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaCalculateStatisticsNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaTotalStatistics*")] VmaTotalStatistics* pStats);

		/// <summary>/// <br/>/// This function is called "calculate" not "get" because it has to traverse all<br/>/// internal data structures, so it may be quite slow. Use it for debugging purposes.<br/>/// For faster but more brief statistics suitable to be called every frame or every allocation,<br/>/// use vmaGetHeapBudgets().<br/>/// Note that when using allocator from multiple threads, returned information may immediately<br/>/// become outdated.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaCalculateStatistics([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaTotalStatistics*")] VmaTotalStatistics* pStats)
		{
			VmaCalculateStatisticsNative(allocator, pStats);
		}

		/// <summary>/// <br/>/// This function is called "calculate" not "get" because it has to traverse all<br/>/// internal data structures, so it may be quite slow. Use it for debugging purposes.<br/>/// For faster but more brief statistics suitable to be called every frame or every allocation,<br/>/// use vmaGetHeapBudgets().<br/>/// Note that when using allocator from multiple threads, returned information may immediately<br/>/// become outdated.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculateStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaCalculateStatistics([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pStats")] [NativeName(NativeNameType.Type, "VmaTotalStatistics*")] ref VmaTotalStatistics pStats)
		{
			fixed (VmaTotalStatistics* ppStats = &pStats)
			{
				VmaCalculateStatisticsNative(allocator, (VmaTotalStatistics*)ppStats);
			}
		}

		/// <summary>
		/// <br/>
		/// This function is called "get" not "calculate" because it is very fast, suitable to be called<br/>
		/// every frame or every allocation. For more detailed statistics use vmaCalculateStatistics().<br/>
		/// Note that when using allocator from multiple threads, returned information may immediately<br/>
		/// become outdated.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetHeapBudgets")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetHeapBudgets")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetHeapBudgetsNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBudgets")] [NativeName(NativeNameType.Type, "VmaBudget*")] VmaBudget* pBudgets);

		/// <summary>/// <br/>/// This function is called "get" not "calculate" because it is very fast, suitable to be called<br/>/// every frame or every allocation. For more detailed statistics use vmaCalculateStatistics().<br/>/// Note that when using allocator from multiple threads, returned information may immediately<br/>/// become outdated.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetHeapBudgets")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetHeapBudgets([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBudgets")] [NativeName(NativeNameType.Type, "VmaBudget*")] VmaBudget* pBudgets)
		{
			VmaGetHeapBudgetsNative(allocator, pBudgets);
		}

		/// <summary>/// <br/>/// This function is called "get" not "calculate" because it is very fast, suitable to be called<br/>/// every frame or every allocation. For more detailed statistics use vmaCalculateStatistics().<br/>/// Note that when using allocator from multiple threads, returned information may immediately<br/>/// become outdated.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetHeapBudgets")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetHeapBudgets([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBudgets")] [NativeName(NativeNameType.Type, "VmaBudget*")] ref VmaBudget pBudgets)
		{
			fixed (VmaBudget* ppBudgets = &pBudgets)
			{
				VmaGetHeapBudgetsNative(allocator, (VmaBudget*)ppBudgets);
			}
		}

		/// <summary>
		/// This algorithm tries to find a memory type that:<br/>
		/// - Is allowed by memoryTypeBits.<br/>
		/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>
		/// - Matches intended usage.<br/>
		/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaFindMemoryTypeIndex")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaFindMemoryTypeIndexNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex);

		/// <summary>/// This algorithm tries to find a memory type that:<br/>/// - Is allowed by memoryTypeBits.<br/>/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>/// - Matches intended usage.<br/>/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndex([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			VkResult ret = VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, pAllocationCreateInfo, pMemoryTypeIndex);
			return ret;
		}

		/// <summary>/// This algorithm tries to find a memory type that:<br/>/// - Is allowed by memoryTypeBits.<br/>/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>/// - Matches intended usage.<br/>/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndex([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// This algorithm tries to find a memory type that:<br/>/// - Is allowed by memoryTypeBits.<br/>/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>/// - Matches intended usage.<br/>/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndex([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
			{
				VkResult ret = VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// This algorithm tries to find a memory type that:<br/>/// - Is allowed by memoryTypeBits.<br/>/// - Contains all the flags from pAllocationCreateInfo->requiredFlags.<br/>/// - Matches intended usage.<br/>/// - Has as many flags from pAllocationCreateInfo->preferredFlags as possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndex")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndex([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "memoryTypeBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint memoryTypeBits, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = VmaFindMemoryTypeIndexNative(allocator, memoryTypeBits, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>
		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>
		/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaFindMemoryTypeIndexForBufferInfo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaFindMemoryTypeIndexForBufferInfoNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex);

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForBufferInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			VkResult ret = VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
			return ret;
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForBufferInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				VkResult ret = VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForBufferInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForBufferInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					VkResult ret = VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForBufferInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
			{
				VkResult ret = VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForBufferInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForBufferInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] VkBufferCreateInfo* pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = VmaFindMemoryTypeIndexForBufferInfoNative(allocator, pBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy buffer that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForBufferInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForBufferInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pBufferCreateInfo")] [NativeName(NativeNameType.Type, "const VkBufferCreateInfo*")] ref VkBufferCreateInfo pBufferCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkBufferCreateInfo* ppBufferCreateInfo = &pBufferCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
					{
						VkResult ret = VmaFindMemoryTypeIndexForBufferInfoNative(allocator, (VkBufferCreateInfo*)ppBufferCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>
		/// It internally creates a temporary, dummy image that never has memory bound.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaFindMemoryTypeIndexForImageInfo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaFindMemoryTypeIndexForImageInfoNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex);

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForImageInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			VkResult ret = VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
			return ret;
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForImageInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				VkResult ret = VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForImageInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				VkResult ret = VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForImageInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					VkResult ret = VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, pMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForImageInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
			{
				VkResult ret = VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
				return ret;
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForImageInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, pAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForImageInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] VkImageCreateInfo* pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
			{
				fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
				{
					VkResult ret = VmaFindMemoryTypeIndexForImageInfoNative(allocator, pImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
					return ret;
				}
			}
		}

		/// <summary>/// It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex.<br/>/// It internally creates a temporary, dummy image that never has memory bound.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFindMemoryTypeIndexForImageInfo")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaFindMemoryTypeIndexForImageInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pImageCreateInfo")] [NativeName(NativeNameType.Type, "const VkImageCreateInfo*")] ref VkImageCreateInfo pImageCreateInfo, [NativeName(NativeNameType.Param, "pAllocationCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pAllocationCreateInfo, [NativeName(NativeNameType.Param, "pMemoryTypeIndex")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint pMemoryTypeIndex)
		{
			fixed (VkImageCreateInfo* ppImageCreateInfo = &pImageCreateInfo)
			{
				fixed (VmaAllocationCreateInfo* ppAllocationCreateInfo = &pAllocationCreateInfo)
				{
					fixed (uint* ppMemoryTypeIndex = &pMemoryTypeIndex)
					{
						VkResult ret = VmaFindMemoryTypeIndexForImageInfoNative(allocator, (VkImageCreateInfo*)ppImageCreateInfo, (VmaAllocationCreateInfo*)ppAllocationCreateInfo, (uint*)ppMemoryTypeIndex);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCreatePool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCreatePoolNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] VmaPoolCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] VmaPool* pPool);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreatePool([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] VmaPoolCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] VmaPool* pPool)
		{
			VkResult ret = VmaCreatePoolNative(allocator, pCreateInfo, pPool);
			return ret;
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreatePool([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] ref VmaPoolCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] VmaPool* pPool)
		{
			fixed (VmaPoolCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VmaCreatePoolNative(allocator, (VmaPoolCreateInfo*)ppCreateInfo, pPool);
				return ret;
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreatePool([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] VmaPoolCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] ref VmaPool pPool)
		{
			fixed (VmaPool* ppPool = &pPool)
			{
				VkResult ret = VmaCreatePoolNative(allocator, pCreateInfo, (VmaPool*)ppPool);
				return ret;
			}
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCreatePool")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCreatePool([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaPoolCreateInfo*")] ref VmaPoolCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pPool")] [NativeName(NativeNameType.Type, "VmaPool*")] ref VmaPool pPool)
		{
			fixed (VmaPoolCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaPool* ppPool = &pPool)
				{
					VkResult ret = VmaCreatePoolNative(allocator, (VmaPoolCreateInfo*)ppCreateInfo, (VmaPool*)ppPool);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaDestroyPool")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaDestroyPool")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaDestroyPoolNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaDestroyPool")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaDestroyPool([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool)
		{
			VmaDestroyPoolNative(allocator, pool);
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetPoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetPoolStatistics")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetPoolStatisticsNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] VmaStatistics* pPoolStats);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetPoolStatistics([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] VmaStatistics* pPoolStats)
		{
			VmaGetPoolStatisticsNative(allocator, pool, pPoolStats);
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetPoolStatistics([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaStatistics*")] ref VmaStatistics pPoolStats)
		{
			fixed (VmaStatistics* ppPoolStats = &pPoolStats)
			{
				VmaGetPoolStatisticsNative(allocator, pool, (VmaStatistics*)ppPoolStats);
			}
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCalculatePoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaCalculatePoolStatistics")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaCalculatePoolStatisticsNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] VmaDetailedStatistics* pPoolStats);

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculatePoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaCalculatePoolStatistics([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] VmaDetailedStatistics* pPoolStats)
		{
			VmaCalculatePoolStatisticsNative(allocator, pool, pPoolStats);
		}

		/// <summary>/// <br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCalculatePoolStatistics")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaCalculatePoolStatistics([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pPoolStats")] [NativeName(NativeNameType.Type, "VmaDetailedStatistics*")] ref VmaDetailedStatistics pPoolStats)
		{
			fixed (VmaDetailedStatistics* ppPoolStats = &pPoolStats)
			{
				VmaCalculatePoolStatisticsNative(allocator, pool, (VmaDetailedStatistics*)ppPoolStats);
			}
		}

		/// <summary>
		/// <br/>
		/// Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,<br/>
		/// `VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is<br/>
		/// `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<br/>
		/// Possible return values:<br/>
		/// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.<br/>
		/// - `VK_SUCCESS` - corruption detection has been performed and succeeded.<br/>
		/// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.<br/>
		/// `VMA_ASSERT` is also fired in that case.<br/>
		/// - Other value: Error returned by Vulkan, e.g. memory mapping failure.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaCheckPoolCorruption")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaCheckPoolCorruption")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaCheckPoolCorruptionNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool);

		/// <summary>/// <br/>/// Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,<br/>/// `VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is<br/>/// `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<br/>/// Possible return values:<br/>/// - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.<br/>/// - `VK_SUCCESS` - corruption detection has been performed and succeeded.<br/>/// - `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations.<br/>/// `VMA_ASSERT` is also fired in that case.<br/>/// - Other value: Error returned by Vulkan, e.g. memory mapping failure.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaCheckPoolCorruption")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaCheckPoolCorruption([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool)
		{
			VkResult ret = VmaCheckPoolCorruptionNative(allocator, pool);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// After the call `ppName` is either null or points to an internally-owned null-terminated string<br/>
		/// containing name of the pool that was previously set. The pointer becomes invalid when the pool is<br/>
		/// destroyed or its name is changed using vmaSetPoolName().<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetPoolName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetPoolNameNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "ppName")] [NativeName(NativeNameType.Type, "const char**")] byte** ppName);

		/// <summary>/// <br/>/// After the call `ppName` is either null or points to an internally-owned null-terminated string<br/>/// containing name of the pool that was previously set. The pointer becomes invalid when the pool is<br/>/// destroyed or its name is changed using vmaSetPoolName().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetPoolName([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "ppName")] [NativeName(NativeNameType.Type, "const char**")] byte** ppName)
		{
			VmaGetPoolNameNative(allocator, pool, ppName);
		}

		/// <summary>/// <br/>/// After the call `ppName` is either null or points to an internally-owned null-terminated string<br/>/// containing name of the pool that was previously set. The pointer becomes invalid when the pool is<br/>/// destroyed or its name is changed using vmaSetPoolName().<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetPoolName([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "ppName")] [NativeName(NativeNameType.Type, "const char**")] ref byte* ppName)
		{
			fixed (byte** pppName = &ppName)
			{
				VmaGetPoolNameNative(allocator, pool, (byte**)pppName);
			}
		}

		/// <summary>
		/// <br/>
		/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>
		/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaSetPoolName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaSetPoolNameNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] byte* pName);

		/// <summary>/// <br/>/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaSetPoolName([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] byte* pName)
		{
			VmaSetPoolNameNative(allocator, pool, pName);
		}

		/// <summary>/// <br/>/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaSetPoolName([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] ref byte pName)
		{
			fixed (byte* ppName = &pName)
			{
				VmaSetPoolNameNative(allocator, pool, (byte*)ppName);
			}
		}

		/// <summary>/// <br/>/// `pName` can be either null or pointer to a null-terminated string with new name for the pool.<br/>/// Function makes internal copy of the string, so it can be changed or freed immediately after this call.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetPoolName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaSetPoolName([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pool")] [NativeName(NativeNameType.Type, "VmaPool")] VmaPool pool, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] string pName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VmaSetPoolNameNative(allocator, pool, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// <br/>
		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>
		/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>
		/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaAllocateMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaAllocateMemoryNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo);

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				VkResult ret = VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					VkResult ret = VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						VkResult ret = VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),<br/>/// vmaCreateBuffer(), vmaCreateImage() instead whenever possible.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemory")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocation = &pAllocation)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaAllocateMemoryNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>
		/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>
		/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>
		/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>
		/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>
		/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>
		/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaAllocateMemoryPages")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaAllocateMemoryPagesNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo);

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, pAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, pAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, pCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] VkMemoryRequirements* pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocations = &pAllocations)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryPagesNative(allocator, pVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>/// <br/>/// You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages().<br/>/// Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding.<br/>/// It is just a general purpose allocation function able to make multiple allocations at once.<br/>/// It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times.<br/>/// All allocations are made using same parameters. All of them are created out of the same memory pool and type.<br/>/// If any allocation fails, all allocations already made within this function call are also freed, so that when<br/>/// returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryPages")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "pVkMemoryRequirements")] [NativeName(NativeNameType.Type, "const VkMemoryRequirements*")] ref VkMemoryRequirements pVkMemoryRequirements, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocations, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VkMemoryRequirements* ppVkMemoryRequirements = &pVkMemoryRequirements)
			{
				fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
				{
					fixed (VmaAllocation* ppAllocations = &pAllocations)
					{
						fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
						{
							VkResult ret = VmaAllocateMemoryPagesNative(allocator, (VkMemoryRequirements*)ppVkMemoryRequirements, (VmaAllocationCreateInfo*)ppCreateInfo, allocationCount, (VmaAllocation*)ppAllocations, (VmaAllocationInfo*)ppAllocationInfo);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>
		/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>
		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaAllocateMemoryForBuffer")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaAllocateMemoryForBufferNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo);

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryForBufferNative(allocator, buffer, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateBuffer().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForBuffer")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForBuffer([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "VkBuffer")] VkBuffer buffer, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryForBufferNative(allocator, buffer, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>
		/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>
		/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		[LibraryImport(LibName, EntryPoint = "vmaAllocateMemoryForImage")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial VkResult VmaAllocateMemoryForImageNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo);

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VkResult ret = VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, pAllocation, pAllocationInfo);
			return ret;
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				VkResult ret = VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				VkResult ret = VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					VkResult ret = VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, pAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VkResult ret = VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
				return ret;
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] VmaAllocation* pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, pAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] VmaAllocationCreateInfo* pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocation* ppAllocation = &pAllocation)
			{
				fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
				{
					VkResult ret = VmaAllocateMemoryForImageNative(allocator, image, pCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
					return ret;
				}
			}
		}

		/// <summary>/// <br/>/// It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory().<br/>/// This is a special-purpose function. In most cases you should use vmaCreateImage().<br/>/// You must free the allocation using vmaFreeMemory() when no longer needed.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaAllocateMemoryForImage")]
		[return: NativeName(NativeNameType.Type, "VkResult")]
		public static VkResult VmaAllocateMemoryForImage([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "image")] [NativeName(NativeNameType.Type, "VkImage")] VkImage image, [NativeName(NativeNameType.Param, "pCreateInfo")] [NativeName(NativeNameType.Type, "const VmaAllocationCreateInfo*")] ref VmaAllocationCreateInfo pCreateInfo, [NativeName(NativeNameType.Param, "pAllocation")] [NativeName(NativeNameType.Type, "VmaAllocation*")] ref VmaAllocation pAllocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationCreateInfo* ppCreateInfo = &pCreateInfo)
			{
				fixed (VmaAllocation* ppAllocation = &pAllocation)
				{
					fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
					{
						VkResult ret = VmaAllocateMemoryForImageNative(allocator, image, (VmaAllocationCreateInfo*)ppCreateInfo, (VmaAllocation*)ppAllocation, (VmaAllocationInfo*)ppAllocationInfo);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaFreeMemory")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaFreeMemory")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaFreeMemoryNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "const VmaAllocation")] VmaAllocation allocation);

		/// <summary>/// <br/>/// Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemory")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeMemory([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "const VmaAllocation")] VmaAllocation allocation)
		{
			VmaFreeMemoryNative(allocator, allocation);
		}

		/// <summary>
		/// <br/>
		/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>
		/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>
		/// vmaAllocateMemoryPages() and other functions.<br/>
		/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>
		/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>
		/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaFreeMemoryPages")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaFreeMemoryPagesNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* pAllocations);

		/// <summary>/// <br/>/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>/// vmaAllocateMemoryPages() and other functions.<br/>/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* pAllocations)
		{
			VmaFreeMemoryPagesNative(allocator, allocationCount, pAllocations);
		}

		/// <summary>/// <br/>/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>/// vmaAllocateMemoryPages() and other functions.<br/>/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] VmaAllocation* pAllocations)
		{
			VmaFreeMemoryPagesNative(allocator, allocationCount, pAllocations);
		}

		/// <summary>/// <br/>/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>/// vmaAllocateMemoryPages() and other functions.<br/>/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] ulong allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation pAllocations)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				VmaFreeMemoryPagesNative(allocator, allocationCount, (VmaAllocation*)ppAllocations);
			}
		}

		/// <summary>/// <br/>/// Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding.<br/>/// It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),<br/>/// vmaAllocateMemoryPages() and other functions.<br/>/// It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times.<br/>/// Allocations in `pAllocations` array can come from any memory pools and types.<br/>/// Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaFreeMemoryPages")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaFreeMemoryPages([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocationCount")] [NativeName(NativeNameType.Type, "size_t")] nuint allocationCount, [NativeName(NativeNameType.Param, "pAllocations")] [NativeName(NativeNameType.Type, "const VmaAllocation*")] ref VmaAllocation pAllocations)
		{
			fixed (VmaAllocation* ppAllocations = &pAllocations)
			{
				VmaFreeMemoryPagesNative(allocator, allocationCount, (VmaAllocation*)ppAllocations);
			}
		}

		/// <summary>
		/// <br/>
		/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>
		/// Although this function doesn't lock any mutex, so it should be quite efficient,<br/>
		/// you should avoid calling it too often.<br/>
		/// You can retrieve same VmaAllocationInfo structure while creating your resource, from function<br/>
		/// vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change<br/>
		/// (e.g. due to defragmentation).<br/>
		/// There is also a new function vmaGetAllocationInfo2() that offers extended information<br/>
		/// about the allocation, returned using new structure #VmaAllocationInfo2.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetAllocationInfo")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetAllocationInfoNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo);

		/// <summary>/// <br/>/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>/// Although this function doesn't lock any mutex, so it should be quite efficient,<br/>/// you should avoid calling it too often.<br/>/// You can retrieve same VmaAllocationInfo structure while creating your resource, from function<br/>/// vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change<br/>/// (e.g. due to defragmentation).<br/>/// There is also a new function vmaGetAllocationInfo2() that offers extended information<br/>/// about the allocation, returned using new structure #VmaAllocationInfo2.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetAllocationInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] VmaAllocationInfo* pAllocationInfo)
		{
			VmaGetAllocationInfoNative(allocator, allocation, pAllocationInfo);
		}

		/// <summary>/// <br/>/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>/// Although this function doesn't lock any mutex, so it should be quite efficient,<br/>/// you should avoid calling it too often.<br/>/// You can retrieve same VmaAllocationInfo structure while creating your resource, from function<br/>/// vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change<br/>/// (e.g. due to defragmentation).<br/>/// There is also a new function vmaGetAllocationInfo2() that offers extended information<br/>/// about the allocation, returned using new structure #VmaAllocationInfo2.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetAllocationInfo([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo*")] ref VmaAllocationInfo pAllocationInfo)
		{
			fixed (VmaAllocationInfo* ppAllocationInfo = &pAllocationInfo)
			{
				VmaGetAllocationInfoNative(allocator, allocation, (VmaAllocationInfo*)ppAllocationInfo);
			}
		}

		/// <summary>
		/// <br/>
		/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>
		/// Extended parameters in structure #VmaAllocationInfo2 include memory block size<br/>
		/// and a flag telling whether the allocation has dedicated memory.<br/>
		/// It can be useful e.g. for interop with OpenGL.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo2")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaGetAllocationInfo2")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaGetAllocationInfo2Native([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo2*")] VmaAllocationInfo2* pAllocationInfo);

		/// <summary>/// <br/>/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>/// Extended parameters in structure #VmaAllocationInfo2 include memory block size<br/>/// and a flag telling whether the allocation has dedicated memory.<br/>/// It can be useful e.g. for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo2")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetAllocationInfo2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo2*")] VmaAllocationInfo2* pAllocationInfo)
		{
			VmaGetAllocationInfo2Native(allocator, allocation, pAllocationInfo);
		}

		/// <summary>/// <br/>/// Current parameters of given allocation are returned in `pAllocationInfo`.<br/>/// Extended parameters in structure #VmaAllocationInfo2 include memory block size<br/>/// and a flag telling whether the allocation has dedicated memory.<br/>/// It can be useful e.g. for interop with OpenGL.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaGetAllocationInfo2")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaGetAllocationInfo2([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pAllocationInfo")] [NativeName(NativeNameType.Type, "VmaAllocationInfo2*")] ref VmaAllocationInfo2 pAllocationInfo)
		{
			fixed (VmaAllocationInfo2* ppAllocationInfo = &pAllocationInfo)
			{
				VmaGetAllocationInfo2Native(allocator, allocation, (VmaAllocationInfo2*)ppAllocationInfo);
			}
		}

		/// <summary>
		/// <br/>
		/// The value of pointer `pUserData` is copied to allocation's `pUserData`.<br/>
		/// It is opaque, so you can use it however you want - e.g.<br/>
		/// as a pointer, ordinal number or some handle to you own data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaSetAllocationUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaSetAllocationUserData")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaSetAllocationUserDataNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pUserData")] [NativeName(NativeNameType.Type, "void*")] void* pUserData);

		/// <summary>/// <br/>/// The value of pointer `pUserData` is copied to allocation's `pUserData`.<br/>/// It is opaque, so you can use it however you want - e.g.<br/>/// as a pointer, ordinal number or some handle to you own data.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaSetAllocationUserData([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pUserData")] [NativeName(NativeNameType.Type, "void*")] void* pUserData)
		{
			VmaSetAllocationUserDataNative(allocator, allocation, pUserData);
		}

		/// <summary>
		/// <br/>
		/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>
		/// makes local copy of the string and sets it as allocation's `pName`. String<br/>
		/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>
		/// you can free it after this call. String previously pointed by allocation's<br/>
		/// `pName` is freed from memory.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		[LibraryImport(LibName, EntryPoint = "vmaSetAllocationName")]
		[UnmanagedCallConv(CallConvs = new Type[] {typeof(System.Runtime.CompilerServices.CallConvCdecl)})]
		internal static partial void VmaSetAllocationNameNative([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] byte* pName);

		/// <summary>/// <br/>/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>/// makes local copy of the string and sets it as allocation's `pName`. String<br/>/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>/// you can free it after this call. String previously pointed by allocation's<br/>/// `pName` is freed from memory.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaSetAllocationName([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] byte* pName)
		{
			VmaSetAllocationNameNative(allocator, allocation, pName);
		}

		/// <summary>/// <br/>/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>/// makes local copy of the string and sets it as allocation's `pName`. String<br/>/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>/// you can free it after this call. String previously pointed by allocation's<br/>/// `pName` is freed from memory.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaSetAllocationName([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] ref byte pName)
		{
			fixed (byte* ppName = &pName)
			{
				VmaSetAllocationNameNative(allocator, allocation, (byte*)ppName);
			}
		}

		/// <summary>/// <br/>/// `pName` must be either null, or pointer to a null-terminated string. The function<br/>/// makes local copy of the string and sets it as allocation's `pName`. String<br/>/// passed as pName doesn't need to be valid for whole lifetime of the allocation -<br/>/// you can free it after this call. String previously pointed by allocation's<br/>/// `pName` is freed from memory.<br/>/// </summary>		[NativeName(NativeNameType.Func, "vmaSetAllocationName")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VmaSetAllocationName([NativeName(NativeNameType.Param, "allocator")] [NativeName(NativeNameType.Type, "VmaAllocator")] VmaAllocator allocator, [NativeName(NativeNameType.Param, "allocation")] [NativeName(NativeNameType.Type, "VmaAllocation")] VmaAllocation allocation, [NativeName(NativeNameType.Param, "pName")] [NativeName(NativeNameType.Type, "const char*")] string pName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VmaSetAllocationNameNative(allocator, allocation, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}
	}
}
