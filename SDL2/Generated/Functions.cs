// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace HexaEngine.SDL2
{
	public unsafe partial class SDL
	{
		internal const string LibName = "SDL2d";

		/// <summary>
		/// Get the name of the platform.<br/>
		/// Here are the names returned for some (but not all) supported platforms:<br/>
		/// - "Windows"<br/>
		/// - "Mac OS X"<br/>
		/// - "Linux"<br/>
		/// - "iOS"<br/>
		/// - "Android"<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPlatform")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetPlatform")]
		internal static extern byte* SDLGetPlatformNative();

		/// <summary>		/// Get the name of the platform.<br/>		/// Here are the names returned for some (but not all) supported platforms:<br/>		/// - "Windows"<br/>		/// - "Mac OS X"<br/>		/// - "Linux"<br/>		/// - "iOS"<br/>		/// - "Android"<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPlatform")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetPlatform()
		{
			byte* ret = SDLGetPlatformNative();
			return ret;
		}

		/// <summary>		/// Get the name of the platform.<br/>		/// Here are the names returned for some (but not all) supported platforms:<br/>		/// - "Windows"<br/>		/// - "Mac OS X"<br/>		/// - "Linux"<br/>		/// - "iOS"<br/>		/// - "Android"<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPlatform")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetPlatformS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetPlatformNative());
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_malloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_malloc")]
		internal static extern void* SDLMallocNative([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size);

		[NativeName(NativeNameType.Func, "SDL_malloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLMalloc([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			void* ret = SDLMallocNative(size);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_calloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_calloc")]
		internal static extern void* SDLCallocNative([NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size);

		[NativeName(NativeNameType.Func, "SDL_calloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLCalloc([NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			void* ret = SDLCallocNative(nmemb, size);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_realloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_realloc")]
		internal static extern void* SDLReallocNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size);

		[NativeName(NativeNameType.Func, "SDL_realloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLRealloc([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size)
		{
			void* ret = SDLReallocNative(mem, size);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_free")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_free")]
		internal static extern void SDLFreeNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem);

		[NativeName(NativeNameType.Func, "SDL_free")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFree([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem)
		{
			SDLFreeNative(mem);
		}

		/// <summary>
		/// Get the original set of SDL memory functions<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetOriginalMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetOriginalMemoryFunctions")]
		internal static extern void SDLGetOriginalMemoryFunctionsNative([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func*")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func*")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func*")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func*")] SDLFreeFunc freeFunc);

		/// <summary>		/// Get the original set of SDL memory functions<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetOriginalMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetOriginalMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func*")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func*")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func*")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func*")] SDLFreeFunc freeFunc)
		{
			SDLGetOriginalMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, freeFunc);
		}

		/// <summary>
		/// Get the current set of SDL memory functions<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetMemoryFunctions")]
		internal static extern void SDLGetMemoryFunctionsNative([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func*")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func*")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func*")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func*")] SDLFreeFunc freeFunc);

		/// <summary>		/// Get the current set of SDL memory functions<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func*")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func*")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func*")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func*")] SDLFreeFunc freeFunc)
		{
			SDLGetMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, freeFunc);
		}

		/// <summary>
		/// Replace SDL's memory allocation functions with a custom set<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetMemoryFunctions")]
		internal static extern int SDLSetMemoryFunctionsNative([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc);

		/// <summary>		/// Replace SDL's memory allocation functions with a custom set<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetMemoryFunctions")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetMemoryFunctions([NativeName(NativeNameType.Param, "malloc_func")] [NativeName(NativeNameType.Type, "SDL_malloc_func")] SDLMallocFunc mallocFunc, [NativeName(NativeNameType.Param, "calloc_func")] [NativeName(NativeNameType.Type, "SDL_calloc_func")] SDLCallocFunc callocFunc, [NativeName(NativeNameType.Param, "realloc_func")] [NativeName(NativeNameType.Type, "SDL_realloc_func")] SDLReallocFunc reallocFunc, [NativeName(NativeNameType.Param, "free_func")] [NativeName(NativeNameType.Type, "SDL_free_func")] SDLFreeFunc freeFunc)
		{
			int ret = SDLSetMemoryFunctionsNative(mallocFunc, callocFunc, reallocFunc, freeFunc);
			return ret;
		}

		/// <summary>
		/// Get the number of outstanding (unfreed) allocations<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAllocations")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetNumAllocations")]
		internal static extern int SDLGetNumAllocationsNative();

		/// <summary>		/// Get the number of outstanding (unfreed) allocations<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumAllocations")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumAllocations()
		{
			int ret = SDLGetNumAllocationsNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_getenv")]
		internal static extern byte* SDLGetenvNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name);

		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			byte* ret = SDLGetenvNative(name);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetenvS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetenvNative(name));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = SDLGetenvNative((byte*)pname);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetenvS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetenvNative((byte*)pname));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLGetenvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_getenv")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetenvS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLGetenvNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_setenv")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_setenv")]
		internal static extern int SDLSetenvNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite);

		[NativeName(NativeNameType.Func, "SDL_setenv")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			int ret = SDLSetenvNative(name, value, overwrite);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_setenv")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			fixed (byte* pname = &name)
			{
				int ret = SDLSetenvNative((byte*)pname, value, overwrite);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_setenv")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLSetenvNative(pStr0, value, overwrite);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_setenv")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			fixed (byte* pvalue = &value)
			{
				int ret = SDLSetenvNative(name, (byte*)pvalue, overwrite);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_setenv")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLSetenvNative(name, pStr0, overwrite);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_setenv")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					int ret = SDLSetenvNative((byte*)pname, (byte*)pvalue, overwrite);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_setenv")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetenv([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "overwrite")] [NativeName(NativeNameType.Type, "int")] int overwrite)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLSetenvNative(pStr0, pStr1, overwrite);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_qsort")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_qsort")]
		internal static extern void SDLQsortNative([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void*")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "int (*)(void* base, size_t nmemb, size_t size, int (*)(const void*, const void*)* compare)*")] delegate*<void*, nuint, nuint, delegate*<void*, void*>> compare);

		[NativeName(NativeNameType.Func, "SDL_qsort")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLQsort([NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "void*")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "int (*)(void* base, size_t nmemb, size_t size, int (*)(const void*, const void*)* compare)*")] delegate*<void*, nuint, nuint, delegate*<void*, void*>> compare)
		{
			SDLQsortNative(baseValue, nmemb, size, compare);
		}

		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_bsearch")]
		internal static extern void* SDLBsearchNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "const void*")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "const void*")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "int (*)(const void* key, const void* base, size_t nmemb, size_t size, int (*)(const void*, const void*)* compare)*")] delegate*<void*, void*, nuint, nuint, delegate*<void*, void*>> compare);

		[NativeName(NativeNameType.Func, "SDL_bsearch")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLBsearch([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "const void*")] void* key, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "const void*")] void* baseValue, [NativeName(NativeNameType.Param, "nmemb")] [NativeName(NativeNameType.Type, "size_t")] nuint nmemb, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "compare")] [NativeName(NativeNameType.Type, "int (*)(const void* key, const void* base, size_t nmemb, size_t size, int (*)(const void*, const void*)* compare)*")] delegate*<void*, void*, nuint, nuint, delegate*<void*, void*>> compare)
		{
			void* ret = SDLBsearchNative(key, baseValue, nmemb, size, compare);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_abs")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_abs")]
		internal static extern int SDLAbsNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_abs")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAbs([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLAbsNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_isalpha")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_isalpha")]
		internal static extern int SDLIsalphaNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_isalpha")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIsalpha([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIsalphaNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_isalnum")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_isalnum")]
		internal static extern int SDLIsalnumNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_isalnum")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIsalnum([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIsalnumNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_isblank")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_isblank")]
		internal static extern int SDLIsblankNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_isblank")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIsblank([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIsblankNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_iscntrl")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_iscntrl")]
		internal static extern int SDLIscntrlNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_iscntrl")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIscntrl([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIscntrlNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_isdigit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_isdigit")]
		internal static extern int SDLIsdigitNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_isdigit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIsdigit([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIsdigitNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_isxdigit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_isxdigit")]
		internal static extern int SDLIsxdigitNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_isxdigit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIsxdigit([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIsxdigitNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ispunct")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ispunct")]
		internal static extern int SDLIspunctNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_ispunct")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIspunct([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIspunctNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_isspace")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_isspace")]
		internal static extern int SDLIsspaceNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_isspace")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIsspace([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIsspaceNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_isupper")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_isupper")]
		internal static extern int SDLIsupperNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_isupper")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIsupper([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIsupperNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_islower")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_islower")]
		internal static extern int SDLIslowerNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_islower")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIslower([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIslowerNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_isprint")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_isprint")]
		internal static extern int SDLIsprintNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_isprint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIsprint([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIsprintNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_isgraph")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_isgraph")]
		internal static extern int SDLIsgraphNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_isgraph")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIsgraph([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLIsgraphNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_toupper")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_toupper")]
		internal static extern int SDLToupperNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_toupper")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLToupper([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLToupperNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_tolower")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_tolower")]
		internal static extern int SDLTolowerNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x);

		[NativeName(NativeNameType.Func, "SDL_tolower")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLTolower([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x)
		{
			int ret = SDLTolowerNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_crc16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_crc16")]
		internal static extern ushort SDLCrc16Native([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint16")] ushort crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len);

		[NativeName(NativeNameType.Func, "SDL_crc16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLCrc16([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint16")] ushort crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			ushort ret = SDLCrc16Native(crc, data, len);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_crc32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_crc32")]
		internal static extern uint SDLCrc32Native([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint32")] uint crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len);

		[NativeName(NativeNameType.Func, "SDL_crc32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLCrc32([NativeName(NativeNameType.Param, "crc")] [NativeName(NativeNameType.Type, "Uint32")] uint crc, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			uint ret = SDLCrc32Native(crc, data, len);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_memset")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_memset")]
		internal static extern void* SDLMemsetNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len);

		[NativeName(NativeNameType.Func, "SDL_memset")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLMemset([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = SDLMemsetNative(dst, c, len);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_memcpy")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_memcpy")]
		internal static extern void* SDLMemcpyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len);

		[NativeName(NativeNameType.Func, "SDL_memcpy")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLMemcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = SDLMemcpyNative(dst, src, len);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_memmove")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_memmove")]
		internal static extern void* SDLMemmoveNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len);

		[NativeName(NativeNameType.Func, "SDL_memmove")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLMemmove([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			void* ret = SDLMemmoveNative(dst, src, len);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_memcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_memcmp")]
		internal static extern int SDLMemcmpNative([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "const void*")] void* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const void*")] void* s2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len);

		[NativeName(NativeNameType.Func, "SDL_memcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLMemcmp([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "const void*")] void* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const void*")] void* s2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			int ret = SDLMemcmpNative(s1, s2, len);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_wcslen")]
		internal static extern nuint SDLWcslenNative([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] char* wstr);

		[NativeName(NativeNameType.Func, "SDL_wcslen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] char* wstr)
		{
			nuint ret = SDLWcslenNative(wstr);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] ref char wstr)
		{
			fixed (char* pwstr = &wstr)
			{
				nuint ret = SDLWcslenNative((char*)pwstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcslen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslen([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] string wstr)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (wstr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(wstr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(wstr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			nuint ret = SDLWcslenNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_wcslcpy")]
		internal static extern nuint SDLWcslcpyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = SDLWcslcpyNative(dst, src, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				nuint ret = SDLWcslcpyNative((char*)pdst, src, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			nuint ret = SDLWcslcpyNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] ref char src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* psrc = &src)
			{
				nuint ret = SDLWcslcpyNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			nuint ret = SDLWcslcpyNative(dst, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] ref char src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = &src)
				{
					nuint ret = SDLWcslcpyNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			nuint ret = SDLWcslcpyNative(pStr0, pStr1, maxlen);
			dst = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_wcslcat")]
		internal static extern nuint SDLWcslcatNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = SDLWcslcatNative(dst, src, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				nuint ret = SDLWcslcatNative((char*)pdst, src, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] char* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			nuint ret = SDLWcslcatNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] ref char src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* psrc = &src)
			{
				nuint ret = SDLWcslcatNative(dst, (char*)psrc, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] char* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			nuint ret = SDLWcslcatNative(dst, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] ref char dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] ref char src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pdst = &dst)
			{
				fixed (char* psrc = &src)
				{
					nuint ret = SDLWcslcatNative((char*)pdst, (char*)psrc, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcslcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWcslcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "wchar*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const wchar*")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			nuint ret = SDLWcslcatNative(pStr0, pStr1, maxlen);
			dst = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_wcsdup")]
		internal static extern char* SDLWcsdupNative([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] char* wstr);

		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsdup([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] char* wstr)
		{
			char* ret = SDLWcsdupNative(wstr);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsdupS([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] char* wstr)
		{
			string ret = Utils.DecodeStringUTF16(SDLWcsdupNative(wstr));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsdup([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] ref char wstr)
		{
			fixed (char* pwstr = &wstr)
			{
				char* ret = SDLWcsdupNative((char*)pwstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsdupS([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] ref char wstr)
		{
			fixed (char* pwstr = &wstr)
			{
				string ret = Utils.DecodeStringUTF16(SDLWcsdupNative((char*)pwstr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsdup([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] string wstr)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (wstr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(wstr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(wstr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* ret = SDLWcsdupNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsdup")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsdupS([NativeName(NativeNameType.Param, "wstr")] [NativeName(NativeNameType.Type, "const wchar*")] string wstr)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (wstr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(wstr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(wstr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			string ret = Utils.DecodeStringUTF16(SDLWcsdupNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_wcsstr")]
		internal static extern char* SDLWcsstrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] char* needle);

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] char* needle)
		{
			char* ret = SDLWcsstrNative(haystack, needle);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] char* needle)
		{
			string ret = Utils.DecodeStringUTF16(SDLWcsstrNative(haystack, needle));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] ref char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] char* needle)
		{
			fixed (char* phaystack = &haystack)
			{
				char* ret = SDLWcsstrNative((char*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] ref char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] char* needle)
		{
			fixed (char* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF16(SDLWcsstrNative((char*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] char* needle)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* ret = SDLWcsstrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] char* needle)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			string ret = Utils.DecodeStringUTF16(SDLWcsstrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] ref char needle)
		{
			fixed (char* pneedle = &needle)
			{
				char* ret = SDLWcsstrNative(haystack, (char*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] ref char needle)
		{
			fixed (char* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF16(SDLWcsstrNative(haystack, (char*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] string needle)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* ret = SDLWcsstrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] char* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] string needle)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			string ret = Utils.DecodeStringUTF16(SDLWcsstrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] ref char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] ref char needle)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					char* ret = SDLWcsstrNative((char*)phaystack, (char*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] ref char haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] ref char needle)
		{
			fixed (char* phaystack = &haystack)
			{
				fixed (char* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF16(SDLWcsstrNative((char*)phaystack, (char*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static char* SDLWcsstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] string needle)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			char* ret = SDLWcsstrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsstr")]
		[return: NativeName(NativeNameType.Type, "wchar*")]
		public static string SDLWcsstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const wchar*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const wchar*")] string needle)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			string ret = Utils.DecodeStringUTF16(SDLWcsstrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_wcscmp")]
		internal static extern int SDLWcscmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2);

		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2)
		{
			int ret = SDLWcscmpNative(str1, str2);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = SDLWcscmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLWcscmpNative(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str2)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = SDLWcscmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] string str2)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLWcscmpNative(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str2)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = SDLWcscmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcscmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] string str2)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			int ret = SDLWcscmpNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_wcsncmp")]
		internal static extern int SDLWcsncmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = SDLWcsncmpNative(str1, str2, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = SDLWcsncmpNative((char*)pstr1, str2, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLWcsncmpNative(pStr0, str2, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = SDLWcsncmpNative(str1, (char*)pstr2, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLWcsncmpNative(str1, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = SDLWcsncmpNative((char*)pstr1, (char*)pstr2, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			int ret = SDLWcsncmpNative(pStr0, pStr1, maxlen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_wcscasecmp")]
		internal static extern int SDLWcscasecmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2);

		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2)
		{
			int ret = SDLWcscasecmpNative(str1, str2);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = SDLWcscasecmpNative((char*)pstr1, str2);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLWcscasecmpNative(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str2)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = SDLWcscasecmpNative(str1, (char*)pstr2);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] string str2)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLWcscasecmpNative(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str2)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = SDLWcscasecmpNative((char*)pstr1, (char*)pstr2);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcscasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcscasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] string str2)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			int ret = SDLWcscasecmpNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_wcsncasecmp")]
		internal static extern int SDLWcsncasecmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len);

		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			int ret = SDLWcsncasecmpNative(str1, str2, len);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (char* pstr1 = &str1)
			{
				int ret = SDLWcsncasecmpNative((char*)pstr1, str2, len);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] char* str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLWcsncasecmpNative(pStr0, str2, len);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (char* pstr2 = &str2)
			{
				int ret = SDLWcsncasecmpNative(str1, (char*)pstr2, len);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] char* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] string str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLWcsncasecmpNative(str1, pStr0, len);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] ref char str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (char* pstr1 = &str1)
			{
				fixed (char* pstr2 = &str2)
				{
					int ret = SDLWcsncasecmpNative((char*)pstr1, (char*)pstr2, len);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_wcsncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWcsncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const wchar*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const wchar*")] string str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			char* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF16(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<char>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = (char*)pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF16(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = '\0';
			}
			int ret = SDLWcsncasecmpNative(pStr0, pStr1, len);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strlen")]
		internal static extern nuint SDLStrlenNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str);

		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			nuint ret = SDLStrlenNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = SDLStrlenNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SDLStrlenNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strlcpy")]
		internal static extern nuint SDLStrlcpyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = SDLStrlcpyNative(dst, src, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				nuint ret = SDLStrlcpyNative((byte*)pdst, src, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SDLStrlcpyNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ref byte src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* psrc = &src)
			{
				nuint ret = SDLStrlcpyNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SDLStrlcpyNative(dst, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ref byte src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					nuint ret = SDLStrlcpyNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = SDLStrlcpyNative(pStr0, pStr1, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_utf8strlcpy")]
		internal static extern nuint SDLUtf8StrlcpyNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes);

		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			nuint ret = SDLUtf8StrlcpyNative(dst, src, dstBytes);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			fixed (byte* pdst = &dst)
			{
				nuint ret = SDLUtf8StrlcpyNative((byte*)pdst, src, dstBytes);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SDLUtf8StrlcpyNative(pStr0, src, dstBytes);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ref byte src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			fixed (byte* psrc = &src)
			{
				nuint ret = SDLUtf8StrlcpyNative(dst, (byte*)psrc, dstBytes);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] string src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SDLUtf8StrlcpyNative(dst, pStr0, dstBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ref byte src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					nuint ret = SDLUtf8StrlcpyNative((byte*)pdst, (byte*)psrc, dstBytes);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlcpy")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlcpy([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] string src, [NativeName(NativeNameType.Param, "dst_bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint dstBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = SDLUtf8StrlcpyNative(pStr0, pStr1, dstBytes);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strlcat")]
		internal static extern nuint SDLStrlcatNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			nuint ret = SDLStrlcatNative(dst, src, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				nuint ret = SDLStrlcatNative((byte*)pdst, src, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] byte* src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SDLStrlcatNative(pStr0, src, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ref byte src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* psrc = &src)
			{
				nuint ret = SDLStrlcatNative(dst, (byte*)psrc, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (src != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(src);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(src, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SDLStrlcatNative(dst, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] ref byte src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					nuint ret = SDLStrlcatNative((byte*)pdst, (byte*)psrc, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlcat")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLStrlcat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "char*")] ref string dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const char*")] string src, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (dst != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(dst);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(dst, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (src != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(src);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(src, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			nuint ret = SDLStrlcatNative(pStr0, pStr1, maxlen);
			dst = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strdup")]
		internal static extern byte* SDLStrdupNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str);

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrdup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			byte* ret = SDLStrdupNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrdupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(SDLStrdupNative(str));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrdup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLStrdupNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrdupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrdupNative((byte*)pstr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrdup([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrdupNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strdup")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrdupS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrdupNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strrev")]
		internal static extern byte* SDLStrrevNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str);

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrrev([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str)
		{
			byte* ret = SDLStrrevNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrrevS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(SDLStrrevNative(str));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrrev([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLStrrevNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrrevS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrrevNative((byte*)pstr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrrev([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrrevNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrev")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrrevS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrrevNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strupr")]
		internal static extern byte* SDLStruprNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str);

		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrupr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str)
		{
			byte* ret = SDLStruprNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStruprS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(SDLStruprNative(str));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrupr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLStruprNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStruprS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLStruprNative((byte*)pstr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrupr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStruprNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strupr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStruprS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStruprNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strlwr")]
		internal static extern byte* SDLStrlwrNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str);

		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrlwr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str)
		{
			byte* ret = SDLStrlwrNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrlwrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str)
		{
			string ret = Utils.DecodeStringUTF8(SDLStrlwrNative(str));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrlwr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLStrlwrNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrlwrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrlwrNative((byte*)pstr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrlwr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrlwrNative(pStr0);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strlwr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrlwrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrlwrNative(pStr0));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strchr")]
		internal static extern byte* SDLStrchrNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c);

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* ret = SDLStrchrNative(str, c);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			string ret = Utils.DecodeStringUTF8(SDLStrchrNative(str, c));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLStrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrchrNative(pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrchrNative(pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strrchr")]
		internal static extern byte* SDLStrrchrNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c);

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* ret = SDLStrrchrNative(str, c);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			string ret = Utils.DecodeStringUTF8(SDLStrrchrNative(str, c));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLStrrchrNative((byte*)pstr, c);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrrchrNative((byte*)pstr, c));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrrchr([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrrchrNative(pStr0, c);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strrchr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrrchrS([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "int")] int c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrrchrNative(pStr0, c));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strstr")]
		internal static extern byte* SDLStrstrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle);

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			byte* ret = SDLStrstrNative(haystack, needle);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			string ret = Utils.DecodeStringUTF8(SDLStrstrNative(haystack, needle));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = SDLStrstrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrstrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrstrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrstrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = SDLStrstrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrstrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrstrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrstrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = SDLStrstrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(SDLStrstrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrstr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = SDLStrstrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strstr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrstrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrstrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strcasestr")]
		internal static extern byte* SDLStrcasestrNative([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle);

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			byte* ret = SDLStrcasestrNative(haystack, needle);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			string ret = Utils.DecodeStringUTF8(SDLStrcasestrNative(haystack, needle));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				byte* ret = SDLStrcasestrNative((byte*)phaystack, needle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrcasestrNative((byte*)phaystack, needle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrcasestrNative(pStr0, needle);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] byte* needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrcasestrNative(pStr0, needle));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				byte* ret = SDLStrcasestrNative(haystack, (byte*)pneedle);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] ref byte needle)
		{
			fixed (byte* pneedle = &needle)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrcasestrNative(haystack, (byte*)pneedle));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrcasestrNative(haystack, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] byte* haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (needle != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(needle);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(needle, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrcasestrNative(haystack, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					byte* ret = SDLStrcasestrNative((byte*)phaystack, (byte*)pneedle);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] ref byte haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] ref byte needle)
		{
			fixed (byte* phaystack = &haystack)
			{
				fixed (byte* pneedle = &needle)
				{
					string ret = Utils.DecodeStringUTF8(SDLStrcasestrNative((byte*)phaystack, (byte*)pneedle));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrcasestr([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = SDLStrcasestrNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasestr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrcasestrS([NativeName(NativeNameType.Param, "haystack")] [NativeName(NativeNameType.Type, "const char*")] string haystack, [NativeName(NativeNameType.Param, "needle")] [NativeName(NativeNameType.Type, "const char*")] string needle)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (haystack != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(haystack);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(haystack, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (needle != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(needle);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(needle, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrcasestrNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strtokr")]
		internal static extern byte* SDLStrtokrNative([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr);

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			byte* ret = SDLStrtokrNative(s1, s2, saveptr);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(s1, s2, saveptr));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				byte* ret = SDLStrtokrNative((byte*)ps1, s2, saveptr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrtokrNative((byte*)ps1, s2, saveptr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrtokrNative(pStr0, s2, saveptr);
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(pStr0, s2, saveptr));
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				byte* ret = SDLStrtokrNative(s1, (byte*)ps2, saveptr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(s1, (byte*)ps2, saveptr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLStrtokrNative(s1, pStr0, saveptr);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(s1, pStr0, saveptr));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					byte* ret = SDLStrtokrNative((byte*)ps1, (byte*)ps2, saveptr);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					string ret = Utils.DecodeStringUTF8(SDLStrtokrNative((byte*)ps1, (byte*)ps2, saveptr));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = SDLStrtokrNative(pStr0, pStr1, saveptr);
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] byte** saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(pStr0, pStr1, saveptr));
			s1 = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = SDLStrtokrNative(s1, s2, (byte**)psaveptr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(s1, s2, (byte**)psaveptr));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = SDLStrtokrNative((byte*)ps1, s2, (byte**)psaveptr);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(SDLStrtokrNative((byte*)ps1, s2, (byte**)psaveptr));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = SDLStrtokrNative(pStr0, s2, (byte**)psaveptr);
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] byte* s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(pStr0, s2, (byte**)psaveptr));
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					byte* ret = SDLStrtokrNative(s1, (byte*)ps2, (byte**)psaveptr);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			fixed (byte* ps2 = &s2)
			{
				fixed (byte** psaveptr = &saveptr)
				{
					string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(s1, (byte*)ps2, (byte**)psaveptr));
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = SDLStrtokrNative(s1, pStr0, (byte**)psaveptr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] byte* s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(s1, pStr0, (byte**)psaveptr));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						byte* ret = SDLStrtokrNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref byte s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] ref byte s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			fixed (byte* ps1 = &s1)
			{
				fixed (byte* ps2 = &s2)
				{
					fixed (byte** psaveptr = &saveptr)
					{
						string ret = Utils.DecodeStringUTF8(SDLStrtokrNative((byte*)ps1, (byte*)ps2, (byte**)psaveptr));
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLStrtokr([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				byte* ret = SDLStrtokrNative(pStr0, pStr1, (byte**)psaveptr);
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtokr")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLStrtokrS([NativeName(NativeNameType.Param, "s1")] [NativeName(NativeNameType.Type, "char*")] ref string s1, [NativeName(NativeNameType.Param, "s2")] [NativeName(NativeNameType.Type, "const char*")] string s2, [NativeName(NativeNameType.Param, "saveptr")] [NativeName(NativeNameType.Type, "char**")] ref byte* saveptr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (s2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(s2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(s2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (byte** psaveptr = &saveptr)
			{
				string ret = Utils.DecodeStringUTF8(SDLStrtokrNative(pStr0, pStr1, (byte**)psaveptr));
				s1 = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_utf8strlen")]
		internal static extern nuint SDLUtf8StrlenNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str);

		[NativeName(NativeNameType.Func, "SDL_utf8strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			nuint ret = SDLUtf8StrlenNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = SDLUtf8StrlenNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SDLUtf8StrlenNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_utf8strnlen")]
		internal static extern nuint SDLUtf8StrnlenNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint bytes);

		[NativeName(NativeNameType.Func, "SDL_utf8strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint bytes)
		{
			nuint ret = SDLUtf8StrnlenNative(str, bytes);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint bytes)
		{
			fixed (byte* pstr = &str)
			{
				nuint ret = SDLUtf8StrnlenNative((byte*)pstr, bytes);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_utf8strnlen")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLUtf8Strnlen([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "bytes")] [NativeName(NativeNameType.Type, "size_t")] nuint bytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			nuint ret = SDLUtf8StrnlenNative(pStr0, bytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_itoa")]
		internal static extern byte* SDLItoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix);

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLItoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = SDLItoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLItoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(SDLItoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLItoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLItoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLItoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLItoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLItoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLItoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_itoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLItoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLItoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_uitoa")]
		internal static extern byte* SDLUitoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix);

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLUitoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = SDLUitoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLUitoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(SDLUitoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLUitoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLUitoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLUitoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLUitoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLUitoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLUitoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_uitoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLUitoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLUitoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ltoa")]
		internal static extern byte* SDLLtoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix);

		[NativeName(NativeNameType.Func, "SDL_ltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLLtoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = SDLLtoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLLtoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(SDLLtoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLLtoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLLtoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_ltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLLtoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLLtoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_ltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLLtoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLLtoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLLtoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLLtoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ultoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ultoa")]
		internal static extern byte* SDLUltoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix);

		[NativeName(NativeNameType.Func, "SDL_ultoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLUltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = SDLUltoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ultoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLUltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(SDLUltoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ultoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLUltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLUltoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_ultoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLUltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLUltoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_ultoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLUltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLUltoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ultoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLUltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "unsigned int")] uint value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLUltoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_lltoa")]
		internal static extern byte* SDLLltoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix);

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLLltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = SDLLltoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLLltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(SDLLltoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLLltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLLltoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLLltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLLltoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLLltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLLltoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLLltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint64")] long value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLLltoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ulltoa")]
		internal static extern byte* SDLUlltoaNative([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix);

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLUlltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* ret = SDLUlltoaNative(value, str, radix);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLUlltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] byte* str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			string ret = Utils.DecodeStringUTF8(SDLUlltoaNative(value, str, radix));
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLUlltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				byte* ret = SDLUlltoaNative(value, (byte*)pstr, radix);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLUlltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref byte str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			fixed (byte* pstr = &str)
			{
				string ret = Utils.DecodeStringUTF8(SDLUlltoaNative(value, (byte*)pstr, radix));
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLUlltoa([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLUlltoaNative(value, pStr0, radix);
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ulltoa")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLUlltoaS([NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value, [NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "char*")] ref string str, [NativeName(NativeNameType.Param, "radix")] [NativeName(NativeNameType.Type, "int")] int radix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLUlltoaNative(value, pStr0, radix));
			str = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atoi")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_atoi")]
		internal static extern int SDLAtoiNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str);

		[NativeName(NativeNameType.Func, "SDL_atoi")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtoi([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			int ret = SDLAtoiNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atoi")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtoi([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				int ret = SDLAtoiNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_atoi")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtoi([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLAtoiNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atof")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_atof")]
		internal static extern double SDLAtofNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str);

		[NativeName(NativeNameType.Func, "SDL_atof")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLAtof([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			double ret = SDLAtofNative(str);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atof")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLAtof([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				double ret = SDLAtofNative((byte*)pstr);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_atof")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLAtof([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			double ret = SDLAtofNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strtol")]
		internal static extern int SDLStrtolNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue);

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			int ret = SDLStrtolNative(str, endp, baseValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				int ret = SDLStrtolNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLStrtolNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				int ret = SDLStrtolNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					int ret = SDLStrtolNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtol")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrtol([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				int ret = SDLStrtolNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strtoul")]
		internal static extern uint SDLStrtoulNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue);

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint SDLStrtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			uint ret = SDLStrtoulNative(str, endp, baseValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint SDLStrtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				uint ret = SDLStrtoulNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint SDLStrtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = SDLStrtoulNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint SDLStrtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				uint ret = SDLStrtoulNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint SDLStrtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					uint ret = SDLStrtoulNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoul")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint SDLStrtoul([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				uint ret = SDLStrtoulNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strtoll")]
		internal static extern long SDLStrtollNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue);

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLStrtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			long ret = SDLStrtollNative(str, endp, baseValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLStrtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				long ret = SDLStrtollNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLStrtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			long ret = SDLStrtollNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLStrtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				long ret = SDLStrtollNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLStrtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					long ret = SDLStrtollNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoll")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLStrtoll([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				long ret = SDLStrtollNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strtoull")]
		internal static extern ulong SDLStrtoullNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue);

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLStrtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			ulong ret = SDLStrtoullNative(str, endp, baseValue);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLStrtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				ulong ret = SDLStrtoullNative((byte*)pstr, endp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLStrtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ulong ret = SDLStrtoullNative(pStr0, endp, baseValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLStrtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte** pendp = &endp)
			{
				ulong ret = SDLStrtoullNative(str, (byte**)pendp, baseValue);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLStrtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					ulong ret = SDLStrtoullNative((byte*)pstr, (byte**)pendp, baseValue);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtoull")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLStrtoull([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp, [NativeName(NativeNameType.Param, "base")] [NativeName(NativeNameType.Type, "int")] int baseValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				ulong ret = SDLStrtoullNative(pStr0, (byte**)pendp, baseValue);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strtod")]
		internal static extern double SDLStrtodNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp);

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLStrtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp)
		{
			double ret = SDLStrtodNative(str, endp);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLStrtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp)
		{
			fixed (byte* pstr = &str)
			{
				double ret = SDLStrtodNative((byte*)pstr, endp);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLStrtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] byte** endp)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			double ret = SDLStrtodNative(pStr0, endp);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLStrtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp)
		{
			fixed (byte** pendp = &endp)
			{
				double ret = SDLStrtodNative(str, (byte**)pendp);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLStrtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp)
		{
			fixed (byte* pstr = &str)
			{
				fixed (byte** pendp = &endp)
				{
					double ret = SDLStrtodNative((byte*)pstr, (byte**)pendp);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strtod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLStrtod([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str, [NativeName(NativeNameType.Param, "endp")] [NativeName(NativeNameType.Type, "char**")] ref byte* endp)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte** pendp = &endp)
			{
				double ret = SDLStrtodNative(pStr0, (byte**)pendp);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strcmp")]
		internal static extern int SDLStrcmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2);

		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2)
		{
			int ret = SDLStrcmpNative(str1, str2);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = SDLStrcmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLStrcmpNative(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] ref byte str2)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = SDLStrcmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLStrcmpNative(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] ref byte str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = SDLStrcmpNative((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLStrcmpNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strncmp")]
		internal static extern int SDLStrncmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = SDLStrncmpNative(str1, str2, maxlen);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = SDLStrncmpNative((byte*)pstr1, str2, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLStrncmpNative(pStr0, str2, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] ref byte str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = SDLStrncmpNative(str1, (byte*)pstr2, maxlen);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLStrncmpNative(str1, pStr0, maxlen);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] ref byte str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = SDLStrncmpNative((byte*)pstr1, (byte*)pstr2, maxlen);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strncmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] string str2, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLStrncmpNative(pStr0, pStr1, maxlen);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strcasecmp")]
		internal static extern int SDLStrcasecmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2);

		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2)
		{
			int ret = SDLStrcasecmpNative(str1, str2);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = SDLStrcasecmpNative((byte*)pstr1, str2);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLStrcasecmpNative(pStr0, str2);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] ref byte str2)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = SDLStrcasecmpNative(str1, (byte*)pstr2);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLStrcasecmpNative(str1, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] ref byte str2)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = SDLStrcasecmpNative((byte*)pstr1, (byte*)pstr2);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strcasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrcasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] string str2)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLStrcasecmpNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_strncasecmp")]
		internal static extern int SDLStrncasecmpNative([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len);

		[NativeName(NativeNameType.Func, "SDL_strncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			int ret = SDLStrncasecmpNative(str1, str2, len);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (byte* pstr1 = &str1)
			{
				int ret = SDLStrncasecmpNative((byte*)pstr1, str2, len);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] byte* str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLStrncasecmpNative(pStr0, str2, len);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] ref byte str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (byte* pstr2 = &str2)
			{
				int ret = SDLStrncasecmpNative(str1, (byte*)pstr2, len);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] byte* str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] string str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str2 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str2);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str2, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLStrncasecmpNative(str1, pStr0, len);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_strncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] ref byte str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] ref byte str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			fixed (byte* pstr1 = &str1)
			{
				fixed (byte* pstr2 = &str2)
				{
					int ret = SDLStrncasecmpNative((byte*)pstr1, (byte*)pstr2, len);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_strncasecmp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLStrncasecmp([NativeName(NativeNameType.Param, "str1")] [NativeName(NativeNameType.Type, "const char*")] string str1, [NativeName(NativeNameType.Param, "str2")] [NativeName(NativeNameType.Type, "const char*")] string str2, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "size_t")] nuint len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str2 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str2);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str2, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLStrncasecmpNative(pStr0, pStr1, len);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_sscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_sscanf")]
		internal static extern int SDLSscanfNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		[NativeName(NativeNameType.Func, "SDL_sscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			int ret = SDLSscanfNative(text, fmt);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_sscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SDLSscanfNative((byte*)ptext, fmt);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_sscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLSscanfNative(pStr0, fmt);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_sscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SDLSscanfNative(text, (byte*)pfmt);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_sscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLSscanfNative(text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_sscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = SDLSscanfNative((byte*)ptext, (byte*)pfmt);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_sscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLSscanfNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vsscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_vsscanf")]
		internal static extern int SDLVsscanfNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap);

		[NativeName(NativeNameType.Func, "SDL_vsscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			int ret = SDLVsscanfNative(text, fmt, ap);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vsscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SDLVsscanfNative((byte*)ptext, fmt, ap);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vsscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLVsscanfNative(pStr0, fmt, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vsscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SDLVsscanfNative(text, (byte*)pfmt, ap);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vsscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLVsscanfNative(text, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vsscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = SDLVsscanfNative((byte*)ptext, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vsscanf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsscanf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLVsscanfNative(pStr0, pStr1, ap);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_snprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_snprintf")]
		internal static extern int SDLSnprintfNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		[NativeName(NativeNameType.Func, "SDL_snprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			int ret = SDLSnprintfNative(text, maxlen, fmt);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_snprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SDLSnprintfNative((byte*)ptext, maxlen, fmt);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_snprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref string text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLSnprintfNative(pStr0, maxlen, fmt);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_snprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SDLSnprintfNative(text, maxlen, (byte*)pfmt);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_snprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLSnprintfNative(text, maxlen, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_snprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = SDLSnprintfNative((byte*)ptext, maxlen, (byte*)pfmt);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_snprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref string text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLSnprintfNative(pStr0, maxlen, pStr1);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vsnprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_vsnprintf")]
		internal static extern int SDLVsnprintfNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap);

		[NativeName(NativeNameType.Func, "SDL_vsnprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			int ret = SDLVsnprintfNative(text, maxlen, fmt, ap);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vsnprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SDLVsnprintfNative((byte*)ptext, maxlen, fmt, ap);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vsnprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref string text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLVsnprintfNative(pStr0, maxlen, fmt, ap);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vsnprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SDLVsnprintfNative(text, maxlen, (byte*)pfmt, ap);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vsnprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] byte* text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLVsnprintfNative(text, maxlen, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vsnprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref byte text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = SDLVsnprintfNative((byte*)ptext, maxlen, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vsnprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVsnprintf([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "char*")] ref string text, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmt != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmt, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLVsnprintfNative(pStr0, maxlen, pStr1, ap);
			text = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_asprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_asprintf")]
		internal static extern int SDLAsprintfNative([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] byte** strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		[NativeName(NativeNameType.Func, "SDL_asprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAsprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] byte** strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			int ret = SDLAsprintfNative(strp, fmt);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_asprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAsprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] ref byte* strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			fixed (byte** pstrp = &strp)
			{
				int ret = SDLAsprintfNative((byte**)pstrp, fmt);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_asprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAsprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] byte** strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SDLAsprintfNative(strp, (byte*)pfmt);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_asprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAsprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] byte** strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLAsprintfNative(strp, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_asprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAsprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] ref byte* strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte** pstrp = &strp)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = SDLAsprintfNative((byte**)pstrp, (byte*)pfmt);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_asprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAsprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] ref byte* strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			fixed (byte** pstrp = &strp)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = SDLAsprintfNative((byte**)pstrp, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vasprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_vasprintf")]
		internal static extern int SDLVasprintfNative([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] byte** strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap);

		[NativeName(NativeNameType.Func, "SDL_vasprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVasprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] byte** strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			int ret = SDLVasprintfNative(strp, fmt, ap);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vasprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVasprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] ref byte* strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte** pstrp = &strp)
			{
				int ret = SDLVasprintfNative((byte**)pstrp, fmt, ap);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vasprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVasprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] byte** strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SDLVasprintfNative(strp, (byte*)pfmt, ap);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vasprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVasprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] byte** strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLVasprintfNative(strp, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_vasprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVasprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] ref byte* strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte** pstrp = &strp)
			{
				fixed (byte* pfmt = &fmt)
				{
					int ret = SDLVasprintfNative((byte**)pstrp, (byte*)pfmt, ap);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_vasprintf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVasprintf([NativeName(NativeNameType.Param, "strp")] [NativeName(NativeNameType.Type, "char**")] ref byte* strp, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte** pstrp = &strp)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmt != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmt);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = SDLVasprintfNative((byte**)pstrp, pStr0, ap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Use this function to compute arc cosine of `x`.<br/>
		/// The definition of `y = acos(x)` is `x = cos(y)`.<br/>
		/// Domain: `-1 <br/>
		/// <<br/>
		/// = x <br/>
		/// <<br/>
		/// = 1`<br/>
		/// Range: `0 <br/>
		/// <<br/>
		/// = y <br/>
		/// <<br/>
		/// = Pi`<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_acos")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_acos")]
		internal static extern double SDLAcosNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		/// <summary>		/// Use this function to compute arc cosine of `x`.<br/>		/// The definition of `y = acos(x)` is `x = cos(y)`.<br/>		/// Domain: `-1 <br/>		/// <<br/>		/// = x <br/>		/// <<br/>		/// = 1`<br/>		/// Range: `0 <br/>		/// <<br/>		/// = y <br/>		/// <<br/>		/// = Pi`<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_acos")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLAcos([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLAcosNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_acosf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_acosf")]
		internal static extern float SDLAcosfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_acosf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLAcosf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLAcosfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_asin")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_asin")]
		internal static extern double SDLAsinNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_asin")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLAsin([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLAsinNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_asinf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_asinf")]
		internal static extern float SDLAsinfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_asinf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLAsinf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLAsinfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atan")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_atan")]
		internal static extern double SDLAtanNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_atan")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLAtan([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLAtanNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_atanf")]
		internal static extern float SDLAtanfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_atanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLAtanf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLAtanfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atan2")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_atan2")]
		internal static extern double SDLAtan2Native([NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_atan2")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLAtan2([NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLAtan2Native(y, x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_atan2f")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_atan2f")]
		internal static extern float SDLAtan2FNative([NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_atan2f")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLAtan2F([NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLAtan2FNative(y, x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ceil")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ceil")]
		internal static extern double SDLCeilNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_ceil")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLCeil([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLCeilNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_ceilf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ceilf")]
		internal static extern float SDLCeilfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_ceilf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLCeilf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLCeilfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_copysign")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_copysign")]
		internal static extern double SDLCopysignNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y);

		[NativeName(NativeNameType.Func, "SDL_copysign")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLCopysign([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y)
		{
			double ret = SDLCopysignNative(x, y);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_copysignf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_copysignf")]
		internal static extern float SDLCopysignfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y);

		[NativeName(NativeNameType.Func, "SDL_copysignf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLCopysignf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			float ret = SDLCopysignfNative(x, y);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_cos")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_cos")]
		internal static extern double SDLCosNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_cos")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLCos([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLCosNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_cosf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_cosf")]
		internal static extern float SDLCosfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_cosf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLCosf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLCosfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_exp")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_exp")]
		internal static extern double SDLExpNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_exp")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLExp([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLExpNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_expf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_expf")]
		internal static extern float SDLExpfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_expf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLExpf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLExpfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_fabs")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_fabs")]
		internal static extern double SDLFabsNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_fabs")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLFabs([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLFabsNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_fabsf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_fabsf")]
		internal static extern float SDLFabsfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_fabsf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLFabsf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLFabsfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_floor")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_floor")]
		internal static extern double SDLFloorNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_floor")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLFloor([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLFloorNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_floorf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_floorf")]
		internal static extern float SDLFloorfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_floorf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLFloorf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLFloorfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_trunc")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_trunc")]
		internal static extern double SDLTruncNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_trunc")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLTrunc([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLTruncNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_truncf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_truncf")]
		internal static extern float SDLTruncfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_truncf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLTruncf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLTruncfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_fmod")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_fmod")]
		internal static extern double SDLFmodNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y);

		[NativeName(NativeNameType.Func, "SDL_fmod")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLFmod([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y)
		{
			double ret = SDLFmodNative(x, y);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_fmodf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_fmodf")]
		internal static extern float SDLFmodfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y);

		[NativeName(NativeNameType.Func, "SDL_fmodf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLFmodf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			float ret = SDLFmodfNative(x, y);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_log")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_log")]
		internal static extern double SDLLogNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_log")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLLog([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLLogNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_logf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_logf")]
		internal static extern float SDLLogfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_logf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLLogf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLLogfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_log10")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_log10")]
		internal static extern double SDLLog10Native([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_log10")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLLog10([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLLog10Native(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_log10f")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_log10f")]
		internal static extern float SDLLog10FNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_log10f")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLLog10F([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLLog10FNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_pow")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_pow")]
		internal static extern double SDLPowNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y);

		[NativeName(NativeNameType.Func, "SDL_pow")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLPow([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "double")] double y)
		{
			double ret = SDLPowNative(x, y);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_powf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_powf")]
		internal static extern float SDLPowfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y);

		[NativeName(NativeNameType.Func, "SDL_powf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLPowf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			float ret = SDLPowfNative(x, y);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_round")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_round")]
		internal static extern double SDLRoundNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_round")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLRound([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLRoundNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_roundf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_roundf")]
		internal static extern float SDLRoundfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_roundf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLRoundf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLRoundfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lround")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_lround")]
		internal static extern int SDLLroundNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_lround")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLround([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			int ret = SDLLroundNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_lroundf")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_lroundf")]
		internal static extern int SDLLroundfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_lroundf")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLroundf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			int ret = SDLLroundfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_scalbn")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_scalbn")]
		internal static extern double SDLScalbnNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n);

		[NativeName(NativeNameType.Func, "SDL_scalbn")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLScalbn([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			double ret = SDLScalbnNative(x, n);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_scalbnf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_scalbnf")]
		internal static extern float SDLScalbnfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n);

		[NativeName(NativeNameType.Func, "SDL_scalbnf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLScalbnf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "n")] [NativeName(NativeNameType.Type, "int")] int n)
		{
			float ret = SDLScalbnfNative(x, n);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_sin")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_sin")]
		internal static extern double SDLSinNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_sin")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLSin([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLSinNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_sinf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_sinf")]
		internal static extern float SDLSinfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_sinf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLSinf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLSinfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_sqrt")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_sqrt")]
		internal static extern double SDLSqrtNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_sqrt")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLSqrt([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLSqrtNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_sqrtf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_sqrtf")]
		internal static extern float SDLSqrtfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_sqrtf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLSqrtf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLSqrtfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_tan")]
		[return: NativeName(NativeNameType.Type, "double")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_tan")]
		internal static extern double SDLTanNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x);

		[NativeName(NativeNameType.Func, "SDL_tan")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double SDLTan([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "double")] double x)
		{
			double ret = SDLTanNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_tanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_tanf")]
		internal static extern float SDLTanfNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x);

		[NativeName(NativeNameType.Func, "SDL_tanf")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLTanf([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x)
		{
			float ret = SDLTanfNative(x);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_iconv_open")]
		internal static extern SDLIconv SDLIconvOpenNative([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode);

		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv SDLIconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode)
		{
			SDLIconv ret = SDLIconvOpenNative(tocode, fromcode);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv SDLIconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode)
		{
			fixed (byte* ptocode = &tocode)
			{
				SDLIconv ret = SDLIconvOpenNative((byte*)ptocode, fromcode);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv SDLIconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIconv ret = SDLIconvOpenNative(pStr0, fromcode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv SDLIconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				SDLIconv ret = SDLIconvOpenNative(tocode, (byte*)pfromcode);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv SDLIconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLIconv ret = SDLIconvOpenNative(tocode, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv SDLIconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					SDLIconv ret = SDLIconvOpenNative((byte*)ptocode, (byte*)pfromcode);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv_open")]
		[return: NativeName(NativeNameType.Type, "SDL_iconv_t")]
		public static SDLIconv SDLIconvOpen([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLIconv ret = SDLIconvOpenNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_iconv_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_iconv_close")]
		internal static extern int SDLIconvCloseNative([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd);

		[NativeName(NativeNameType.Func, "SDL_iconv_close")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLIconvClose([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd)
		{
			int ret = SDLIconvCloseNative(cd);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_iconv")]
		internal static extern nuint SDLIconvNative([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* outbytesleft);

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* outbytesleft)
		{
			nuint ret = SDLIconvNative(cd, inbuf, inbytesleft, outbuf, outbytesleft);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				nuint ret = SDLIconvNative(cd, (byte**)pinbuf, inbytesleft, outbuf, outbytesleft);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				nuint ret = SDLIconvNative(cd, inbuf, (nuint*)pinbytesleft, outbuf, outbytesleft);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					nuint ret = SDLIconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, outbuf, outbytesleft);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* outbytesleft)
		{
			fixed (byte** poutbuf = &outbuf)
			{
				nuint ret = SDLIconvNative(cd, inbuf, inbytesleft, (byte**)poutbuf, outbytesleft);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					nuint ret = SDLIconvNative(cd, (byte**)pinbuf, inbytesleft, (byte**)poutbuf, outbytesleft);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					nuint ret = SDLIconvNative(cd, inbuf, (nuint*)pinbytesleft, (byte**)poutbuf, outbytesleft);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (byte** poutbuf = &outbuf)
					{
						nuint ret = SDLIconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, (byte**)poutbuf, outbytesleft);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint outbytesleft)
		{
			fixed (nuint* poutbytesleft = &outbytesleft)
			{
				nuint ret = SDLIconvNative(cd, inbuf, inbytesleft, outbuf, (nuint*)poutbytesleft);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = SDLIconvNative(cd, (byte**)pinbuf, inbytesleft, outbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = SDLIconvNative(cd, inbuf, (nuint*)pinbytesleft, outbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] byte** outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = SDLIconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, outbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint outbytesleft)
		{
			fixed (byte** poutbuf = &outbuf)
			{
				fixed (nuint* poutbytesleft = &outbytesleft)
				{
					nuint ret = SDLIconvNative(cd, inbuf, inbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] nuint* inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = SDLIconvNative(cd, (byte**)pinbuf, inbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] byte** inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint outbytesleft)
		{
			fixed (nuint* pinbytesleft = &inbytesleft)
			{
				fixed (byte** poutbuf = &outbuf)
				{
					fixed (nuint* poutbytesleft = &outbytesleft)
					{
						nuint ret = SDLIconvNative(cd, inbuf, (nuint*)pinbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
						return ret;
					}
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_iconv")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLIconv([NativeName(NativeNameType.Param, "cd")] [NativeName(NativeNameType.Type, "SDL_iconv_t")] SDLIconv cd, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char**")] ref byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint inbytesleft, [NativeName(NativeNameType.Param, "outbuf")] [NativeName(NativeNameType.Type, "char**")] ref byte* outbuf, [NativeName(NativeNameType.Param, "outbytesleft")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint outbytesleft)
		{
			fixed (byte** pinbuf = &inbuf)
			{
				fixed (nuint* pinbytesleft = &inbytesleft)
				{
					fixed (byte** poutbuf = &outbuf)
					{
						fixed (nuint* poutbytesleft = &outbytesleft)
						{
							nuint ret = SDLIconvNative(cd, (byte**)pinbuf, (nuint*)pinbytesleft, (byte**)poutbuf, (nuint*)poutbytesleft);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// This function converts a buffer or string between encodings in one pass, returning a<br/>
		/// string that must be freed with SDL_free() or NULL on error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_iconv_string")]
		internal static extern byte* SDLIconvStringNative([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft);

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* ret = SDLIconvStringNative(tocode, fromcode, inbuf, inbytesleft);
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, fromcode, inbuf, inbytesleft));
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				byte* ret = SDLIconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				string ret = Utils.DecodeStringUTF8(SDLIconvStringNative((byte*)ptocode, fromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLIconvStringNative(pStr0, fromcode, inbuf, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(pStr0, fromcode, inbuf, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				byte* ret = SDLIconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, (byte*)pfromcode, inbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLIconvStringNative(tocode, pStr0, inbuf, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, pStr0, inbuf, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					byte* ret = SDLIconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					string ret = Utils.DecodeStringUTF8(SDLIconvStringNative((byte*)ptocode, (byte*)pfromcode, inbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = SDLIconvStringNative(pStr0, pStr1, inbuf, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] byte* inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(pStr0, pStr1, inbuf, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				byte* ret = SDLIconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft);
				return ret;
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pinbuf = &inbuf)
			{
				string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, fromcode, (byte*)pinbuf, inbytesleft));
				return ret;
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLIconvStringNative(tocode, fromcode, pStr0, inbytesleft);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inbuf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inbuf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, fromcode, pStr0, inbytesleft));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					byte* ret = SDLIconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					string ret = Utils.DecodeStringUTF8(SDLIconvStringNative((byte*)ptocode, fromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = SDLIconvStringNative(pStr0, fromcode, pStr1, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] byte* fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(pStr0, fromcode, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					byte* ret = SDLIconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
					return ret;
				}
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* pfromcode = &fromcode)
			{
				fixed (byte* pinbuf = &inbuf)
				{
					string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
					return ret;
				}
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = SDLIconvStringNative(tocode, pStr0, pStr1, inbytesleft);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] byte* tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fromcode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fromcode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inbuf != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inbuf, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(tocode, pStr0, pStr1, inbytesleft));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					fixed (byte* pinbuf = &inbuf)
					{
						byte* ret = SDLIconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] ref byte tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] ref byte fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] ref byte inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			fixed (byte* ptocode = &tocode)
			{
				fixed (byte* pfromcode = &fromcode)
				{
					fixed (byte* pinbuf = &inbuf)
					{
						string ret = Utils.DecodeStringUTF8(SDLIconvStringNative((byte*)ptocode, (byte*)pfromcode, (byte*)pinbuf, inbytesleft));
						return ret;
					}
				}
			}
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLIconvString([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (inbuf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(inbuf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			byte* ret = SDLIconvStringNative(pStr0, pStr1, pStr2, inbytesleft);
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// This function converts a buffer or string between encodings in one pass, returning a<br/>		/// string that must be freed with SDL_free() or NULL on error.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_iconv_string")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLIconvStringS([NativeName(NativeNameType.Param, "tocode")] [NativeName(NativeNameType.Type, "const char*")] string tocode, [NativeName(NativeNameType.Param, "fromcode")] [NativeName(NativeNameType.Type, "const char*")] string fromcode, [NativeName(NativeNameType.Param, "inbuf")] [NativeName(NativeNameType.Type, "const char*")] string inbuf, [NativeName(NativeNameType.Param, "inbytesleft")] [NativeName(NativeNameType.Type, "size_t")] nuint inbytesleft)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tocode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tocode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tocode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fromcode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fromcode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fromcode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* pStr2 = null;
			int pStrSize2 = 0;
			if (inbuf != null)
			{
				pStrSize2 = Utils.GetByteCountUTF8(inbuf);
				if (pStrSize2 >= Utils.MaxStackallocSize)
				{
					pStr2 = Utils.Alloc<byte>(pStrSize2 + 1);
				}
				else
				{
					byte* pStrStack2 = stackalloc byte[pStrSize2 + 1];
					pStr2 = pStrStack2;
				}
				int pStrOffset2 = Utils.EncodeStringUTF8(inbuf, pStr2, pStrSize2);
				pStr2[pStrOffset2] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLIconvStringNative(pStr0, pStr1, pStr2, inbytesleft));
			if (pStrSize2 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr2);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_main")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_main")]
		internal static extern int SDLMainNative([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char*[-1]")] byte** argv);

		[NativeName(NativeNameType.Func, "SDL_main")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLMain([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char*[-1]")] byte** argv)
		{
			int ret = SDLMainNative(argc, argv);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_main")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLMain([NativeName(NativeNameType.Param, "argc")] [NativeName(NativeNameType.Type, "int")] int argc, [NativeName(NativeNameType.Param, "argv")] [NativeName(NativeNameType.Type, "char*[-1]")] string[] argv)
		{
			byte** pStrArray0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(argv);
			if (argv != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < argv.Length; i++)
			{
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(argv[i]);
			}
			int ret = SDLMainNative(argc, pStrArray0);
			for (int i = 0; i < argv.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
			}
			return ret;
		}

		/// <summary>
		/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>
		/// point.<br/>
		/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>
		/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>
		/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>
		/// including SDL.h.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetMainReady")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetMainReady")]
		internal static extern void SDLSetMainReadyNative();

		/// <summary>		/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>		/// point.<br/>		/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>		/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>		/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>		/// including SDL.h.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetMainReady")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetMainReady()
		{
			SDLSetMainReadyNative();
		}

		/// <summary>
		/// Register a win32 window class for SDL's use.<br/>
		/// This can be called to set the application window class at startup. It is<br/>
		/// safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
		/// while a previous registration is still active will be ignored, other than<br/>
		/// to increment a counter.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when initializing the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RegisterApp")]
		internal static extern int SDLRegisterAppNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void*")] void* hInst);

		/// <summary>		/// Register a win32 window class for SDL's use.<br/>		/// This can be called to set the application window class at startup. It is<br/>		/// safe to call this multiple times, as long as every call is eventually<br/>		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>		/// while a previous registration is still active will be ignored, other than<br/>		/// to increment a counter.<br/>		/// Most applications do not need to, and should not, call this directly; SDL<br/>		/// will call it when initializing the video subsystem.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void*")] void* hInst)
		{
			int ret = SDLRegisterAppNative(name, style, hInst);
			return ret;
		}

		/// <summary>		/// Register a win32 window class for SDL's use.<br/>		/// This can be called to set the application window class at startup. It is<br/>		/// safe to call this multiple times, as long as every call is eventually<br/>		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>		/// while a previous registration is still active will be ignored, other than<br/>		/// to increment a counter.<br/>		/// Most applications do not need to, and should not, call this directly; SDL<br/>		/// will call it when initializing the video subsystem.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void*")] void* hInst)
		{
			fixed (byte* pname = &name)
			{
				int ret = SDLRegisterAppNative((byte*)pname, style, hInst);
				return ret;
			}
		}

		/// <summary>		/// Register a win32 window class for SDL's use.<br/>		/// This can be called to set the application window class at startup. It is<br/>		/// safe to call this multiple times, as long as every call is eventually<br/>		/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>		/// while a previous registration is still active will be ignored, other than<br/>		/// to increment a counter.<br/>		/// Most applications do not need to, and should not, call this directly; SDL<br/>		/// will call it when initializing the video subsystem.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RegisterApp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRegisterApp([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "style")] [NativeName(NativeNameType.Type, "Uint32")] uint style, [NativeName(NativeNameType.Param, "hInst")] [NativeName(NativeNameType.Type, "void*")] void* hInst)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLRegisterAppNative(pStr0, style, hInst);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>
		/// This can be called to undo the effects of SDL_RegisterApp.<br/>
		/// Most applications do not need to, and should not, call this directly; SDL<br/>
		/// will call it when deinitializing the video subsystem.<br/>
		/// It is safe to call this multiple times, as long as every call is eventually<br/>
		/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>
		/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>
		/// zero through calls to this function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnregisterApp")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnregisterApp")]
		internal static extern void SDLUnregisterAppNative();

		/// <summary>		/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>		/// This can be called to undo the effects of SDL_RegisterApp.<br/>		/// Most applications do not need to, and should not, call this directly; SDL<br/>		/// will call it when deinitializing the video subsystem.<br/>		/// It is safe to call this multiple times, as long as every call is eventually<br/>		/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>		/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>		/// zero through calls to this function.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnregisterApp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnregisterApp()
		{
			SDLUnregisterAppNative();
		}

		/// <summary>
		/// Don't include intrin.h here because it contains C++ code <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "__debugbreak")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "__debugbreak")]
		internal static extern void DebugbreakNative();

		/// <summary>		/// Don't include intrin.h here because it contains C++ code <br/>		/// </summary>		[NativeName(NativeNameType.Func, "__debugbreak")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Debugbreak()
		{
			DebugbreakNative();
		}

		/// <summary>
		/// Set an application-defined assertion handler.<br/>
		/// This function allows an application to show its own assertion UI and/or<br/>
		/// force the response to an assertion failure. If the application doesn't<br/>
		/// provide this, SDL will try to do the right thing, popping up a<br/>
		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>
		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>
		/// it will only fire from one thread at a time.<br/>
		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetAssertionHandler")]
		internal static extern void SDLSetAssertionHandlerNative([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] SDLAssertionHandler handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Set an application-defined assertion handler.<br/>		/// This function allows an application to show its own assertion UI and/or<br/>		/// force the response to an assertion failure. If the application doesn't<br/>		/// provide this, SDL will try to do the right thing, popping up a<br/>		/// system-specific GUI dialog, and probably minimizing any fullscreen windows.<br/>		/// This callback may fire from any thread, but it runs wrapped in a mutex, so<br/>		/// it will only fire from one thread at a time.<br/>		/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetAssertionHandler([NativeName(NativeNameType.Param, "handler")] [NativeName(NativeNameType.Type, "SDL_AssertionHandler")] SDLAssertionHandler handler, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLSetAssertionHandlerNative(handler, userdata);
		}

		/// <summary>
		/// Get the default assertion handler.<br/>
		/// This returns the function pointer that is called by default when an<br/>
		/// assertion is triggered. This is an internal function provided by SDL, that<br/>
		/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>
		/// provide a different function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDefaultAssertionHandler")]
		internal static extern SDLAssertionHandler SDLGetDefaultAssertionHandlerNative();

		/// <summary>		/// Get the default assertion handler.<br/>		/// This returns the function pointer that is called by default when an<br/>		/// assertion is triggered. This is an internal function provided by SDL, that<br/>		/// is used for assertions when SDL_SetAssertionHandler() hasn't been used to<br/>		/// provide a different function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		public static SDLAssertionHandler SDLGetDefaultAssertionHandler()
		{
			SDLAssertionHandler ret = SDLGetDefaultAssertionHandlerNative();
			return ret;
		}

		/// <summary>
		/// Get the current assertion handler.<br/>
		/// This returns the function pointer that is called when an assertion is<br/>
		/// triggered. This is either the value last passed to<br/>
		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>
		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>
		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>
		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>
		/// will always be NULL for the default handler. If you don't care about this<br/>
		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetAssertionHandler")]
		internal static extern SDLAssertionHandler SDLGetAssertionHandlerNative([NativeName(NativeNameType.Param, "puserdata")] [NativeName(NativeNameType.Type, "void**")] void** puserdata);

		/// <summary>		/// Get the current assertion handler.<br/>		/// This returns the function pointer that is called when an assertion is<br/>		/// triggered. This is either the value last passed to<br/>		/// SDL_SetAssertionHandler(), or if no application-specified function is set,<br/>		/// is equivalent to calling SDL_GetDefaultAssertionHandler().<br/>		/// The parameter `puserdata` is a pointer to a void*, which will store the<br/>		/// "userdata" pointer that was passed to SDL_SetAssertionHandler(). This value<br/>		/// will always be NULL for the default handler. If you don't care about this<br/>		/// data, it is safe to pass a NULL pointer to this function to ignore it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAssertionHandler")]
		[return: NativeName(NativeNameType.Type, "SDL_AssertionHandler")]
		public static SDLAssertionHandler SDLGetAssertionHandler([NativeName(NativeNameType.Param, "puserdata")] [NativeName(NativeNameType.Type, "void**")] void** puserdata)
		{
			SDLAssertionHandler ret = SDLGetAssertionHandlerNative(puserdata);
			return ret;
		}

		/// <summary>
		/// Get a list of all assertion failures.<br/>
		/// This function gets all assertions triggered since the last call to<br/>
		/// SDL_ResetAssertionReport(), or the start of the program.<br/>
		/// The proper way to examine this data looks something like this:<br/>
		/// ```c<br/>
		/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>
		/// while (item) {<br/>
		/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>
		/// item->condition, item->function, item->filename,<br/>
		/// item->linenum, item->trigger_count,<br/>
		/// item->always_ignore ? "yes" : "no");<br/>
		/// item = item->next;<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "const SDL_AssertData*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetAssertionReport")]
		internal static extern SDLAssertData* SDLGetAssertionReportNative();

		/// <summary>		/// Get a list of all assertion failures.<br/>		/// This function gets all assertions triggered since the last call to<br/>		/// SDL_ResetAssertionReport(), or the start of the program.<br/>		/// The proper way to examine this data looks something like this:<br/>		/// ```c<br/>		/// const SDL_AssertData *item = SDL_GetAssertionReport();<br/>		/// while (item) {<br/>		/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",<br/>		/// item->condition, item->function, item->filename,<br/>		/// item->linenum, item->trigger_count,<br/>		/// item->always_ignore ? "yes" : "no");<br/>		/// item = item->next;<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "const SDL_AssertData*")]
		public static SDLAssertData* SDLGetAssertionReport()
		{
			SDLAssertData* ret = SDLGetAssertionReportNative();
			return ret;
		}

		/// <summary>
		/// Clear the list of all assertion failures.<br/>
		/// This function will clear the list of all assertions triggered up to that<br/>
		/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>
		/// no items. In addition, any previously-triggered assertions will be reset to<br/>
		/// a trigger_count of zero, and their always_ignore state will be false.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ResetAssertionReport")]
		internal static extern void SDLResetAssertionReportNative();

		/// <summary>		/// Clear the list of all assertion failures.<br/>		/// This function will clear the list of all assertions triggered up to that<br/>		/// point. Immediately following this call, SDL_GetAssertionReport will return<br/>		/// no items. In addition, any previously-triggered assertions will be reset to<br/>		/// a trigger_count of zero, and their always_ignore state will be false.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ResetAssertionReport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLResetAssertionReport()
		{
			SDLResetAssertionReportNative();
		}

		/// <summary>
		/// Try to lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicTryLock")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicTryLock")]
		internal static extern SDLBool SDLAtomicTryLockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0);

		/// <summary>		/// Try to lock a spin lock by setting it to a non-zero value.<br/>		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>		/// doing. Please be careful using any sort of spinlock!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicTryLock")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLAtomicTryLock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0)
		{
			SDLBool ret = SDLAtomicTryLockNative(lock0);
			return ret;
		}

		/// <summary>		/// Try to lock a spin lock by setting it to a non-zero value.<br/>		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>		/// doing. Please be careful using any sort of spinlock!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicTryLock")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLAtomicTryLock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				SDLBool ret = SDLAtomicTryLockNative((int*)plock0);
				return ret;
			}
		}

		/// <summary>
		/// Lock a spin lock by setting it to a non-zero value.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicLock")]
		internal static extern void SDLAtomicLockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0);

		/// <summary>		/// Lock a spin lock by setting it to a non-zero value.<br/>		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>		/// doing. Please be careful using any sort of spinlock!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAtomicLock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0)
		{
			SDLAtomicLockNative(lock0);
		}

		/// <summary>		/// Lock a spin lock by setting it to a non-zero value.<br/>		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>		/// doing. Please be careful using any sort of spinlock!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicLock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAtomicLock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				SDLAtomicLockNative((int*)plock0);
			}
		}

		/// <summary>
		/// Unlock a spin lock by setting it to 0.<br/>
		/// Always returns immediately.<br/>
		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
		/// doing. Please be careful using any sort of spinlock!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicUnlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicUnlock")]
		internal static extern void SDLAtomicUnlockNative([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0);

		/// <summary>		/// Unlock a spin lock by setting it to 0.<br/>		/// Always returns immediately.<br/>		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>		/// doing. Please be careful using any sort of spinlock!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicUnlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAtomicUnlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] int* lock0)
		{
			SDLAtomicUnlockNative(lock0);
		}

		/// <summary>		/// Unlock a spin lock by setting it to 0.<br/>		/// Always returns immediately.<br/>		/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>		/// doing. Please be careful using any sort of spinlock!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicUnlock")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAtomicUnlock([NativeName(NativeNameType.Param, "lock")] [NativeName(NativeNameType.Type, "SDL_SpinLock*")] ref int lock0)
		{
			fixed (int* plock0 = &lock0)
			{
				SDLAtomicUnlockNative((int*)plock0);
			}
		}

		/// <summary>
		/// Memory barriers are designed to prevent reads and writes from being<br/>
		/// reordered by the compiler and being seen out of order on multi-core CPUs.<br/>
		/// A typical pattern would be for thread A to write some data and a flag, and<br/>
		/// for thread B to read the flag and get the data. In this case you would<br/>
		/// insert a release barrier between writing the data and the flag,<br/>
		/// guaranteeing that the data write completes no later than the flag is<br/>
		/// written, and you would insert an acquire barrier between reading the flag<br/>
		/// and reading the data, to ensure that all the reads associated with the flag<br/>
		/// have completed.<br/>
		/// In this pattern you should always see a release barrier paired with an<br/>
		/// acquire barrier and you should gate the data reads/writes with a single<br/>
		/// flag variable.<br/>
		/// For more information on these semantics, take a look at the blog post:<br/>
		/// http://preshing.com/20120913/acquire-and-release-semantics<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierReleaseFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MemoryBarrierReleaseFunction")]
		internal static extern void SDLMemoryBarrierReleaseFunctionNative();

		/// <summary>		/// Memory barriers are designed to prevent reads and writes from being<br/>		/// reordered by the compiler and being seen out of order on multi-core CPUs.<br/>		/// A typical pattern would be for thread A to write some data and a flag, and<br/>		/// for thread B to read the flag and get the data. In this case you would<br/>		/// insert a release barrier between writing the data and the flag,<br/>		/// guaranteeing that the data write completes no later than the flag is<br/>		/// written, and you would insert an acquire barrier between reading the flag<br/>		/// and reading the data, to ensure that all the reads associated with the flag<br/>		/// have completed.<br/>		/// In this pattern you should always see a release barrier paired with an<br/>		/// acquire barrier and you should gate the data reads/writes with a single<br/>		/// flag variable.<br/>		/// For more information on these semantics, take a look at the blog post:<br/>		/// http://preshing.com/20120913/acquire-and-release-semantics<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierReleaseFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMemoryBarrierReleaseFunction()
		{
			SDLMemoryBarrierReleaseFunctionNative();
		}

		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierAcquireFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MemoryBarrierAcquireFunction")]
		internal static extern void SDLMemoryBarrierAcquireFunctionNative();

		[NativeName(NativeNameType.Func, "SDL_MemoryBarrierAcquireFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMemoryBarrierAcquireFunction()
		{
			SDLMemoryBarrierAcquireFunctionNative();
		}

		/// <summary>
		/// Set an atomic variable to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicCAS")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicCAS")]
		internal static extern SDLBool SDLAtomicCASNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval);

		/// <summary>		/// Set an atomic variable to a new value if it is currently an old value.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicCAS")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLAtomicCAS([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval)
		{
			SDLBool ret = SDLAtomicCASNative(a, oldval, newval);
			return ret;
		}

		/// <summary>		/// Set an atomic variable to a new value if it is currently an old value.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicCAS")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLAtomicCAS([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] ref SDLAtomic a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "int")] int oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "int")] int newval)
		{
			fixed (SDLAtomic* pa = &a)
			{
				SDLBool ret = SDLAtomicCASNative((SDLAtomic*)pa, oldval, newval);
				return ret;
			}
		}

		/// <summary>
		/// Set an atomic variable to a value.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicSet")]
		internal static extern int SDLAtomicSetNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v);

		/// <summary>		/// Set an atomic variable to a value.<br/>		/// This function also acts as a full memory barrier.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtomicSet([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			int ret = SDLAtomicSetNative(a, v);
			return ret;
		}

		/// <summary>		/// Set an atomic variable to a value.<br/>		/// This function also acts as a full memory barrier.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtomicSet([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] ref SDLAtomic a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			fixed (SDLAtomic* pa = &a)
			{
				int ret = SDLAtomicSetNative((SDLAtomic*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Get the value of an atomic variable.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicGet")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicGet")]
		internal static extern int SDLAtomicGetNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a);

		/// <summary>		/// Get the value of an atomic variable.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicGet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtomicGet([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a)
		{
			int ret = SDLAtomicGetNative(a);
			return ret;
		}

		/// <summary>		/// Get the value of an atomic variable.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicGet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtomicGet([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] ref SDLAtomic a)
		{
			fixed (SDLAtomic* pa = &a)
			{
				int ret = SDLAtomicGetNative((SDLAtomic*)pa);
				return ret;
			}
		}

		/// <summary>
		/// Add to an atomic variable.<br/>
		/// This function also acts as a full memory barrier.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicAdd")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicAdd")]
		internal static extern int SDLAtomicAddNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v);

		/// <summary>		/// Add to an atomic variable.<br/>		/// This function also acts as a full memory barrier.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicAdd")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtomicAdd([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] SDLAtomic* a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			int ret = SDLAtomicAddNative(a, v);
			return ret;
		}

		/// <summary>		/// Add to an atomic variable.<br/>		/// This function also acts as a full memory barrier.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicAdd")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAtomicAdd([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "SDL_atomic_t*")] ref SDLAtomic a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "int")] int v)
		{
			fixed (SDLAtomic* pa = &a)
			{
				int ret = SDLAtomicAddNative((SDLAtomic*)pa, v);
				return ret;
			}
		}

		/// <summary>
		/// Set a pointer to a new value if it is currently an old value.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicCASPtr")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicCASPtr")]
		internal static extern SDLBool SDLAtomicCASPtrNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void*")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void*")] void* newval);

		/// <summary>		/// Set a pointer to a new value if it is currently an old value.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicCASPtr")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLAtomicCASPtr([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a, [NativeName(NativeNameType.Param, "oldval")] [NativeName(NativeNameType.Type, "void*")] void* oldval, [NativeName(NativeNameType.Param, "newval")] [NativeName(NativeNameType.Type, "void*")] void* newval)
		{
			SDLBool ret = SDLAtomicCASPtrNative(a, oldval, newval);
			return ret;
		}

		/// <summary>
		/// Set a pointer to a value atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicSetPtr")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicSetPtr")]
		internal static extern void* SDLAtomicSetPtrNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void*")] void* v);

		/// <summary>		/// Set a pointer to a value atomically.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicSetPtr")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLAtomicSetPtr([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "void*")] void* v)
		{
			void* ret = SDLAtomicSetPtrNative(a, v);
			return ret;
		}

		/// <summary>
		/// Get the value of a pointer atomically.<br/>
		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
		/// it!***<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AtomicGetPtr")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AtomicGetPtr")]
		internal static extern void* SDLAtomicGetPtrNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a);

		/// <summary>		/// Get the value of a pointer atomically.<br/>		/// ***Note: If you don't know what this function is for, you shouldn't use<br/>		/// it!***<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AtomicGetPtr")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLAtomicGetPtr([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "void**")] void** a)
		{
			void* ret = SDLAtomicGetPtrNative(a);
			return ret;
		}

		/// <summary>
		/// Set the SDL error message for the current thread.<br/>
		/// Calling this function will replace any previous error message that was set.<br/>
		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>
		/// failing result, leading to this idiom:<br/>
		/// ```c<br/>
		/// if (error_code) {<br/>
		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetError")]
		internal static extern int SDLSetErrorNative([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		/// <summary>		/// Set the SDL error message for the current thread.<br/>		/// Calling this function will replace any previous error message that was set.<br/>		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>		/// failing result, leading to this idiom:<br/>		/// ```c<br/>		/// if (error_code) {<br/>		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			int ret = SDLSetErrorNative(fmt);
			return ret;
		}

		/// <summary>		/// Set the SDL error message for the current thread.<br/>		/// Calling this function will replace any previous error message that was set.<br/>		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>		/// failing result, leading to this idiom:<br/>		/// ```c<br/>		/// if (error_code) {<br/>		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				int ret = SDLSetErrorNative((byte*)pfmt);
				return ret;
			}
		}

		/// <summary>		/// Set the SDL error message for the current thread.<br/>		/// Calling this function will replace any previous error message that was set.<br/>		/// This function always returns -1, since SDL frequently uses -1 to signify an<br/>		/// failing result, leading to this idiom:<br/>		/// ```c<br/>		/// if (error_code) {<br/>		/// return SDL_SetError("This operation has failed: %d", error_code);<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetError")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetError([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLSetErrorNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Retrieve a message about the last error that occurred on the current<br/>
		/// thread.<br/>
		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
		/// Only the last error is returned.<br/>
		/// The message is only applicable when an SDL function has signaled an error.<br/>
		/// You must check the return values of SDL function calls to determine when to<br/>
		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
		/// an error string even when reporting success.<br/>
		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
		/// check return values for failure cases before you can assume the error<br/>
		/// string applies.<br/>
		/// Error strings are set per-thread, so an error set in a different thread<br/>
		/// will not interfere with the current thread's operation.<br/>
		/// The returned string is internally allocated and must not be freed by the<br/>
		/// application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetError")]
		internal static extern byte* SDLGetErrorNative();

		/// <summary>		/// Retrieve a message about the last error that occurred on the current<br/>		/// thread.<br/>		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>		/// Only the last error is returned.<br/>		/// The message is only applicable when an SDL function has signaled an error.<br/>		/// You must check the return values of SDL function calls to determine when to<br/>		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>		/// an error string even when reporting success.<br/>		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>		/// check return values for failure cases before you can assume the error<br/>		/// string applies.<br/>		/// Error strings are set per-thread, so an error set in a different thread<br/>		/// will not interfere with the current thread's operation.<br/>		/// The returned string is internally allocated and must not be freed by the<br/>		/// application.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetError()
		{
			byte* ret = SDLGetErrorNative();
			return ret;
		}

		/// <summary>		/// Retrieve a message about the last error that occurred on the current<br/>		/// thread.<br/>		/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>		/// Only the last error is returned.<br/>		/// The message is only applicable when an SDL function has signaled an error.<br/>		/// You must check the return values of SDL function calls to determine when to<br/>		/// appropriately call SDL_GetError(). You should *not* use the results of<br/>		/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>		/// an error string even when reporting success.<br/>		/// SDL will *not* clear the error string for successful API calls. You *must*<br/>		/// check return values for failure cases before you can assume the error<br/>		/// string applies.<br/>		/// Error strings are set per-thread, so an error set in a different thread<br/>		/// will not interfere with the current thread's operation.<br/>		/// The returned string is internally allocated and must not be freed by the<br/>		/// application.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetError")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetErrorS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetErrorNative());
			return ret;
		}

		/// <summary>
		/// Get the last error message that was set for the current thread.<br/>
		/// This allows the caller to copy the error string into a provided buffer, but<br/>
		/// otherwise operates exactly the same as SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetErrorMsg")]
		internal static extern byte* SDLGetErrorMsgNative([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] byte* errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen);

		/// <summary>		/// Get the last error message that was set for the current thread.<br/>		/// This allows the caller to copy the error string into a provided buffer, but<br/>		/// otherwise operates exactly the same as SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetErrorMsg([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] byte* errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen)
		{
			byte* ret = SDLGetErrorMsgNative(errstr, maxlen);
			return ret;
		}

		/// <summary>		/// Get the last error message that was set for the current thread.<br/>		/// This allows the caller to copy the error string into a provided buffer, but<br/>		/// otherwise operates exactly the same as SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetErrorMsgS([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] byte* errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetErrorMsgNative(errstr, maxlen));
			return ret;
		}

		/// <summary>		/// Get the last error message that was set for the current thread.<br/>		/// This allows the caller to copy the error string into a provided buffer, but<br/>		/// otherwise operates exactly the same as SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetErrorMsg([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] ref byte errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen)
		{
			fixed (byte* perrstr = &errstr)
			{
				byte* ret = SDLGetErrorMsgNative((byte*)perrstr, maxlen);
				return ret;
			}
		}

		/// <summary>		/// Get the last error message that was set for the current thread.<br/>		/// This allows the caller to copy the error string into a provided buffer, but<br/>		/// otherwise operates exactly the same as SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetErrorMsgS([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] ref byte errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen)
		{
			fixed (byte* perrstr = &errstr)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetErrorMsgNative((byte*)perrstr, maxlen));
				return ret;
			}
		}

		/// <summary>		/// Get the last error message that was set for the current thread.<br/>		/// This allows the caller to copy the error string into a provided buffer, but<br/>		/// otherwise operates exactly the same as SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetErrorMsg([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] ref string errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (errstr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(errstr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(errstr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLGetErrorMsgNative(pStr0, maxlen);
			errstr = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get the last error message that was set for the current thread.<br/>		/// This allows the caller to copy the error string into a provided buffer, but<br/>		/// otherwise operates exactly the same as SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetErrorMsg")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetErrorMsgS([NativeName(NativeNameType.Param, "errstr")] [NativeName(NativeNameType.Type, "char*")] ref string errstr, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "int")] int maxlen)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (errstr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(errstr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(errstr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLGetErrorMsgNative(pStr0, maxlen));
			errstr = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Clear any previous error message for this thread.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearError")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ClearError")]
		internal static extern void SDLClearErrorNative();

		/// <summary>		/// Clear any previous error message for this thread.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ClearError")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLClearError()
		{
			SDLClearErrorNative();
		}

		/// <summary>
		/// SDL_Error() unconditionally returns -1. <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Error")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Error")]
		internal static extern int SDLErrorNative([NativeName(NativeNameType.Param, "code")] [NativeName(NativeNameType.Type, "SDL_errorcode")] SDLErrorcode code);

		/// <summary>		/// SDL_Error() unconditionally returns -1. <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Error")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLError([NativeName(NativeNameType.Param, "code")] [NativeName(NativeNameType.Type, "SDL_errorcode")] SDLErrorcode code)
		{
			int ret = SDLErrorNative(code);
			return ret;
		}

		/// <summary>
		/// Create a new mutex.<br/>
		/// All newly-created mutexes begin in the _unlocked_ state.<br/>
		/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>
		/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>
		/// SDL mutexes are reentrant.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateMutex")]
		[return: NativeName(NativeNameType.Type, "SDL_mutex*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateMutex")]
		internal static extern SDLMutex* SDLCreateMutexNative();

		/// <summary>		/// Create a new mutex.<br/>		/// All newly-created mutexes begin in the _unlocked_ state.<br/>		/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>		/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>		/// SDL mutexes are reentrant.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateMutex")]
		[return: NativeName(NativeNameType.Type, "SDL_mutex*")]
		public static SDLMutex* SDLCreateMutex()
		{
			SDLMutex* ret = SDLCreateMutexNative();
			return ret;
		}

		/// <summary>
		/// Lock the mutex.<br/>
		/// This will block until the mutex is available, which is to say it is in the<br/>
		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LockMutex")]
		internal static extern int SDLLockMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>		/// Lock the mutex.<br/>		/// This will block until the mutex is available, which is to say it is in the<br/>		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>		/// unlock it the same number of times before it is actually made available for<br/>		/// other threads in the system (this is known as a "recursive mutex").<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			int ret = SDLLockMutexNative(mutex);
			return ret;
		}

		/// <summary>		/// Lock the mutex.<br/>		/// This will block until the mutex is available, which is to say it is in the<br/>		/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>		/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>		/// unlock it the same number of times before it is actually made available for<br/>		/// other threads in the system (this is known as a "recursive mutex").<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = SDLLockMutexNative((SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>
		/// Try to lock a mutex without blocking.<br/>
		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
		/// this function returns `SDL_MUTEX_TIMEOUT` immediately.<br/>
		/// This technique is useful if you need exclusive access to a resource but<br/>
		/// don't want to wait for it, and will return to it to try again later.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TryLockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_TryLockMutex")]
		internal static extern int SDLTryLockMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>		/// Try to lock a mutex without blocking.<br/>		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>		/// this function returns `SDL_MUTEX_TIMEOUT` immediately.<br/>		/// This technique is useful if you need exclusive access to a resource but<br/>		/// don't want to wait for it, and will return to it to try again later.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_TryLockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLTryLockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			int ret = SDLTryLockMutexNative(mutex);
			return ret;
		}

		/// <summary>		/// Try to lock a mutex without blocking.<br/>		/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>		/// this function returns `SDL_MUTEX_TIMEOUT` immediately.<br/>		/// This technique is useful if you need exclusive access to a resource but<br/>		/// don't want to wait for it, and will return to it to try again later.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_TryLockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLTryLockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = SDLTryLockMutexNative((SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>
		/// Unlock the mutex.<br/>
		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
		/// unlock it the same number of times before it is actually made available for<br/>
		/// other threads in the system (this is known as a "recursive mutex").<br/>
		/// It is an error to unlock a mutex that has not been locked by the current<br/>
		/// thread, and doing so results in undefined behavior.<br/>
		/// It is also an error to unlock a mutex that isn't locked at all.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnlockMutex")]
		internal static extern int SDLUnlockMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>		/// Unlock the mutex.<br/>		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>		/// unlock it the same number of times before it is actually made available for<br/>		/// other threads in the system (this is known as a "recursive mutex").<br/>		/// It is an error to unlock a mutex that has not been locked by the current<br/>		/// thread, and doing so results in undefined behavior.<br/>		/// It is also an error to unlock a mutex that isn't locked at all.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUnlockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			int ret = SDLUnlockMutexNative(mutex);
			return ret;
		}

		/// <summary>		/// Unlock the mutex.<br/>		/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>		/// unlock it the same number of times before it is actually made available for<br/>		/// other threads in the system (this is known as a "recursive mutex").<br/>		/// It is an error to unlock a mutex that has not been locked by the current<br/>		/// thread, and doing so results in undefined behavior.<br/>		/// It is also an error to unlock a mutex that isn't locked at all.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockMutex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUnlockMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = SDLUnlockMutexNative((SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a mutex created with SDL_CreateMutex().<br/>
		/// This function must be called on any mutex that is no longer needed. Failure<br/>
		/// to destroy a mutex will result in a system memory or resource leak. While<br/>
		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
		/// on the platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DestroyMutex")]
		internal static extern void SDLDestroyMutexNative([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>		/// Destroy a mutex created with SDL_CreateMutex().<br/>		/// This function must be called on any mutex that is no longer needed. Failure<br/>		/// to destroy a mutex will result in a system memory or resource leak. While<br/>		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>		/// on the platform.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			SDLDestroyMutexNative(mutex);
		}

		/// <summary>		/// Destroy a mutex created with SDL_CreateMutex().<br/>		/// This function must be called on any mutex that is no longer needed. Failure<br/>		/// to destroy a mutex will result in a system memory or resource leak. While<br/>		/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>		/// to destroy a locked mutex, and may result in undefined behavior depending<br/>		/// on the platform.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyMutex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyMutex([NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				SDLDestroyMutexNative((SDLMutex*)pmutex);
			}
		}

		/// <summary>
		/// Create a semaphore.<br/>
		/// This function creates a new semaphore and initializes it with the value<br/>
		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
		/// decrement the semaphore value and potentially block if the semaphore value<br/>
		/// is 0. Each post operation will atomically increment the semaphore value and<br/>
		/// wake waiting threads and allow them to retry the wait operation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSemaphore")]
		[return: NativeName(NativeNameType.Type, "SDL_sem*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateSemaphore")]
		internal static extern SDLSemaphore* SDLCreateSemaphoreNative([NativeName(NativeNameType.Param, "initial_value")] [NativeName(NativeNameType.Type, "Uint32")] uint initialValue);

		/// <summary>		/// Create a semaphore.<br/>		/// This function creates a new semaphore and initializes it with the value<br/>		/// `initial_value`. Each wait operation on the semaphore will atomically<br/>		/// decrement the semaphore value and potentially block if the semaphore value<br/>		/// is 0. Each post operation will atomically increment the semaphore value and<br/>		/// wake waiting threads and allow them to retry the wait operation.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateSemaphore")]
		[return: NativeName(NativeNameType.Type, "SDL_sem*")]
		public static SDLSemaphore* SDLCreateSemaphore([NativeName(NativeNameType.Param, "initial_value")] [NativeName(NativeNameType.Type, "Uint32")] uint initialValue)
		{
			SDLSemaphore* ret = SDLCreateSemaphoreNative(initialValue);
			return ret;
		}

		/// <summary>
		/// Destroy a semaphore.<br/>
		/// It is not safe to destroy a semaphore if there are threads currently<br/>
		/// waiting on it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DestroySemaphore")]
		internal static extern void SDLDestroySemaphoreNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>		/// Destroy a semaphore.<br/>		/// It is not safe to destroy a semaphore if there are threads currently<br/>		/// waiting on it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroySemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			SDLDestroySemaphoreNative(sem);
		}

		/// <summary>		/// Destroy a semaphore.<br/>		/// It is not safe to destroy a semaphore if there are threads currently<br/>		/// waiting on it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroySemaphore")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroySemaphore([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				SDLDestroySemaphoreNative((SDLSemaphore*)psem);
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>
		/// signal or error. If the call is successful it will atomically decrement the<br/>
		/// semaphore value.<br/>
		/// This function is the equivalent of calling SDL_SemWaitTimeout() with a time<br/>
		/// length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SemWait")]
		internal static extern int SDLSemWaitNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>		/// Wait until a semaphore has a positive value and then decrements it.<br/>		/// This function suspends the calling thread until either the semaphore<br/>		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>		/// signal or error. If the call is successful it will atomically decrement the<br/>		/// semaphore value.<br/>		/// This function is the equivalent of calling SDL_SemWaitTimeout() with a time<br/>		/// length of `SDL_MUTEX_MAXWAIT`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemWait([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			int ret = SDLSemWaitNative(sem);
			return ret;
		}

		/// <summary>		/// Wait until a semaphore has a positive value and then decrements it.<br/>		/// This function suspends the calling thread until either the semaphore<br/>		/// pointed to by `sem` has a positive value or the call is interrupted by a<br/>		/// signal or error. If the call is successful it will atomically decrement the<br/>		/// semaphore value.<br/>		/// This function is the equivalent of calling SDL_SemWaitTimeout() with a time<br/>		/// length of `SDL_MUTEX_MAXWAIT`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemWait([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = SDLSemWaitNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// See if a semaphore has a positive value and decrement it if it does.<br/>
		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
		/// positive value and atomically decrements the semaphore value if it does. If<br/>
		/// the semaphore doesn't have a positive value, the function immediately<br/>
		/// returns SDL_MUTEX_TIMEDOUT.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemTryWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SemTryWait")]
		internal static extern int SDLSemTryWaitNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>		/// See if a semaphore has a positive value and decrement it if it does.<br/>		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>		/// positive value and atomically decrements the semaphore value if it does. If<br/>		/// the semaphore doesn't have a positive value, the function immediately<br/>		/// returns SDL_MUTEX_TIMEDOUT.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemTryWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemTryWait([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			int ret = SDLSemTryWaitNative(sem);
			return ret;
		}

		/// <summary>		/// See if a semaphore has a positive value and decrement it if it does.<br/>		/// This function checks to see if the semaphore pointed to by `sem` has a<br/>		/// positive value and atomically decrements the semaphore value if it does. If<br/>		/// the semaphore doesn't have a positive value, the function immediately<br/>		/// returns SDL_MUTEX_TIMEDOUT.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemTryWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemTryWait([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = SDLSemTryWaitNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a semaphore has a positive value and then decrements it.<br/>
		/// This function suspends the calling thread until either the semaphore<br/>
		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>
		/// signal or error, or the specified time has elapsed. If the call is<br/>
		/// successful it will atomically decrement the semaphore value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SemWaitTimeout")]
		internal static extern int SDLSemWaitTimeoutNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "Uint32")] uint timeout);

		/// <summary>		/// Wait until a semaphore has a positive value and then decrements it.<br/>		/// This function suspends the calling thread until either the semaphore<br/>		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>		/// signal or error, or the specified time has elapsed. If the call is<br/>		/// successful it will atomically decrement the semaphore value.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemWaitTimeout([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "Uint32")] uint timeout)
		{
			int ret = SDLSemWaitTimeoutNative(sem, timeout);
			return ret;
		}

		/// <summary>		/// Wait until a semaphore has a positive value and then decrements it.<br/>		/// This function suspends the calling thread until either the semaphore<br/>		/// pointed to by `sem` has a positive value, the call is interrupted by a<br/>		/// signal or error, or the specified time has elapsed. If the call is<br/>		/// successful it will atomically decrement the semaphore value.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemWaitTimeout([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] ref SDLSemaphore sem, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "Uint32")] uint timeout)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = SDLSemWaitTimeoutNative((SDLSemaphore*)psem, timeout);
				return ret;
			}
		}

		/// <summary>
		/// Atomically increment a semaphore's value and wake waiting threads.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemPost")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SemPost")]
		internal static extern int SDLSemPostNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>		/// Atomically increment a semaphore's value and wake waiting threads.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemPost")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemPost([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			int ret = SDLSemPostNative(sem);
			return ret;
		}

		/// <summary>		/// Atomically increment a semaphore's value and wake waiting threads.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemPost")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSemPost([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				int ret = SDLSemPostNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Get the current value of a semaphore.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SemValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SemValue")]
		internal static extern uint SDLSemValueNative([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem);

		/// <summary>		/// Get the current value of a semaphore.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLSemValue([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] SDLSemaphore* sem)
		{
			uint ret = SDLSemValueNative(sem);
			return ret;
		}

		/// <summary>		/// Get the current value of a semaphore.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SemValue")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLSemValue([NativeName(NativeNameType.Param, "sem")] [NativeName(NativeNameType.Type, "SDL_sem*")] ref SDLSemaphore sem)
		{
			fixed (SDLSemaphore* psem = &sem)
			{
				uint ret = SDLSemValueNative((SDLSemaphore*)psem);
				return ret;
			}
		}

		/// <summary>
		/// Create a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCond")]
		[return: NativeName(NativeNameType.Type, "SDL_cond*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateCond")]
		internal static extern SDLCond* SDLCreateCondNative();

		/// <summary>		/// Create a condition variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCond")]
		[return: NativeName(NativeNameType.Type, "SDL_cond*")]
		public static SDLCond* SDLCreateCond()
		{
			SDLCond* ret = SDLCreateCondNative();
			return ret;
		}

		/// <summary>
		/// Destroy a condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyCond")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DestroyCond")]
		internal static extern void SDLDestroyCondNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond);

		/// <summary>		/// Destroy a condition variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyCond")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyCond([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond)
		{
			SDLDestroyCondNative(cond);
		}

		/// <summary>		/// Destroy a condition variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyCond")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyCond([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] ref SDLCond cond)
		{
			fixed (SDLCond* pcond = &cond)
			{
				SDLDestroyCondNative((SDLCond*)pcond);
			}
		}

		/// <summary>
		/// Restart one of the threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CondSignal")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CondSignal")]
		internal static extern int SDLCondSignalNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond);

		/// <summary>		/// Restart one of the threads that are waiting on the condition variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondSignal")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondSignal([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond)
		{
			int ret = SDLCondSignalNative(cond);
			return ret;
		}

		/// <summary>		/// Restart one of the threads that are waiting on the condition variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondSignal")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondSignal([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] ref SDLCond cond)
		{
			fixed (SDLCond* pcond = &cond)
			{
				int ret = SDLCondSignalNative((SDLCond*)pcond);
				return ret;
			}
		}

		/// <summary>
		/// Restart all threads that are waiting on the condition variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CondBroadcast")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CondBroadcast")]
		internal static extern int SDLCondBroadcastNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond);

		/// <summary>		/// Restart all threads that are waiting on the condition variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondBroadcast")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondBroadcast([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond)
		{
			int ret = SDLCondBroadcastNative(cond);
			return ret;
		}

		/// <summary>		/// Restart all threads that are waiting on the condition variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondBroadcast")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondBroadcast([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] ref SDLCond cond)
		{
			fixed (SDLCond* pcond = &cond)
			{
				int ret = SDLCondBroadcastNative((SDLCond*)pcond);
				return ret;
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>
		/// the function returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>
		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CondWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CondWait")]
		internal static extern int SDLCondWaitNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex);

		/// <summary>		/// Wait until a condition variable is signaled.<br/>		/// This function unlocks the specified `mutex` and waits for another thread to<br/>		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>		/// the function returns.<br/>		/// The mutex must be locked before calling this function.<br/>		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWait([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			int ret = SDLCondWaitNative(cond, mutex);
			return ret;
		}

		/// <summary>		/// Wait until a condition variable is signaled.<br/>		/// This function unlocks the specified `mutex` and waits for another thread to<br/>		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>		/// the function returns.<br/>		/// The mutex must be locked before calling this function.<br/>		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWait([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] ref SDLCond cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex)
		{
			fixed (SDLCond* pcond = &cond)
			{
				int ret = SDLCondWaitNative((SDLCond*)pcond, mutex);
				return ret;
			}
		}

		/// <summary>		/// Wait until a condition variable is signaled.<br/>		/// This function unlocks the specified `mutex` and waits for another thread to<br/>		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>		/// the function returns.<br/>		/// The mutex must be locked before calling this function.<br/>		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWait([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = SDLCondWaitNative(cond, (SDLMutex*)pmutex);
				return ret;
			}
		}

		/// <summary>		/// Wait until a condition variable is signaled.<br/>		/// This function unlocks the specified `mutex` and waits for another thread to<br/>		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>		/// `cond`. Once the condition variable is signaled, the mutex is re-locked and<br/>		/// the function returns.<br/>		/// The mutex must be locked before calling this function.<br/>		/// This function is the equivalent of calling SDL_CondWaitTimeout() with a<br/>		/// time length of `SDL_MUTEX_MAXWAIT`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWait")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWait([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] ref SDLCond cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex)
		{
			fixed (SDLCond* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					int ret = SDLCondWaitNative((SDLCond*)pcond, (SDLMutex*)pmutex);
					return ret;
				}
			}
		}

		/// <summary>
		/// Wait until a condition variable is signaled or a certain time has passed.<br/>
		/// This function unlocks the specified `mutex` and waits for another thread to<br/>
		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>
		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>
		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>
		/// returns.<br/>
		/// The mutex must be locked before calling this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CondWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CondWaitTimeout")]
		internal static extern int SDLCondWaitTimeoutNative([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms);

		/// <summary>		/// Wait until a condition variable is signaled or a certain time has passed.<br/>		/// This function unlocks the specified `mutex` and waits for another thread to<br/>		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>		/// returns.<br/>		/// The mutex must be locked before calling this function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWaitTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms)
		{
			int ret = SDLCondWaitTimeoutNative(cond, mutex, ms);
			return ret;
		}

		/// <summary>		/// Wait until a condition variable is signaled or a certain time has passed.<br/>		/// This function unlocks the specified `mutex` and waits for another thread to<br/>		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>		/// returns.<br/>		/// The mutex must be locked before calling this function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWaitTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] ref SDLCond cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] SDLMutex* mutex, [NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms)
		{
			fixed (SDLCond* pcond = &cond)
			{
				int ret = SDLCondWaitTimeoutNative((SDLCond*)pcond, mutex, ms);
				return ret;
			}
		}

		/// <summary>		/// Wait until a condition variable is signaled or a certain time has passed.<br/>		/// This function unlocks the specified `mutex` and waits for another thread to<br/>		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>		/// returns.<br/>		/// The mutex must be locked before calling this function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWaitTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] SDLCond* cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex, [NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms)
		{
			fixed (SDLMutex* pmutex = &mutex)
			{
				int ret = SDLCondWaitTimeoutNative(cond, (SDLMutex*)pmutex, ms);
				return ret;
			}
		}

		/// <summary>		/// Wait until a condition variable is signaled or a certain time has passed.<br/>		/// This function unlocks the specified `mutex` and waits for another thread to<br/>		/// call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable<br/>		/// `cond`, or for the specified time to elapse. Once the condition variable is<br/>		/// signaled or the time elapsed, the mutex is re-locked and the function<br/>		/// returns.<br/>		/// The mutex must be locked before calling this function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CondWaitTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCondWaitTimeout([NativeName(NativeNameType.Param, "cond")] [NativeName(NativeNameType.Type, "SDL_cond*")] ref SDLCond cond, [NativeName(NativeNameType.Param, "mutex")] [NativeName(NativeNameType.Type, "SDL_mutex*")] ref SDLMutex mutex, [NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms)
		{
			fixed (SDLCond* pcond = &cond)
			{
				fixed (SDLMutex* pmutex = &mutex)
				{
					int ret = SDLCondWaitTimeoutNative((SDLCond*)pcond, (SDLMutex*)pmutex, ms);
					return ret;
				}
			}
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThread")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateThread")]
		internal static extern SDLThread* SDL_CreateThreadNative([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnSDLCurrentBeginThread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnSDLCurrentEndThread pfnEndThread);

		[NativeName(NativeNameType.Func, "SDL_CreateThread")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThread([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnSDLCurrentBeginThread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThread* ret = SDL_CreateThreadNative(fn, name, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThread")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThread([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnSDLCurrentBeginThread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThread* ret = SDL_CreateThreadNative(fn, (byte*)pname, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThread")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThread([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnSDLCurrentBeginThread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThread* ret = SDL_CreateThreadNative(fn, pStr0, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateThreadWithStackSize")]
		internal static extern SDLThread* SDL_CreateThreadWithStackSizeNative([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] nuint stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnSDLCurrentBeginThread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnSDLCurrentEndThread pfnEndThread);

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThreadWithStackSize([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] nuint stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnSDLCurrentBeginThread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnSDLCurrentEndThread pfnEndThread)
		{
			SDLThread* ret = SDL_CreateThreadWithStackSizeNative(fn, name, stacksize, data, pfnBeginThread, pfnEndThread);
			return ret;
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThreadWithStackSize([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] nuint stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnSDLCurrentBeginThread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnSDLCurrentEndThread pfnEndThread)
		{
			fixed (byte* pname = &name)
			{
				SDLThread* ret = SDL_CreateThreadWithStackSizeNative(fn, (byte*)pname, stacksize, data, pfnBeginThread, pfnEndThread);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "SDL_CreateThreadWithStackSize")]
		[return: NativeName(NativeNameType.Type, "SDL_Thread*")]
		public static SDLThread* SDL_CreateThreadWithStackSize([NativeName(NativeNameType.Param, "fn")] [NativeName(NativeNameType.Type, "SDL_ThreadFunction")] SDLThreadFunction fn, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "stacksize")] [NativeName(NativeNameType.Type, "const size_t")] nuint stacksize, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "pfnBeginThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentBeginThread")] PfnSDLCurrentBeginThread pfnBeginThread, [NativeName(NativeNameType.Param, "pfnEndThread")] [NativeName(NativeNameType.Type, "pfnSDL_CurrentEndThread")] PfnSDLCurrentEndThread pfnEndThread)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLThread* ret = SDL_CreateThreadWithStackSizeNative(fn, pStr0, stacksize, data, pfnBeginThread, pfnEndThread);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the thread name as it was specified in SDL_CreateThread().<br/>
		/// This is internal memory, not to be freed by the caller, and remains valid<br/>
		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetThreadName")]
		internal static extern byte* SDLGetThreadNameNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread);

		/// <summary>		/// Get the thread name as it was specified in SDL_CreateThread().<br/>		/// This is internal memory, not to be freed by the caller, and remains valid<br/>		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetThreadName([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			byte* ret = SDLGetThreadNameNative(thread);
			return ret;
		}

		/// <summary>		/// Get the thread name as it was specified in SDL_CreateThread().<br/>		/// This is internal memory, not to be freed by the caller, and remains valid<br/>		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetThreadNameS([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetThreadNameNative(thread));
			return ret;
		}

		/// <summary>		/// Get the thread name as it was specified in SDL_CreateThread().<br/>		/// This is internal memory, not to be freed by the caller, and remains valid<br/>		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetThreadName([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				byte* ret = SDLGetThreadNameNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>		/// Get the thread name as it was specified in SDL_CreateThread().<br/>		/// This is internal memory, not to be freed by the caller, and remains valid<br/>		/// until the specified thread is cleaned up by SDL_WaitThread().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetThreadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetThreadNameS([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetThreadNameNative((SDLThread*)pthread));
				return ret;
			}
		}

		/// <summary>
		/// Get the thread identifier for the current thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// This function also returns a valid thread ID when called from the main<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_threadID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ThreadID")]
		internal static extern uint SDLThreadIDNative();

		/// <summary>		/// Get the thread identifier for the current thread.<br/>		/// This thread identifier is as reported by the underlying operating system.<br/>		/// If SDL is running on a platform that does not support threads the return<br/>		/// value will always be zero.<br/>		/// This function also returns a valid thread ID when called from the main<br/>		/// thread.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_threadID")]
		public static uint SDLThreadID()
		{
			uint ret = SDLThreadIDNative();
			return ret;
		}

		/// <summary>
		/// Get the thread identifier for the specified thread.<br/>
		/// This thread identifier is as reported by the underlying operating system.<br/>
		/// If SDL is running on a platform that does not support threads the return<br/>
		/// value will always be zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_threadID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetThreadID")]
		internal static extern uint SDLGetThreadIDNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread);

		/// <summary>		/// Get the thread identifier for the specified thread.<br/>		/// This thread identifier is as reported by the underlying operating system.<br/>		/// If SDL is running on a platform that does not support threads the return<br/>		/// value will always be zero.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_threadID")]
		public static uint SDLGetThreadID([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			uint ret = SDLGetThreadIDNative(thread);
			return ret;
		}

		/// <summary>		/// Get the thread identifier for the specified thread.<br/>		/// This thread identifier is as reported by the underlying operating system.<br/>		/// If SDL is running on a platform that does not support threads the return<br/>		/// value will always be zero.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetThreadID")]
		[return: NativeName(NativeNameType.Type, "SDL_threadID")]
		public static uint SDLGetThreadID([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				uint ret = SDLGetThreadIDNative((SDLThread*)pthread);
				return ret;
			}
		}

		/// <summary>
		/// Set the priority for the current thread.<br/>
		/// Note that some platforms will not let you alter the priority (or at least,<br/>
		/// promote the thread to a higher priority) at all, and some require you to be<br/>
		/// an administrator account. Be prepared for this to fail.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetThreadPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetThreadPriority")]
		internal static extern int SDLSetThreadPriorityNative([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_ThreadPriority")] SDLThreadPriority priority);

		/// <summary>		/// Set the priority for the current thread.<br/>		/// Note that some platforms will not let you alter the priority (or at least,<br/>		/// promote the thread to a higher priority) at all, and some require you to be<br/>		/// an administrator account. Be prepared for this to fail.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetThreadPriority")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetThreadPriority([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_ThreadPriority")] SDLThreadPriority priority)
		{
			int ret = SDLSetThreadPriorityNative(priority);
			return ret;
		}

		/// <summary>
		/// Wait for a thread to finish.<br/>
		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
		/// function cleans them up. Not doing so is a resource leak.<br/>
		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
		/// that references it becomes invalid and should not be referenced again. As<br/>
		/// such, only one thread may call SDL_WaitThread() on another.<br/>
		/// The return code for the thread function is placed in the area pointed to by<br/>
		/// `status`, if `status` is not NULL.<br/>
		/// You may not wait on a thread that has been used in a call to<br/>
		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
		/// behavior is undefined.<br/>
		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
		/// Note that the thread pointer is freed by this function and is not valid<br/>
		/// afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WaitThread")]
		internal static extern void SDLWaitThreadNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] int* status);

		/// <summary>		/// Wait for a thread to finish.<br/>		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>		/// function cleans them up. Not doing so is a resource leak.<br/>		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>		/// that references it becomes invalid and should not be referenced again. As<br/>		/// such, only one thread may call SDL_WaitThread() on another.<br/>		/// The return code for the thread function is placed in the area pointed to by<br/>		/// `status`, if `status` is not NULL.<br/>		/// You may not wait on a thread that has been used in a call to<br/>		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>		/// behavior is undefined.<br/>		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>		/// Note that the thread pointer is freed by this function and is not valid<br/>		/// afterward.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] int* status)
		{
			SDLWaitThreadNative(thread, status);
		}

		/// <summary>		/// Wait for a thread to finish.<br/>		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>		/// function cleans them up. Not doing so is a resource leak.<br/>		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>		/// that references it becomes invalid and should not be referenced again. As<br/>		/// such, only one thread may call SDL_WaitThread() on another.<br/>		/// The return code for the thread function is placed in the area pointed to by<br/>		/// `status`, if `status` is not NULL.<br/>		/// You may not wait on a thread that has been used in a call to<br/>		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>		/// behavior is undefined.<br/>		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>		/// Note that the thread pointer is freed by this function and is not valid<br/>		/// afterward.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] ref SDLThread thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] int* status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				SDLWaitThreadNative((SDLThread*)pthread, status);
			}
		}

		/// <summary>		/// Wait for a thread to finish.<br/>		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>		/// function cleans them up. Not doing so is a resource leak.<br/>		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>		/// that references it becomes invalid and should not be referenced again. As<br/>		/// such, only one thread may call SDL_WaitThread() on another.<br/>		/// The return code for the thread function is placed in the area pointed to by<br/>		/// `status`, if `status` is not NULL.<br/>		/// You may not wait on a thread that has been used in a call to<br/>		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>		/// behavior is undefined.<br/>		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>		/// Note that the thread pointer is freed by this function and is not valid<br/>		/// afterward.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] ref int status)
		{
			fixed (int* pstatus = &status)
			{
				SDLWaitThreadNative(thread, (int*)pstatus);
			}
		}

		/// <summary>		/// Wait for a thread to finish.<br/>		/// Threads that haven't been detached will remain (as a "zombie") until this<br/>		/// function cleans them up. Not doing so is a resource leak.<br/>		/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>		/// that references it becomes invalid and should not be referenced again. As<br/>		/// such, only one thread may call SDL_WaitThread() on another.<br/>		/// The return code for the thread function is placed in the area pointed to by<br/>		/// `status`, if `status` is not NULL.<br/>		/// You may not wait on a thread that has been used in a call to<br/>		/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>		/// behavior is undefined.<br/>		/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>		/// Note that the thread pointer is freed by this function and is not valid<br/>		/// afterward.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWaitThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] ref SDLThread thread, [NativeName(NativeNameType.Param, "status")] [NativeName(NativeNameType.Type, "int*")] ref int status)
		{
			fixed (SDLThread* pthread = &thread)
			{
				fixed (int* pstatus = &status)
				{
					SDLWaitThreadNative((SDLThread*)pthread, (int*)pstatus);
				}
			}
		}

		/// <summary>
		/// Let a thread clean up on exit without intervention.<br/>
		/// A thread may be "detached" to signify that it should not remain until<br/>
		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
		/// useful for long-running threads that nothing needs to synchronize with or<br/>
		/// further manage. When a detached thread is done, it simply goes away.<br/>
		/// There is no way to recover the return code of a detached thread. If you<br/>
		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
		/// safe to reference again, as it will become invalid immediately upon the<br/>
		/// detached thread's exit, instead of remaining until someone has called<br/>
		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
		/// thread more than once.<br/>
		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
		/// either that function or this one, but not both, or behavior is undefined.<br/>
		/// It is safe to pass NULL to this function; it is a no-op.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DetachThread")]
		internal static extern void SDLDetachThreadNative([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread);

		/// <summary>		/// Let a thread clean up on exit without intervention.<br/>		/// A thread may be "detached" to signify that it should not remain until<br/>		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>		/// useful for long-running threads that nothing needs to synchronize with or<br/>		/// further manage. When a detached thread is done, it simply goes away.<br/>		/// There is no way to recover the return code of a detached thread. If you<br/>		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>		/// safe to reference again, as it will become invalid immediately upon the<br/>		/// detached thread's exit, instead of remaining until someone has called<br/>		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>		/// thread more than once.<br/>		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>		/// either that function or this one, but not both, or behavior is undefined.<br/>		/// It is safe to pass NULL to this function; it is a no-op.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDetachThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] SDLThread* thread)
		{
			SDLDetachThreadNative(thread);
		}

		/// <summary>		/// Let a thread clean up on exit without intervention.<br/>		/// A thread may be "detached" to signify that it should not remain until<br/>		/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>		/// useful for long-running threads that nothing needs to synchronize with or<br/>		/// further manage. When a detached thread is done, it simply goes away.<br/>		/// There is no way to recover the return code of a detached thread. If you<br/>		/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>		/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>		/// safe to reference again, as it will become invalid immediately upon the<br/>		/// detached thread's exit, instead of remaining until someone has called<br/>		/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>		/// thread more than once.<br/>		/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>		/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>		/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>		/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>		/// either that function or this one, but not both, or behavior is undefined.<br/>		/// It is safe to pass NULL to this function; it is a no-op.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DetachThread")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDetachThread([NativeName(NativeNameType.Param, "thread")] [NativeName(NativeNameType.Type, "SDL_Thread*")] ref SDLThread thread)
		{
			fixed (SDLThread* pthread = &thread)
			{
				SDLDetachThreadNative((SDLThread*)pthread);
			}
		}

		/// <summary>
		/// Create a piece of thread-local storage.<br/>
		/// This creates an identifier that is globally visible to all threads but<br/>
		/// refers to data that is thread-specific.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSCreate")]
		[return: NativeName(NativeNameType.Type, "SDL_TLSID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_TLSCreate")]
		internal static extern uint SDLTLSCreateNative();

		/// <summary>		/// Create a piece of thread-local storage.<br/>		/// This creates an identifier that is globally visible to all threads but<br/>		/// refers to data that is thread-specific.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSCreate")]
		[return: NativeName(NativeNameType.Type, "SDL_TLSID")]
		public static uint SDLTLSCreate()
		{
			uint ret = SDLTLSCreateNative();
			return ret;
		}

		/// <summary>
		/// Get the current thread's value associated with a thread local storage ID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSGet")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_TLSGet")]
		internal static extern void* SDLTLSGetNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id);

		/// <summary>		/// Get the current thread's value associated with a thread local storage ID.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSGet")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLTLSGet([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id)
		{
			void* ret = SDLTLSGetNative(id);
			return ret;
		}

		/// <summary>
		/// Set the current thread's value associated with a thread local storage ID.<br/>
		/// The function prototype for `destructor` is:<br/>
		/// ```c<br/>
		/// void destructor(void *value)<br/>
		/// ```<br/>
		/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_TLSSet")]
		internal static extern int SDLTLSSetNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const void*")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "void (*)(SDL_TLSID id, const void* value, void (*)(void*)* destructor)*")] delegate*<uint, void*, delegate*<void*>> destructor);

		/// <summary>		/// Set the current thread's value associated with a thread local storage ID.<br/>		/// The function prototype for `destructor` is:<br/>		/// ```c<br/>		/// void destructor(void *value)<br/>		/// ```<br/>		/// where its parameter `value` is what was passed as `value` to SDL_TLSSet().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSSet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLTLSSet([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TLSID")] uint id, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const void*")] void* value, [NativeName(NativeNameType.Param, "destructor")] [NativeName(NativeNameType.Type, "void (*)(SDL_TLSID id, const void* value, void (*)(void*)* destructor)*")] delegate*<uint, void*, delegate*<void*>> destructor)
		{
			int ret = SDLTLSSetNative(id, value, destructor);
			return ret;
		}

		/// <summary>
		/// Cleanup all TLS data for this thread.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_TLSCleanup")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_TLSCleanup")]
		internal static extern void SDLTLSCleanupNative();

		/// <summary>		/// Cleanup all TLS data for this thread.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_TLSCleanup")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLTLSCleanup()
		{
			SDLTLSCleanupNative();
		}

		/// <summary>
		/// Use this function to create a new SDL_RWops structure for reading from<br/>
		/// and/or writing to a named file.<br/>
		/// The `mode` string is treated roughly the same as in a call to the C<br/>
		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
		/// scenes.<br/>
		/// Available `mode` strings:<br/>
		/// - "r": Open a file for reading. The file must exist.<br/>
		/// - "w": Create an empty file for writing. If a file with the same name<br/>
		/// already exists its content is erased and the file is treated as a new<br/>
		/// empty file.<br/>
		/// - "a": Append to a file. Writing operations append data at the end of the<br/>
		/// file. The file is created if it does not exist.<br/>
		/// - "r+": Open a file for update both reading and writing. The file must<br/>
		/// exist.<br/>
		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
		/// the same name already exists its content is erased and the file is<br/>
		/// treated as a new empty file.<br/>
		/// - "a+": Open a file for reading and appending. All writing operations are<br/>
		/// performed at the end of the file, protecting the previous content to be<br/>
		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
		/// anywhere in the file for reading, but writing operations will move it<br/>
		/// back to the end of file. The file is created if it does not exist.<br/>
		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
		/// be included in the `mode` string. This additional "b" character can either<br/>
		/// be appended at the end of the string (thus making the following compound<br/>
		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
		/// Additional characters may follow the sequence, although they should have no<br/>
		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
		/// a text file.<br/>
		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
		/// format, regardless of the underlying operating system.<br/>
		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>
		/// in an Android app's `assets`.<br/>
		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWFromFile")]
		internal static extern SDLRWops* SDLRWFromFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode);

		/// <summary>		/// Use this function to create a new SDL_RWops structure for reading from<br/>		/// and/or writing to a named file.<br/>		/// The `mode` string is treated roughly the same as in a call to the C<br/>		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>		/// scenes.<br/>		/// Available `mode` strings:<br/>		/// - "r": Open a file for reading. The file must exist.<br/>		/// - "w": Create an empty file for writing. If a file with the same name<br/>		/// already exists its content is erased and the file is treated as a new<br/>		/// empty file.<br/>		/// - "a": Append to a file. Writing operations append data at the end of the<br/>		/// file. The file is created if it does not exist.<br/>		/// - "r+": Open a file for update both reading and writing. The file must<br/>		/// exist.<br/>		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>		/// the same name already exists its content is erased and the file is<br/>		/// treated as a new empty file.<br/>		/// - "a+": Open a file for reading and appending. All writing operations are<br/>		/// performed at the end of the file, protecting the previous content to be<br/>		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>		/// anywhere in the file for reading, but writing operations will move it<br/>		/// back to the end of file. The file is created if it does not exist.<br/>		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>		/// be included in the `mode` string. This additional "b" character can either<br/>		/// be appended at the end of the string (thus making the following compound<br/>		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>		/// Additional characters may follow the sequence, although they should have no<br/>		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>		/// a text file.<br/>		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>		/// format, regardless of the underlying operating system.<br/>		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>		/// in an Android app's `assets`.<br/>		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode)
		{
			SDLRWops* ret = SDLRWFromFileNative(file, mode);
			return ret;
		}

		/// <summary>		/// Use this function to create a new SDL_RWops structure for reading from<br/>		/// and/or writing to a named file.<br/>		/// The `mode` string is treated roughly the same as in a call to the C<br/>		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>		/// scenes.<br/>		/// Available `mode` strings:<br/>		/// - "r": Open a file for reading. The file must exist.<br/>		/// - "w": Create an empty file for writing. If a file with the same name<br/>		/// already exists its content is erased and the file is treated as a new<br/>		/// empty file.<br/>		/// - "a": Append to a file. Writing operations append data at the end of the<br/>		/// file. The file is created if it does not exist.<br/>		/// - "r+": Open a file for update both reading and writing. The file must<br/>		/// exist.<br/>		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>		/// the same name already exists its content is erased and the file is<br/>		/// treated as a new empty file.<br/>		/// - "a+": Open a file for reading and appending. All writing operations are<br/>		/// performed at the end of the file, protecting the previous content to be<br/>		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>		/// anywhere in the file for reading, but writing operations will move it<br/>		/// back to the end of file. The file is created if it does not exist.<br/>		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>		/// be included in the `mode` string. This additional "b" character can either<br/>		/// be appended at the end of the string (thus making the following compound<br/>		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>		/// Additional characters may follow the sequence, although they should have no<br/>		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>		/// a text file.<br/>		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>		/// format, regardless of the underlying operating system.<br/>		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>		/// in an Android app's `assets`.<br/>		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode)
		{
			fixed (byte* pfile = &file)
			{
				SDLRWops* ret = SDLRWFromFileNative((byte*)pfile, mode);
				return ret;
			}
		}

		/// <summary>		/// Use this function to create a new SDL_RWops structure for reading from<br/>		/// and/or writing to a named file.<br/>		/// The `mode` string is treated roughly the same as in a call to the C<br/>		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>		/// scenes.<br/>		/// Available `mode` strings:<br/>		/// - "r": Open a file for reading. The file must exist.<br/>		/// - "w": Create an empty file for writing. If a file with the same name<br/>		/// already exists its content is erased and the file is treated as a new<br/>		/// empty file.<br/>		/// - "a": Append to a file. Writing operations append data at the end of the<br/>		/// file. The file is created if it does not exist.<br/>		/// - "r+": Open a file for update both reading and writing. The file must<br/>		/// exist.<br/>		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>		/// the same name already exists its content is erased and the file is<br/>		/// treated as a new empty file.<br/>		/// - "a+": Open a file for reading and appending. All writing operations are<br/>		/// performed at the end of the file, protecting the previous content to be<br/>		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>		/// anywhere in the file for reading, but writing operations will move it<br/>		/// back to the end of file. The file is created if it does not exist.<br/>		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>		/// be included in the `mode` string. This additional "b" character can either<br/>		/// be appended at the end of the string (thus making the following compound<br/>		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>		/// Additional characters may follow the sequence, although they should have no<br/>		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>		/// a text file.<br/>		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>		/// format, regardless of the underlying operating system.<br/>		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>		/// in an Android app's `assets`.<br/>		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLRWops* ret = SDLRWFromFileNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Use this function to create a new SDL_RWops structure for reading from<br/>		/// and/or writing to a named file.<br/>		/// The `mode` string is treated roughly the same as in a call to the C<br/>		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>		/// scenes.<br/>		/// Available `mode` strings:<br/>		/// - "r": Open a file for reading. The file must exist.<br/>		/// - "w": Create an empty file for writing. If a file with the same name<br/>		/// already exists its content is erased and the file is treated as a new<br/>		/// empty file.<br/>		/// - "a": Append to a file. Writing operations append data at the end of the<br/>		/// file. The file is created if it does not exist.<br/>		/// - "r+": Open a file for update both reading and writing. The file must<br/>		/// exist.<br/>		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>		/// the same name already exists its content is erased and the file is<br/>		/// treated as a new empty file.<br/>		/// - "a+": Open a file for reading and appending. All writing operations are<br/>		/// performed at the end of the file, protecting the previous content to be<br/>		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>		/// anywhere in the file for reading, but writing operations will move it<br/>		/// back to the end of file. The file is created if it does not exist.<br/>		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>		/// be included in the `mode` string. This additional "b" character can either<br/>		/// be appended at the end of the string (thus making the following compound<br/>		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>		/// Additional characters may follow the sequence, although they should have no<br/>		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>		/// a text file.<br/>		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>		/// format, regardless of the underlying operating system.<br/>		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>		/// in an Android app's `assets`.<br/>		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				SDLRWops* ret = SDLRWFromFileNative(file, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>		/// Use this function to create a new SDL_RWops structure for reading from<br/>		/// and/or writing to a named file.<br/>		/// The `mode` string is treated roughly the same as in a call to the C<br/>		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>		/// scenes.<br/>		/// Available `mode` strings:<br/>		/// - "r": Open a file for reading. The file must exist.<br/>		/// - "w": Create an empty file for writing. If a file with the same name<br/>		/// already exists its content is erased and the file is treated as a new<br/>		/// empty file.<br/>		/// - "a": Append to a file. Writing operations append data at the end of the<br/>		/// file. The file is created if it does not exist.<br/>		/// - "r+": Open a file for update both reading and writing. The file must<br/>		/// exist.<br/>		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>		/// the same name already exists its content is erased and the file is<br/>		/// treated as a new empty file.<br/>		/// - "a+": Open a file for reading and appending. All writing operations are<br/>		/// performed at the end of the file, protecting the previous content to be<br/>		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>		/// anywhere in the file for reading, but writing operations will move it<br/>		/// back to the end of file. The file is created if it does not exist.<br/>		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>		/// be included in the `mode` string. This additional "b" character can either<br/>		/// be appended at the end of the string (thus making the following compound<br/>		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>		/// Additional characters may follow the sequence, although they should have no<br/>		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>		/// a text file.<br/>		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>		/// format, regardless of the underlying operating system.<br/>		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>		/// in an Android app's `assets`.<br/>		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLRWops* ret = SDLRWFromFileNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Use this function to create a new SDL_RWops structure for reading from<br/>		/// and/or writing to a named file.<br/>		/// The `mode` string is treated roughly the same as in a call to the C<br/>		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>		/// scenes.<br/>		/// Available `mode` strings:<br/>		/// - "r": Open a file for reading. The file must exist.<br/>		/// - "w": Create an empty file for writing. If a file with the same name<br/>		/// already exists its content is erased and the file is treated as a new<br/>		/// empty file.<br/>		/// - "a": Append to a file. Writing operations append data at the end of the<br/>		/// file. The file is created if it does not exist.<br/>		/// - "r+": Open a file for update both reading and writing. The file must<br/>		/// exist.<br/>		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>		/// the same name already exists its content is erased and the file is<br/>		/// treated as a new empty file.<br/>		/// - "a+": Open a file for reading and appending. All writing operations are<br/>		/// performed at the end of the file, protecting the previous content to be<br/>		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>		/// anywhere in the file for reading, but writing operations will move it<br/>		/// back to the end of file. The file is created if it does not exist.<br/>		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>		/// be included in the `mode` string. This additional "b" character can either<br/>		/// be appended at the end of the string (thus making the following compound<br/>		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>		/// Additional characters may follow the sequence, although they should have no<br/>		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>		/// a text file.<br/>		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>		/// format, regardless of the underlying operating system.<br/>		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>		/// in an Android app's `assets`.<br/>		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] ref byte mode)
		{
			fixed (byte* pfile = &file)
			{
				fixed (byte* pmode = &mode)
				{
					SDLRWops* ret = SDLRWFromFileNative((byte*)pfile, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>		/// Use this function to create a new SDL_RWops structure for reading from<br/>		/// and/or writing to a named file.<br/>		/// The `mode` string is treated roughly the same as in a call to the C<br/>		/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>		/// scenes.<br/>		/// Available `mode` strings:<br/>		/// - "r": Open a file for reading. The file must exist.<br/>		/// - "w": Create an empty file for writing. If a file with the same name<br/>		/// already exists its content is erased and the file is treated as a new<br/>		/// empty file.<br/>		/// - "a": Append to a file. Writing operations append data at the end of the<br/>		/// file. The file is created if it does not exist.<br/>		/// - "r+": Open a file for update both reading and writing. The file must<br/>		/// exist.<br/>		/// - "w+": Create an empty file for both reading and writing. If a file with<br/>		/// the same name already exists its content is erased and the file is<br/>		/// treated as a new empty file.<br/>		/// - "a+": Open a file for reading and appending. All writing operations are<br/>		/// performed at the end of the file, protecting the previous content to be<br/>		/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>		/// anywhere in the file for reading, but writing operations will move it<br/>		/// back to the end of file. The file is created if it does not exist.<br/>		/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>		/// be included in the `mode` string. This additional "b" character can either<br/>		/// be appended at the end of the string (thus making the following compound<br/>		/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>		/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>		/// Additional characters may follow the sequence, although they should have no<br/>		/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>		/// a text file.<br/>		/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>		/// format, regardless of the underlying operating system.<br/>		/// As a fallback, SDL_RWFromFile() will transparently open a matching filename<br/>		/// in an Android app's `assets`.<br/>		/// Closing the SDL_RWops will close the file handle SDL is holding internally.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFile")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const char*")] string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLRWops* ret = SDLRWFromFileNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to create an SDL_RWops structure from a standard I/O file<br/>
		/// pointer (stdio.h's `FILE*`).<br/>
		/// This function is not available on Windows, since files opened in an<br/>
		/// application on that platform cannot be used by a dynamically linked<br/>
		/// library.<br/>
		/// On some platforms, the first parameter is a `void*`, on others, it's a<br/>
		/// `FILE*`, depending on what system headers are available to SDL. It is<br/>
		/// always intended to be the `FILE*` type from the C runtime's stdio.h.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromFP")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWFromFP")]
		internal static extern SDLRWops* SDLRWFromFPNative([NativeName(NativeNameType.Param, "fp")] [NativeName(NativeNameType.Type, "void*")] void* fp, [NativeName(NativeNameType.Param, "autoclose")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool autoclose);

		/// <summary>		/// Use this function to create an SDL_RWops structure from a standard I/O file<br/>		/// pointer (stdio.h's `FILE*`).<br/>		/// This function is not available on Windows, since files opened in an<br/>		/// application on that platform cannot be used by a dynamically linked<br/>		/// library.<br/>		/// On some platforms, the first parameter is a `void*`, on others, it's a<br/>		/// `FILE*`, depending on what system headers are available to SDL. It is<br/>		/// always intended to be the `FILE*` type from the C runtime's stdio.h.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromFP")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromFP([NativeName(NativeNameType.Param, "fp")] [NativeName(NativeNameType.Type, "void*")] void* fp, [NativeName(NativeNameType.Param, "autoclose")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool autoclose)
		{
			SDLRWops* ret = SDLRWFromFPNative(fp, autoclose);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-write memory buffer for use with<br/>
		/// SDL_RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size, for both read and write access.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to make sure the RWops never writes to the memory buffer, you<br/>
		/// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWFromMem")]
		internal static extern SDLRWops* SDLRWFromMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size);

		/// <summary>		/// Use this function to prepare a read-write memory buffer for use with<br/>		/// SDL_RWops.<br/>		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>		/// certain size, for both read and write access.<br/>		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>		/// remain valid until you close the stream. Closing the stream will not free<br/>		/// the original buffer.<br/>		/// If you need to make sure the RWops never writes to the memory buffer, you<br/>		/// should use SDL_RWFromConstMem() with a read-only buffer of memory instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			SDLRWops* ret = SDLRWFromMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to prepare a read-only memory buffer for use with RWops.<br/>
		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>
		/// certain size. It assumes the memory area is not writable.<br/>
		/// Attempting to write to this RWops stream will report an error without<br/>
		/// writing to the memory buffer.<br/>
		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>
		/// remain valid until you close the stream. Closing the stream will not free<br/>
		/// the original buffer.<br/>
		/// If you need to write to a memory buffer, you should use SDL_RWFromMem()<br/>
		/// with a writable buffer of memory instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWFromConstMem")]
		internal static extern SDLRWops* SDLRWFromConstMemNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "const void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size);

		/// <summary>		/// Use this function to prepare a read-only memory buffer for use with RWops.<br/>		/// This function sets up an SDL_RWops struct based on a memory area of a<br/>		/// certain size. It assumes the memory area is not writable.<br/>		/// Attempting to write to this RWops stream will report an error without<br/>		/// writing to the memory buffer.<br/>		/// This memory buffer is not copied by the RWops; the pointer you provide must<br/>		/// remain valid until you close the stream. Closing the stream will not free<br/>		/// the original buffer.<br/>		/// If you need to write to a memory buffer, you should use SDL_RWFromMem()<br/>		/// with a writable buffer of memory instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWFromConstMem")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLRWFromConstMem([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "const void*")] void* mem, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			SDLRWops* ret = SDLRWFromConstMemNative(mem, size);
			return ret;
		}

		/// <summary>
		/// Use this function to allocate an empty, unpopulated SDL_RWops structure.<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.<br/>
		/// You must free the returned pointer with SDL_FreeRW(). Depending on your<br/>
		/// operating system and compiler, there may be a difference between the<br/>
		/// malloc() and free() your program uses and the versions SDL calls<br/>
		/// internally. Trying to mix the two can cause crashing such as segmentation<br/>
		/// faults. Since all SDL_RWops must free themselves when their **close**<br/>
		/// method is called, all SDL_RWops must be allocated through this function, so<br/>
		/// they can all be freed correctly with SDL_FreeRW().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AllocRW")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AllocRW")]
		internal static extern SDLRWops* SDLAllocRWNative();

		/// <summary>		/// Use this function to allocate an empty, unpopulated SDL_RWops structure.<br/>		/// Applications do not need to use this function unless they are providing<br/>		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>		/// read/write a common data source, you should use the built-in<br/>		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.<br/>		/// You must free the returned pointer with SDL_FreeRW(). Depending on your<br/>		/// operating system and compiler, there may be a difference between the<br/>		/// malloc() and free() your program uses and the versions SDL calls<br/>		/// internally. Trying to mix the two can cause crashing such as segmentation<br/>		/// faults. Since all SDL_RWops must free themselves when their **close**<br/>		/// method is called, all SDL_RWops must be allocated through this function, so<br/>		/// they can all be freed correctly with SDL_FreeRW().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AllocRW")]
		[return: NativeName(NativeNameType.Type, "SDL_RWops*")]
		public static SDLRWops* SDLAllocRW()
		{
			SDLRWops* ret = SDLAllocRWNative();
			return ret;
		}

		/// <summary>
		/// Use this function to free an SDL_RWops structure allocated by<br/>
		/// SDL_AllocRW().<br/>
		/// Applications do not need to use this function unless they are providing<br/>
		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>
		/// read/write a common data source, you should use the built-in<br/>
		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>
		/// call the **close** method on those SDL_RWops pointers when you are done<br/>
		/// with them.<br/>
		/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>
		/// invalid as soon as this function returns. Any extra memory allocated during<br/>
		/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>
		/// be responsible for managing that memory in their **close** method.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeRW")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FreeRW")]
		internal static extern void SDLFreeRWNative([NativeName(NativeNameType.Param, "area")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* area);

		/// <summary>		/// Use this function to free an SDL_RWops structure allocated by<br/>		/// SDL_AllocRW().<br/>		/// Applications do not need to use this function unless they are providing<br/>		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>		/// read/write a common data source, you should use the built-in<br/>		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>		/// call the **close** method on those SDL_RWops pointers when you are done<br/>		/// with them.<br/>		/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>		/// invalid as soon as this function returns. Any extra memory allocated during<br/>		/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>		/// be responsible for managing that memory in their **close** method.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeRW")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeRW([NativeName(NativeNameType.Param, "area")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* area)
		{
			SDLFreeRWNative(area);
		}

		/// <summary>		/// Use this function to free an SDL_RWops structure allocated by<br/>		/// SDL_AllocRW().<br/>		/// Applications do not need to use this function unless they are providing<br/>		/// their own SDL_RWops implementation. If you just need a SDL_RWops to<br/>		/// read/write a common data source, you should use the built-in<br/>		/// implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and<br/>		/// call the **close** method on those SDL_RWops pointers when you are done<br/>		/// with them.<br/>		/// Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is<br/>		/// invalid as soon as this function returns. Any extra memory allocated during<br/>		/// creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must<br/>		/// be responsible for managing that memory in their **close** method.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeRW")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeRW([NativeName(NativeNameType.Param, "area")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops area)
		{
			fixed (SDLRWops* parea = &area)
			{
				SDLFreeRWNative((SDLRWops*)parea);
			}
		}

		/// <summary>
		/// Use this function to get the size of the data stream in an SDL_RWops.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWsize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWsize")]
		internal static extern long SDLRWsizeNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context);

		/// <summary>		/// Use this function to get the size of the data stream in an SDL_RWops.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWsize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWsize([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			long ret = SDLRWsizeNative(context);
			return ret;
		}

		/// <summary>		/// Use this function to get the size of the data stream in an SDL_RWops.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWsize")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWsize([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				long ret = SDLRWsizeNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Seek within an SDL_RWops data stream.<br/>
		/// This function seeks to byte `offset`, relative to `whence`.<br/>
		/// `whence` may be any of the following values:<br/>
		/// - `RW_SEEK_SET`: seek from the beginning of data<br/>
		/// - `RW_SEEK_CUR`: seek relative to current read point<br/>
		/// - `RW_SEEK_END`: seek relative to the end of data<br/>
		/// If this stream can not seek, it will return -1.<br/>
		/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>
		/// `seek` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWseek")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWseek")]
		internal static extern long SDLRWseekNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "int")] int whence);

		/// <summary>		/// Seek within an SDL_RWops data stream.<br/>		/// This function seeks to byte `offset`, relative to `whence`.<br/>		/// `whence` may be any of the following values:<br/>		/// - `RW_SEEK_SET`: seek from the beginning of data<br/>		/// - `RW_SEEK_CUR`: seek relative to current read point<br/>		/// - `RW_SEEK_END`: seek relative to the end of data<br/>		/// If this stream can not seek, it will return -1.<br/>		/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>		/// `seek` method appropriately, to simplify application development.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWseek")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWseek([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "int")] int whence)
		{
			long ret = SDLRWseekNative(context, offset, whence);
			return ret;
		}

		/// <summary>		/// Seek within an SDL_RWops data stream.<br/>		/// This function seeks to byte `offset`, relative to `whence`.<br/>		/// `whence` may be any of the following values:<br/>		/// - `RW_SEEK_SET`: seek from the beginning of data<br/>		/// - `RW_SEEK_CUR`: seek relative to current read point<br/>		/// - `RW_SEEK_END`: seek relative to the end of data<br/>		/// If this stream can not seek, it will return -1.<br/>		/// SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's<br/>		/// `seek` method appropriately, to simplify application development.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWseek")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWseek([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "Sint64")] long offset, [NativeName(NativeNameType.Param, "whence")] [NativeName(NativeNameType.Type, "int")] int whence)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				long ret = SDLRWseekNative((SDLRWops*)pcontext, offset, whence);
				return ret;
			}
		}

		/// <summary>
		/// Determine the current read/write offset in an SDL_RWops data stream.<br/>
		/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>
		/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>
		/// application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWtell")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWtell")]
		internal static extern long SDLRWtellNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context);

		/// <summary>		/// Determine the current read/write offset in an SDL_RWops data stream.<br/>		/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>		/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>		/// application development.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWtell")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWtell([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			long ret = SDLRWtellNative(context);
			return ret;
		}

		/// <summary>		/// Determine the current read/write offset in an SDL_RWops data stream.<br/>		/// SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`<br/>		/// method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify<br/>		/// application development.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWtell")]
		[return: NativeName(NativeNameType.Type, "Sint64")]
		public static long SDLRWtell([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				long ret = SDLRWtellNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Read from a data source.<br/>
		/// This function reads up to `maxnum` objects each of size `size` from the<br/>
		/// data source to the area pointed at by `ptr`. This function may read less<br/>
		/// objects than requested. It will return zero when there has been an error or<br/>
		/// the data stream is completely read.<br/>
		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `read` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWread")]
		internal static extern nuint SDLRWreadNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] nuint maxnum);

		/// <summary>		/// Read from a data source.<br/>		/// This function reads up to `maxnum` objects each of size `size` from the<br/>		/// data source to the area pointed at by `ptr`. This function may read less<br/>		/// objects than requested. It will return zero when there has been an error or<br/>		/// the data stream is completely read.<br/>		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>		/// `read` method appropriately, to simplify application development.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] nuint maxnum)
		{
			nuint ret = SDLRWreadNative(context, ptr, size, maxnum);
			return ret;
		}

		/// <summary>		/// Read from a data source.<br/>		/// This function reads up to `maxnum` objects each of size `size` from the<br/>		/// data source to the area pointed at by `ptr`. This function may read less<br/>		/// objects than requested. It will return zero when there has been an error or<br/>		/// the data stream is completely read.<br/>		/// SDL_RWread() is actually a function wrapper that calls the SDL_RWops's<br/>		/// `read` method appropriately, to simplify application development.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWread")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLRWread([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "maxnum")] [NativeName(NativeNameType.Type, "size_t")] nuint maxnum)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				nuint ret = SDLRWreadNative((SDLRWops*)pcontext, ptr, size, maxnum);
				return ret;
			}
		}

		/// <summary>
		/// Write to an SDL_RWops data stream.<br/>
		/// This function writes exactly `num` objects each of size `size` from the<br/>
		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>
		/// return less than `num` to demonstrate how far the write progressed. On<br/>
		/// success, it returns `num`.<br/>
		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>
		/// `write` method appropriately, to simplify application development.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWwrite")]
		internal static extern nuint SDLRWwriteNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] nuint num);

		/// <summary>		/// Write to an SDL_RWops data stream.<br/>		/// This function writes exactly `num` objects each of size `size` from the<br/>		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>		/// return less than `num` to demonstrate how far the write progressed. On<br/>		/// success, it returns `num`.<br/>		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>		/// `write` method appropriately, to simplify application development.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] nuint num)
		{
			nuint ret = SDLRWwriteNative(context, ptr, size, num);
			return ret;
		}

		/// <summary>		/// Write to an SDL_RWops data stream.<br/>		/// This function writes exactly `num` objects each of size `size` from the<br/>		/// area pointed at by `ptr` to the stream. If this fails for any reason, it'll<br/>		/// return less than `num` to demonstrate how far the write progressed. On<br/>		/// success, it returns `num`.<br/>		/// SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's<br/>		/// `write` method appropriately, to simplify application development.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWwrite")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLRWwrite([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context, [NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "const void*")] void* ptr, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] nuint size, [NativeName(NativeNameType.Param, "num")] [NativeName(NativeNameType.Type, "size_t")] nuint num)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				nuint ret = SDLRWwriteNative((SDLRWops*)pcontext, ptr, size, num);
				return ret;
			}
		}

		/// <summary>
		/// Close and free an allocated SDL_RWops structure.<br/>
		/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>
		/// resources used by the stream and frees the SDL_RWops itself with<br/>
		/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>
		/// flush to its output (e.g. to disk).<br/>
		/// Note that if this fails to flush the stream to disk, this function reports<br/>
		/// an error, but the SDL_RWops is still invalid once this function returns.<br/>
		/// Prior to SDL 2.0.10, this function was a macro.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RWclose")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RWclose")]
		internal static extern int SDLRWcloseNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context);

		/// <summary>		/// Close and free an allocated SDL_RWops structure.<br/>		/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>		/// resources used by the stream and frees the SDL_RWops itself with<br/>		/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>		/// flush to its output (e.g. to disk).<br/>		/// Note that if this fails to flush the stream to disk, this function reports<br/>		/// an error, but the SDL_RWops is still invalid once this function returns.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWclose")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRWclose([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* context)
		{
			int ret = SDLRWcloseNative(context);
			return ret;
		}

		/// <summary>		/// Close and free an allocated SDL_RWops structure.<br/>		/// SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any<br/>		/// resources used by the stream and frees the SDL_RWops itself with<br/>		/// SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to<br/>		/// flush to its output (e.g. to disk).<br/>		/// Note that if this fails to flush the stream to disk, this function reports<br/>		/// an error, but the SDL_RWops is still invalid once this function returns.<br/>		/// Prior to SDL 2.0.10, this function was a macro.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RWclose")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRWclose([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops context)
		{
			fixed (SDLRWops* pcontext = &context)
			{
				int ret = SDLRWcloseNative((SDLRWops*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Load all the data from an SDL data stream.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LoadFile_RW")]
		internal static extern void* SDLLoadFileRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] nuint* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc);

		/// <summary>		/// Load all the data from an SDL data stream.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] nuint* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			void* ret = SDLLoadFileRWNative(src, datasize, freesrc);
			return ret;
		}

		/// <summary>		/// Load all the data from an SDL data stream.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] nuint* datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				void* ret = SDLLoadFileRWNative((SDLRWops*)psrc, datasize, freesrc);
				return ret;
			}
		}

		/// <summary>		/// Load all the data from an SDL data stream.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileRWNative(src, (nuint*)pdatasize, freesrc);
				return ret;
			}
		}

		/// <summary>		/// Load all the data from an SDL data stream.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile_RW")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFileRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = SDLLoadFileRWNative((SDLRWops*)psrc, (nuint*)pdatasize, freesrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load all the data from a file path.<br/>
		/// The data is allocated with a zero byte at the end (null terminated) for<br/>
		/// convenience. This extra byte is not included in the value reported via<br/>
		/// `datasize`.<br/>
		/// The data should be freed with SDL_free().<br/>
		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>
		/// SDL_LoadFile_RW.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LoadFile")]
		internal static extern void* SDLLoadFileNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] nuint* datasize);

		/// <summary>		/// Load all the data from a file path.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>		/// SDL_LoadFile_RW.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] nuint* datasize)
		{
			void* ret = SDLLoadFileNative(file, datasize);
			return ret;
		}

		/// <summary>		/// Load all the data from a file path.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>		/// SDL_LoadFile_RW.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] nuint* datasize)
		{
			fixed (byte* pfile = &file)
			{
				void* ret = SDLLoadFileNative((byte*)pfile, datasize);
				return ret;
			}
		}

		/// <summary>		/// Load all the data from a file path.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>		/// SDL_LoadFile_RW.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] nuint* datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SDLLoadFileNative(pStr0, datasize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Load all the data from a file path.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>		/// SDL_LoadFile_RW.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileNative(file, (nuint*)pdatasize);
				return ret;
			}
		}

		/// <summary>		/// Load all the data from a file path.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>		/// SDL_LoadFile_RW.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			fixed (byte* pfile = &file)
			{
				fixed (nuint* pdatasize = &datasize)
				{
					void* ret = SDLLoadFileNative((byte*)pfile, (nuint*)pdatasize);
					return ret;
				}
			}
		}

		/// <summary>		/// Load all the data from a file path.<br/>		/// The data is allocated with a zero byte at the end (null terminated) for<br/>		/// convenience. This extra byte is not included in the value reported via<br/>		/// `datasize`.<br/>		/// The data should be freed with SDL_free().<br/>		/// Prior to SDL 2.0.10, this function was a macro wrapping around<br/>		/// SDL_LoadFile_RW.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFile([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "datasize")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint datasize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (nuint* pdatasize = &datasize)
			{
				void* ret = SDLLoadFileNative(pStr0, (nuint*)pdatasize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read a byte from an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ReadU8")]
		internal static extern byte SDLReadU8Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>		/// Use this function to read a byte from an SDL_RWops.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			byte ret = SDLReadU8Native(src);
			return ret;
		}

		/// <summary>		/// Use this function to read a byte from an SDL_RWops.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadU8")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLReadU8([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte ret = SDLReadU8Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ReadLE16")]
		internal static extern ushort SDLReadLE16Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>		/// and return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadLE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ushort ret = SDLReadLE16Native(src);
			return ret;
		}

		/// <summary>		/// Use this function to read 16 bits of little-endian data from an SDL_RWops<br/>		/// and return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadLE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = SDLReadLE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ReadBE16")]
		internal static extern ushort SDLReadBE16Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>		/// return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadBE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ushort ret = SDLReadBE16Native(src);
			return ret;
		}

		/// <summary>		/// Use this function to read 16 bits of big-endian data from an SDL_RWops and<br/>		/// return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE16")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLReadBE16([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ushort ret = SDLReadBE16Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ReadLE32")]
		internal static extern uint SDLReadLE32Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>		/// and return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadLE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			uint ret = SDLReadLE32Native(src);
			return ret;
		}

		/// <summary>		/// Use this function to read 32 bits of little-endian data from an SDL_RWops<br/>		/// and return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadLE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = SDLReadLE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ReadBE32")]
		internal static extern uint SDLReadBE32Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>		/// return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadBE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			uint ret = SDLReadBE32Native(src);
			return ret;
		}

		/// <summary>		/// Use this function to read 32 bits of big-endian data from an SDL_RWops and<br/>		/// return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE32")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLReadBE32([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				uint ret = SDLReadBE32Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>
		/// and return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ReadLE64")]
		internal static extern ulong SDLReadLE64Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>		/// and return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadLE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ulong ret = SDLReadLE64Native(src);
			return ret;
		}

		/// <summary>		/// Use this function to read 64 bits of little-endian data from an SDL_RWops<br/>		/// and return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadLE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadLE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = SDLReadLE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>
		/// return in native format.<br/>
		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
		/// the native byte order.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ReadBE64")]
		internal static extern ulong SDLReadBE64Native([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>		/// return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadBE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			ulong ret = SDLReadBE64Native(src);
			return ret;
		}

		/// <summary>		/// Use this function to read 64 bits of big-endian data from an SDL_RWops and<br/>		/// return in native format.<br/>		/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>		/// the native byte order.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ReadBE64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLReadBE64([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				ulong ret = SDLReadBE64Native((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write a byte to an SDL_RWops.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WriteU8")]
		internal static extern nuint SDLWriteU8Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value);

		/// <summary>		/// Use this function to write a byte to an SDL_RWops.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteU8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			nuint ret = SDLWriteU8Native(dst, value);
			return ret;
		}

		/// <summary>		/// Use this function to write a byte to an SDL_RWops.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteU8")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteU8([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = SDLWriteU8Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WriteLE16")]
		internal static extern nuint SDLWriteLE16Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value);

		/// <summary>		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>		/// little-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in little-endian<br/>		/// format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteLE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			nuint ret = SDLWriteLE16Native(dst, value);
			return ret;
		}

		/// <summary>		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>		/// little-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in little-endian<br/>		/// format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteLE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = SDLWriteLE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WriteBE16")]
		internal static extern nuint SDLWriteBE16Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value);

		/// <summary>		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>		/// big-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in big-endian format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteBE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			nuint ret = SDLWriteBE16Native(dst, value);
			return ret;
		}

		/// <summary>		/// Use this function to write 16 bits in native format to a SDL_RWops as<br/>		/// big-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in big-endian format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE16")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteBE16([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint16")] ushort value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = SDLWriteBE16Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WriteLE32")]
		internal static extern nuint SDLWriteLE32Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value);

		/// <summary>		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>		/// little-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in little-endian<br/>		/// format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteLE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			nuint ret = SDLWriteLE32Native(dst, value);
			return ret;
		}

		/// <summary>		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>		/// little-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in little-endian<br/>		/// format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteLE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = SDLWriteLE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WriteBE32")]
		internal static extern nuint SDLWriteBE32Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value);

		/// <summary>		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>		/// big-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in big-endian format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteBE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			nuint ret = SDLWriteBE32Native(dst, value);
			return ret;
		}

		/// <summary>		/// Use this function to write 32 bits in native format to a SDL_RWops as<br/>		/// big-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in big-endian format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE32")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteBE32([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint32")] uint value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = SDLWriteBE32Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// little-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in little-endian<br/>
		/// format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WriteLE64")]
		internal static extern nuint SDLWriteLE64Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value);

		/// <summary>		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>		/// little-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in little-endian<br/>		/// format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteLE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			nuint ret = SDLWriteLE64Native(dst, value);
			return ret;
		}

		/// <summary>		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>		/// little-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in little-endian<br/>		/// format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteLE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteLE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = SDLWriteLE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>
		/// big-endian data.<br/>
		/// SDL byteswaps the data only if necessary, so the application always<br/>
		/// specifies native format, and the data written will be in big-endian format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WriteBE64")]
		internal static extern nuint SDLWriteBE64Native([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value);

		/// <summary>		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>		/// big-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in big-endian format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteBE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			nuint ret = SDLWriteBE64Native(dst, value);
			return ret;
		}

		/// <summary>		/// Use this function to write 64 bits in native format to a SDL_RWops as<br/>		/// big-endian data.<br/>		/// SDL byteswaps the data only if necessary, so the application always<br/>		/// specifies native format, and the data written will be in big-endian format.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WriteBE64")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLWriteBE64([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint64")] ulong value)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				nuint ret = SDLWriteBE64Native((SDLRWops*)pdst, value);
				return ret;
			}
		}

		/// <summary>
		/// Use this function to get the number of built-in audio drivers.<br/>
		/// This function returns a hardcoded number. This never returns a negative<br/>
		/// value; if there are no drivers compiled into this build of SDL, this<br/>
		/// function returns zero. The presence of a driver in this list does not mean<br/>
		/// it will function, it just means SDL is capable of interacting with that<br/>
		/// interface. For example, a build of SDL might have esound support, but if<br/>
		/// there's no esound server available, SDL's esound driver would fail if used.<br/>
		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
		/// found to be usable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetNumAudioDrivers")]
		internal static extern int SDLGetNumAudioDriversNative();

		/// <summary>		/// Use this function to get the number of built-in audio drivers.<br/>		/// This function returns a hardcoded number. This never returns a negative<br/>		/// value; if there are no drivers compiled into this build of SDL, this<br/>		/// function returns zero. The presence of a driver in this list does not mean<br/>		/// it will function, it just means SDL is capable of interacting with that<br/>		/// interface. For example, a build of SDL might have esound support, but if<br/>		/// there's no esound server available, SDL's esound driver would fail if used.<br/>		/// By default, SDL tries all drivers, in its preferred order, until one is<br/>		/// found to be usable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumAudioDrivers()
		{
			int ret = SDLGetNumAudioDriversNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the name of a built in audio driver.<br/>
		/// The list of audio drivers is given in the order that they are normally<br/>
		/// initialized by default; the drivers that seem more reasonable to choose<br/>
		/// first (as far as the SDL developers believe) are earlier in the list.<br/>
		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>
		/// meant to be proper names.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetAudioDriver")]
		internal static extern byte* SDLGetAudioDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index);

		/// <summary>		/// Use this function to get the name of a built in audio driver.<br/>		/// The list of audio drivers is given in the order that they are normally<br/>		/// initialized by default; the drivers that seem more reasonable to choose<br/>		/// first (as far as the SDL developers believe) are earlier in the list.<br/>		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>		/// meant to be proper names.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetAudioDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = SDLGetAudioDriverNative(index);
			return ret;
		}

		/// <summary>		/// Use this function to get the name of a built in audio driver.<br/>		/// The list of audio drivers is given in the order that they are normally<br/>		/// initialized by default; the drivers that seem more reasonable to choose<br/>		/// first (as far as the SDL developers believe) are earlier in the list.<br/>		/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>		/// "coreaudio" or "xaudio2". These never have Unicode characters, and are not<br/>		/// meant to be proper names.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetAudioDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetAudioDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Use this function to initialize a particular audio driver.<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to designate the audio driver you want to use. You should<br/>
		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AudioInit")]
		internal static extern int SDLAudioInitNative([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName);

		/// <summary>		/// Use this function to initialize a particular audio driver.<br/>		/// This function is used internally, and should not be used unless you have a<br/>		/// specific need to designate the audio driver you want to use. You should<br/>		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName)
		{
			int ret = SDLAudioInitNative(driverName);
			return ret;
		}

		/// <summary>		/// Use this function to initialize a particular audio driver.<br/>		/// This function is used internally, and should not be used unless you have a<br/>		/// specific need to designate the audio driver you want to use. You should<br/>		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte driverName)
		{
			fixed (byte* pdriverName = &driverName)
			{
				int ret = SDLAudioInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>		/// Use this function to initialize a particular audio driver.<br/>		/// This function is used internally, and should not be used unless you have a<br/>		/// specific need to designate the audio driver you want to use. You should<br/>		/// normally use SDL_Init() or SDL_InitSubSystem().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] string driverName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (driverName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(driverName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(driverName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLAudioInitNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Use this function to shut down audio if you initialized it with<br/>
		/// SDL_AudioInit().<br/>
		/// This function is used internally, and should not be used unless you have a<br/>
		/// specific need to specify the audio driver you want to use. You should<br/>
		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AudioQuit")]
		internal static extern void SDLAudioQuitNative();

		/// <summary>		/// Use this function to shut down audio if you initialized it with<br/>		/// SDL_AudioInit().<br/>		/// This function is used internally, and should not be used unless you have a<br/>		/// specific need to specify the audio driver you want to use. You should<br/>		/// normally use SDL_Quit() or SDL_QuitSubSystem().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAudioQuit()
		{
			SDLAudioQuitNative();
		}

		/// <summary>
		/// Get the name of the current audio driver.<br/>
		/// The returned string points to internal static memory and thus never becomes<br/>
		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>
		/// (although such a case would return a different static string from another<br/>
		/// call to this function, of course). As such, you should not modify or free<br/>
		/// the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetCurrentAudioDriver")]
		internal static extern byte* SDLGetCurrentAudioDriverNative();

		/// <summary>		/// Get the name of the current audio driver.<br/>		/// The returned string points to internal static memory and thus never becomes<br/>		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>		/// (although such a case would return a different static string from another<br/>		/// call to this function, of course). As such, you should not modify or free<br/>		/// the returned string.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetCurrentAudioDriver()
		{
			byte* ret = SDLGetCurrentAudioDriverNative();
			return ret;
		}

		/// <summary>		/// Get the name of the current audio driver.<br/>		/// The returned string points to internal static memory and thus never becomes<br/>		/// invalid, even if you quit the audio subsystem and initialize a new driver<br/>		/// (although such a case would return a different static string from another<br/>		/// call to this function, of course). As such, you should not modify or free<br/>		/// the returned string.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentAudioDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetCurrentAudioDriverS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetCurrentAudioDriverNative());
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of opening the audio device.<br/>
		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>
		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>
		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>
		/// This function is roughly equivalent to:<br/>
		/// ```c<br/>
		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>
		/// ```<br/>
		/// With two notable exceptions:<br/>
		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>
		/// means desired will be modified to have the correct values for silence,<br/>
		/// etc, and SDL will convert any differences between your app's specific<br/>
		/// request and the hardware behind the scenes.<br/>
		/// - The return value is always success or failure, and not a device ID, which<br/>
		/// means you can only have one device open at a time with this function.<br/>
		/// <br/>
		/// If `obtained` is NULL, the audio data passed to the callback<br/>
		/// function will be guaranteed to be in the requested format, and<br/>
		/// will be automatically converted to the actual hardware audio<br/>
		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>
		/// fields modified.<br/>
		/// This function returns a negative error code on failure to open the<br/>
		/// audio device or failure to set up the audio thread; call<br/>
		/// SDL_GetError() for more information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_OpenAudio")]
		internal static extern int SDLOpenAudioNative([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained);

		/// <summary>		/// This function is a legacy means of opening the audio device.<br/>		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>		/// This function is roughly equivalent to:<br/>		/// ```c<br/>		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>		/// ```<br/>		/// With two notable exceptions:<br/>		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>		/// means desired will be modified to have the correct values for silence,<br/>		/// etc, and SDL will convert any differences between your app's specific<br/>		/// request and the hardware behind the scenes.<br/>		/// - The return value is always success or failure, and not a device ID, which<br/>		/// means you can only have one device open at a time with this function.<br/>		/// <br/>		/// If `obtained` is NULL, the audio data passed to the callback<br/>		/// function will be guaranteed to be in the requested format, and<br/>		/// will be automatically converted to the actual hardware audio<br/>		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>		/// fields modified.<br/>		/// This function returns a negative error code on failure to open the<br/>		/// audio device or failure to set up the audio thread; call<br/>		/// SDL_GetError() for more information.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained)
		{
			int ret = SDLOpenAudioNative(desired, obtained);
			return ret;
		}

		/// <summary>		/// This function is a legacy means of opening the audio device.<br/>		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>		/// This function is roughly equivalent to:<br/>		/// ```c<br/>		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>		/// ```<br/>		/// With two notable exceptions:<br/>		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>		/// means desired will be modified to have the correct values for silence,<br/>		/// etc, and SDL will convert any differences between your app's specific<br/>		/// request and the hardware behind the scenes.<br/>		/// - The return value is always success or failure, and not a device ID, which<br/>		/// means you can only have one device open at a time with this function.<br/>		/// <br/>		/// If `obtained` is NULL, the audio data passed to the callback<br/>		/// function will be guaranteed to be in the requested format, and<br/>		/// will be automatically converted to the actual hardware audio<br/>		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>		/// fields modified.<br/>		/// This function returns a negative error code on failure to open the<br/>		/// audio device or failure to set up the audio thread; call<br/>		/// SDL_GetError() for more information.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				int ret = SDLOpenAudioNative((SDLAudioSpec*)pdesired, obtained);
				return ret;
			}
		}

		/// <summary>		/// This function is a legacy means of opening the audio device.<br/>		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>		/// This function is roughly equivalent to:<br/>		/// ```c<br/>		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>		/// ```<br/>		/// With two notable exceptions:<br/>		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>		/// means desired will be modified to have the correct values for silence,<br/>		/// etc, and SDL will convert any differences between your app's specific<br/>		/// request and the hardware behind the scenes.<br/>		/// - The return value is always success or failure, and not a device ID, which<br/>		/// means you can only have one device open at a time with this function.<br/>		/// <br/>		/// If `obtained` is NULL, the audio data passed to the callback<br/>		/// function will be guaranteed to be in the requested format, and<br/>		/// will be automatically converted to the actual hardware audio<br/>		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>		/// fields modified.<br/>		/// This function returns a negative error code on failure to open the<br/>		/// audio device or failure to set up the audio thread; call<br/>		/// SDL_GetError() for more information.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				int ret = SDLOpenAudioNative(desired, (SDLAudioSpec*)pobtained);
				return ret;
			}
		}

		/// <summary>		/// This function is a legacy means of opening the audio device.<br/>		/// This function remains for compatibility with SDL 1.2, but also because it's<br/>		/// slightly easier to use than the new functions in SDL 2.0. The new, more<br/>		/// powerful, and preferred way to do this is SDL_OpenAudioDevice().<br/>		/// This function is roughly equivalent to:<br/>		/// ```c<br/>		/// SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);<br/>		/// ```<br/>		/// With two notable exceptions:<br/>		/// - If `obtained` is NULL, we use `desired` (and allow no changes), which<br/>		/// means desired will be modified to have the correct values for silence,<br/>		/// etc, and SDL will convert any differences between your app's specific<br/>		/// request and the hardware behind the scenes.<br/>		/// - The return value is always success or failure, and not a device ID, which<br/>		/// means you can only have one device open at a time with this function.<br/>		/// <br/>		/// If `obtained` is NULL, the audio data passed to the callback<br/>		/// function will be guaranteed to be in the requested format, and<br/>		/// will be automatically converted to the actual hardware audio<br/>		/// format if necessary. If `obtained` is NULL, `desired` will have<br/>		/// fields modified.<br/>		/// This function returns a negative error code on failure to open the<br/>		/// audio device or failure to set up the audio thread; call<br/>		/// SDL_GetError() for more information.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenAudio([NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					int ret = SDLOpenAudioNative((SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the number of built-in audio devices.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem.<br/>
		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>
		/// `iscapture` parameter is for future expansion and should always be zero for<br/>
		/// now.<br/>
		/// This function will return -1 if an explicit list of devices can't be<br/>
		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>
		/// talk to a remote audio server, it can't list every one available on the<br/>
		/// Internet, but it will still allow a specific host to be specified in<br/>
		/// SDL_OpenAudioDevice().<br/>
		/// In many common cases, when this function returns a value <br/>
		/// <<br/>
		/// = 0, it can still<br/>
		/// successfully open the default device (NULL for first argument of<br/>
		/// SDL_OpenAudioDevice()).<br/>
		/// This function may trigger a complete redetect of available hardware. It<br/>
		/// should not be called for each iteration of a loop, but rather once at the<br/>
		/// start of a loop:<br/>
		/// ```c<br/>
		/// // Don't do this:<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// SDL_GetNumAudioDevices(0); i++)<br/>
		/// // do this instead:<br/>
		/// const int count = SDL_GetNumAudioDevices(0);<br/>
		/// for (int i = 0; i <br/>
		/// <<br/>
		/// count; ++i) { do_something_here(); }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetNumAudioDevices")]
		internal static extern int SDLGetNumAudioDevicesNative([NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture);

		/// <summary>		/// Get the number of built-in audio devices.<br/>		/// This function is only valid after successfully initializing the audio<br/>		/// subsystem.<br/>		/// Note that audio capture support is not implemented as of SDL 2.0.4, so the<br/>		/// `iscapture` parameter is for future expansion and should always be zero for<br/>		/// now.<br/>		/// This function will return -1 if an explicit list of devices can't be<br/>		/// determined. Returning -1 is not an error. For example, if SDL is set up to<br/>		/// talk to a remote audio server, it can't list every one available on the<br/>		/// Internet, but it will still allow a specific host to be specified in<br/>		/// SDL_OpenAudioDevice().<br/>		/// In many common cases, when this function returns a value <br/>		/// <<br/>		/// = 0, it can still<br/>		/// successfully open the default device (NULL for first argument of<br/>		/// SDL_OpenAudioDevice()).<br/>		/// This function may trigger a complete redetect of available hardware. It<br/>		/// should not be called for each iteration of a loop, but rather once at the<br/>		/// start of a loop:<br/>		/// ```c<br/>		/// // Don't do this:<br/>		/// for (int i = 0; i <br/>		/// <<br/>		/// SDL_GetNumAudioDevices(0); i++)<br/>		/// // do this instead:<br/>		/// const int count = SDL_GetNumAudioDevices(0);<br/>		/// for (int i = 0; i <br/>		/// <<br/>		/// count; ++i) { do_something_here(); }<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumAudioDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumAudioDevices([NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			int ret = SDLGetNumAudioDevicesNative(iscapture);
			return ret;
		}

		/// <summary>
		/// Get the human-readable name of a specific audio device.<br/>
		/// This function is only valid after successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>
		/// managed internally. You are not to free it. If you need to keep the string<br/>
		/// for any length of time, you should make your own copy of it, as it will be<br/>
		/// invalid next time any of several other SDL functions are called.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetAudioDeviceName")]
		internal static extern byte* SDLGetAudioDeviceNameNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture);

		/// <summary>		/// Get the human-readable name of a specific audio device.<br/>		/// This function is only valid after successfully initializing the audio<br/>		/// subsystem. The values returned by this function reflect the latest call to<br/>		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>		/// hardware.<br/>		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>		/// managed internally. You are not to free it. If you need to keep the string<br/>		/// for any length of time, you should make your own copy of it, as it will be<br/>		/// invalid next time any of several other SDL functions are called.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetAudioDeviceName([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			byte* ret = SDLGetAudioDeviceNameNative(index, iscapture);
			return ret;
		}

		/// <summary>		/// Get the human-readable name of a specific audio device.<br/>		/// This function is only valid after successfully initializing the audio<br/>		/// subsystem. The values returned by this function reflect the latest call to<br/>		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>		/// hardware.<br/>		/// The string returned by this function is UTF-8 encoded, read-only, and<br/>		/// managed internally. You are not to free it. If you need to keep the string<br/>		/// for any length of time, you should make your own copy of it, as it will be<br/>		/// invalid next time any of several other SDL functions are called.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetAudioDeviceNameS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetAudioDeviceNameNative(index, iscapture));
			return ret;
		}

		/// <summary>
		/// Get the preferred audio format of a specific audio device.<br/>
		/// This function is only valid after a successfully initializing the audio<br/>
		/// subsystem. The values returned by this function reflect the latest call to<br/>
		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>
		/// hardware.<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetAudioDeviceSpec")]
		internal static extern int SDLGetAudioDeviceSpecNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec);

		/// <summary>		/// Get the preferred audio format of a specific audio device.<br/>		/// This function is only valid after a successfully initializing the audio<br/>		/// subsystem. The values returned by this function reflect the latest call to<br/>		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>		/// hardware.<br/>		/// `spec` will be filled with the sample rate, sample format, and channel<br/>		/// count.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetAudioDeviceSpec([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec)
		{
			int ret = SDLGetAudioDeviceSpecNative(index, iscapture, spec);
			return ret;
		}

		/// <summary>		/// Get the preferred audio format of a specific audio device.<br/>		/// This function is only valid after a successfully initializing the audio<br/>		/// subsystem. The values returned by this function reflect the latest call to<br/>		/// SDL_GetNumAudioDevices(); re-call that function to redetect available<br/>		/// hardware.<br/>		/// `spec` will be filled with the sample rate, sample format, and channel<br/>		/// count.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceSpec")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetAudioDeviceSpec([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = SDLGetAudioDeviceSpecNative(index, iscapture, (SDLAudioSpec*)pspec);
				return ret;
			}
		}

		/// <summary>
		/// Get the name and preferred format of the default audio device.<br/>
		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>
		/// about the "default" device. This can actually be a completely different<br/>
		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>
		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>
		/// As a result, this call is not guaranteed to be performant, as it can query<br/>
		/// the sound server directly every time, unlike the other query functions. You<br/>
		/// should call this function sparingly!<br/>
		/// `spec` will be filled with the sample rate, sample format, and channel<br/>
		/// count, if a default device exists on the system. If `name` is provided,<br/>
		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDefaultAudioInfo")]
		internal static extern int SDLGetDefaultAudioInfoNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture);

		/// <summary>		/// Get the name and preferred format of the default audio device.<br/>		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>		/// about the "default" device. This can actually be a completely different<br/>		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>		/// As a result, this call is not guaranteed to be performant, as it can query<br/>		/// the sound server directly every time, unlike the other query functions. You<br/>		/// should call this function sparingly!<br/>		/// `spec` will be filled with the sample rate, sample format, and channel<br/>		/// count, if a default device exists on the system. If `name` is provided,<br/>		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			int ret = SDLGetDefaultAudioInfoNative(name, spec, iscapture);
			return ret;
		}

		/// <summary>		/// Get the name and preferred format of the default audio device.<br/>		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>		/// about the "default" device. This can actually be a completely different<br/>		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>		/// As a result, this call is not guaranteed to be performant, as it can query<br/>		/// the sound server directly every time, unlike the other query functions. You<br/>		/// should call this function sparingly!<br/>		/// `spec` will be filled with the sample rate, sample format, and channel<br/>		/// count, if a default device exists on the system. If `name` is provided,<br/>		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] ref byte* name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (byte** pname = &name)
			{
				int ret = SDLGetDefaultAudioInfoNative((byte**)pname, spec, iscapture);
				return ret;
			}
		}

		/// <summary>		/// Get the name and preferred format of the default audio device.<br/>		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>		/// about the "default" device. This can actually be a completely different<br/>		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>		/// As a result, this call is not guaranteed to be performant, as it can query<br/>		/// the sound server directly every time, unlike the other query functions. You<br/>		/// should call this function sparingly!<br/>		/// `spec` will be filled with the sample rate, sample format, and channel<br/>		/// count, if a default device exists on the system. If `name` is provided,<br/>		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] byte** name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				int ret = SDLGetDefaultAudioInfoNative(name, (SDLAudioSpec*)pspec, iscapture);
				return ret;
			}
		}

		/// <summary>		/// Get the name and preferred format of the default audio device.<br/>		/// Some (but not all!) platforms have an isolated mechanism to get information<br/>		/// about the "default" device. This can actually be a completely different<br/>		/// device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can<br/>		/// even be a network address! (This is discussed in SDL_OpenAudioDevice().)<br/>		/// As a result, this call is not guaranteed to be performant, as it can query<br/>		/// the sound server directly every time, unlike the other query functions. You<br/>		/// should call this function sparingly!<br/>		/// `spec` will be filled with the sample rate, sample format, and channel<br/>		/// count, if a default device exists on the system. If `name` is provided,<br/>		/// will be filled with either a dynamically-allocated UTF-8 string or NULL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultAudioInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDefaultAudioInfo([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "char**")] ref byte* name, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture)
		{
			fixed (byte** pname = &name)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					int ret = SDLGetDefaultAudioInfoNative((byte**)pname, (SDLAudioSpec*)pspec, iscapture);
					return ret;
				}
			}
		}

		/// <summary>
		/// Open a specific audio device.<br/>
		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>
		/// this function will never return a 1 so as not to conflict with the legacy<br/>
		/// function.<br/>
		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>
		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>
		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>
		/// Passing in a `device` name of NULL requests the most reasonable default<br/>
		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>
		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>
		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>
		/// hostname/IP address for a remote audio server, or a filename in the<br/>
		/// diskaudio driver.<br/>
		/// An opened audio device starts out paused, and should be enabled for playing<br/>
		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>
		/// callback function to be called. Since the audio driver may modify the<br/>
		/// requested size of the audio buffer, you should allocate any local mixing<br/>
		/// buffers after you open the audio device.<br/>
		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>
		/// race conditions between your callback and other threads without fully<br/>
		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>
		/// callback, see SDL_AudioSpec.<br/>
		/// Managing the audio spec via 'desired' and 'obtained':<br/>
		/// When filling in the desired audio spec structure:<br/>
		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>
		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>
		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>
		/// frames_ (with stereo output, two samples--left and right--would make a<br/>
		/// single sample frame). This number should be a power of two, and may be<br/>
		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>
		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>
		/// the application and CPU speed. Smaller values reduce latency, but can<br/>
		/// lead to underflow if the application is doing heavy processing and cannot<br/>
		/// fill the audio buffer in time. Note that the number of sample frames is<br/>
		/// directly related to time by the following formula: `ms =<br/>
		/// (sampleframes*1000)/freq`<br/>
		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>
		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>
		/// - `desired->callback` should be set to a function that will be called when<br/>
		/// the audio device is ready for more data. It is passed a pointer to the<br/>
		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>
		/// usually runs in a separate thread, and so you should protect data<br/>
		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>
		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>
		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>
		/// more audio samples to be played (or for capture devices, call<br/>
		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>
		/// - `desired->userdata` is passed as the first parameter to your callback<br/>
		/// function. If you passed a NULL callback, this value is ignored.<br/>
		/// `allowed_changes` can have the following flags OR'd together:<br/>
		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>
		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>
		/// These flags specify how SDL should behave when a device cannot offer a<br/>
		/// specific feature. If the application requests a feature that the hardware<br/>
		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>
		/// For example, if you ask for float32 audio format, but the sound card only<br/>
		/// supports int16, SDL will set the hardware to int16. If you had set<br/>
		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>
		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>
		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>
		/// will keep the originally requested format in the `obtained` structure.<br/>
		/// The resulting audio specs, varying depending on hardware and on what<br/>
		/// changes were allowed, will then be written back to `obtained`.<br/>
		/// If your application can only handle one specific data format, pass a zero<br/>
		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>
		/// <br/>
		/// For compatibility with SDL 1.2, this will never return 1, since<br/>
		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_OpenAudioDevice")]
		internal static extern uint SDLOpenAudioDeviceNative([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges);

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			uint ret = SDLOpenAudioDeviceNative(device, iscapture, desired, obtained, allowedChanges);
			return ret;
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, desired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, desired, obtained, allowedChanges);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = SDLOpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, obtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = SDLOpenAudioDeviceNative(device, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
				return ret;
			}
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] SDLAudioSpec* desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pobtained = &obtained)
			{
				uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, desired, (SDLAudioSpec*)pobtained, allowedChanges);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] byte* device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative(device, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					return ret;
				}
			}
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] ref byte device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			fixed (byte* pdevice = &device)
			{
				fixed (SDLAudioSpec* pdesired = &desired)
				{
					fixed (SDLAudioSpec* pobtained = &obtained)
					{
						uint ret = SDLOpenAudioDeviceNative((byte*)pdevice, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Open a specific audio device.<br/>		/// SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,<br/>		/// this function will never return a 1 so as not to conflict with the legacy<br/>		/// function.<br/>		/// Please note that SDL 2.0 before 2.0.5 did not support recording; as such,<br/>		/// this function would fail if `iscapture` was not zero. Starting with SDL<br/>		/// 2.0.5, recording is implemented and this value can be non-zero.<br/>		/// Passing in a `device` name of NULL requests the most reasonable default<br/>		/// (and is equivalent to what SDL_OpenAudio() does to choose a device). The<br/>		/// `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but<br/>		/// some drivers allow arbitrary and driver-specific strings, such as a<br/>		/// hostname/IP address for a remote audio server, or a filename in the<br/>		/// diskaudio driver.<br/>		/// An opened audio device starts out paused, and should be enabled for playing<br/>		/// by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio<br/>		/// callback function to be called. Since the audio driver may modify the<br/>		/// requested size of the audio buffer, you should allocate any local mixing<br/>		/// buffers after you open the audio device.<br/>		/// The audio callback runs in a separate thread in most cases; you can prevent<br/>		/// race conditions between your callback and other threads without fully<br/>		/// pausing playback with SDL_LockAudioDevice(). For more information about the<br/>		/// callback, see SDL_AudioSpec.<br/>		/// Managing the audio spec via 'desired' and 'obtained':<br/>		/// When filling in the desired audio spec structure:<br/>		/// - `desired->freq` should be the frequency in sample-frames-per-second (Hz).<br/>		/// - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc).<br/>		/// - `desired->samples` is the desired size of the audio buffer, in _sample<br/>		/// frames_ (with stereo output, two samples--left and right--would make a<br/>		/// single sample frame). This number should be a power of two, and may be<br/>		/// adjusted by the audio driver to a value more suitable for the hardware.<br/>		/// Good values seem to range between 512 and 8096 inclusive, depending on<br/>		/// the application and CPU speed. Smaller values reduce latency, but can<br/>		/// lead to underflow if the application is doing heavy processing and cannot<br/>		/// fill the audio buffer in time. Note that the number of sample frames is<br/>		/// directly related to time by the following formula: `ms =<br/>		/// (sampleframes*1000)/freq`<br/>		/// - `desired->size` is the size in _bytes_ of the audio buffer, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->silence` is the value used to set the buffer to silence, and is<br/>		/// calculated by SDL_OpenAudioDevice(). You don't initialize this.<br/>		/// - `desired->callback` should be set to a function that will be called when<br/>		/// the audio device is ready for more data. It is passed a pointer to the<br/>		/// audio buffer, and the length in bytes of the audio buffer. This function<br/>		/// usually runs in a separate thread, and so you should protect data<br/>		/// structures that it accesses by calling SDL_LockAudioDevice() and<br/>		/// SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL<br/>		/// pointer here, and call SDL_QueueAudio() with some frequency, to queue<br/>		/// more audio samples to be played (or for capture devices, call<br/>		/// SDL_DequeueAudio() with some frequency, to obtain audio samples).<br/>		/// - `desired->userdata` is passed as the first parameter to your callback<br/>		/// function. If you passed a NULL callback, this value is ignored.<br/>		/// `allowed_changes` can have the following flags OR'd together:<br/>		/// - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`<br/>		/// - `SDL_AUDIO_ALLOW_ANY_CHANGE`<br/>		/// These flags specify how SDL should behave when a device cannot offer a<br/>		/// specific feature. If the application requests a feature that the hardware<br/>		/// doesn't offer, SDL will always try to get the closest equivalent.<br/>		/// For example, if you ask for float32 audio format, but the sound card only<br/>		/// supports int16, SDL will set the hardware to int16. If you had set<br/>		/// SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`<br/>		/// structure. If that flag was *not* set, SDL will prepare to convert your<br/>		/// callback's float32 audio to int16 before feeding it to the hardware and<br/>		/// will keep the originally requested format in the `obtained` structure.<br/>		/// The resulting audio specs, varying depending on hardware and on what<br/>		/// changes were allowed, will then be written back to `obtained`.<br/>		/// If your application can only handle one specific data format, pass a zero<br/>		/// for `allowed_changes` and let SDL transparently handle any differences.<br/>		/// <br/>		/// For compatibility with SDL 1.2, this will never return 1, since<br/>		/// SDL reserves that ID for the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenAudioDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioDeviceID")]
		public static uint SDLOpenAudioDevice([NativeName(NativeNameType.Param, "device")] [NativeName(NativeNameType.Type, "const char*")] string device, [NativeName(NativeNameType.Param, "iscapture")] [NativeName(NativeNameType.Type, "int")] int iscapture, [NativeName(NativeNameType.Param, "desired")] [NativeName(NativeNameType.Type, "const SDL_AudioSpec*")] ref SDLAudioSpec desired, [NativeName(NativeNameType.Param, "obtained")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec obtained, [NativeName(NativeNameType.Param, "allowed_changes")] [NativeName(NativeNameType.Type, "int")] int allowedChanges)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (device != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(device);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(device, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLAudioSpec* pdesired = &desired)
			{
				fixed (SDLAudioSpec* pobtained = &obtained)
				{
					uint ret = SDLOpenAudioDeviceNative(pStr0, iscapture, (SDLAudioSpec*)pdesired, (SDLAudioSpec*)pobtained, allowedChanges);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// This function is a legacy means of querying the audio device.<br/>
		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_GetAudioDeviceStatus(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetAudioStatus")]
		internal static extern SDLAudioStatus SDLGetAudioStatusNative();

		/// <summary>		/// This function is a legacy means of querying the audio device.<br/>		/// New programs might want to use SDL_GetAudioDeviceStatus() instead. This<br/>		/// function is equivalent to calling...<br/>		/// ```c<br/>		/// SDL_GetAudioDeviceStatus(1);<br/>		/// ```<br/>		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		public static SDLAudioStatus SDLGetAudioStatus()
		{
			SDLAudioStatus ret = SDLGetAudioStatusNative();
			return ret;
		}

		/// <summary>
		/// Use this function to get the current audio state of an audio device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetAudioDeviceStatus")]
		internal static extern SDLAudioStatus SDLGetAudioDeviceStatusNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev);

		/// <summary>		/// Use this function to get the current audio state of an audio device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetAudioDeviceStatus")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStatus")]
		public static SDLAudioStatus SDLGetAudioDeviceStatus([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			SDLAudioStatus ret = SDLGetAudioDeviceStatusNative(dev);
			return ret;
		}

		/// <summary>
		/// This function is a legacy means of pausing the audio device.<br/>
		/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_PauseAudioDevice(1, pause_on);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_PauseAudio")]
		internal static extern void SDLPauseAudioNative([NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn);

		/// <summary>		/// This function is a legacy means of pausing the audio device.<br/>		/// New programs might want to use SDL_PauseAudioDevice() instead. This<br/>		/// function is equivalent to calling...<br/>		/// ```c<br/>		/// SDL_PauseAudioDevice(1, pause_on);<br/>		/// ```<br/>		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PauseAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLPauseAudio([NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			SDLPauseAudioNative(pauseOn);
		}

		/// <summary>
		/// Use this function to pause and unpause audio playback on a specified<br/>
		/// device.<br/>
		/// This function pauses and unpauses the audio callback processing for a given<br/>
		/// device. Newly-opened audio devices start in the paused state, so you must<br/>
		/// call this function with **pause_on**=0 after opening the specified audio<br/>
		/// device to start playing sound. This allows you to safely initialize data<br/>
		/// for your callback function after opening the audio device. Silence will be<br/>
		/// written to the audio device while paused, and the audio callback is<br/>
		/// guaranteed to not be called. Pausing one device does not prevent other<br/>
		/// unpaused devices from running their callbacks.<br/>
		/// Pausing state does not stack; even if you pause a device several times, a<br/>
		/// single unpause will start the device playing again, and vice versa. This is<br/>
		/// different from how SDL_LockAudioDevice() works.<br/>
		/// If you just need to protect a few variables from race conditions vs your<br/>
		/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>
		/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PauseAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_PauseAudioDevice")]
		internal static extern void SDLPauseAudioDeviceNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn);

		/// <summary>		/// Use this function to pause and unpause audio playback on a specified<br/>		/// device.<br/>		/// This function pauses and unpauses the audio callback processing for a given<br/>		/// device. Newly-opened audio devices start in the paused state, so you must<br/>		/// call this function with **pause_on**=0 after opening the specified audio<br/>		/// device to start playing sound. This allows you to safely initialize data<br/>		/// for your callback function after opening the audio device. Silence will be<br/>		/// written to the audio device while paused, and the audio callback is<br/>		/// guaranteed to not be called. Pausing one device does not prevent other<br/>		/// unpaused devices from running their callbacks.<br/>		/// Pausing state does not stack; even if you pause a device several times, a<br/>		/// single unpause will start the device playing again, and vice versa. This is<br/>		/// different from how SDL_LockAudioDevice() works.<br/>		/// If you just need to protect a few variables from race conditions vs your<br/>		/// callback, you shouldn't pause the audio device, as it will lead to dropouts<br/>		/// in the audio playback. Instead, you should use SDL_LockAudioDevice().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PauseAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLPauseAudioDevice([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "pause_on")] [NativeName(NativeNameType.Type, "int")] int pauseOn)
		{
			SDLPauseAudioDeviceNative(dev, pauseOn);
		}

		/// <summary>
		/// Load the audio data of a WAVE file into memory.<br/>
		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
		/// be valid pointers. The entire data portion of the file is then loaded into<br/>
		/// memory and decoded if necessary.<br/>
		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>
		/// freed before the function returns.<br/>
		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
		/// cause an error.<br/>
		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>
		/// and the pointer to the audio data allocated by the function is written to<br/>
		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>
		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>
		/// data in the buffer. The `samples` member is set to a sane default and all<br/>
		/// others are set to zero.<br/>
		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>
		/// `audio_buf` when it is no longer used.<br/>
		/// Because of the underspecification of the .WAV format, there are many<br/>
		/// problematic files in the wild that cause issues with strict decoders. To<br/>
		/// provide compatibility with these files, this decoder is lenient in regards<br/>
		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
		/// tune the behavior of the loading process.<br/>
		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
		/// critical I/O error from the data source will terminate the loading process<br/>
		/// with an error. The function returns NULL on error and in all cases (with<br/>
		/// the exception of `src` being NULL), an appropriate error message will be<br/>
		/// set.<br/>
		/// It is required that the data source supports seeking.<br/>
		/// Example:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>
		/// messy way:<br/>
		/// ```c<br/>
		/// SDL_LoadWAV("sample.wav", <br/>
		/// &spec<br/>
		/// , <br/>
		/// &buf<br/>
		/// , <br/>
		/// &len<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>
		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>
		/// more information.<br/>
		/// When the application is done with the data returned in<br/>
		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LoadWAV_RW")]
		internal static extern SDLAudioSpec* SDLLoadWAVRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen);

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, spec, audioBuf, audioLen);
			return ret;
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, audioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, audioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, audioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, spec, (byte**)paudioBuf, audioLen);
				return ret;
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, (byte**)paudioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
					return ret;
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] uint* audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, audioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (uint* paudioLen = &audioLen)
			{
				SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, spec, audioBuf, (uint*)paudioLen);
				return ret;
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, audioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] byte** audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, audioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (byte** paudioBuf = &audioBuf)
			{
				fixed (uint* paudioLen = &audioLen)
				{
					SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, spec, (byte**)paudioBuf, (uint*)paudioLen);
					return ret;
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] SDLAudioSpec* spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, spec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLAudioSpec* pspec = &spec)
			{
				fixed (byte** paudioBuf = &audioBuf)
				{
					fixed (uint* paudioLen = &audioLen)
					{
						SDLAudioSpec* ret = SDLLoadWAVRWNative(src, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Load the audio data of a WAVE file into memory.<br/>		/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>		/// be valid pointers. The entire data portion of the file is then loaded into<br/>		/// memory and decoded if necessary.<br/>		/// If `freesrc` is non-zero, the data source gets automatically closed and<br/>		/// freed before the function returns.<br/>		/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>		/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>		/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>		/// cause an error.<br/>		/// If this function succeeds, the pointer returned by it is equal to `spec`<br/>		/// and the pointer to the audio data allocated by the function is written to<br/>		/// `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec<br/>		/// members `freq`, `channels`, and `format` are set to the values of the audio<br/>		/// data in the buffer. The `samples` member is set to a sane default and all<br/>		/// others are set to zero.<br/>		/// It's necessary to use SDL_FreeWAV() to free the audio data returned in<br/>		/// `audio_buf` when it is no longer used.<br/>		/// Because of the underspecification of the .WAV format, there are many<br/>		/// problematic files in the wild that cause issues with strict decoders. To<br/>		/// provide compatibility with these files, this decoder is lenient in regards<br/>		/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>		/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>		/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>		/// tune the behavior of the loading process.<br/>		/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>		/// the headers), too big, or unsupported causes an error. Additionally, any<br/>		/// critical I/O error from the data source will terminate the loading process<br/>		/// with an error. The function returns NULL on error and in all cases (with<br/>		/// the exception of `src` being NULL), an appropriate error message will be<br/>		/// set.<br/>		/// It is required that the data source supports seeking.<br/>		/// Example:<br/>		/// ```c<br/>		/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// Note that the SDL_LoadWAV macro does this same thing for you, but in a less<br/>		/// messy way:<br/>		/// ```c<br/>		/// SDL_LoadWAV("sample.wav", <br/>		/// &spec<br/>		/// , <br/>		/// &buf<br/>		/// , <br/>		/// &len<br/>		/// );<br/>		/// ```<br/>		/// <br/>		/// This function returns NULL if the .WAV file cannot be opened, uses<br/>		/// an unknown data format, or is corrupt; call SDL_GetError() for<br/>		/// more information.<br/>		/// When the application is done with the data returned in<br/>		/// `audio_buf`, it should call SDL_FreeWAV() to dispose of it.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadWAV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioSpec*")]
		public static SDLAudioSpec* SDLLoadWAVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "spec")] [NativeName(NativeNameType.Type, "SDL_AudioSpec*")] ref SDLAudioSpec spec, [NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8**")] ref byte* audioBuf, [NativeName(NativeNameType.Param, "audio_len")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint audioLen)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (SDLAudioSpec* pspec = &spec)
				{
					fixed (byte** paudioBuf = &audioBuf)
					{
						fixed (uint* paudioLen = &audioLen)
						{
							SDLAudioSpec* ret = SDLLoadWAVRWNative((SDLRWops*)psrc, freesrc, (SDLAudioSpec*)pspec, (byte**)paudioBuf, (uint*)paudioLen);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().<br/>
		/// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()<br/>
		/// its data can eventually be freed with SDL_FreeWAV(). It is safe to call<br/>
		/// this function with a NULL pointer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeWAV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FreeWAV")]
		internal static extern void SDLFreeWAVNative([NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8*")] byte* audioBuf);

		/// <summary>		/// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().<br/>		/// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()<br/>		/// its data can eventually be freed with SDL_FreeWAV(). It is safe to call<br/>		/// this function with a NULL pointer.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeWAV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeWAV([NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8*")] byte* audioBuf)
		{
			SDLFreeWAVNative(audioBuf);
		}

		/// <summary>		/// Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW().<br/>		/// After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()<br/>		/// its data can eventually be freed with SDL_FreeWAV(). It is safe to call<br/>		/// this function with a NULL pointer.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeWAV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeWAV([NativeName(NativeNameType.Param, "audio_buf")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte audioBuf)
		{
			fixed (byte* paudioBuf = &audioBuf)
			{
				SDLFreeWAVNative((byte*)paudioBuf);
			}
		}

		/// <summary>
		/// Initialize an SDL_AudioCVT structure for conversion.<br/>
		/// Before an SDL_AudioCVT structure can be used to convert audio data it must<br/>
		/// be initialized with source and destination information.<br/>
		/// This function will zero out every field of the SDL_AudioCVT, so it must be<br/>
		/// called before the application fills in the final buffer information.<br/>
		/// Once this function has returned successfully, and reported that a<br/>
		/// conversion is necessary, the application fills in the rest of the fields in<br/>
		/// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,<br/>
		/// and then can call SDL_ConvertAudio() to complete the conversion.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_BuildAudioCVT")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_BuildAudioCVT")]
		internal static extern int SDLBuildAudioCVNative([NativeName(NativeNameType.Param, "cvt")] [NativeName(NativeNameType.Type, "SDL_AudioCVT*")] SDLAudioCV* cvt, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort srcFormat, [NativeName(NativeNameType.Param, "src_channels")] [NativeName(NativeNameType.Type, "Uint8")] byte srcChannels, [NativeName(NativeNameType.Param, "src_rate")] [NativeName(NativeNameType.Type, "int")] int srcRate, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort dstFormat, [NativeName(NativeNameType.Param, "dst_channels")] [NativeName(NativeNameType.Type, "Uint8")] byte dstChannels, [NativeName(NativeNameType.Param, "dst_rate")] [NativeName(NativeNameType.Type, "int")] int dstRate);

		/// <summary>		/// Initialize an SDL_AudioCVT structure for conversion.<br/>		/// Before an SDL_AudioCVT structure can be used to convert audio data it must<br/>		/// be initialized with source and destination information.<br/>		/// This function will zero out every field of the SDL_AudioCVT, so it must be<br/>		/// called before the application fills in the final buffer information.<br/>		/// Once this function has returned successfully, and reported that a<br/>		/// conversion is necessary, the application fills in the rest of the fields in<br/>		/// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,<br/>		/// and then can call SDL_ConvertAudio() to complete the conversion.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_BuildAudioCVT")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLBuildAudioCV([NativeName(NativeNameType.Param, "cvt")] [NativeName(NativeNameType.Type, "SDL_AudioCVT*")] SDLAudioCV* cvt, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort srcFormat, [NativeName(NativeNameType.Param, "src_channels")] [NativeName(NativeNameType.Type, "Uint8")] byte srcChannels, [NativeName(NativeNameType.Param, "src_rate")] [NativeName(NativeNameType.Type, "int")] int srcRate, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort dstFormat, [NativeName(NativeNameType.Param, "dst_channels")] [NativeName(NativeNameType.Type, "Uint8")] byte dstChannels, [NativeName(NativeNameType.Param, "dst_rate")] [NativeName(NativeNameType.Type, "int")] int dstRate)
		{
			int ret = SDLBuildAudioCVNative(cvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			return ret;
		}

		/// <summary>		/// Initialize an SDL_AudioCVT structure for conversion.<br/>		/// Before an SDL_AudioCVT structure can be used to convert audio data it must<br/>		/// be initialized with source and destination information.<br/>		/// This function will zero out every field of the SDL_AudioCVT, so it must be<br/>		/// called before the application fills in the final buffer information.<br/>		/// Once this function has returned successfully, and reported that a<br/>		/// conversion is necessary, the application fills in the rest of the fields in<br/>		/// SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,<br/>		/// and then can call SDL_ConvertAudio() to complete the conversion.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_BuildAudioCVT")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLBuildAudioCV([NativeName(NativeNameType.Param, "cvt")] [NativeName(NativeNameType.Type, "SDL_AudioCVT*")] ref SDLAudioCV cvt, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort srcFormat, [NativeName(NativeNameType.Param, "src_channels")] [NativeName(NativeNameType.Type, "Uint8")] byte srcChannels, [NativeName(NativeNameType.Param, "src_rate")] [NativeName(NativeNameType.Type, "int")] int srcRate, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort dstFormat, [NativeName(NativeNameType.Param, "dst_channels")] [NativeName(NativeNameType.Type, "Uint8")] byte dstChannels, [NativeName(NativeNameType.Param, "dst_rate")] [NativeName(NativeNameType.Type, "int")] int dstRate)
		{
			fixed (SDLAudioCV* pcvt = &cvt)
			{
				int ret = SDLBuildAudioCVNative((SDLAudioCV*)pcvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
				return ret;
			}
		}

		/// <summary>
		/// Convert audio data to a desired audio format.<br/>
		/// This function does the actual audio data conversion, after the application<br/>
		/// has called SDL_BuildAudioCVT() to prepare the conversion information and<br/>
		/// then filled in the buffer details.<br/>
		/// Once the application has initialized the `cvt` structure using<br/>
		/// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio<br/>
		/// data in the source format, this function will convert the buffer, in-place,<br/>
		/// to the desired format.<br/>
		/// The data conversion may go through several passes; any given pass may<br/>
		/// possibly temporarily increase the size of the data. For example, SDL might<br/>
		/// expand 16-bit data to 32 bits before resampling to a lower frequency,<br/>
		/// shrinking the data size after having grown it briefly. Since the supplied<br/>
		/// buffer will be both the source and destination, converting as necessary<br/>
		/// in-place, the application must allocate a buffer that will fully contain<br/>
		/// the data during its largest conversion pass. After SDL_BuildAudioCVT()<br/>
		/// returns, the application should set the `cvt->len` field to the size, in<br/>
		/// bytes, of the source data, and allocate a buffer that is `cvt->len *<br/>
		/// cvt->len_mult` bytes long for the `buf` field.<br/>
		/// The source data should be copied into this buffer before the call to<br/>
		/// SDL_ConvertAudio(). Upon successful return, this buffer will contain the<br/>
		/// converted audio, and `cvt->len_cvt` will be the size of the converted data,<br/>
		/// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once<br/>
		/// this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ConvertAudio")]
		internal static extern int SDLConvertAudioNative([NativeName(NativeNameType.Param, "cvt")] [NativeName(NativeNameType.Type, "SDL_AudioCVT*")] SDLAudioCV* cvt);

		/// <summary>		/// Convert audio data to a desired audio format.<br/>		/// This function does the actual audio data conversion, after the application<br/>		/// has called SDL_BuildAudioCVT() to prepare the conversion information and<br/>		/// then filled in the buffer details.<br/>		/// Once the application has initialized the `cvt` structure using<br/>		/// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio<br/>		/// data in the source format, this function will convert the buffer, in-place,<br/>		/// to the desired format.<br/>		/// The data conversion may go through several passes; any given pass may<br/>		/// possibly temporarily increase the size of the data. For example, SDL might<br/>		/// expand 16-bit data to 32 bits before resampling to a lower frequency,<br/>		/// shrinking the data size after having grown it briefly. Since the supplied<br/>		/// buffer will be both the source and destination, converting as necessary<br/>		/// in-place, the application must allocate a buffer that will fully contain<br/>		/// the data during its largest conversion pass. After SDL_BuildAudioCVT()<br/>		/// returns, the application should set the `cvt->len` field to the size, in<br/>		/// bytes, of the source data, and allocate a buffer that is `cvt->len *<br/>		/// cvt->len_mult` bytes long for the `buf` field.<br/>		/// The source data should be copied into this buffer before the call to<br/>		/// SDL_ConvertAudio(). Upon successful return, this buffer will contain the<br/>		/// converted audio, and `cvt->len_cvt` will be the size of the converted data,<br/>		/// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once<br/>		/// this function returns.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLConvertAudio([NativeName(NativeNameType.Param, "cvt")] [NativeName(NativeNameType.Type, "SDL_AudioCVT*")] SDLAudioCV* cvt)
		{
			int ret = SDLConvertAudioNative(cvt);
			return ret;
		}

		/// <summary>		/// Convert audio data to a desired audio format.<br/>		/// This function does the actual audio data conversion, after the application<br/>		/// has called SDL_BuildAudioCVT() to prepare the conversion information and<br/>		/// then filled in the buffer details.<br/>		/// Once the application has initialized the `cvt` structure using<br/>		/// SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio<br/>		/// data in the source format, this function will convert the buffer, in-place,<br/>		/// to the desired format.<br/>		/// The data conversion may go through several passes; any given pass may<br/>		/// possibly temporarily increase the size of the data. For example, SDL might<br/>		/// expand 16-bit data to 32 bits before resampling to a lower frequency,<br/>		/// shrinking the data size after having grown it briefly. Since the supplied<br/>		/// buffer will be both the source and destination, converting as necessary<br/>		/// in-place, the application must allocate a buffer that will fully contain<br/>		/// the data during its largest conversion pass. After SDL_BuildAudioCVT()<br/>		/// returns, the application should set the `cvt->len` field to the size, in<br/>		/// bytes, of the source data, and allocate a buffer that is `cvt->len *<br/>		/// cvt->len_mult` bytes long for the `buf` field.<br/>		/// The source data should be copied into this buffer before the call to<br/>		/// SDL_ConvertAudio(). Upon successful return, this buffer will contain the<br/>		/// converted audio, and `cvt->len_cvt` will be the size of the converted data,<br/>		/// in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once<br/>		/// this function returns.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLConvertAudio([NativeName(NativeNameType.Param, "cvt")] [NativeName(NativeNameType.Type, "SDL_AudioCVT*")] ref SDLAudioCV cvt)
		{
			fixed (SDLAudioCV* pcvt = &cvt)
			{
				int ret = SDLConvertAudioNative((SDLAudioCV*)pcvt);
				return ret;
			}
		}

		/// <summary>
		/// Create a new audio stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_NewAudioStream")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStream*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_NewAudioStream")]
		internal static extern SDLAudioStream* SDLNewAudioStreamNative([NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "const SDL_AudioFormat")] ushort srcFormat, [NativeName(NativeNameType.Param, "src_channels")] [NativeName(NativeNameType.Type, "const Uint8")] byte srcChannels, [NativeName(NativeNameType.Param, "src_rate")] [NativeName(NativeNameType.Type, "const int")] int srcRate, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "const SDL_AudioFormat")] ushort dstFormat, [NativeName(NativeNameType.Param, "dst_channels")] [NativeName(NativeNameType.Type, "const Uint8")] byte dstChannels, [NativeName(NativeNameType.Param, "dst_rate")] [NativeName(NativeNameType.Type, "const int")] int dstRate);

		/// <summary>		/// Create a new audio stream.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_NewAudioStream")]
		[return: NativeName(NativeNameType.Type, "SDL_AudioStream*")]
		public static SDLAudioStream* SDLNewAudioStream([NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "const SDL_AudioFormat")] ushort srcFormat, [NativeName(NativeNameType.Param, "src_channels")] [NativeName(NativeNameType.Type, "const Uint8")] byte srcChannels, [NativeName(NativeNameType.Param, "src_rate")] [NativeName(NativeNameType.Type, "const int")] int srcRate, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "const SDL_AudioFormat")] ushort dstFormat, [NativeName(NativeNameType.Param, "dst_channels")] [NativeName(NativeNameType.Type, "const Uint8")] byte dstChannels, [NativeName(NativeNameType.Param, "dst_rate")] [NativeName(NativeNameType.Type, "const int")] int dstRate)
		{
			SDLAudioStream* ret = SDLNewAudioStreamNative(srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate);
			return ret;
		}

		/// <summary>
		/// Add data to be converted/resampled to the stream.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioStreamPut")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AudioStreamPut")]
		internal static extern int SDLAudioStreamPutNative([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "const void*")] void* buf, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "int")] int len);

		/// <summary>		/// Add data to be converted/resampled to the stream.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamPut")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioStreamPut([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "const void*")] void* buf, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "int")] int len)
		{
			int ret = SDLAudioStreamPutNative(stream, buf, len);
			return ret;
		}

		/// <summary>		/// Add data to be converted/resampled to the stream.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamPut")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioStreamPut([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] ref SDLAudioStream stream, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "const void*")] void* buf, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "int")] int len)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = SDLAudioStreamPutNative((SDLAudioStream*)pstream, buf, len);
				return ret;
			}
		}

		/// <summary>
		/// Get converted/resampled data from the stream<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioStreamGet")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AudioStreamGet")]
		internal static extern int SDLAudioStreamGetNative([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "void*")] void* buf, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "int")] int len);

		/// <summary>		/// Get converted/resampled data from the stream<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamGet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioStreamGet([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "void*")] void* buf, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "int")] int len)
		{
			int ret = SDLAudioStreamGetNative(stream, buf, len);
			return ret;
		}

		/// <summary>		/// Get converted/resampled data from the stream<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamGet")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioStreamGet([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] ref SDLAudioStream stream, [NativeName(NativeNameType.Param, "buf")] [NativeName(NativeNameType.Type, "void*")] void* buf, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "int")] int len)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = SDLAudioStreamGetNative((SDLAudioStream*)pstream, buf, len);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of converted/resampled bytes available.<br/>
		/// The stream may be buffering data behind the scenes until it has enough to<br/>
		/// resample correctly, so this number might be lower than what you expect, or<br/>
		/// even be zero. Add more data or flush the stream if you need the data now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioStreamAvailable")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AudioStreamAvailable")]
		internal static extern int SDLAudioStreamAvailableNative([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream);

		/// <summary>		/// Get the number of converted/resampled bytes available.<br/>		/// The stream may be buffering data behind the scenes until it has enough to<br/>		/// resample correctly, so this number might be lower than what you expect, or<br/>		/// even be zero. Add more data or flush the stream if you need the data now.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamAvailable")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioStreamAvailable([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream)
		{
			int ret = SDLAudioStreamAvailableNative(stream);
			return ret;
		}

		/// <summary>		/// Get the number of converted/resampled bytes available.<br/>		/// The stream may be buffering data behind the scenes until it has enough to<br/>		/// resample correctly, so this number might be lower than what you expect, or<br/>		/// even be zero. Add more data or flush the stream if you need the data now.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamAvailable")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioStreamAvailable([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = SDLAudioStreamAvailableNative((SDLAudioStream*)pstream);
				return ret;
			}
		}

		/// <summary>
		/// Tell the stream that you're done sending data, and anything being buffered<br/>
		/// should be converted/resampled and made available immediately.<br/>
		/// It is legal to add more data to a stream after flushing, but there will be<br/>
		/// audio gaps in the output. Generally this is intended to signal the end of<br/>
		/// input, so the complete output becomes available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioStreamFlush")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AudioStreamFlush")]
		internal static extern int SDLAudioStreamFlushNative([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream);

		/// <summary>		/// Tell the stream that you're done sending data, and anything being buffered<br/>		/// should be converted/resampled and made available immediately.<br/>		/// It is legal to add more data to a stream after flushing, but there will be<br/>		/// audio gaps in the output. Generally this is intended to signal the end of<br/>		/// input, so the complete output becomes available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamFlush")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioStreamFlush([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream)
		{
			int ret = SDLAudioStreamFlushNative(stream);
			return ret;
		}

		/// <summary>		/// Tell the stream that you're done sending data, and anything being buffered<br/>		/// should be converted/resampled and made available immediately.<br/>		/// It is legal to add more data to a stream after flushing, but there will be<br/>		/// audio gaps in the output. Generally this is intended to signal the end of<br/>		/// input, so the complete output becomes available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamFlush")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLAudioStreamFlush([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				int ret = SDLAudioStreamFlushNative((SDLAudioStream*)pstream);
				return ret;
			}
		}

		/// <summary>
		/// Clear any pending data in the stream without converting it<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AudioStreamClear")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AudioStreamClear")]
		internal static extern void SDLAudioStreamClearNative([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream);

		/// <summary>		/// Clear any pending data in the stream without converting it<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamClear")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAudioStreamClear([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream)
		{
			SDLAudioStreamClearNative(stream);
		}

		/// <summary>		/// Clear any pending data in the stream without converting it<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AudioStreamClear")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAudioStreamClear([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				SDLAudioStreamClearNative((SDLAudioStream*)pstream);
			}
		}

		/// <summary>
		/// Free an audio stream<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeAudioStream")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FreeAudioStream")]
		internal static extern void SDLFreeAudioStreamNative([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream);

		/// <summary>		/// Free an audio stream<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeAudioStream")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeAudioStream([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] SDLAudioStream* stream)
		{
			SDLFreeAudioStreamNative(stream);
		}

		/// <summary>		/// Free an audio stream<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeAudioStream")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeAudioStream([NativeName(NativeNameType.Param, "stream")] [NativeName(NativeNameType.Type, "SDL_AudioStream*")] ref SDLAudioStream stream)
		{
			fixed (SDLAudioStream* pstream = &stream)
			{
				SDLFreeAudioStreamNative((SDLAudioStream*)pstream);
			}
		}

		/// <summary>
		/// This function is a legacy means of mixing audio.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>
		/// ```<br/>
		/// ...where `format` is the obtained format of the audio device from the<br/>
		/// legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MixAudio")]
		internal static extern void SDLMixAudioNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume);

		/// <summary>		/// This function is a legacy means of mixing audio.<br/>		/// This function is equivalent to calling...<br/>		/// ```c<br/>		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>		/// ```<br/>		/// ...where `format` is the obtained format of the audio device from the<br/>		/// legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMixAudio([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume)
		{
			SDLMixAudioNative(dst, src, len, volume);
		}

		/// <summary>		/// This function is a legacy means of mixing audio.<br/>		/// This function is equivalent to calling...<br/>		/// ```c<br/>		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>		/// ```<br/>		/// ...where `format` is the obtained format of the audio device from the<br/>		/// legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMixAudio([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume)
		{
			fixed (byte* pdst = &dst)
			{
				SDLMixAudioNative((byte*)pdst, src, len, volume);
			}
		}

		/// <summary>		/// This function is a legacy means of mixing audio.<br/>		/// This function is equivalent to calling...<br/>		/// ```c<br/>		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>		/// ```<br/>		/// ...where `format` is the obtained format of the audio device from the<br/>		/// legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMixAudio([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume)
		{
			fixed (byte* psrc = &src)
			{
				SDLMixAudioNative(dst, (byte*)psrc, len, volume);
			}
		}

		/// <summary>		/// This function is a legacy means of mixing audio.<br/>		/// This function is equivalent to calling...<br/>		/// ```c<br/>		/// SDL_MixAudioFormat(dst, src, format, len, volume);<br/>		/// ```<br/>		/// ...where `format` is the obtained format of the audio device from the<br/>		/// legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MixAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMixAudio([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte src, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					SDLMixAudioNative((byte*)pdst, (byte*)psrc, len, volume);
				}
			}
		}

		/// <summary>
		/// Mix audio data in a specified format.<br/>
		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
		/// `format` data.<br/>
		/// This is provided for convenience -- you can mix your own audio data.<br/>
		/// Do not use this function for mixing together more than two streams of<br/>
		/// sample data. The output from repeated application of this function may be<br/>
		/// distorted by clipping, because there is no accumulator with greater range<br/>
		/// than the input (not to mention this being an inefficient way of doing it).<br/>
		/// It is a common misconception that this function is required to write audio<br/>
		/// data to an output stream in an audio callback. While you can do that,<br/>
		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>
		/// audio stream with a volume adjustment.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MixAudioFormat")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MixAudioFormat")]
		internal static extern void SDLMixAudioFormatNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume);

		/// <summary>		/// Mix audio data in a specified format.<br/>		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>		/// `format` data.<br/>		/// This is provided for convenience -- you can mix your own audio data.<br/>		/// Do not use this function for mixing together more than two streams of<br/>		/// sample data. The output from repeated application of this function may be<br/>		/// distorted by clipping, because there is no accumulator with greater range<br/>		/// than the input (not to mention this being an inefficient way of doing it).<br/>		/// It is a common misconception that this function is required to write audio<br/>		/// data to an output stream in an audio callback. While you can do that,<br/>		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>		/// audio stream with a volume adjustment.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MixAudioFormat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMixAudioFormat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume)
		{
			SDLMixAudioFormatNative(dst, src, format, len, volume);
		}

		/// <summary>		/// Mix audio data in a specified format.<br/>		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>		/// `format` data.<br/>		/// This is provided for convenience -- you can mix your own audio data.<br/>		/// Do not use this function for mixing together more than two streams of<br/>		/// sample data. The output from repeated application of this function may be<br/>		/// distorted by clipping, because there is no accumulator with greater range<br/>		/// than the input (not to mention this being an inefficient way of doing it).<br/>		/// It is a common misconception that this function is required to write audio<br/>		/// data to an output stream in an audio callback. While you can do that,<br/>		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>		/// audio stream with a volume adjustment.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MixAudioFormat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMixAudioFormat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume)
		{
			fixed (byte* pdst = &dst)
			{
				SDLMixAudioFormatNative((byte*)pdst, src, format, len, volume);
			}
		}

		/// <summary>		/// Mix audio data in a specified format.<br/>		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>		/// `format` data.<br/>		/// This is provided for convenience -- you can mix your own audio data.<br/>		/// Do not use this function for mixing together more than two streams of<br/>		/// sample data. The output from repeated application of this function may be<br/>		/// distorted by clipping, because there is no accumulator with greater range<br/>		/// than the input (not to mention this being an inefficient way of doing it).<br/>		/// It is a common misconception that this function is required to write audio<br/>		/// data to an output stream in an audio callback. While you can do that,<br/>		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>		/// audio stream with a volume adjustment.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MixAudioFormat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMixAudioFormat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] byte* dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume)
		{
			fixed (byte* psrc = &src)
			{
				SDLMixAudioFormatNative(dst, (byte*)psrc, format, len, volume);
			}
		}

		/// <summary>		/// Mix audio data in a specified format.<br/>		/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>		/// it into `dst`, performing addition, volume adjustment, and overflow<br/>		/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>		/// `format` data.<br/>		/// This is provided for convenience -- you can mix your own audio data.<br/>		/// Do not use this function for mixing together more than two streams of<br/>		/// sample data. The output from repeated application of this function may be<br/>		/// distorted by clipping, because there is no accumulator with greater range<br/>		/// than the input (not to mention this being an inefficient way of doing it).<br/>		/// It is a common misconception that this function is required to write audio<br/>		/// data to an output stream in an audio callback. While you can do that,<br/>		/// SDL_MixAudioFormat() is really only needed when you're mixing a single<br/>		/// audio stream with a volume adjustment.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MixAudioFormat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMixAudioFormat([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte dst, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte src, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_AudioFormat")] ushort format, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len, [NativeName(NativeNameType.Param, "volume")] [NativeName(NativeNameType.Type, "int")] int volume)
		{
			fixed (byte* pdst = &dst)
			{
				fixed (byte* psrc = &src)
				{
					SDLMixAudioFormatNative((byte*)pdst, (byte*)psrc, format, len, volume);
				}
			}
		}

		/// <summary>
		/// Queue more audio on non-callback devices.<br/>
		/// If you are looking to retrieve queued audio from a non-callback capture<br/>
		/// device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return<br/>
		/// -1 to signify an error if you use it with capture devices.<br/>
		/// SDL offers two ways to feed audio to the device: you can either supply a<br/>
		/// callback that SDL triggers with some frequency to obtain more audio (pull<br/>
		/// method), or you can supply no callback, and then SDL will expect you to<br/>
		/// supply data at regular intervals (push method) with this function.<br/>
		/// There are no limits on the amount of data you can queue, short of<br/>
		/// exhaustion of address space. Queued data will drain to the device as<br/>
		/// necessary without further intervention from you. If the device needs audio<br/>
		/// but there is not enough queued, it will play silence to make up the<br/>
		/// difference. This means you will have skips in your audio playback if you<br/>
		/// aren't routinely queueing sufficient data.<br/>
		/// This function copies the supplied data, so you are safe to free it when the<br/>
		/// function returns. This function is thread-safe, but queueing to the same<br/>
		/// device from two threads at once does not promise which buffer will be<br/>
		/// queued first.<br/>
		/// You may not queue audio on a device that is using an application-supplied<br/>
		/// callback; doing so returns an error. You have to use the audio callback or<br/>
		/// queue audio with this function, but not both.<br/>
		/// You should not call SDL_LockAudio() on the device before queueing; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// Note that SDL2 does not support planar audio. You will need to resample<br/>
		/// from planar audio formats into a non-planar one (see SDL_AudioFormat)<br/>
		/// before queuing audio.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueueAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_QueueAudio")]
		internal static extern int SDLQueueAudioNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len);

		/// <summary>		/// Queue more audio on non-callback devices.<br/>		/// If you are looking to retrieve queued audio from a non-callback capture<br/>		/// device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return<br/>		/// -1 to signify an error if you use it with capture devices.<br/>		/// SDL offers two ways to feed audio to the device: you can either supply a<br/>		/// callback that SDL triggers with some frequency to obtain more audio (pull<br/>		/// method), or you can supply no callback, and then SDL will expect you to<br/>		/// supply data at regular intervals (push method) with this function.<br/>		/// There are no limits on the amount of data you can queue, short of<br/>		/// exhaustion of address space. Queued data will drain to the device as<br/>		/// necessary without further intervention from you. If the device needs audio<br/>		/// but there is not enough queued, it will play silence to make up the<br/>		/// difference. This means you will have skips in your audio playback if you<br/>		/// aren't routinely queueing sufficient data.<br/>		/// This function copies the supplied data, so you are safe to free it when the<br/>		/// function returns. This function is thread-safe, but queueing to the same<br/>		/// device from two threads at once does not promise which buffer will be<br/>		/// queued first.<br/>		/// You may not queue audio on a device that is using an application-supplied<br/>		/// callback; doing so returns an error. You have to use the audio callback or<br/>		/// queue audio with this function, but not both.<br/>		/// You should not call SDL_LockAudio() on the device before queueing; SDL<br/>		/// handles locking internally for this function.<br/>		/// Note that SDL2 does not support planar audio. You will need to resample<br/>		/// from planar audio formats into a non-planar one (see SDL_AudioFormat)<br/>		/// before queuing audio.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueueAudio")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueueAudio([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len)
		{
			int ret = SDLQueueAudioNative(dev, data, len);
			return ret;
		}

		/// <summary>
		/// Dequeue more audio on non-callback devices.<br/>
		/// If you are looking to queue audio for output on a non-callback playback<br/>
		/// device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always<br/>
		/// return 0 if you use it with playback devices.<br/>
		/// SDL offers two ways to retrieve audio from a capture device: you can either<br/>
		/// supply a callback that SDL triggers with some frequency as the device<br/>
		/// records more audio data, (push method), or you can supply no callback, and<br/>
		/// then SDL will expect you to retrieve data at regular intervals (pull<br/>
		/// method) with this function.<br/>
		/// There are no limits on the amount of data you can queue, short of<br/>
		/// exhaustion of address space. Data from the device will keep queuing as<br/>
		/// necessary without further intervention from you. This means you will<br/>
		/// eventually run out of memory if you aren't routinely dequeueing data.<br/>
		/// Capture devices will not queue data when paused; if you are expecting to<br/>
		/// not need captured audio for some length of time, use SDL_PauseAudioDevice()<br/>
		/// to stop the capture device from queueing more data. This can be useful<br/>
		/// during, say, level loading times. When unpaused, capture devices will start<br/>
		/// queueing data from that point, having flushed any capturable data available<br/>
		/// while paused.<br/>
		/// This function is thread-safe, but dequeueing from the same device from two<br/>
		/// threads at once does not promise which thread will dequeue data first.<br/>
		/// You may not dequeue audio from a device that is using an<br/>
		/// application-supplied callback; doing so returns an error. You have to use<br/>
		/// the audio callback, or dequeue audio with this function, but not both.<br/>
		/// You should not call SDL_LockAudio() on the device before dequeueing; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DequeueAudio")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DequeueAudio")]
		internal static extern uint SDLDequeueAudioNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len);

		/// <summary>		/// Dequeue more audio on non-callback devices.<br/>		/// If you are looking to queue audio for output on a non-callback playback<br/>		/// device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always<br/>		/// return 0 if you use it with playback devices.<br/>		/// SDL offers two ways to retrieve audio from a capture device: you can either<br/>		/// supply a callback that SDL triggers with some frequency as the device<br/>		/// records more audio data, (push method), or you can supply no callback, and<br/>		/// then SDL will expect you to retrieve data at regular intervals (pull<br/>		/// method) with this function.<br/>		/// There are no limits on the amount of data you can queue, short of<br/>		/// exhaustion of address space. Data from the device will keep queuing as<br/>		/// necessary without further intervention from you. This means you will<br/>		/// eventually run out of memory if you aren't routinely dequeueing data.<br/>		/// Capture devices will not queue data when paused; if you are expecting to<br/>		/// not need captured audio for some length of time, use SDL_PauseAudioDevice()<br/>		/// to stop the capture device from queueing more data. This can be useful<br/>		/// during, say, level loading times. When unpaused, capture devices will start<br/>		/// queueing data from that point, having flushed any capturable data available<br/>		/// while paused.<br/>		/// This function is thread-safe, but dequeueing from the same device from two<br/>		/// threads at once does not promise which thread will dequeue data first.<br/>		/// You may not dequeue audio from a device that is using an<br/>		/// application-supplied callback; doing so returns an error. You have to use<br/>		/// the audio callback, or dequeue audio with this function, but not both.<br/>		/// You should not call SDL_LockAudio() on the device before dequeueing; SDL<br/>		/// handles locking internally for this function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DequeueAudio")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLDequeueAudio([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "void*")] void* data, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "Uint32")] uint len)
		{
			uint ret = SDLDequeueAudioNative(dev, data, len);
			return ret;
		}

		/// <summary>
		/// Get the number of bytes of still-queued audio.<br/>
		/// For playback devices: this is the number of bytes that have been queued for<br/>
		/// playback with SDL_QueueAudio(), but have not yet been sent to the hardware.<br/>
		/// Once we've sent it to the hardware, this function can not decide the exact<br/>
		/// byte boundary of what has been played. It's possible that we just gave the<br/>
		/// hardware several kilobytes right before you called this function, but it<br/>
		/// hasn't played any of it yet, or maybe half of it, etc.<br/>
		/// For capture devices, this is the number of bytes that have been captured by<br/>
		/// the device and are waiting for you to dequeue. This number may grow at any<br/>
		/// time, so this only informs of the lower-bound of available data.<br/>
		/// You may not queue or dequeue audio on a device that is using an<br/>
		/// application-supplied callback; calling this function on such a device<br/>
		/// always returns 0. You have to use the audio callback or queue audio, but<br/>
		/// not both.<br/>
		/// You should not call SDL_LockAudio() on the device before querying; SDL<br/>
		/// handles locking internally for this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetQueuedAudioSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetQueuedAudioSize")]
		internal static extern uint SDLGetQueuedAudioSizeNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev);

		/// <summary>		/// Get the number of bytes of still-queued audio.<br/>		/// For playback devices: this is the number of bytes that have been queued for<br/>		/// playback with SDL_QueueAudio(), but have not yet been sent to the hardware.<br/>		/// Once we've sent it to the hardware, this function can not decide the exact<br/>		/// byte boundary of what has been played. It's possible that we just gave the<br/>		/// hardware several kilobytes right before you called this function, but it<br/>		/// hasn't played any of it yet, or maybe half of it, etc.<br/>		/// For capture devices, this is the number of bytes that have been captured by<br/>		/// the device and are waiting for you to dequeue. This number may grow at any<br/>		/// time, so this only informs of the lower-bound of available data.<br/>		/// You may not queue or dequeue audio on a device that is using an<br/>		/// application-supplied callback; calling this function on such a device<br/>		/// always returns 0. You have to use the audio callback or queue audio, but<br/>		/// not both.<br/>		/// You should not call SDL_LockAudio() on the device before querying; SDL<br/>		/// handles locking internally for this function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetQueuedAudioSize")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetQueuedAudioSize([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			uint ret = SDLGetQueuedAudioSizeNative(dev);
			return ret;
		}

		/// <summary>
		/// Drop any queued audio data waiting to be sent to the hardware.<br/>
		/// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For<br/>
		/// output devices, the hardware will start playing silence if more audio isn't<br/>
		/// queued. For capture devices, the hardware will start filling the empty<br/>
		/// queue with new data if the capture device isn't paused.<br/>
		/// This will not prevent playback of queued audio that's already been sent to<br/>
		/// the hardware, as we can not undo that, so expect there to be some fraction<br/>
		/// of a second of audio that might still be heard. This can be useful if you<br/>
		/// want to, say, drop any pending music or any unprocessed microphone input<br/>
		/// during a level change in your game.<br/>
		/// You may not queue or dequeue audio on a device that is using an<br/>
		/// application-supplied callback; calling this function on such a device<br/>
		/// always returns 0. You have to use the audio callback or queue audio, but<br/>
		/// not both.<br/>
		/// You should not call SDL_LockAudio() on the device before clearing the<br/>
		/// queue; SDL handles locking internally for this function.<br/>
		/// This function always succeeds and thus returns void.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearQueuedAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ClearQueuedAudio")]
		internal static extern void SDLClearQueuedAudioNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev);

		/// <summary>		/// Drop any queued audio data waiting to be sent to the hardware.<br/>		/// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For<br/>		/// output devices, the hardware will start playing silence if more audio isn't<br/>		/// queued. For capture devices, the hardware will start filling the empty<br/>		/// queue with new data if the capture device isn't paused.<br/>		/// This will not prevent playback of queued audio that's already been sent to<br/>		/// the hardware, as we can not undo that, so expect there to be some fraction<br/>		/// of a second of audio that might still be heard. This can be useful if you<br/>		/// want to, say, drop any pending music or any unprocessed microphone input<br/>		/// during a level change in your game.<br/>		/// You may not queue or dequeue audio on a device that is using an<br/>		/// application-supplied callback; calling this function on such a device<br/>		/// always returns 0. You have to use the audio callback or queue audio, but<br/>		/// not both.<br/>		/// You should not call SDL_LockAudio() on the device before clearing the<br/>		/// queue; SDL handles locking internally for this function.<br/>		/// This function always succeeds and thus returns void.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ClearQueuedAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLClearQueuedAudio([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			SDLClearQueuedAudioNative(dev);
		}

		/// <summary>
		/// This function is a legacy means of locking the audio device.<br/>
		/// New programs might want to use SDL_LockAudioDevice() instead. This function<br/>
		/// is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_LockAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LockAudio")]
		internal static extern void SDLLockAudioNative();

		/// <summary>		/// This function is a legacy means of locking the audio device.<br/>		/// New programs might want to use SDL_LockAudioDevice() instead. This function<br/>		/// is equivalent to calling...<br/>		/// ```c<br/>		/// SDL_LockAudioDevice(1);<br/>		/// ```<br/>		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLockAudio()
		{
			SDLLockAudioNative();
		}

		/// <summary>
		/// Use this function to lock out the audio callback function for a specified<br/>
		/// device.<br/>
		/// The lock manipulated by these functions protects the audio callback<br/>
		/// function specified in SDL_OpenAudioDevice(). During a<br/>
		/// SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed<br/>
		/// that the callback function for that device is not running, even if the<br/>
		/// device is not paused. While a device is locked, any other unpaused,<br/>
		/// unlocked devices may still run their callbacks.<br/>
		/// Calling this function from inside your audio callback is unnecessary. SDL<br/>
		/// obtains this lock before calling your function, and releases it when the<br/>
		/// function returns.<br/>
		/// You should not hold the lock longer than absolutely necessary. If you hold<br/>
		/// it too long, you'll experience dropouts in your audio playback. Ideally,<br/>
		/// your application locks the device, sets a few variables and unlocks again.<br/>
		/// Do not do heavy work while holding the lock for a device.<br/>
		/// It is safe to lock the audio device multiple times, as long as you unlock<br/>
		/// it an equivalent number of times. The callback will not run until the<br/>
		/// device has been unlocked completely in this way. If your application fails<br/>
		/// to unlock the device appropriately, your callback will never run, you might<br/>
		/// hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably<br/>
		/// deadlock.<br/>
		/// Internally, the audio device lock is a mutex; if you lock from two threads<br/>
		/// at once, not only will you block the audio callback, you'll block the other<br/>
		/// thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LockAudioDevice")]
		internal static extern void SDLLockAudioDeviceNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev);

		/// <summary>		/// Use this function to lock out the audio callback function for a specified<br/>		/// device.<br/>		/// The lock manipulated by these functions protects the audio callback<br/>		/// function specified in SDL_OpenAudioDevice(). During a<br/>		/// SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed<br/>		/// that the callback function for that device is not running, even if the<br/>		/// device is not paused. While a device is locked, any other unpaused,<br/>		/// unlocked devices may still run their callbacks.<br/>		/// Calling this function from inside your audio callback is unnecessary. SDL<br/>		/// obtains this lock before calling your function, and releases it when the<br/>		/// function returns.<br/>		/// You should not hold the lock longer than absolutely necessary. If you hold<br/>		/// it too long, you'll experience dropouts in your audio playback. Ideally,<br/>		/// your application locks the device, sets a few variables and unlocks again.<br/>		/// Do not do heavy work while holding the lock for a device.<br/>		/// It is safe to lock the audio device multiple times, as long as you unlock<br/>		/// it an equivalent number of times. The callback will not run until the<br/>		/// device has been unlocked completely in this way. If your application fails<br/>		/// to unlock the device appropriately, your callback will never run, you might<br/>		/// hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably<br/>		/// deadlock.<br/>		/// Internally, the audio device lock is a mutex; if you lock from two threads<br/>		/// at once, not only will you block the audio callback, you'll block the other<br/>		/// thread.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLockAudioDevice([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			SDLLockAudioDeviceNative(dev);
		}

		/// <summary>
		/// This function is a legacy means of unlocking the audio device.<br/>
		/// New programs might want to use SDL_UnlockAudioDevice() instead. This<br/>
		/// function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_UnlockAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnlockAudio")]
		internal static extern void SDLUnlockAudioNative();

		/// <summary>		/// This function is a legacy means of unlocking the audio device.<br/>		/// New programs might want to use SDL_UnlockAudioDevice() instead. This<br/>		/// function is equivalent to calling...<br/>		/// ```c<br/>		/// SDL_UnlockAudioDevice(1);<br/>		/// ```<br/>		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockAudio()
		{
			SDLUnlockAudioNative();
		}

		/// <summary>
		/// Use this function to unlock the audio callback function for a specified<br/>
		/// device.<br/>
		/// This function should be paired with a previous SDL_LockAudioDevice() call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnlockAudioDevice")]
		internal static extern void SDLUnlockAudioDeviceNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev);

		/// <summary>		/// Use this function to unlock the audio callback function for a specified<br/>		/// device.<br/>		/// This function should be paired with a previous SDL_LockAudioDevice() call.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockAudioDevice([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			SDLUnlockAudioDeviceNative(dev);
		}

		/// <summary>
		/// This function is a legacy means of closing the audio device.<br/>
		/// This function is equivalent to calling...<br/>
		/// ```c<br/>
		/// SDL_CloseAudioDevice(1);<br/>
		/// ```<br/>
		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CloseAudio")]
		internal static extern void SDLCloseAudioNative();

		/// <summary>		/// This function is a legacy means of closing the audio device.<br/>		/// This function is equivalent to calling...<br/>		/// ```c<br/>		/// SDL_CloseAudioDevice(1);<br/>		/// ```<br/>		/// ...and is only useful if you used the legacy SDL_OpenAudio() function.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CloseAudio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLCloseAudio()
		{
			SDLCloseAudioNative();
		}

		/// <summary>
		/// Use this function to shut down audio processing and close the audio device.<br/>
		/// The application should close open audio devices once they are no longer<br/>
		/// needed. Calling this function will wait until the device's audio callback<br/>
		/// is not running, release the audio hardware and then clean up internal<br/>
		/// state. No further audio will play from this device once this function<br/>
		/// returns.<br/>
		/// This function may block briefly while pending audio data is played by the<br/>
		/// hardware, so that applications don't drop the last buffer of data they<br/>
		/// supplied.<br/>
		/// The device ID is invalid as soon as the device is closed, and is eligible<br/>
		/// for reuse in a new SDL_OpenAudioDevice() call immediately.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CloseAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CloseAudioDevice")]
		internal static extern void SDLCloseAudioDeviceNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev);

		/// <summary>		/// Use this function to shut down audio processing and close the audio device.<br/>		/// The application should close open audio devices once they are no longer<br/>		/// needed. Calling this function will wait until the device's audio callback<br/>		/// is not running, release the audio hardware and then clean up internal<br/>		/// state. No further audio will play from this device once this function<br/>		/// returns.<br/>		/// This function may block briefly while pending audio data is played by the<br/>		/// hardware, so that applications don't drop the last buffer of data they<br/>		/// supplied.<br/>		/// The device ID is invalid as soon as the device is closed, and is eligible<br/>		/// for reuse in a new SDL_OpenAudioDevice() call immediately.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CloseAudioDevice")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLCloseAudioDevice([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_AudioDeviceID")] uint dev)
		{
			SDLCloseAudioDeviceNative(dev);
		}

		/// <summary>
		/// Put UTF-8 text into the clipboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetClipboardText")]
		internal static extern int SDLSetClipboardTextNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text);

		/// <summary>		/// Put UTF-8 text into the clipboard.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			int ret = SDLSetClipboardTextNative(text);
			return ret;
		}

		/// <summary>		/// Put UTF-8 text into the clipboard.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SDLSetClipboardTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>		/// Put UTF-8 text into the clipboard.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetClipboardText")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetClipboardText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLSetClipboardTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the clipboard, which must be freed with SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the clipboard's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipboardText")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetClipboardText")]
		internal static extern byte* SDLGetClipboardTextNative();

		/// <summary>		/// Get UTF-8 text from the clipboard, which must be freed with SDL_free().<br/>		/// This functions returns empty string if there was not enough memory left for<br/>		/// a copy of the clipboard's content.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClipboardText")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetClipboardText()
		{
			byte* ret = SDLGetClipboardTextNative();
			return ret;
		}

		/// <summary>		/// Get UTF-8 text from the clipboard, which must be freed with SDL_free().<br/>		/// This functions returns empty string if there was not enough memory left for<br/>		/// a copy of the clipboard's content.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClipboardText")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetClipboardTextS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetClipboardTextNative());
			return ret;
		}

		/// <summary>
		/// Query whether the clipboard exists and contains a non-empty text string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasClipboardText")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasClipboardText")]
		internal static extern SDLBool SDLHasClipboardTextNative();

		/// <summary>		/// Query whether the clipboard exists and contains a non-empty text string.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasClipboardText")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasClipboardText()
		{
			SDLBool ret = SDLHasClipboardTextNative();
			return ret;
		}

		/// <summary>
		/// Put UTF-8 text into the primary selection.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetPrimarySelectionText")]
		internal static extern int SDLSetPrimarySelectionTextNative([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text);

		/// <summary>		/// Put UTF-8 text into the primary selection.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPrimarySelectionText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] byte* text)
		{
			int ret = SDLSetPrimarySelectionTextNative(text);
			return ret;
		}

		/// <summary>		/// Put UTF-8 text into the primary selection.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPrimarySelectionText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				int ret = SDLSetPrimarySelectionTextNative((byte*)ptext);
				return ret;
			}
		}

		/// <summary>		/// Put UTF-8 text into the primary selection.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPrimarySelectionText([NativeName(NativeNameType.Param, "text")] [NativeName(NativeNameType.Type, "const char*")] string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLSetPrimarySelectionTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get UTF-8 text from the primary selection, which must be freed with<br/>
		/// SDL_free().<br/>
		/// This functions returns empty string if there was not enough memory left for<br/>
		/// a copy of the primary selection's content.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetPrimarySelectionText")]
		internal static extern byte* SDLGetPrimarySelectionTextNative();

		/// <summary>		/// Get UTF-8 text from the primary selection, which must be freed with<br/>		/// SDL_free().<br/>		/// This functions returns empty string if there was not enough memory left for<br/>		/// a copy of the primary selection's content.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrimarySelectionText()
		{
			byte* ret = SDLGetPrimarySelectionTextNative();
			return ret;
		}

		/// <summary>		/// Get UTF-8 text from the primary selection, which must be freed with<br/>		/// SDL_free().<br/>		/// This functions returns empty string if there was not enough memory left for<br/>		/// a copy of the primary selection's content.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrimarySelectionTextS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetPrimarySelectionTextNative());
			return ret;
		}

		/// <summary>
		/// Query whether the primary selection exists and contains a non-empty text<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasPrimarySelectionText")]
		internal static extern SDLBool SDLHasPrimarySelectionTextNative();

		/// <summary>		/// Query whether the primary selection exists and contains a non-empty text<br/>		/// string.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasPrimarySelectionText")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasPrimarySelectionText()
		{
			SDLBool ret = SDLHasPrimarySelectionTextNative();
			return ret;
		}

		/// <summary>
		/// Get the number of CPU cores available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCPUCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetCPUCount")]
		internal static extern int SDLGetCPUCountNative();

		/// <summary>		/// Get the number of CPU cores available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCPUCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetCPUCount()
		{
			int ret = SDLGetCPUCountNative();
			return ret;
		}

		/// <summary>
		/// Determine the L1 cache line size of the CPU.<br/>
		/// This is useful for determining multi-threaded structure padding or SIMD<br/>
		/// prefetch sizes.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCPUCacheLineSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetCPUCacheLineSize")]
		internal static extern int SDLGetCPUCacheLineSizeNative();

		/// <summary>		/// Determine the L1 cache line size of the CPU.<br/>		/// This is useful for determining multi-threaded structure padding or SIMD<br/>		/// prefetch sizes.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCPUCacheLineSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetCPUCacheLineSize()
		{
			int ret = SDLGetCPUCacheLineSizeNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has the RDTSC instruction.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasRDTSC")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasRDTSC")]
		internal static extern SDLBool SDLHasRDTSCNative();

		/// <summary>		/// Determine whether the CPU has the RDTSC instruction.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasRDTSC")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasRDTSC()
		{
			SDLBool ret = SDLHasRDTSCNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AltiVec features.<br/>
		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAltiVec")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasAltiVec")]
		internal static extern SDLBool SDLHasAltiVecNative();

		/// <summary>		/// Determine whether the CPU has AltiVec features.<br/>		/// This always returns false on CPUs that aren't using PowerPC instruction<br/>		/// sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasAltiVec")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasAltiVec()
		{
			SDLBool ret = SDLHasAltiVecNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has MMX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasMMX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasMMX")]
		internal static extern SDLBool SDLHasMMXNative();

		/// <summary>		/// Determine whether the CPU has MMX features.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasMMX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasMMX()
		{
			SDLBool ret = SDLHasMMXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has 3DNow! features.<br/>
		/// This always returns false on CPUs that aren't using AMD instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Has3DNow")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Has3DNow")]
		internal static extern SDLBool SDLHas3DNowNative();

		/// <summary>		/// Determine whether the CPU has 3DNow! features.<br/>		/// This always returns false on CPUs that aren't using AMD instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Has3DNow")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHas3DNow()
		{
			SDLBool ret = SDLHas3DNowNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasSSE")]
		internal static extern SDLBool SDLHasSSENative();

		/// <summary>		/// Determine whether the CPU has SSE features.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasSSE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasSSE()
		{
			SDLBool ret = SDLHasSSENative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE2")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasSSE2")]
		internal static extern SDLBool SDLHasSSE2Native();

		/// <summary>		/// Determine whether the CPU has SSE2 features.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasSSE2")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasSSE2()
		{
			SDLBool ret = SDLHasSSE2Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE3 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE3")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasSSE3")]
		internal static extern SDLBool SDLHasSSE3Native();

		/// <summary>		/// Determine whether the CPU has SSE3 features.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasSSE3")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasSSE3()
		{
			SDLBool ret = SDLHasSSE3Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.1 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE41")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasSSE41")]
		internal static extern SDLBool SDLHasSSE41Native();

		/// <summary>		/// Determine whether the CPU has SSE4.1 features.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasSSE41")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasSSE41()
		{
			SDLBool ret = SDLHasSSE41Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has SSE4.2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSSE42")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasSSE42")]
		internal static extern SDLBool SDLHasSSE42Native();

		/// <summary>		/// Determine whether the CPU has SSE4.2 features.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasSSE42")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasSSE42()
		{
			SDLBool ret = SDLHasSSE42Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasAVX")]
		internal static extern SDLBool SDLHasAVXNative();

		/// <summary>		/// Determine whether the CPU has AVX features.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasAVX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasAVX()
		{
			SDLBool ret = SDLHasAVXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX2 features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX2")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasAVX2")]
		internal static extern SDLBool SDLHasAVX2Native();

		/// <summary>		/// Determine whether the CPU has AVX2 features.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasAVX2")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasAVX2()
		{
			SDLBool ret = SDLHasAVX2Native();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has AVX-512F (foundation) features.<br/>
		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasAVX512F")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasAVX512F")]
		internal static extern SDLBool SDLHasAVX512FNative();

		/// <summary>		/// Determine whether the CPU has AVX-512F (foundation) features.<br/>		/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasAVX512F")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasAVX512F()
		{
			SDLBool ret = SDLHasAVX512FNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has ARM SIMD (ARMv6) features.<br/>
		/// This is different from ARM NEON, which is a different instruction set.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasARMSIMD")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasARMSIMD")]
		internal static extern SDLBool SDLHasARMSIMDNative();

		/// <summary>		/// Determine whether the CPU has ARM SIMD (ARMv6) features.<br/>		/// This is different from ARM NEON, which is a different instruction set.<br/>		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasARMSIMD")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasARMSIMD()
		{
			SDLBool ret = SDLHasARMSIMDNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has NEON (ARM SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasNEON")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasNEON")]
		internal static extern SDLBool SDLHasNEONNative();

		/// <summary>		/// Determine whether the CPU has NEON (ARM SIMD) features.<br/>		/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasNEON")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasNEON()
		{
			SDLBool ret = SDLHasNEONNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has LSX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasLSX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasLSX")]
		internal static extern SDLBool SDLHasLSXNative();

		/// <summary>		/// Determine whether the CPU has LSX (LOONGARCH SIMD) features.<br/>		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>		/// sets.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasLSX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasLSX()
		{
			SDLBool ret = SDLHasLSXNative();
			return ret;
		}

		/// <summary>
		/// Determine whether the CPU has LASX (LOONGARCH SIMD) features.<br/>
		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
		/// sets.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasLASX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasLASX")]
		internal static extern SDLBool SDLHasLASXNative();

		/// <summary>		/// Determine whether the CPU has LASX (LOONGARCH SIMD) features.<br/>		/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>		/// sets.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasLASX")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasLASX()
		{
			SDLBool ret = SDLHasLASXNative();
			return ret;
		}

		/// <summary>
		/// Get the amount of RAM configured in the system.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSystemRAM")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetSystemRAM")]
		internal static extern int SDLGetSystemRAMNative();

		/// <summary>		/// Get the amount of RAM configured in the system.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSystemRAM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSystemRAM()
		{
			int ret = SDLGetSystemRAMNative();
			return ret;
		}

		/// <summary>
		/// Report the alignment this system needs for SIMD allocations.<br/>
		/// This will return the minimum number of bytes to which a pointer must be<br/>
		/// aligned to be compatible with SIMD instructions on the current machine. For<br/>
		/// example, if the machine supports SSE only, it will return 16, but if it<br/>
		/// supports AVX-512F, it'll return 64 (etc). This only reports values for<br/>
		/// instruction sets SDL knows about, so if your SDL build doesn't have<br/>
		/// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and<br/>
		/// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.<br/>
		/// Plan accordingly.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SIMDGetAlignment")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SIMDGetAlignment")]
		internal static extern nuint SDLSIMDGetAlignmentNative();

		/// <summary>		/// Report the alignment this system needs for SIMD allocations.<br/>		/// This will return the minimum number of bytes to which a pointer must be<br/>		/// aligned to be compatible with SIMD instructions on the current machine. For<br/>		/// example, if the machine supports SSE only, it will return 16, but if it<br/>		/// supports AVX-512F, it'll return 64 (etc). This only reports values for<br/>		/// instruction sets SDL knows about, so if your SDL build doesn't have<br/>		/// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and<br/>		/// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.<br/>		/// Plan accordingly.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SIMDGetAlignment")]
		[return: NativeName(NativeNameType.Type, "size_t")]
		public static nuint SDLSIMDGetAlignment()
		{
			nuint ret = SDLSIMDGetAlignmentNative();
			return ret;
		}

		/// <summary>
		/// Allocate memory in a SIMD-friendly way.<br/>
		/// This will allocate a block of memory that is suitable for use with SIMD<br/>
		/// instructions. Specifically, it will be properly aligned and padded for the<br/>
		/// system's supported vector instructions.<br/>
		/// The memory returned will be padded such that it is safe to read or write an<br/>
		/// incomplete vector at the end of the memory block. This can be useful so you<br/>
		/// don't have to drop back to a scalar fallback at the end of your SIMD<br/>
		/// processing loop to deal with the final elements without overflowing the<br/>
		/// allocated buffer.<br/>
		/// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or<br/>
		/// delete[], etc.<br/>
		/// Note that SDL will only deal with SIMD instruction sets it is aware of; for<br/>
		/// example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and<br/>
		/// AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants<br/>
		/// 64. To be clear: if you can't decide to use an instruction set with an<br/>
		/// SDL_Has*() function, don't use that instruction set with memory allocated<br/>
		/// through here.<br/>
		/// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't<br/>
		/// out of memory, but you are not allowed to dereference it (because you only<br/>
		/// own zero bytes of that buffer).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SIMDAlloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SIMDAlloc")]
		internal static extern void* SDLSIMDAllocNative([NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "const size_t")] nuint len);

		/// <summary>		/// Allocate memory in a SIMD-friendly way.<br/>		/// This will allocate a block of memory that is suitable for use with SIMD<br/>		/// instructions. Specifically, it will be properly aligned and padded for the<br/>		/// system's supported vector instructions.<br/>		/// The memory returned will be padded such that it is safe to read or write an<br/>		/// incomplete vector at the end of the memory block. This can be useful so you<br/>		/// don't have to drop back to a scalar fallback at the end of your SIMD<br/>		/// processing loop to deal with the final elements without overflowing the<br/>		/// allocated buffer.<br/>		/// You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or<br/>		/// delete[], etc.<br/>		/// Note that SDL will only deal with SIMD instruction sets it is aware of; for<br/>		/// example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and<br/>		/// AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants<br/>		/// 64. To be clear: if you can't decide to use an instruction set with an<br/>		/// SDL_Has*() function, don't use that instruction set with memory allocated<br/>		/// through here.<br/>		/// SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't<br/>		/// out of memory, but you are not allowed to dereference it (because you only<br/>		/// own zero bytes of that buffer).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SIMDAlloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLSIMDAlloc([NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "const size_t")] nuint len)
		{
			void* ret = SDLSIMDAllocNative(len);
			return ret;
		}

		/// <summary>
		/// Reallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,<br/>
		/// SDL_malloc, memalign, new[], etc.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SIMDRealloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SIMDRealloc")]
		internal static extern void* SDLSIMDReallocNative([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "const size_t")] nuint len);

		/// <summary>		/// Reallocate memory obtained from SDL_SIMDAlloc<br/>		/// It is not valid to use this function on a pointer from anything but<br/>		/// SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,<br/>		/// SDL_malloc, memalign, new[], etc.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SIMDRealloc")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLSIMDRealloc([NativeName(NativeNameType.Param, "mem")] [NativeName(NativeNameType.Type, "void*")] void* mem, [NativeName(NativeNameType.Param, "len")] [NativeName(NativeNameType.Type, "const size_t")] nuint len)
		{
			void* ret = SDLSIMDReallocNative(mem, len);
			return ret;
		}

		/// <summary>
		/// Deallocate memory obtained from SDL_SIMDAlloc<br/>
		/// It is not valid to use this function on a pointer from anything but<br/>
		/// SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from<br/>
		/// malloc, realloc, SDL_malloc, memalign, new[], etc.<br/>
		/// However, SDL_SIMDFree(NULL) is a legal no-op.<br/>
		/// The memory pointed to by `ptr` is no longer valid for access upon return,<br/>
		/// and may be returned to the system or reused by a future allocation. The<br/>
		/// pointer passed to this function is no longer safe to dereference once this<br/>
		/// function returns, and should be discarded.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SIMDFree")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SIMDFree")]
		internal static extern void SDLSIMDFreeNative([NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr);

		/// <summary>		/// Deallocate memory obtained from SDL_SIMDAlloc<br/>		/// It is not valid to use this function on a pointer from anything but<br/>		/// SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from<br/>		/// malloc, realloc, SDL_malloc, memalign, new[], etc.<br/>		/// However, SDL_SIMDFree(NULL) is a legal no-op.<br/>		/// The memory pointed to by `ptr` is no longer valid for access upon return,<br/>		/// and may be returned to the system or reused by a future allocation. The<br/>		/// pointer passed to this function is no longer safe to dereference once this<br/>		/// function returns, and should be discarded.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SIMDFree")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSIMDFree([NativeName(NativeNameType.Param, "ptr")] [NativeName(NativeNameType.Type, "void*")] void* ptr)
		{
			SDLSIMDFreeNative(ptr);
		}

		/// <summary>
		/// Get the human readable name of a pixel format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPixelFormatName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetPixelFormatName")]
		internal static extern byte* SDLGetPixelFormatNameNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format);

		/// <summary>		/// Get the human readable name of a pixel format.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPixelFormatName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetPixelFormatName([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			byte* ret = SDLGetPixelFormatNameNative(format);
			return ret;
		}

		/// <summary>		/// Get the human readable name of a pixel format.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPixelFormatName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetPixelFormatNameS([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetPixelFormatNameNative(format));
			return ret;
		}

		/// <summary>
		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_PixelFormatEnumToMasks")]
		internal static extern SDLBool SDLPixelFormatEnumToMasksNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask);

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, bmask, amask);
				return ret;
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, bmask, amask);
				return ret;
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, amask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, bmask, amask);
				return ret;
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, amask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, rmask, gmask, (uint*)pbmask, amask);
				return ret;
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, amask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, amask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (uint* pamask = &amask)
			{
				SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, rmask, gmask, bmask, (uint*)pamask);
				return ret;
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, bmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, bmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, bmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (uint* pbmask = &bmask)
			{
				fixed (uint* pamask = &amask)
				{
					SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
					return ret;
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, gmask, (uint*)pbmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (uint* pgmask = &gmask)
			{
				fixed (uint* pbmask = &bmask)
				{
					fixed (uint* pamask = &amask)
					{
						SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] uint* rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, rmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] int* bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (uint* prmask = &rmask)
			{
				fixed (uint* pgmask = &gmask)
				{
					fixed (uint* pbmask = &bmask)
					{
						fixed (uint* pamask = &amask)
						{
							SDLBool ret = SDLPixelFormatEnumToMasksNative(format, bpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PixelFormatEnumToMasks")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLPixelFormatEnumToMasks([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int*")] ref int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint amask)
		{
			fixed (int* pbpp = &bpp)
			{
				fixed (uint* prmask = &rmask)
				{
					fixed (uint* pgmask = &gmask)
					{
						fixed (uint* pbmask = &bmask)
						{
							fixed (uint* pamask = &amask)
							{
								SDLBool ret = SDLPixelFormatEnumToMasksNative(format, (int*)pbpp, (uint*)prmask, (uint*)pgmask, (uint*)pbmask, (uint*)pamask);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>
		/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>
		/// possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MasksToPixelFormatEnum")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MasksToPixelFormatEnum")]
		internal static extern uint SDLMasksToPixelFormatEnumNative([NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int")] int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask);

		/// <summary>		/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>		/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>		/// possible.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MasksToPixelFormatEnum")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLMasksToPixelFormatEnum([NativeName(NativeNameType.Param, "bpp")] [NativeName(NativeNameType.Type, "int")] int bpp, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			uint ret = SDLMasksToPixelFormatEnumNative(bpp, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Create an SDL_PixelFormat structure corresponding to a pixel format.<br/>
		/// Returned structure may come from a shared global cache (i.e. not newly<br/>
		/// allocated), and hence should not be modified, especially the palette. Weird<br/>
		/// errors such as `Blit combination not supported` may occur.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AllocFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_PixelFormat*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AllocFormat")]
		internal static extern SDLPixelFormat* SDLAllocFormatNative([NativeName(NativeNameType.Param, "pixel_format")] [NativeName(NativeNameType.Type, "Uint32")] uint pixelFormat);

		/// <summary>		/// Create an SDL_PixelFormat structure corresponding to a pixel format.<br/>		/// Returned structure may come from a shared global cache (i.e. not newly<br/>		/// allocated), and hence should not be modified, especially the palette. Weird<br/>		/// errors such as `Blit combination not supported` may occur.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AllocFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_PixelFormat*")]
		public static SDLPixelFormat* SDLAllocFormat([NativeName(NativeNameType.Param, "pixel_format")] [NativeName(NativeNameType.Type, "Uint32")] uint pixelFormat)
		{
			SDLPixelFormat* ret = SDLAllocFormatNative(pixelFormat);
			return ret;
		}

		/// <summary>
		/// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeFormat")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FreeFormat")]
		internal static extern void SDLFreeFormatNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat*")] SDLPixelFormat* format);

		/// <summary>		/// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeFormat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat*")] SDLPixelFormat* format)
		{
			SDLFreeFormatNative(format);
		}

		/// <summary>		/// Free an SDL_PixelFormat structure allocated by SDL_AllocFormat().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeFormat")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeFormat([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat*")] ref SDLPixelFormat format)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				SDLFreeFormatNative((SDLPixelFormat*)pformat);
			}
		}

		/// <summary>
		/// Create a palette structure with the specified number of color entries.<br/>
		/// The palette entries are initialized to white.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AllocPalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AllocPalette")]
		internal static extern SDLPalette* SDLAllocPaletteNative([NativeName(NativeNameType.Param, "ncolors")] [NativeName(NativeNameType.Type, "int")] int ncolors);

		/// <summary>		/// Create a palette structure with the specified number of color entries.<br/>		/// The palette entries are initialized to white.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AllocPalette")]
		[return: NativeName(NativeNameType.Type, "SDL_Palette*")]
		public static SDLPalette* SDLAllocPalette([NativeName(NativeNameType.Param, "ncolors")] [NativeName(NativeNameType.Type, "int")] int ncolors)
		{
			SDLPalette* ret = SDLAllocPaletteNative(ncolors);
			return ret;
		}

		/// <summary>
		/// Set the palette for a pixel format structure.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPixelFormatPalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetPixelFormatPalette")]
		internal static extern int SDLSetPixelFormatPaletteNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette);

		/// <summary>		/// Set the palette for a pixel format structure.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPixelFormatPalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPixelFormatPalette([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette)
		{
			int ret = SDLSetPixelFormatPaletteNative(format, palette);
			return ret;
		}

		/// <summary>		/// Set the palette for a pixel format structure.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPixelFormatPalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPixelFormatPalette([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				int ret = SDLSetPixelFormatPaletteNative((SDLPixelFormat*)pformat, palette);
				return ret;
			}
		}

		/// <summary>		/// Set the palette for a pixel format structure.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPixelFormatPalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPixelFormatPalette([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				int ret = SDLSetPixelFormatPaletteNative(format, (SDLPalette*)ppalette);
				return ret;
			}
		}

		/// <summary>		/// Set the palette for a pixel format structure.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPixelFormatPalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPixelFormatPalette([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					int ret = SDLSetPixelFormatPaletteNative((SDLPixelFormat*)pformat, (SDLPalette*)ppalette);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a range of colors in a palette.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetPaletteColors")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetPaletteColors")]
		internal static extern int SDLSetPaletteColorsNative([NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette, [NativeName(NativeNameType.Param, "colors")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* colors, [NativeName(NativeNameType.Param, "firstcolor")] [NativeName(NativeNameType.Type, "int")] int firstcolor, [NativeName(NativeNameType.Param, "ncolors")] [NativeName(NativeNameType.Type, "int")] int ncolors);

		/// <summary>		/// Set a range of colors in a palette.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPaletteColors")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPaletteColors([NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette, [NativeName(NativeNameType.Param, "colors")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* colors, [NativeName(NativeNameType.Param, "firstcolor")] [NativeName(NativeNameType.Type, "int")] int firstcolor, [NativeName(NativeNameType.Param, "ncolors")] [NativeName(NativeNameType.Type, "int")] int ncolors)
		{
			int ret = SDLSetPaletteColorsNative(palette, colors, firstcolor, ncolors);
			return ret;
		}

		/// <summary>		/// Set a range of colors in a palette.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPaletteColors")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPaletteColors([NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "colors")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* colors, [NativeName(NativeNameType.Param, "firstcolor")] [NativeName(NativeNameType.Type, "int")] int firstcolor, [NativeName(NativeNameType.Param, "ncolors")] [NativeName(NativeNameType.Type, "int")] int ncolors)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				int ret = SDLSetPaletteColorsNative((SDLPalette*)ppalette, colors, firstcolor, ncolors);
				return ret;
			}
		}

		/// <summary>		/// Set a range of colors in a palette.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPaletteColors")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPaletteColors([NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette, [NativeName(NativeNameType.Param, "colors")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor colors, [NativeName(NativeNameType.Param, "firstcolor")] [NativeName(NativeNameType.Type, "int")] int firstcolor, [NativeName(NativeNameType.Param, "ncolors")] [NativeName(NativeNameType.Type, "int")] int ncolors)
		{
			fixed (SDLColor* pcolors = &colors)
			{
				int ret = SDLSetPaletteColorsNative(palette, (SDLColor*)pcolors, firstcolor, ncolors);
				return ret;
			}
		}

		/// <summary>		/// Set a range of colors in a palette.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetPaletteColors")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetPaletteColors([NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette, [NativeName(NativeNameType.Param, "colors")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor colors, [NativeName(NativeNameType.Param, "firstcolor")] [NativeName(NativeNameType.Type, "int")] int firstcolor, [NativeName(NativeNameType.Param, "ncolors")] [NativeName(NativeNameType.Type, "int")] int ncolors)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				fixed (SDLColor* pcolors = &colors)
				{
					int ret = SDLSetPaletteColorsNative((SDLPalette*)ppalette, (SDLColor*)pcolors, firstcolor, ncolors);
					return ret;
				}
			}
		}

		/// <summary>
		/// Free a palette created with SDL_AllocPalette().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreePalette")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FreePalette")]
		internal static extern void SDLFreePaletteNative([NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette);

		/// <summary>		/// Free a palette created with SDL_AllocPalette().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreePalette")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreePalette([NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette)
		{
			SDLFreePaletteNative(palette);
		}

		/// <summary>		/// Free a palette created with SDL_AllocPalette().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreePalette")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreePalette([NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				SDLFreePaletteNative((SDLPalette*)ppalette);
			}
		}

		/// <summary>
		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
		/// This function maps the RGB color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGB color value for<br/>
		/// the given pixel format.<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the specified pixel format has an alpha component it will be returned as<br/>
		/// all 1 bits (fully opaque).<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapRGB")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MapRGB")]
		internal static extern uint SDLMapRGBNative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b);

		/// <summary>		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>		/// This function maps the RGB color value to the specified pixel format and<br/>		/// returns the pixel value best approximating the given RGB color value for<br/>		/// the given pixel format.<br/>		/// If the format has a palette (8-bit) the index of the closest matching color<br/>		/// in the palette will be returned.<br/>		/// If the specified pixel format has an alpha component it will be returned as<br/>		/// all 1 bits (fully opaque).<br/>		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>		/// for an 8-bpp format).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MapRGB")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLMapRGB([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			uint ret = SDLMapRGBNative(format, r, g, b);
			return ret;
		}

		/// <summary>		/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>		/// This function maps the RGB color value to the specified pixel format and<br/>		/// returns the pixel value best approximating the given RGB color value for<br/>		/// the given pixel format.<br/>		/// If the format has a palette (8-bit) the index of the closest matching color<br/>		/// in the palette will be returned.<br/>		/// If the specified pixel format has an alpha component it will be returned as<br/>		/// all 1 bits (fully opaque).<br/>		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>		/// for an 8-bpp format).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MapRGB")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLMapRGB([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				uint ret = SDLMapRGBNative((SDLPixelFormat*)pformat, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
		/// This function maps the RGBA color value to the specified pixel format and<br/>
		/// returns the pixel value best approximating the given RGBA color value for<br/>
		/// the given pixel format.<br/>
		/// If the specified pixel format has no alpha component the alpha value will<br/>
		/// be ignored (as it will be in formats with a palette).<br/>
		/// If the format has a palette (8-bit) the index of the closest matching color<br/>
		/// in the palette will be returned.<br/>
		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
		/// for an 8-bpp format).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MapRGBA")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MapRGBA")]
		internal static extern uint SDLMapRGBANative([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a);

		/// <summary>		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>		/// This function maps the RGBA color value to the specified pixel format and<br/>		/// returns the pixel value best approximating the given RGBA color value for<br/>		/// the given pixel format.<br/>		/// If the specified pixel format has no alpha component the alpha value will<br/>		/// be ignored (as it will be in formats with a palette).<br/>		/// If the format has a palette (8-bit) the index of the closest matching color<br/>		/// in the palette will be returned.<br/>		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>		/// for an 8-bpp format).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MapRGBA")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLMapRGBA([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			uint ret = SDLMapRGBANative(format, r, g, b, a);
			return ret;
		}

		/// <summary>		/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>		/// This function maps the RGBA color value to the specified pixel format and<br/>		/// returns the pixel value best approximating the given RGBA color value for<br/>		/// the given pixel format.<br/>		/// If the specified pixel format has no alpha component the alpha value will<br/>		/// be ignored (as it will be in formats with a palette).<br/>		/// If the format has a palette (8-bit) the index of the closest matching color<br/>		/// in the palette will be returned.<br/>		/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>		/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>		/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>		/// for an 8-bpp format).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MapRGBA")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLMapRGBA([NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				uint ret = SDLMapRGBANative((SDLPixelFormat*)pformat, r, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Get RGB values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRGB")]
		internal static extern void SDLGetRGBNative([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b);

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			SDLGetRGBNative(pixel, format, r, g, b);
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				SDLGetRGBNative(pixel, (SDLPixelFormat*)pformat, r, g, b);
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				SDLGetRGBNative(pixel, format, (byte*)pr, g, b);
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					SDLGetRGBNative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, b);
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pg = &g)
			{
				SDLGetRGBNative(pixel, format, r, (byte*)pg, b);
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					SDLGetRGBNative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, b);
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					SDLGetRGBNative(pixel, format, (byte*)pr, (byte*)pg, b);
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						SDLGetRGBNative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, b);
					}
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pb = &b)
			{
				SDLGetRGBNative(pixel, format, r, g, (byte*)pb);
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					SDLGetRGBNative(pixel, (SDLPixelFormat*)pformat, r, g, (byte*)pb);
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					SDLGetRGBNative(pixel, format, (byte*)pr, g, (byte*)pb);
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						SDLGetRGBNative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, (byte*)pb);
					}
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					SDLGetRGBNative(pixel, format, r, (byte*)pg, (byte*)pb);
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						SDLGetRGBNative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, (byte*)pb);
					}
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						SDLGetRGBNative(pixel, format, (byte*)pr, (byte*)pg, (byte*)pb);
					}
				}
			}
		}

		/// <summary>		/// Get RGB values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGB([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							SDLGetRGBNative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, (byte*)pb);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get RGBA values from a pixel in the specified format.<br/>
		/// This function uses the entire 8-bit [0..255] range when converting color<br/>
		/// components from pixel formats with less than 8-bits per RGB component<br/>
		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
		/// (100% opaque).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRGBA")]
		internal static extern void SDLGetRGBANative([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a);

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			SDLGetRGBANative(pixel, format, r, g, b, a);
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, b, a);
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				SDLGetRGBANative(pixel, format, (byte*)pr, g, b, a);
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, b, a);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pg = &g)
			{
				SDLGetRGBANative(pixel, format, r, (byte*)pg, b, a);
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, b, a);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					SDLGetRGBANative(pixel, format, (byte*)pr, (byte*)pg, b, a);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, b, a);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pb = &b)
			{
				SDLGetRGBANative(pixel, format, r, g, (byte*)pb, a);
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					SDLGetRGBANative(pixel, format, (byte*)pr, g, (byte*)pb, a);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					SDLGetRGBANative(pixel, format, r, (byte*)pg, (byte*)pb, a);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						SDLGetRGBANative(pixel, format, (byte*)pr, (byte*)pg, (byte*)pb, a);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, (byte*)pb, a);
						}
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pa = &a)
			{
				SDLGetRGBANative(pixel, format, r, g, b, (byte*)pa);
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pa = &a)
				{
					SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, b, (byte*)pa);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pa = &a)
				{
					SDLGetRGBANative(pixel, format, (byte*)pr, g, b, (byte*)pa);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pa = &a)
					{
						SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pa = &a)
				{
					SDLGetRGBANative(pixel, format, r, (byte*)pg, b, (byte*)pa);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						SDLGetRGBANative(pixel, format, (byte*)pr, (byte*)pg, b, (byte*)pa);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pa = &a)
						{
							SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, b, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pa = &a)
				{
					SDLGetRGBANative(pixel, format, r, g, (byte*)pb, (byte*)pa);
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, r, g, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						SDLGetRGBANative(pixel, format, (byte*)pr, g, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, g, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						SDLGetRGBANative(pixel, format, r, (byte*)pg, (byte*)pb, (byte*)pa);
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, r, (byte*)pg, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							SDLGetRGBANative(pixel, format, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
						}
					}
				}
			}
		}

		/// <summary>		/// Get RGBA values from a pixel in the specified format.<br/>		/// This function uses the entire 8-bit [0..255] range when converting color<br/>		/// components from pixel formats with less than 8-bits per RGB component<br/>		/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>		/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>		/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>		/// (100% opaque).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRGBA")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetRGBA([NativeName(NativeNameType.Param, "pixel")] [NativeName(NativeNameType.Type, "Uint32")] uint pixel, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat format, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLPixelFormat* pformat = &format)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								SDLGetRGBANative(pixel, (SDLPixelFormat*)pformat, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Calculate a 256 entry gamma ramp for a gamma value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CalculateGammaRamp")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CalculateGammaRamp")]
		internal static extern void SDLCalculateGammaRampNative([NativeName(NativeNameType.Param, "gamma")] [NativeName(NativeNameType.Type, "float")] float gamma, [NativeName(NativeNameType.Param, "ramp")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* ramp);

		/// <summary>		/// Calculate a 256 entry gamma ramp for a gamma value.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CalculateGammaRamp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLCalculateGammaRamp([NativeName(NativeNameType.Param, "gamma")] [NativeName(NativeNameType.Type, "float")] float gamma, [NativeName(NativeNameType.Param, "ramp")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* ramp)
		{
			SDLCalculateGammaRampNative(gamma, ramp);
		}

		/// <summary>		/// Calculate a 256 entry gamma ramp for a gamma value.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CalculateGammaRamp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLCalculateGammaRamp([NativeName(NativeNameType.Param, "gamma")] [NativeName(NativeNameType.Type, "float")] float gamma, [NativeName(NativeNameType.Param, "ramp")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort ramp)
		{
			fixed (ushort* pramp = &ramp)
			{
				SDLCalculateGammaRampNative(gamma, (ushort*)pramp);
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasIntersection")]
		internal static extern SDLBool SDLHasIntersectionNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b);

		/// <summary>		/// Determine whether two rectangles intersect.<br/>		/// If either pointer is NULL the function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b)
		{
			SDLBool ret = SDLHasIntersectionNative(a, b);
			return ret;
		}

		/// <summary>		/// Determine whether two rectangles intersect.<br/>		/// If either pointer is NULL the function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b)
		{
			fixed (SDLRect* pa = &a)
			{
				SDLBool ret = SDLHasIntersectionNative((SDLRect*)pa, b);
				return ret;
			}
		}

		/// <summary>		/// Determine whether two rectangles intersect.<br/>		/// If either pointer is NULL the function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLBool ret = SDLHasIntersectionNative(a, (SDLRect*)pb);
				return ret;
			}
		}

		/// <summary>		/// Determine whether two rectangles intersect.<br/>		/// If either pointer is NULL the function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersection")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersection([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					SDLBool ret = SDLHasIntersectionNative((SDLRect*)pa, (SDLRect*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IntersectRect")]
		internal static extern SDLBool SDLIntersectRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result);

		/// <summary>		/// Calculate the intersection of two rectangles.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			SDLBool ret = SDLIntersectRectNative(a, b, result);
			return ret;
		}

		/// <summary>		/// Calculate the intersection of two rectangles.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				SDLBool ret = SDLIntersectRectNative((SDLRect*)pa, b, result);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLBool ret = SDLIntersectRectNative(a, (SDLRect*)pb, result);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					SDLBool ret = SDLIntersectRectNative((SDLRect*)pa, (SDLRect*)pb, result);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLBool ret = SDLIntersectRectNative(a, b, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = SDLIntersectRectNative((SDLRect*)pa, b, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = SDLIntersectRectNative(a, (SDLRect*)pb, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					fixed (SDLRect* presult = &result)
					{
						SDLBool ret = SDLIntersectRectNative((SDLRect*)pa, (SDLRect*)pb, (SDLRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnionRect")]
		internal static extern void SDLUnionRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result);

		/// <summary>		/// Calculate the union of two rectangles.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			SDLUnionRectNative(a, b, result);
		}

		/// <summary>		/// Calculate the union of two rectangles.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				SDLUnionRectNative((SDLRect*)pa, b, result);
			}
		}

		/// <summary>		/// Calculate the union of two rectangles.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pb = &b)
			{
				SDLUnionRectNative(a, (SDLRect*)pb, result);
			}
		}

		/// <summary>		/// Calculate the union of two rectangles.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					SDLUnionRectNative((SDLRect*)pa, (SDLRect*)pb, result);
				}
			}
		}

		/// <summary>		/// Calculate the union of two rectangles.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLUnionRectNative(a, b, (SDLRect*)presult);
			}
		}

		/// <summary>		/// Calculate the union of two rectangles.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLUnionRectNative((SDLRect*)pa, b, (SDLRect*)presult);
				}
			}
		}

		/// <summary>		/// Calculate the union of two rectangles.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pb = &b)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLUnionRectNative(a, (SDLRect*)pb, (SDLRect*)presult);
				}
			}
		}

		/// <summary>		/// Calculate the union of two rectangles.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pa = &a)
			{
				fixed (SDLRect* pb = &b)
				{
					fixed (SDLRect* presult = &result)
					{
						SDLUnionRectNative((SDLRect*)pa, (SDLRect*)pb, (SDLRect*)presult);
					}
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_EnclosePoints")]
		internal static extern SDLBool SDLEnclosePointsNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result);

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			SDLBool ret = SDLEnclosePointsNative(points, count, clip, result);
			return ret;
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				SDLBool ret = SDLEnclosePointsNative((SDLPoint*)ppoints, count, clip, result);
				return ret;
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				SDLBool ret = SDLEnclosePointsNative(points, count, (SDLRect*)pclip, result);
				return ret;
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* pclip = &clip)
				{
					SDLBool ret = SDLEnclosePointsNative((SDLPoint*)ppoints, count, (SDLRect*)pclip, result);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* presult = &result)
			{
				SDLBool ret = SDLEnclosePointsNative(points, count, clip, (SDLRect*)presult);
				return ret;
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = SDLEnclosePointsNative((SDLPoint*)ppoints, count, clip, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLRect* pclip = &clip)
			{
				fixed (SDLRect* presult = &result)
				{
					SDLBool ret = SDLEnclosePointsNative(points, count, (SDLRect*)pclip, (SDLRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnclosePoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEnclosePoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect result)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				fixed (SDLRect* pclip = &clip)
				{
					fixed (SDLRect* presult = &result)
					{
						SDLBool ret = SDLEnclosePointsNative((SDLPoint*)ppoints, count, (SDLRect*)pclip, (SDLRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IntersectRectAndLine")]
		internal static extern SDLBool SDLIntersectRectAndLineNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2);

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* py1 = &y1)
			{
				SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, (int*)py1, x2, y2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, (int*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, x2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px2 = &x2)
			{
				SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, y1, (int*)px2, y2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, x1, y1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, y1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, (int*)py1, (int*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, (int*)py1, (int*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] int* y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* px2 = &x2)
						{
							SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, (int*)px2, y2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* py2 = &y2)
			{
				SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, y1, x2, (int*)py2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, x1, y1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, y1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, (int*)py1, x2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, (int*)py1, x2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] int* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, x2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px2 = &x2)
			{
				fixed (int* py2 = &y2)
				{
					SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, y1, (int*)px2, (int*)py2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, x1, y1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, y1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] int* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, (int*)px1, y1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* py1 = &y1)
			{
				fixed (int* px2 = &x2)
				{
					fixed (int* py2 = &y2)
					{
						SDLBool ret = SDLIntersectRectAndLineNative(rect, x1, (int*)py1, (int*)px2, (int*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] int* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, x1, (int*)py1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (int* px1 = &x1)
			{
				fixed (int* py1 = &y1)
				{
					fixed (int* px2 = &x2)
					{
						fixed (int* py2 = &y2)
						{
							SDLBool ret = SDLIntersectRectAndLineNative(rect, (int*)px1, (int*)py1, (int*)px2, (int*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "int*")] ref int x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "int*")] ref int y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "int*")] ref int x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "int*")] ref int y2)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* px1 = &x1)
				{
					fixed (int* py1 = &y1)
					{
						fixed (int* px2 = &x2)
						{
							fixed (int* py2 = &y2)
							{
								SDLBool ret = SDLIntersectRectAndLineNative((SDLRect*)prect, (int*)px1, (int*)py1, (int*)px2, (int*)py2);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Determine whether two rectangles intersect with float precision.<br/>
		/// If either pointer is NULL the function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasIntersectionF")]
		internal static extern SDLBool SDLHasIntersectionFNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b);

		/// <summary>		/// Determine whether two rectangles intersect with float precision.<br/>		/// If either pointer is NULL the function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b)
		{
			SDLBool ret = SDLHasIntersectionFNative(a, b);
			return ret;
		}

		/// <summary>		/// Determine whether two rectangles intersect with float precision.<br/>		/// If either pointer is NULL the function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b)
		{
			fixed (SDLFRect* pa = &a)
			{
				SDLBool ret = SDLHasIntersectionFNative((SDLFRect*)pa, b);
				return ret;
			}
		}

		/// <summary>		/// Determine whether two rectangles intersect with float precision.<br/>		/// If either pointer is NULL the function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b)
		{
			fixed (SDLFRect* pb = &b)
			{
				SDLBool ret = SDLHasIntersectionFNative(a, (SDLFRect*)pb);
				return ret;
			}
		}

		/// <summary>		/// Determine whether two rectangles intersect with float precision.<br/>		/// If either pointer is NULL the function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasIntersectionF")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasIntersectionF([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					SDLBool ret = SDLHasIntersectionFNative((SDLFRect*)pa, (SDLFRect*)pb);
					return ret;
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of two rectangles with float precision.<br/>
		/// If `result` is NULL then this function will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IntersectFRect")]
		internal static extern SDLBool SDLIntersectFRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result);

		/// <summary>		/// Calculate the intersection of two rectangles with float precision.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			SDLBool ret = SDLIntersectFRectNative(a, b, result);
			return ret;
		}

		/// <summary>		/// Calculate the intersection of two rectangles with float precision.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				SDLBool ret = SDLIntersectFRectNative((SDLFRect*)pa, b, result);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles with float precision.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pb = &b)
			{
				SDLBool ret = SDLIntersectFRectNative(a, (SDLFRect*)pb, result);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles with float precision.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					SDLBool ret = SDLIntersectFRectNative((SDLFRect*)pa, (SDLFRect*)pb, result);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles with float precision.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				SDLBool ret = SDLIntersectFRectNative(a, b, (SDLFRect*)presult);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles with float precision.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = SDLIntersectFRectNative((SDLFRect*)pa, b, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles with float precision.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = SDLIntersectFRectNative(a, (SDLFRect*)pb, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of two rectangles with float precision.<br/>		/// If `result` is NULL then this function will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					fixed (SDLFRect* presult = &result)
					{
						SDLBool ret = SDLIntersectFRectNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the union of two rectangles with float precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnionFRect")]
		internal static extern void SDLUnionFRectNative([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result);

		/// <summary>		/// Calculate the union of two rectangles with float precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			SDLUnionFRectNative(a, b, result);
		}

		/// <summary>		/// Calculate the union of two rectangles with float precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				SDLUnionFRectNative((SDLFRect*)pa, b, result);
			}
		}

		/// <summary>		/// Calculate the union of two rectangles with float precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pb = &b)
			{
				SDLUnionFRectNative(a, (SDLFRect*)pb, result);
			}
		}

		/// <summary>		/// Calculate the union of two rectangles with float precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					SDLUnionFRectNative((SDLFRect*)pa, (SDLFRect*)pb, result);
				}
			}
		}

		/// <summary>		/// Calculate the union of two rectangles with float precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				SDLUnionFRectNative(a, b, (SDLFRect*)presult);
			}
		}

		/// <summary>		/// Calculate the union of two rectangles with float precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLUnionFRectNative((SDLFRect*)pa, b, (SDLFRect*)presult);
				}
			}
		}

		/// <summary>		/// Calculate the union of two rectangles with float precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pb = &b)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLUnionFRectNative(a, (SDLFRect*)pb, (SDLFRect*)presult);
				}
			}
		}

		/// <summary>		/// Calculate the union of two rectangles with float precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnionFRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnionFRect([NativeName(NativeNameType.Param, "A")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect a, [NativeName(NativeNameType.Param, "B")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect b, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pa = &a)
			{
				fixed (SDLFRect* pb = &b)
				{
					fixed (SDLFRect* presult = &result)
					{
						SDLUnionFRectNative((SDLFRect*)pa, (SDLFRect*)pb, (SDLFRect*)presult);
					}
				}
			}
		}

		/// <summary>
		/// Calculate a minimal rectangle enclosing a set of points with float<br/>
		/// precision.<br/>
		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
		/// considered.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_EncloseFPoints")]
		internal static extern SDLBool SDLEncloseFPointsNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result);

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points with float<br/>		/// precision.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			SDLBool ret = SDLEncloseFPointsNative(points, count, clip, result);
			return ret;
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points with float<br/>		/// precision.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				SDLBool ret = SDLEncloseFPointsNative((SDLFPoint*)ppoints, count, clip, result);
				return ret;
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points with float<br/>		/// precision.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				SDLBool ret = SDLEncloseFPointsNative(points, count, (SDLFRect*)pclip, result);
				return ret;
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points with float<br/>		/// precision.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] SDLFRect* result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* pclip = &clip)
				{
					SDLBool ret = SDLEncloseFPointsNative((SDLFPoint*)ppoints, count, (SDLFRect*)pclip, result);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points with float<br/>		/// precision.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* presult = &result)
			{
				SDLBool ret = SDLEncloseFPointsNative(points, count, clip, (SDLFRect*)presult);
				return ret;
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points with float<br/>		/// precision.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = SDLEncloseFPointsNative((SDLFPoint*)ppoints, count, clip, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points with float<br/>		/// precision.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFRect* pclip = &clip)
			{
				fixed (SDLFRect* presult = &result)
				{
					SDLBool ret = SDLEncloseFPointsNative(points, count, (SDLFRect*)pclip, (SDLFRect*)presult);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate a minimal rectangle enclosing a set of points with float<br/>		/// precision.<br/>		/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>		/// considered.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EncloseFPoints")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLEncloseFPoints([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "clip")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect clip, [NativeName(NativeNameType.Param, "result")] [NativeName(NativeNameType.Type, "SDL_FRect*")] ref SDLFRect result)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				fixed (SDLFRect* pclip = &clip)
				{
					fixed (SDLFRect* presult = &result)
					{
						SDLBool ret = SDLEncloseFPointsNative((SDLFPoint*)ppoints, count, (SDLFRect*)pclip, (SDLFRect*)presult);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Calculate the intersection of a rectangle and line segment with float<br/>
		/// precision.<br/>
		/// This function is used to clip a line segment to a rectangle. A line segment<br/>
		/// contained entirely within the rectangle or that does not intersect will<br/>
		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
		/// both ends will be clipped to the boundary of the rectangle and the new<br/>
		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IntersectFRectAndLine")]
		internal static extern SDLBool SDLIntersectFRectAndLineNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2);

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, y1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, (float*)py1, x2, y2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, x1, (float*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, x2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, (float*)py1, x2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px2 = &x2)
			{
				SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, y1, (float*)px2, y2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px2 = &x2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, x1, y1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, y1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* px2 = &x2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, y1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, (float*)py1, (float*)px2, y2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, x1, (float*)py1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, (float*)px2, y2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] float* y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* px2 = &x2)
						{
							SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, (float*)py1, (float*)px2, y2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* py2 = &y2)
			{
				SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, y1, x2, (float*)py2);
				return ret;
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, x1, y1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, y1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, y1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, (float*)py1, x2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, x1, (float*)py1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, x2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] float* x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* py2 = &y2)
						{
							SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, (float*)py1, x2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px2 = &x2)
			{
				fixed (float* py2 = &y2)
				{
					SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, y1, (float*)px2, (float*)py2);
					return ret;
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, x1, y1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, y1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] float* y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, y1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* py1 = &y1)
			{
				fixed (float* px2 = &x2)
				{
					fixed (float* py2 = &y2)
					{
						SDLBool ret = SDLIntersectFRectAndLineNative(rect, x1, (float*)py1, (float*)px2, (float*)py2);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] float* x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, x1, (float*)py1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (float* px1 = &x1)
			{
				fixed (float* py1 = &y1)
				{
					fixed (float* px2 = &x2)
					{
						fixed (float* py2 = &y2)
						{
							SDLBool ret = SDLIntersectFRectAndLineNative(rect, (float*)px1, (float*)py1, (float*)px2, (float*)py2);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Calculate the intersection of a rectangle and line segment with float<br/>		/// precision.<br/>		/// This function is used to clip a line segment to a rectangle. A line segment<br/>		/// contained entirely within the rectangle or that does not intersect will<br/>		/// remain unchanged. A line segment that crosses the rectangle at either or<br/>		/// both ends will be clipped to the boundary of the rectangle and the new<br/>		/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IntersectFRectAndLine")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIntersectFRectAndLine([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect, [NativeName(NativeNameType.Param, "X1")] [NativeName(NativeNameType.Type, "float*")] ref float x1, [NativeName(NativeNameType.Param, "Y1")] [NativeName(NativeNameType.Type, "float*")] ref float y1, [NativeName(NativeNameType.Param, "X2")] [NativeName(NativeNameType.Type, "float*")] ref float x2, [NativeName(NativeNameType.Param, "Y2")] [NativeName(NativeNameType.Type, "float*")] ref float y2)
		{
			fixed (SDLFRect* prect = &rect)
			{
				fixed (float* px1 = &x1)
				{
					fixed (float* py1 = &y1)
					{
						fixed (float* px2 = &x2)
						{
							fixed (float* py2 = &y2)
							{
								SDLBool ret = SDLIntersectFRectAndLineNative((SDLFRect*)prect, (float*)px1, (float*)py1, (float*)px2, (float*)py2);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Compose a custom blend mode for renderers.<br/>
		/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>
		/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>
		/// A blend mode controls how the pixels from a drawing operation (source) get<br/>
		/// combined with the pixels from the render target (destination). First, the<br/>
		/// components of the source and destination pixels get multiplied with their<br/>
		/// blend factors. Then, the blend operation takes the two products and<br/>
		/// calculates the result that will get stored in the render target.<br/>
		/// Expressed in pseudocode, it would look like this:<br/>
		/// ```c<br/>
		/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>
		/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>
		/// ```<br/>
		/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>
		/// dst)` can return one of the following:<br/>
		/// - `src + dst`<br/>
		/// - `src - dst`<br/>
		/// - `dst - src`<br/>
		/// - `min(src, dst)`<br/>
		/// - `max(src, dst)`<br/>
		/// The red, green, and blue components are always multiplied with the first,<br/>
		/// second, and third components of the SDL_BlendFactor, respectively. The<br/>
		/// fourth component is not used.<br/>
		/// The alpha component is always multiplied with the fourth component of the<br/>
		/// SDL_BlendFactor. The other components are not used in the alpha<br/>
		/// calculation.<br/>
		/// Support for these blend modes varies for each renderer. To check if a<br/>
		/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>
		/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>
		/// return with an error if the blend mode is not supported.<br/>
		/// This list describes the support of custom blend modes for each renderer in<br/>
		/// SDL 2.0.6. All renderers support the four blend modes listed in the<br/>
		/// SDL_BlendMode enumeration.<br/>
		/// - **direct3d**: Supports all operations with all factors. However, some<br/>
		/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>
		/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>
		/// - **direct3d11**: Same as Direct3D 9.<br/>
		/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL<br/>
		/// 2.0.6.<br/>
		/// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
		/// factors. Color and alpha factors need to be the same. OpenGL ES 1<br/>
		/// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`<br/>
		/// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha<br/>
		/// operations being different from each other. May support color and alpha<br/>
		/// factors being different from each other.<br/>
		/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>
		/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>
		/// operations with all factors.<br/>
		/// - **psp**: No custom blend mode support.<br/>
		/// - **software**: No custom blend mode support.<br/>
		/// Some renderers do not provide an alpha component for the default render<br/>
		/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>
		/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>
		/// case.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ComposeCustomBlendMode")]
		[return: NativeName(NativeNameType.Type, "SDL_BlendMode")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ComposeCustomBlendMode")]
		internal static extern SDLBlendMode SDLComposeCustomBlendModeNative([NativeName(NativeNameType.Param, "srcColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcColorFactor, [NativeName(NativeNameType.Param, "dstColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstColorFactor, [NativeName(NativeNameType.Param, "colorOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation colorOperation, [NativeName(NativeNameType.Param, "srcAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcAlphaFactor, [NativeName(NativeNameType.Param, "dstAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstAlphaFactor, [NativeName(NativeNameType.Param, "alphaOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation alphaOperation);

		/// <summary>		/// Compose a custom blend mode for renderers.<br/>		/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>		/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>		/// A blend mode controls how the pixels from a drawing operation (source) get<br/>		/// combined with the pixels from the render target (destination). First, the<br/>		/// components of the source and destination pixels get multiplied with their<br/>		/// blend factors. Then, the blend operation takes the two products and<br/>		/// calculates the result that will get stored in the render target.<br/>		/// Expressed in pseudocode, it would look like this:<br/>		/// ```c<br/>		/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>		/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>		/// ```<br/>		/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>		/// dst)` can return one of the following:<br/>		/// - `src + dst`<br/>		/// - `src - dst`<br/>		/// - `dst - src`<br/>		/// - `min(src, dst)`<br/>		/// - `max(src, dst)`<br/>		/// The red, green, and blue components are always multiplied with the first,<br/>		/// second, and third components of the SDL_BlendFactor, respectively. The<br/>		/// fourth component is not used.<br/>		/// The alpha component is always multiplied with the fourth component of the<br/>		/// SDL_BlendFactor. The other components are not used in the alpha<br/>		/// calculation.<br/>		/// Support for these blend modes varies for each renderer. To check if a<br/>		/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>		/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>		/// return with an error if the blend mode is not supported.<br/>		/// This list describes the support of custom blend modes for each renderer in<br/>		/// SDL 2.0.6. All renderers support the four blend modes listed in the<br/>		/// SDL_BlendMode enumeration.<br/>		/// - **direct3d**: Supports all operations with all factors. However, some<br/>		/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>		/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>		/// - **direct3d11**: Same as Direct3D 9.<br/>		/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>		/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL<br/>		/// 2.0.6.<br/>		/// - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>		/// factors. Color and alpha factors need to be the same. OpenGL ES 1<br/>		/// implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`<br/>		/// and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha<br/>		/// operations being different from each other. May support color and alpha<br/>		/// factors being different from each other.<br/>		/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>		/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>		/// operations with all factors.<br/>		/// - **psp**: No custom blend mode support.<br/>		/// - **software**: No custom blend mode support.<br/>		/// Some renderers do not provide an alpha component for the default render<br/>		/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>		/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>		/// case.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ComposeCustomBlendMode")]
		[return: NativeName(NativeNameType.Type, "SDL_BlendMode")]
		public static SDLBlendMode SDLComposeCustomBlendMode([NativeName(NativeNameType.Param, "srcColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcColorFactor, [NativeName(NativeNameType.Param, "dstColorFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstColorFactor, [NativeName(NativeNameType.Param, "colorOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation colorOperation, [NativeName(NativeNameType.Param, "srcAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor srcAlphaFactor, [NativeName(NativeNameType.Param, "dstAlphaFactor")] [NativeName(NativeNameType.Type, "SDL_BlendFactor")] SDLBlendFactor dstAlphaFactor, [NativeName(NativeNameType.Param, "alphaOperation")] [NativeName(NativeNameType.Type, "SDL_BlendOperation")] SDLBlendOperation alphaOperation)
		{
			SDLBlendMode ret = SDLComposeCustomBlendModeNative(srcColorFactor, dstColorFactor, colorOperation, srcAlphaFactor, dstAlphaFactor, alphaOperation);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface.<br/>
		/// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.<br/>
		/// If `depth` is greater than 8 bits, the pixel format is set using the<br/>
		/// [RGBA]mask parameters.<br/>
		/// The [RGBA]mask parameters are the bitmasks used to extract that color from<br/>
		/// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is<br/>
		/// stored in the most significant byte. Using zeros for the RGB masks sets a<br/>
		/// default value, based on the depth. For example:<br/>
		/// ```c++<br/>
		/// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);<br/>
		/// ```<br/>
		/// However, using zero for the Amask results in an Amask of 0.<br/>
		/// By default surfaces with an alpha mask are set up for blending as with:<br/>
		/// ```c++<br/>
		/// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)<br/>
		/// ```<br/>
		/// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a<br/>
		/// different `blendMode`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateRGBSurface")]
		internal static extern SDLSurface* SDLCreateRGBSurfaceNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask);

		/// <summary>		/// Allocate a new RGB surface.<br/>		/// If `depth` is 4 or 8 bits, an empty palette is allocated for the surface.<br/>		/// If `depth` is greater than 8 bits, the pixel format is set using the<br/>		/// [RGBA]mask parameters.<br/>		/// The [RGBA]mask parameters are the bitmasks used to extract that color from<br/>		/// a pixel. For instance, `Rmask` being 0xFF000000 means the red data is<br/>		/// stored in the most significant byte. Using zeros for the RGB masks sets a<br/>		/// default value, based on the depth. For example:<br/>		/// ```c++<br/>		/// SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);<br/>		/// ```<br/>		/// However, using zero for the Amask results in an Amask of 0.<br/>		/// By default surfaces with an alpha mask are set up for blending as with:<br/>		/// ```c++<br/>		/// SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)<br/>		/// ```<br/>		/// You can change this by calling SDL_SetSurfaceBlendMode() and selecting a<br/>		/// different `blendMode`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLCreateRGBSurface([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			SDLSurface* ret = SDLCreateRGBSurfaceNative(flags, width, height, depth, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface with a specific pixel format.<br/>
		/// This function operates mostly like SDL_CreateRGBSurface(), except instead<br/>
		/// of providing pixel color masks, you provide it with a predefined format<br/>
		/// from SDL_PixelFormatEnum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateRGBSurfaceWithFormat")]
		internal static extern SDLSurface* SDLCreateRGBSurfaceWithFormatNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format);

		/// <summary>		/// Allocate a new RGB surface with a specific pixel format.<br/>		/// This function operates mostly like SDL_CreateRGBSurface(), except instead<br/>		/// of providing pixel color masks, you provide it with a predefined format<br/>		/// from SDL_PixelFormatEnum.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLCreateRGBSurfaceWithFormat([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			SDLSurface* ret = SDLCreateRGBSurfaceWithFormatNative(flags, width, height, depth, format);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface with existing pixel data.<br/>
		/// This function operates mostly like SDL_CreateRGBSurface(), except it does<br/>
		/// not allocate memory for the pixel data, instead the caller provides an<br/>
		/// existing buffer of data for the surface to use.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateRGBSurfaceFrom")]
		internal static extern SDLSurface* SDLCreateRGBSurfaceFromNative([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask);

		/// <summary>		/// Allocate a new RGB surface with existing pixel data.<br/>		/// This function operates mostly like SDL_CreateRGBSurface(), except it does<br/>		/// not allocate memory for the pixel data, instead the caller provides an<br/>		/// existing buffer of data for the surface to use.<br/>		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>		/// you must free the surface before you free the pixel data.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLCreateRGBSurfaceFrom([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "Rmask")] [NativeName(NativeNameType.Type, "Uint32")] uint rmask, [NativeName(NativeNameType.Param, "Gmask")] [NativeName(NativeNameType.Type, "Uint32")] uint gmask, [NativeName(NativeNameType.Param, "Bmask")] [NativeName(NativeNameType.Type, "Uint32")] uint bmask, [NativeName(NativeNameType.Param, "Amask")] [NativeName(NativeNameType.Type, "Uint32")] uint amask)
		{
			SDLSurface* ret = SDLCreateRGBSurfaceFromNative(pixels, width, height, depth, pitch, rmask, gmask, bmask, amask);
			return ret;
		}

		/// <summary>
		/// Allocate a new RGB surface with with a specific pixel format and existing<br/>
		/// pixel data.<br/>
		/// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except<br/>
		/// instead of providing pixel color masks, you provide it with a predefined<br/>
		/// format from SDL_PixelFormatEnum.<br/>
		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
		/// you must free the surface before you free the pixel data.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormatFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateRGBSurfaceWithFormatFrom")]
		internal static extern SDLSurface* SDLCreateRGBSurfaceWithFormatFromNative([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format);

		/// <summary>		/// Allocate a new RGB surface with with a specific pixel format and existing<br/>		/// pixel data.<br/>		/// This function operates mostly like SDL_CreateRGBSurfaceFrom(), except<br/>		/// instead of providing pixel color masks, you provide it with a predefined<br/>		/// format from SDL_PixelFormatEnum.<br/>		/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>		/// you must free the surface before you free the pixel data.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRGBSurfaceWithFormatFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLCreateRGBSurfaceWithFormatFrom([NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "depth")] [NativeName(NativeNameType.Type, "int")] int depth, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format)
		{
			SDLSurface* ret = SDLCreateRGBSurfaceWithFormatFromNative(pixels, width, height, depth, pitch, format);
			return ret;
		}

		/// <summary>
		/// Free an RGB surface.<br/>
		/// It is safe to pass NULL to this function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FreeSurface")]
		internal static extern void SDLFreeSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>		/// Free an RGB surface.<br/>		/// It is safe to pass NULL to this function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLFreeSurfaceNative(surface);
		}

		/// <summary>		/// Free an RGB surface.<br/>		/// It is safe to pass NULL to this function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLFreeSurfaceNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Set the palette used by a surface.<br/>
		/// A single palette can be shared with many surfaces.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetSurfacePalette")]
		internal static extern int SDLSetSurfacePaletteNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette);

		/// <summary>		/// Set the palette used by a surface.<br/>		/// A single palette can be shared with many surfaces.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette)
		{
			int ret = SDLSetSurfacePaletteNative(surface, palette);
			return ret;
		}

		/// <summary>		/// Set the palette used by a surface.<br/>		/// A single palette can be shared with many surfaces.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] SDLPalette* palette)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLSetSurfacePaletteNative((SDLSurface*)psurface, palette);
				return ret;
			}
		}

		/// <summary>		/// Set the palette used by a surface.<br/>		/// A single palette can be shared with many surfaces.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette)
		{
			fixed (SDLPalette* ppalette = &palette)
			{
				int ret = SDLSetSurfacePaletteNative(surface, (SDLPalette*)ppalette);
				return ret;
			}
		}

		/// <summary>		/// Set the palette used by a surface.<br/>		/// A single palette can be shared with many surfaces.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfacePalette")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfacePalette([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "palette")] [NativeName(NativeNameType.Type, "SDL_Palette*")] ref SDLPalette palette)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLPalette* ppalette = &palette)
				{
					int ret = SDLSetSurfacePaletteNative((SDLSurface*)psurface, (SDLPalette*)ppalette);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set up a surface for directly accessing the pixels.<br/>
		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
		/// and read from `surface->pixels`, using the pixel format stored in<br/>
		/// `surface->format`. Once you are done accessing the surface, you should use<br/>
		/// SDL_UnlockSurface() to release it.<br/>
		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
		/// 0, then you can read and write to the surface at any time, and the pixel<br/>
		/// format of the surface will not change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LockSurface")]
		internal static extern int SDLLockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>		/// Set up a surface for directly accessing the pixels.<br/>		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>		/// and read from `surface->pixels`, using the pixel format stored in<br/>		/// `surface->format`. Once you are done accessing the surface, you should use<br/>		/// SDL_UnlockSurface() to release it.<br/>		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>		/// 0, then you can read and write to the surface at any time, and the pixel<br/>		/// format of the surface will not change.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			int ret = SDLLockSurfaceNative(surface);
			return ret;
		}

		/// <summary>		/// Set up a surface for directly accessing the pixels.<br/>		/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>		/// and read from `surface->pixels`, using the pixel format stored in<br/>		/// `surface->format`. Once you are done accessing the surface, you should use<br/>		/// SDL_UnlockSurface() to release it.<br/>		/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>		/// 0, then you can read and write to the surface at any time, and the pixel<br/>		/// format of the surface will not change.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLLockSurfaceNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Release a surface after directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnlockSurface")]
		internal static extern void SDLUnlockSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>		/// Release a surface after directly accessing the pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLUnlockSurfaceNative(surface);
		}

		/// <summary>		/// Release a surface after directly accessing the pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockSurface")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLUnlockSurfaceNative((SDLSurface*)psurface);
			}
		}

		/// <summary>
		/// Load a BMP image from a seekable SDL data stream.<br/>
		/// The new surface should be freed with SDL_FreeSurface(). Not doing so will<br/>
		/// result in a memory leak.<br/>
		/// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.<br/>
		/// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap<br/>
		/// from a file, convert it to an SDL_Surface and then close the file.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LoadBMP_RW")]
		internal static extern SDLSurface* SDLLoadBMPRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc);

		/// <summary>		/// Load a BMP image from a seekable SDL data stream.<br/>		/// The new surface should be freed with SDL_FreeSurface(). Not doing so will<br/>		/// result in a memory leak.<br/>		/// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.<br/>		/// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap<br/>		/// from a file, convert it to an SDL_Surface and then close the file.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLLoadBMPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			SDLSurface* ret = SDLLoadBMPRWNative(src, freesrc);
			return ret;
		}

		/// <summary>		/// Load a BMP image from a seekable SDL data stream.<br/>		/// The new surface should be freed with SDL_FreeSurface(). Not doing so will<br/>		/// result in a memory leak.<br/>		/// src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile.<br/>		/// Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap<br/>		/// from a file, convert it to an SDL_Surface and then close the file.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLLoadBMPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = SDLLoadBMPRWNative((SDLRWops*)psrc, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Save a surface to a seekable SDL data stream in BMP format.<br/>
		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
		/// not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SaveBMP_RW")]
		internal static extern int SDLSaveBMPRWNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst);

		/// <summary>		/// Save a surface to a seekable SDL data stream in BMP format.<br/>		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>		/// not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			int ret = SDLSaveBMPRWNative(surface, dst, freedst);
			return ret;
		}

		/// <summary>		/// Save a surface to a seekable SDL data stream in BMP format.<br/>		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>		/// not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLSaveBMPRWNative((SDLSurface*)psurface, dst, freedst);
				return ret;
			}
		}

		/// <summary>		/// Save a surface to a seekable SDL data stream in BMP format.<br/>		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>		/// not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = SDLSaveBMPRWNative(surface, (SDLRWops*)pdst, freedst);
				return ret;
			}
		}

		/// <summary>		/// Save a surface to a seekable SDL data stream in BMP format.<br/>		/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>		/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>		/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>		/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>		/// not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveBMP_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveBMPRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRWops* pdst = &dst)
				{
					int ret = SDLSaveBMPRWNative((SDLSurface*)psurface, (SDLRWops*)pdst, freedst);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the RLE acceleration hint for a surface.<br/>
		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
		/// the surface must be locked before directly accessing the pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetSurfaceRLE")]
		internal static extern int SDLSetSurfaceRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag);

		/// <summary>		/// Set the RLE acceleration hint for a surface.<br/>		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>		/// the surface must be locked before directly accessing the pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag)
		{
			int ret = SDLSetSurfaceRLENative(surface, flag);
			return ret;
		}

		/// <summary>		/// Set the RLE acceleration hint for a surface.<br/>		/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>		/// the surface must be locked before directly accessing the pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLSetSurfaceRLENative((SDLSurface*)psurface, flag);
				return ret;
			}
		}

		/// <summary>
		/// Returns whether the surface is RLE enabled<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasSurfaceRLE")]
		internal static extern SDLBool SDLHasSurfaceRLENative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>		/// Returns whether the surface is RLE enabled<br/>		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLBool ret = SDLHasSurfaceRLENative(surface);
			return ret;
		}

		/// <summary>		/// Returns whether the surface is RLE enabled<br/>		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasSurfaceRLE")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasSurfaceRLE([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLBool ret = SDLHasSurfaceRLENative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Set the color key (transparent pixel) in a surface.<br/>
		/// The color key defines a pixel value that will be treated as transparent in<br/>
		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
		/// considered transparent, and therefore not rendered.<br/>
		/// It is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// RLE acceleration can substantially speed up blitting of images with large<br/>
		/// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetColorKey")]
		internal static extern int SDLSetColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key);

		/// <summary>		/// Set the color key (transparent pixel) in a surface.<br/>		/// The color key defines a pixel value that will be treated as transparent in<br/>		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>		/// considered transparent, and therefore not rendered.<br/>		/// It is a pixel of the format used by the surface, as generated by<br/>		/// SDL_MapRGB().<br/>		/// RLE acceleration can substantially speed up blitting of images with large<br/>		/// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			int ret = SDLSetColorKeyNative(surface, flag, key);
			return ret;
		}

		/// <summary>		/// Set the color key (transparent pixel) in a surface.<br/>		/// The color key defines a pixel value that will be treated as transparent in<br/>		/// a blit. For example, one can use this to specify that cyan pixels should be<br/>		/// considered transparent, and therefore not rendered.<br/>		/// It is a pixel of the format used by the surface, as generated by<br/>		/// SDL_MapRGB().<br/>		/// RLE acceleration can substantially speed up blitting of images with large<br/>		/// horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "int")] int flag, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32")] uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLSetColorKeyNative((SDLSurface*)psurface, flag, key);
				return ret;
			}
		}

		/// <summary>
		/// Returns whether the surface has a color key<br/>
		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasColorKey")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasColorKey")]
		internal static extern SDLBool SDLHasColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>		/// Returns whether the surface has a color key<br/>		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasColorKey")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLBool ret = SDLHasColorKeyNative(surface);
			return ret;
		}

		/// <summary>		/// Returns whether the surface has a color key<br/>		/// It is safe to pass a NULL `surface` here; it will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasColorKey")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLBool ret = SDLHasColorKeyNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Get the color key (transparent pixel) for a surface.<br/>
		/// The color key is a pixel of the format used by the surface, as generated by<br/>
		/// SDL_MapRGB().<br/>
		/// If the surface doesn't have color key enabled this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetColorKey")]
		internal static extern int SDLGetColorKeyNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] uint* key);

		/// <summary>		/// Get the color key (transparent pixel) for a surface.<br/>		/// The color key is a pixel of the format used by the surface, as generated by<br/>		/// SDL_MapRGB().<br/>		/// If the surface doesn't have color key enabled this function returns -1.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] uint* key)
		{
			int ret = SDLGetColorKeyNative(surface, key);
			return ret;
		}

		/// <summary>		/// Get the color key (transparent pixel) for a surface.<br/>		/// The color key is a pixel of the format used by the surface, as generated by<br/>		/// SDL_MapRGB().<br/>		/// If the surface doesn't have color key enabled this function returns -1.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] uint* key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLGetColorKeyNative((SDLSurface*)psurface, key);
				return ret;
			}
		}

		/// <summary>		/// Get the color key (transparent pixel) for a surface.<br/>		/// The color key is a pixel of the format used by the surface, as generated by<br/>		/// SDL_MapRGB().<br/>		/// If the surface doesn't have color key enabled this function returns -1.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint key)
		{
			fixed (uint* pkey = &key)
			{
				int ret = SDLGetColorKeyNative(surface, (uint*)pkey);
				return ret;
			}
		}

		/// <summary>		/// Get the color key (transparent pixel) for a surface.<br/>		/// The color key is a pixel of the format used by the surface, as generated by<br/>		/// SDL_MapRGB().<br/>		/// If the surface doesn't have color key enabled this function returns -1.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetColorKey")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetColorKey([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint key)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (uint* pkey = &key)
				{
					int ret = SDLGetColorKeyNative((SDLSurface*)psurface, (uint*)pkey);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into blit operations.<br/>
		/// When this surface is blitted, during the blit operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetSurfaceColorMod")]
		internal static extern int SDLSetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b);

		/// <summary>		/// Set an additional color value multiplied into blit operations.<br/>		/// When this surface is blitted, during the blit operation each source color<br/>		/// channel is modulated by the appropriate color value according to the<br/>		/// following formula:<br/>		/// `srcC = srcC * (color / 255)`<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			int ret = SDLSetSurfaceColorModNative(surface, r, g, b);
			return ret;
		}

		/// <summary>		/// Set an additional color value multiplied into blit operations.<br/>		/// When this surface is blitted, during the blit operation each source color<br/>		/// channel is modulated by the appropriate color value according to the<br/>		/// following formula:<br/>		/// `srcC = srcC * (color / 255)`<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLSetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetSurfaceColorMod")]
		internal static extern int SDLGetSurfaceColorModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b);

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			int ret = SDLGetSurfaceColorModNative(surface, r, g, b);
			return ret;
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLGetSurfaceColorModNative((SDLSurface*)psurface, r, g, b);
				return ret;
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				int ret = SDLGetSurfaceColorModNative(surface, (byte*)pr, g, b);
				return ret;
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					int ret = SDLGetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, b);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pg = &g)
			{
				int ret = SDLGetSurfaceColorModNative(surface, r, (byte*)pg, b);
				return ret;
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						int ret = SDLGetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, b);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pb = &b)
			{
				int ret = SDLGetSurfaceColorModNative(surface, r, g, (byte*)pb);
				return ret;
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetSurfaceColorModNative((SDLSurface*)psurface, r, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetSurfaceColorModNative(surface, (byte*)pr, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, g, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetSurfaceColorModNative(surface, r, (byte*)pg, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetSurfaceColorModNative((SDLSurface*)psurface, r, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetSurfaceColorModNative(surface, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceColorMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							int ret = SDLGetSurfaceColorModNative((SDLSurface*)psurface, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value used in blit operations.<br/>
		/// When this surface is blitted, during the blit operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetSurfaceAlphaMod")]
		internal static extern int SDLSetSurfaceAlphaModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha);

		/// <summary>		/// Set an additional alpha value used in blit operations.<br/>		/// When this surface is blitted, during the blit operation the source alpha<br/>		/// value is modulated by this alpha value according to the following formula:<br/>		/// `srcA = srcA * (alpha / 255)`<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			int ret = SDLSetSurfaceAlphaModNative(surface, alpha);
			return ret;
		}

		/// <summary>		/// Set an additional alpha value used in blit operations.<br/>		/// When this surface is blitted, during the blit operation the source alpha<br/>		/// value is modulated by this alpha value according to the following formula:<br/>		/// `srcA = srcA * (alpha / 255)`<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLSetSurfaceAlphaModNative((SDLSurface*)psurface, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value used in blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetSurfaceAlphaMod")]
		internal static extern int SDLGetSurfaceAlphaModNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha);

		/// <summary>		/// Get the additional alpha value used in blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			int ret = SDLGetSurfaceAlphaModNative(surface, alpha);
			return ret;
		}

		/// <summary>		/// Get the additional alpha value used in blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLGetSurfaceAlphaModNative((SDLSurface*)psurface, alpha);
				return ret;
			}
		}

		/// <summary>		/// Get the additional alpha value used in blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				int ret = SDLGetSurfaceAlphaModNative(surface, (byte*)palpha);
				return ret;
			}
		}

		/// <summary>		/// Get the additional alpha value used in blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceAlphaMod([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte alpha)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* palpha = &alpha)
				{
					int ret = SDLGetSurfaceAlphaModNative((SDLSurface*)psurface, (byte*)palpha);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the blend mode used for blit operations.<br/>
		/// To copy a surface to another surface (or texture) without blending with the<br/>
		/// existing data, the blendmode of the SOURCE surface should be set to<br/>
		/// `SDL_BLENDMODE_NONE`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetSurfaceBlendMode")]
		internal static extern int SDLSetSurfaceBlendModeNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode);

		/// <summary>		/// Set the blend mode used for blit operations.<br/>		/// To copy a surface to another surface (or texture) without blending with the<br/>		/// existing data, the blendmode of the SOURCE surface should be set to<br/>		/// `SDL_BLENDMODE_NONE`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			int ret = SDLSetSurfaceBlendModeNative(surface, blendMode);
			return ret;
		}

		/// <summary>		/// Set the blend mode used for blit operations.<br/>		/// To copy a surface to another surface (or texture) without blending with the<br/>		/// existing data, the blendmode of the SOURCE surface should be set to<br/>		/// `SDL_BLENDMODE_NONE`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLSetSurfaceBlendModeNative((SDLSurface*)psurface, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for blit operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetSurfaceBlendMode")]
		internal static extern int SDLGetSurfaceBlendModeNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode);

		/// <summary>		/// Get the blend mode used for blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			int ret = SDLGetSurfaceBlendModeNative(surface, blendMode);
			return ret;
		}

		/// <summary>		/// Get the blend mode used for blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SDLGetSurfaceBlendModeNative((SDLSurface*)psurface, blendMode);
				return ret;
			}
		}

		/// <summary>		/// Get the blend mode used for blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				int ret = SDLGetSurfaceBlendModeNative(surface, (SDLBlendMode*)pblendMode);
				return ret;
			}
		}

		/// <summary>		/// Get the blend mode used for blit operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetSurfaceBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetSurfaceBlendMode([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					int ret = SDLGetSurfaceBlendModeNative((SDLSurface*)psurface, (SDLBlendMode*)pblendMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// Note that blits are automatically clipped to the edges of the source and<br/>
		/// destination surfaces.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetClipRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetClipRect")]
		internal static extern SDLBool SDLSetClipRectNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Set the clipping rectangle for a surface.<br/>		/// When `surface` is the destination of a blit, only the area within the clip<br/>		/// rectangle is drawn into.<br/>		/// Note that blits are automatically clipped to the edges of the source and<br/>		/// destination surfaces.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetClipRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			SDLBool ret = SDLSetClipRectNative(surface, rect);
			return ret;
		}

		/// <summary>		/// Set the clipping rectangle for a surface.<br/>		/// When `surface` is the destination of a blit, only the area within the clip<br/>		/// rectangle is drawn into.<br/>		/// Note that blits are automatically clipped to the edges of the source and<br/>		/// destination surfaces.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetClipRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLBool ret = SDLSetClipRectNative((SDLSurface*)psurface, rect);
				return ret;
			}
		}

		/// <summary>		/// Set the clipping rectangle for a surface.<br/>		/// When `surface` is the destination of a blit, only the area within the clip<br/>		/// rectangle is drawn into.<br/>		/// Note that blits are automatically clipped to the edges of the source and<br/>		/// destination surfaces.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetClipRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLBool ret = SDLSetClipRectNative(surface, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>		/// Set the clipping rectangle for a surface.<br/>		/// When `surface` is the destination of a blit, only the area within the clip<br/>		/// rectangle is drawn into.<br/>		/// Note that blits are automatically clipped to the edges of the source and<br/>		/// destination surfaces.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetClipRect")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRect* prect = &rect)
				{
					SDLBool ret = SDLSetClipRectNative((SDLSurface*)psurface, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the clipping rectangle for a surface.<br/>
		/// When `surface` is the destination of a blit, only the area within the clip<br/>
		/// rectangle is drawn into.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetClipRect")]
		internal static extern void SDLGetClipRectNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Get the clipping rectangle for a surface.<br/>		/// When `surface` is the destination of a blit, only the area within the clip<br/>		/// rectangle is drawn into.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			SDLGetClipRectNative(surface, rect);
		}

		/// <summary>		/// Get the clipping rectangle for a surface.<br/>		/// When `surface` is the destination of a blit, only the area within the clip<br/>		/// rectangle is drawn into.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLGetClipRectNative((SDLSurface*)psurface, rect);
			}
		}

		/// <summary>		/// Get the clipping rectangle for a surface.<br/>		/// When `surface` is the destination of a blit, only the area within the clip<br/>		/// rectangle is drawn into.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLGetClipRectNative(surface, (SDLRect*)prect);
			}
		}

		/// <summary>		/// Get the clipping rectangle for a surface.<br/>		/// When `surface` is the destination of a blit, only the area within the clip<br/>		/// rectangle is drawn into.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetClipRect([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRect* prect = &rect)
				{
					SDLGetClipRectNative((SDLSurface*)psurface, (SDLRect*)prect);
				}
			}
		}

		/// <summary>
		/// Creates a new surface identical to the existing surface.<br/>
		/// The returned surface should be freed with SDL_FreeSurface().<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DuplicateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DuplicateSurface")]
		internal static extern SDLSurface* SDLDuplicateSurfaceNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>		/// Creates a new surface identical to the existing surface.<br/>		/// The returned surface should be freed with SDL_FreeSurface().<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DuplicateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLDuplicateSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLSurface* ret = SDLDuplicateSurfaceNative(surface);
			return ret;
		}

		/// <summary>		/// Creates a new surface identical to the existing surface.<br/>		/// The returned surface should be freed with SDL_FreeSurface().<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DuplicateSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLDuplicateSurface([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLSurface* ret = SDLDuplicateSurfaceNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format.<br/>
		/// This function is used to optimize images for faster *repeat* blitting. This<br/>
		/// is accomplished by converting the original and storing the result as a new<br/>
		/// surface. The new, optimized surface can then be used as the source for<br/>
		/// future blits, making them faster.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ConvertSurface")]
		internal static extern SDLSurface* SDLConvertSurfaceNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* fmt, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Copy an existing surface to a new surface of the specified format.<br/>		/// This function is used to optimize images for faster *repeat* blitting. This<br/>		/// is accomplished by converting the original and storing the result as a new<br/>		/// surface. The new, optimized surface can then be used as the source for<br/>		/// future blits, making them faster.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLConvertSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* fmt, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			SDLSurface* ret = SDLConvertSurfaceNative(src, fmt, flags);
			return ret;
		}

		/// <summary>		/// Copy an existing surface to a new surface of the specified format.<br/>		/// This function is used to optimize images for faster *repeat* blitting. This<br/>		/// is accomplished by converting the original and storing the result as a new<br/>		/// surface. The new, optimized surface can then be used as the source for<br/>		/// future blits, making them faster.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLConvertSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] SDLPixelFormat* fmt, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			fixed (SDLSurface* psrc = &src)
			{
				SDLSurface* ret = SDLConvertSurfaceNative((SDLSurface*)psrc, fmt, flags);
				return ret;
			}
		}

		/// <summary>		/// Copy an existing surface to a new surface of the specified format.<br/>		/// This function is used to optimize images for faster *repeat* blitting. This<br/>		/// is accomplished by converting the original and storing the result as a new<br/>		/// surface. The new, optimized surface can then be used as the source for<br/>		/// future blits, making them faster.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLConvertSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat fmt, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			fixed (SDLPixelFormat* pfmt = &fmt)
			{
				SDLSurface* ret = SDLConvertSurfaceNative(src, (SDLPixelFormat*)pfmt, flags);
				return ret;
			}
		}

		/// <summary>		/// Copy an existing surface to a new surface of the specified format.<br/>		/// This function is used to optimize images for faster *repeat* blitting. This<br/>		/// is accomplished by converting the original and storing the result as a new<br/>		/// surface. The new, optimized surface can then be used as the source for<br/>		/// future blits, making them faster.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLConvertSurface([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const SDL_PixelFormat*")] ref SDLPixelFormat fmt, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLPixelFormat* pfmt = &fmt)
				{
					SDLSurface* ret = SDLConvertSurfaceNative((SDLSurface*)psrc, (SDLPixelFormat*)pfmt, flags);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy an existing surface to a new surface of the specified format enum.<br/>
		/// This function operates just like SDL_ConvertSurface(), but accepts an<br/>
		/// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,<br/>
		/// it might be easier to call but it doesn't have access to palette<br/>
		/// information for the destination surface, in case that would be important.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ConvertSurfaceFormat")]
		internal static extern SDLSurface* SDLConvertSurfaceFormatNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "pixel_format")] [NativeName(NativeNameType.Type, "Uint32")] uint pixelFormat, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Copy an existing surface to a new surface of the specified format enum.<br/>		/// This function operates just like SDL_ConvertSurface(), but accepts an<br/>		/// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,<br/>		/// it might be easier to call but it doesn't have access to palette<br/>		/// information for the destination surface, in case that would be important.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLConvertSurfaceFormat([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "pixel_format")] [NativeName(NativeNameType.Type, "Uint32")] uint pixelFormat, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			SDLSurface* ret = SDLConvertSurfaceFormatNative(src, pixelFormat, flags);
			return ret;
		}

		/// <summary>		/// Copy an existing surface to a new surface of the specified format enum.<br/>		/// This function operates just like SDL_ConvertSurface(), but accepts an<br/>		/// SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,<br/>		/// it might be easier to call but it doesn't have access to palette<br/>		/// information for the destination surface, in case that would be important.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertSurfaceFormat")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLConvertSurfaceFormat([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "pixel_format")] [NativeName(NativeNameType.Type, "Uint32")] uint pixelFormat, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			fixed (SDLSurface* psrc = &src)
			{
				SDLSurface* ret = SDLConvertSurfaceFormatNative((SDLSurface*)psrc, pixelFormat, flags);
				return ret;
			}
		}

		/// <summary>
		/// Copy a block of pixels of one format to another format.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ConvertPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ConvertPixels")]
		internal static extern int SDLConvertPixelsNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "Uint32")] uint srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "Uint32")] uint dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch);

		/// <summary>		/// Copy a block of pixels of one format to another format.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ConvertPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLConvertPixels([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "Uint32")] uint srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "Uint32")] uint dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch)
		{
			int ret = SDLConvertPixelsNative(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch);
			return ret;
		}

		/// <summary>
		/// Premultiply the alpha on a block of pixels.<br/>
		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
		/// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PremultiplyAlpha")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_PremultiplyAlpha")]
		internal static extern int SDLPremultiplyAlphaNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "Uint32")] uint srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "Uint32")] uint dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch);

		/// <summary>		/// Premultiply the alpha on a block of pixels.<br/>		/// This is safe to use with src == dst, but not for other overlapping areas.<br/>		/// This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PremultiplyAlpha")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPremultiplyAlpha([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "src_format")] [NativeName(NativeNameType.Type, "Uint32")] uint srcFormat, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "const void*")] void* src, [NativeName(NativeNameType.Param, "src_pitch")] [NativeName(NativeNameType.Type, "int")] int srcPitch, [NativeName(NativeNameType.Param, "dst_format")] [NativeName(NativeNameType.Type, "Uint32")] uint dstFormat, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "void*")] void* dst, [NativeName(NativeNameType.Param, "dst_pitch")] [NativeName(NativeNameType.Type, "int")] int dstPitch)
		{
			int ret = SDLPremultiplyAlphaNative(width, height, srcFormat, src, srcPitch, dstFormat, dst, dstPitch);
			return ret;
		}

		/// <summary>
		/// Perform a fast fill of a rectangle with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>
		/// of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FillRect")]
		internal static extern int SDLFillRectNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color);

		/// <summary>		/// Perform a fast fill of a rectangle with a specific color.<br/>		/// `color` should be a pixel of the format used by the surface, and can be<br/>		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>		/// alpha component then the destination is simply filled with that alpha<br/>		/// information, no blending takes place.<br/>		/// If there is a clip rectangle set on the destination (set via<br/>		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>		/// of the clip rectangle and `rect`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			int ret = SDLFillRectNative(dst, rect, color);
			return ret;
		}

		/// <summary>		/// Perform a fast fill of a rectangle with a specific color.<br/>		/// `color` should be a pixel of the format used by the surface, and can be<br/>		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>		/// alpha component then the destination is simply filled with that alpha<br/>		/// information, no blending takes place.<br/>		/// If there is a clip rectangle set on the destination (set via<br/>		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>		/// of the clip rectangle and `rect`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLFillRectNative((SDLSurface*)pdst, rect, color);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast fill of a rectangle with a specific color.<br/>		/// `color` should be a pixel of the format used by the surface, and can be<br/>		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>		/// alpha component then the destination is simply filled with that alpha<br/>		/// information, no blending takes place.<br/>		/// If there is a clip rectangle set on the destination (set via<br/>		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>		/// of the clip rectangle and `rect`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLFillRectNative(dst, (SDLRect*)prect, color);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast fill of a rectangle with a specific color.<br/>		/// `color` should be a pixel of the format used by the surface, and can be<br/>		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>		/// alpha component then the destination is simply filled with that alpha<br/>		/// information, no blending takes place.<br/>		/// If there is a clip rectangle set on the destination (set via<br/>		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>		/// of the clip rectangle and `rect`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRect([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLFillRectNative((SDLSurface*)pdst, (SDLRect*)prect, color);
					return ret;
				}
			}
		}

		/// <summary>
		/// Perform a fast fill of a set of rectangles with a specific color.<br/>
		/// `color` should be a pixel of the format used by the surface, and can be<br/>
		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
		/// alpha component then the destination is simply filled with that alpha<br/>
		/// information, no blending takes place.<br/>
		/// If there is a clip rectangle set on the destination (set via<br/>
		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>
		/// of the clip rectangle and `rect`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FillRects")]
		internal static extern int SDLFillRectsNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color);

		/// <summary>		/// Perform a fast fill of a set of rectangles with a specific color.<br/>		/// `color` should be a pixel of the format used by the surface, and can be<br/>		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>		/// alpha component then the destination is simply filled with that alpha<br/>		/// information, no blending takes place.<br/>		/// If there is a clip rectangle set on the destination (set via<br/>		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>		/// of the clip rectangle and `rect`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			int ret = SDLFillRectsNative(dst, rects, count, color);
			return ret;
		}

		/// <summary>		/// Perform a fast fill of a set of rectangles with a specific color.<br/>		/// `color` should be a pixel of the format used by the surface, and can be<br/>		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>		/// alpha component then the destination is simply filled with that alpha<br/>		/// information, no blending takes place.<br/>		/// If there is a clip rectangle set on the destination (set via<br/>		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>		/// of the clip rectangle and `rect`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLFillRectsNative((SDLSurface*)pdst, rects, count, color);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast fill of a set of rectangles with a specific color.<br/>		/// `color` should be a pixel of the format used by the surface, and can be<br/>		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>		/// alpha component then the destination is simply filled with that alpha<br/>		/// information, no blending takes place.<br/>		/// If there is a clip rectangle set on the destination (set via<br/>		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>		/// of the clip rectangle and `rect`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLRect* prects = &rects)
			{
				int ret = SDLFillRectsNative(dst, (SDLRect*)prects, count, color);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast fill of a set of rectangles with a specific color.<br/>		/// `color` should be a pixel of the format used by the surface, and can be<br/>		/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>		/// alpha component then the destination is simply filled with that alpha<br/>		/// information, no blending takes place.<br/>		/// If there is a clip rectangle set on the destination (set via<br/>		/// SDL_SetClipRect()), then this function will fill based on the intersection<br/>		/// of the clip rectangle and `rect`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFillRects([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "Uint32")] uint color)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* prects = &rects)
				{
					int ret = SDLFillRectsNative((SDLSurface*)pdst, (SDLRect*)prects, count, color);
					return ret;
				}
			}
		}

		/// <summary>
		/// Perform a fast blit from the source surface to the destination surface.<br/>
		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>
		/// macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UpperBlit")]
		internal static extern int SDLUpperBlitNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect);

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLUpperBlitNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				int ret = SDLUpperBlitNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLUpperBlitNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLUpperBlitNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLUpperBlitNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLUpperBlitNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLUpperBlitNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						int ret = SDLUpperBlitNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLUpperBlitNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLUpperBlitNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLUpperBlitNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLUpperBlitNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a fast blit from the source surface to the destination surface.<br/>		/// SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a<br/>		/// macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = SDLUpperBlitNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface blitting only.<br/>
		/// This is a semi-private blit function and it performs low-level surface<br/>
		/// blitting, assuming the input rectangles have already been clipped.<br/>
		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LowerBlit")]
		internal static extern int SDLLowerBlitNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect);

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLLowerBlitNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				int ret = SDLLowerBlitNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLLowerBlitNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLLowerBlitNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLLowerBlitNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLLowerBlitNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLLowerBlitNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						int ret = SDLLowerBlitNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLLowerBlitNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLLowerBlitNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLLowerBlitNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLLowerBlitNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform low-level surface blitting only.<br/>		/// This is a semi-private blit function and it performs low-level surface<br/>		/// blitting, assuming the input rectangles have already been clipped.<br/>		/// Unless you know what you're doing, you should be using SDL_BlitSurface()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlit([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = SDLLowerBlitNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>
		/// format.<br/>
		/// Please use SDL_BlitScaled() instead.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SoftStretch")]
		internal static extern int SDLSoftStretchNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect);

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLSoftStretchNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				int ret = SDLSoftStretchNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLSoftStretchNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLSoftStretchNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLSoftStretchNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLSoftStretchNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLSoftStretchNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						int ret = SDLSoftStretchNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLSoftStretchNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLSoftStretchNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLSoftStretchNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLSoftStretchNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a fast, low quality, stretch blit between two surfaces of the same<br/>		/// format.<br/>		/// Please use SDL_BlitScaled() instead.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretch")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretch([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = SDLSoftStretchNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SoftStretchLinear")]
		internal static extern int SDLSoftStretchLinearNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect);

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLSoftStretchLinearNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				int ret = SDLSoftStretchLinearNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLSoftStretchLinearNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLSoftStretchLinearNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLSoftStretchLinearNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLSoftStretchLinearNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLSoftStretchLinearNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						int ret = SDLSoftStretchLinearNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLSoftStretchLinearNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchLinearNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchLinearNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLSoftStretchLinearNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLSoftStretchLinearNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLSoftStretchLinearNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLSoftStretchLinearNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform bilinear scaling between two surfaces of the same format, 32BPP.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SoftStretchLinear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSoftStretchLinear([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = SDLSoftStretchLinearNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform a scaled surface copy to a destination surface.<br/>
		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>
		/// merely a macro for this function with a less confusing name.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UpperBlitScaled")]
		internal static extern int SDLUpperBlitScaledNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect);

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLUpperBlitScaledNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				int ret = SDLUpperBlitScaledNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLUpperBlitScaledNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLUpperBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLUpperBlitScaledNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLUpperBlitScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLUpperBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						int ret = SDLUpperBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLUpperBlitScaledNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitScaledNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitScaledNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLUpperBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLUpperBlitScaledNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLUpperBlitScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLUpperBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform a scaled surface copy to a destination surface.<br/>		/// SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is<br/>		/// merely a macro for this function with a less confusing name.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpperBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpperBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = SDLUpperBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Perform low-level surface scaled blitting only.<br/>
		/// This is a semi-private function and it performs low-level surface blitting,<br/>
		/// assuming the input rectangles have already been clipped.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LowerBlitScaled")]
		internal static extern int SDLLowerBlitScaledNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect);

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLLowerBlitScaledNative(src, srcrect, dst, dstrect);
			return ret;
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				int ret = SDLLowerBlitScaledNative((SDLSurface*)psrc, srcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLLowerBlitScaledNative(src, (SDLRect*)psrcrect, dst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLLowerBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				int ret = SDLLowerBlitScaledNative(src, srcrect, (SDLSurface*)pdst, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLLowerBlitScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					int ret = SDLLowerBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						int ret = SDLLowerBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLLowerBlitScaledNative(src, srcrect, dst, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitScaledNative((SDLSurface*)psrc, srcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitScaledNative(src, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLLowerBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, dst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* pdst = &dst)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLLowerBlitScaledNative(src, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLLowerBlitScaledNative((SDLSurface*)psrc, srcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLSurface* pdst = &dst)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLLowerBlitScaledNative(src, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Perform low-level surface scaled blitting only.<br/>		/// This is a semi-private function and it performs low-level surface blitting,<br/>		/// assuming the input rectangles have already been clipped.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LowerBlitScaled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLowerBlitScaled([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface src, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface dst, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLSurface* psrc = &src)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLSurface* pdst = &dst)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = SDLLowerBlitScaledNative((SDLSurface*)psrc, (SDLRect*)psrcrect, (SDLSurface*)pdst, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set the YUV conversion mode<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetYUVConversionMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetYUVConversionMode")]
		internal static extern void SDLSetYUVConversionModeNative([NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")] SdL_YUV_Conversion_Mode mode);

		/// <summary>		/// Set the YUV conversion mode<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetYUVConversionMode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetYUVConversionMode([NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")] SdL_YUV_Conversion_Mode mode)
		{
			SDLSetYUVConversionModeNative(mode);
		}

		/// <summary>
		/// Get the YUV conversion mode<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetYUVConversionMode")]
		[return: NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetYUVConversionMode")]
		internal static extern SdL_YUV_Conversion_Mode SDLGetYUVConversionModeNative();

		/// <summary>		/// Get the YUV conversion mode<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetYUVConversionMode")]
		[return: NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")]
		public static SdL_YUV_Conversion_Mode SDLGetYUVConversionMode()
		{
			SdL_YUV_Conversion_Mode ret = SDLGetYUVConversionModeNative();
			return ret;
		}

		/// <summary>
		/// Get the YUV conversion mode, returning the correct mode for the resolution<br/>
		/// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetYUVConversionModeForResolution")]
		[return: NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetYUVConversionModeForResolution")]
		internal static extern SdL_YUV_Conversion_Mode SDLGetYUVConversionModeForResolutionNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height);

		/// <summary>		/// Get the YUV conversion mode, returning the correct mode for the resolution<br/>		/// when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetYUVConversionModeForResolution")]
		[return: NativeName(NativeNameType.Type, "SDL_YUV_CONVERSION_MODE")]
		public static SdL_YUV_Conversion_Mode SDLGetYUVConversionModeForResolution([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			SdL_YUV_Conversion_Mode ret = SDLGetYUVConversionModeForResolutionNative(width, height);
			return ret;
		}

		/// <summary>
		/// Get the number of video drivers compiled into SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumVideoDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetNumVideoDrivers")]
		internal static extern int SDLGetNumVideoDriversNative();

		/// <summary>		/// Get the number of video drivers compiled into SDL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumVideoDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumVideoDrivers()
		{
			int ret = SDLGetNumVideoDriversNative();
			return ret;
		}

		/// <summary>
		/// Get the name of a built in video driver.<br/>
		/// The video drivers are presented in the order in which they are normally<br/>
		/// checked during initialization.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetVideoDriver")]
		internal static extern byte* SDLGetVideoDriverNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index);

		/// <summary>		/// Get the name of a built in video driver.<br/>		/// The video drivers are presented in the order in which they are normally<br/>		/// checked during initialization.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetVideoDriver([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = SDLGetVideoDriverNative(index);
			return ret;
		}

		/// <summary>		/// Get the name of a built in video driver.<br/>		/// The video drivers are presented in the order in which they are normally<br/>		/// checked during initialization.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetVideoDriverS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetVideoDriverNative(index));
			return ret;
		}

		/// <summary>
		/// Initialize the video subsystem, optionally specifying a video driver.<br/>
		/// This function initializes the video subsystem, setting up a connection to<br/>
		/// the window manager, etc, and determines the available display modes and<br/>
		/// pixel formats, but does not initialize a window or graphics mode.<br/>
		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>
		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>
		/// before calling SDL_Quit().<br/>
		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>
		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>
		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>
		/// specific `driver_name`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_VideoInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_VideoInit")]
		internal static extern int SDLVideoInitNative([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName);

		/// <summary>		/// Initialize the video subsystem, optionally specifying a video driver.<br/>		/// This function initializes the video subsystem, setting up a connection to<br/>		/// the window manager, etc, and determines the available display modes and<br/>		/// pixel formats, but does not initialize a window or graphics mode.<br/>		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>		/// before calling SDL_Quit().<br/>		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>		/// specific `driver_name`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_VideoInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVideoInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] byte* driverName)
		{
			int ret = SDLVideoInitNative(driverName);
			return ret;
		}

		/// <summary>		/// Initialize the video subsystem, optionally specifying a video driver.<br/>		/// This function initializes the video subsystem, setting up a connection to<br/>		/// the window manager, etc, and determines the available display modes and<br/>		/// pixel formats, but does not initialize a window or graphics mode.<br/>		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>		/// before calling SDL_Quit().<br/>		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>		/// specific `driver_name`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_VideoInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVideoInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] ref byte driverName)
		{
			fixed (byte* pdriverName = &driverName)
			{
				int ret = SDLVideoInitNative((byte*)pdriverName);
				return ret;
			}
		}

		/// <summary>		/// Initialize the video subsystem, optionally specifying a video driver.<br/>		/// This function initializes the video subsystem, setting up a connection to<br/>		/// the window manager, etc, and determines the available display modes and<br/>		/// pixel formats, but does not initialize a window or graphics mode.<br/>		/// If you use this function and you haven't used the SDL_INIT_VIDEO flag with<br/>		/// either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()<br/>		/// before calling SDL_Quit().<br/>		/// It is safe to call this function multiple times. SDL_VideoInit() will call<br/>		/// SDL_VideoQuit() itself if the video subsystem has already been initialized.<br/>		/// You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a<br/>		/// specific `driver_name`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_VideoInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLVideoInit([NativeName(NativeNameType.Param, "driver_name")] [NativeName(NativeNameType.Type, "const char*")] string driverName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (driverName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(driverName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(driverName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLVideoInitNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Shut down the video subsystem, if initialized with SDL_VideoInit().<br/>
		/// This function closes all windows, and restores the original video mode.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_VideoQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_VideoQuit")]
		internal static extern void SDLVideoQuitNative();

		/// <summary>		/// Shut down the video subsystem, if initialized with SDL_VideoInit().<br/>		/// This function closes all windows, and restores the original video mode.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_VideoQuit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLVideoQuit()
		{
			SDLVideoQuitNative();
		}

		/// <summary>
		/// Get the name of the currently initialized video driver.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetCurrentVideoDriver")]
		internal static extern byte* SDLGetCurrentVideoDriverNative();

		/// <summary>		/// Get the name of the currently initialized video driver.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetCurrentVideoDriver()
		{
			byte* ret = SDLGetCurrentVideoDriverNative();
			return ret;
		}

		/// <summary>		/// Get the name of the currently initialized video driver.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentVideoDriver")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetCurrentVideoDriverS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetCurrentVideoDriverNative());
			return ret;
		}

		/// <summary>
		/// Get the number of available video displays.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumVideoDisplays")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetNumVideoDisplays")]
		internal static extern int SDLGetNumVideoDisplaysNative();

		/// <summary>		/// Get the number of available video displays.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumVideoDisplays")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumVideoDisplays()
		{
			int ret = SDLGetNumVideoDisplaysNative();
			return ret;
		}

		/// <summary>
		/// Get the name of a display in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDisplayName")]
		internal static extern byte* SDLGetDisplayNameNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex);

		/// <summary>		/// Get the name of a display in UTF-8 encoding.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetDisplayName([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex)
		{
			byte* ret = SDLGetDisplayNameNative(displayIndex);
			return ret;
		}

		/// <summary>		/// Get the name of a display in UTF-8 encoding.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetDisplayNameS([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetDisplayNameNative(displayIndex));
			return ret;
		}

		/// <summary>
		/// Get the desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDisplayBounds")]
		internal static extern int SDLGetDisplayBoundsNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Get the desktop area represented by a display.<br/>		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayBounds([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLGetDisplayBoundsNative(displayIndex, rect);
			return ret;
		}

		/// <summary>		/// Get the desktop area represented by a display.<br/>		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayBounds([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLGetDisplayBoundsNative(displayIndex, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Get the usable desktop area represented by a display.<br/>
		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>
		/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>
		/// reserved by the system removed. For example, on Apple's macOS, this<br/>
		/// subtracts the area occupied by the menu bar and dock.<br/>
		/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>
		/// so these are good guidelines for the maximum space available to a<br/>
		/// non-fullscreen window.<br/>
		/// The parameter `rect` is ignored if it is NULL.<br/>
		/// This function also returns -1 if the parameter `displayIndex` is out of<br/>
		/// range.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayUsableBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDisplayUsableBounds")]
		internal static extern int SDLGetDisplayUsableBoundsNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Get the usable desktop area represented by a display.<br/>		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>		/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>		/// reserved by the system removed. For example, on Apple's macOS, this<br/>		/// subtracts the area occupied by the menu bar and dock.<br/>		/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>		/// so these are good guidelines for the maximum space available to a<br/>		/// non-fullscreen window.<br/>		/// The parameter `rect` is ignored if it is NULL.<br/>		/// This function also returns -1 if the parameter `displayIndex` is out of<br/>		/// range.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayUsableBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayUsableBounds([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLGetDisplayUsableBoundsNative(displayIndex, rect);
			return ret;
		}

		/// <summary>		/// Get the usable desktop area represented by a display.<br/>		/// The primary display (`displayIndex` zero) is always located at 0,0.<br/>		/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>		/// reserved by the system removed. For example, on Apple's macOS, this<br/>		/// subtracts the area occupied by the menu bar and dock.<br/>		/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>		/// so these are good guidelines for the maximum space available to a<br/>		/// non-fullscreen window.<br/>		/// The parameter `rect` is ignored if it is NULL.<br/>		/// This function also returns -1 if the parameter `displayIndex` is out of<br/>		/// range.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayUsableBounds")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayUsableBounds([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLGetDisplayUsableBoundsNative(displayIndex, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Get the dots/pixels-per-inch for a display.<br/>
		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>
		/// appropriate parameter is non-NULL.<br/>
		/// A failure of this function usually means that either no DPI information is<br/>
		/// available or the `displayIndex` is out of range.<br/>
		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>
		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>
		/// find the window size, which might be in logical points instead of pixels,<br/>
		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>
		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>
		/// the two values to get an actual scaling value between the two. We will be<br/>
		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>
		/// more consistent, reliable, and clear.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDisplayDPI")]
		internal static extern int SDLGetDisplayDPINative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi);

		/// <summary>		/// Get the dots/pixels-per-inch for a display.<br/>		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>		/// appropriate parameter is non-NULL.<br/>		/// A failure of this function usually means that either no DPI information is<br/>		/// available or the `displayIndex` is out of range.<br/>		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>		/// find the window size, which might be in logical points instead of pixels,<br/>		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>		/// the two values to get an actual scaling value between the two. We will be<br/>		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>		/// more consistent, reliable, and clear.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi)
		{
			int ret = SDLGetDisplayDPINative(displayIndex, ddpi, hdpi, vdpi);
			return ret;
		}

		/// <summary>		/// Get the dots/pixels-per-inch for a display.<br/>		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>		/// appropriate parameter is non-NULL.<br/>		/// A failure of this function usually means that either no DPI information is<br/>		/// available or the `displayIndex` is out of range.<br/>		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>		/// find the window size, which might be in logical points instead of pixels,<br/>		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>		/// the two values to get an actual scaling value between the two. We will be<br/>		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>		/// more consistent, reliable, and clear.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] ref float ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				int ret = SDLGetDisplayDPINative(displayIndex, (float*)pddpi, hdpi, vdpi);
				return ret;
			}
		}

		/// <summary>		/// Get the dots/pixels-per-inch for a display.<br/>		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>		/// appropriate parameter is non-NULL.<br/>		/// A failure of this function usually means that either no DPI information is<br/>		/// available or the `displayIndex` is out of range.<br/>		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>		/// find the window size, which might be in logical points instead of pixels,<br/>		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>		/// the two values to get an actual scaling value between the two. We will be<br/>		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>		/// more consistent, reliable, and clear.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] ref float hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi)
		{
			fixed (float* phdpi = &hdpi)
			{
				int ret = SDLGetDisplayDPINative(displayIndex, ddpi, (float*)phdpi, vdpi);
				return ret;
			}
		}

		/// <summary>		/// Get the dots/pixels-per-inch for a display.<br/>		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>		/// appropriate parameter is non-NULL.<br/>		/// A failure of this function usually means that either no DPI information is<br/>		/// available or the `displayIndex` is out of range.<br/>		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>		/// find the window size, which might be in logical points instead of pixels,<br/>		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>		/// the two values to get an actual scaling value between the two. We will be<br/>		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>		/// more consistent, reliable, and clear.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] ref float ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] ref float hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] float* vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				fixed (float* phdpi = &hdpi)
				{
					int ret = SDLGetDisplayDPINative(displayIndex, (float*)pddpi, (float*)phdpi, vdpi);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the dots/pixels-per-inch for a display.<br/>		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>		/// appropriate parameter is non-NULL.<br/>		/// A failure of this function usually means that either no DPI information is<br/>		/// available or the `displayIndex` is out of range.<br/>		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>		/// find the window size, which might be in logical points instead of pixels,<br/>		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>		/// the two values to get an actual scaling value between the two. We will be<br/>		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>		/// more consistent, reliable, and clear.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] ref float vdpi)
		{
			fixed (float* pvdpi = &vdpi)
			{
				int ret = SDLGetDisplayDPINative(displayIndex, ddpi, hdpi, (float*)pvdpi);
				return ret;
			}
		}

		/// <summary>		/// Get the dots/pixels-per-inch for a display.<br/>		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>		/// appropriate parameter is non-NULL.<br/>		/// A failure of this function usually means that either no DPI information is<br/>		/// available or the `displayIndex` is out of range.<br/>		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>		/// find the window size, which might be in logical points instead of pixels,<br/>		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>		/// the two values to get an actual scaling value between the two. We will be<br/>		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>		/// more consistent, reliable, and clear.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] ref float ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] float* hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] ref float vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				fixed (float* pvdpi = &vdpi)
				{
					int ret = SDLGetDisplayDPINative(displayIndex, (float*)pddpi, hdpi, (float*)pvdpi);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the dots/pixels-per-inch for a display.<br/>		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>		/// appropriate parameter is non-NULL.<br/>		/// A failure of this function usually means that either no DPI information is<br/>		/// available or the `displayIndex` is out of range.<br/>		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>		/// find the window size, which might be in logical points instead of pixels,<br/>		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>		/// the two values to get an actual scaling value between the two. We will be<br/>		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>		/// more consistent, reliable, and clear.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] float* ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] ref float hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] ref float vdpi)
		{
			fixed (float* phdpi = &hdpi)
			{
				fixed (float* pvdpi = &vdpi)
				{
					int ret = SDLGetDisplayDPINative(displayIndex, ddpi, (float*)phdpi, (float*)pvdpi);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the dots/pixels-per-inch for a display.<br/>		/// Diagonal, horizontal and vertical DPI can all be optionally returned if the<br/>		/// appropriate parameter is non-NULL.<br/>		/// A failure of this function usually means that either no DPI information is<br/>		/// available or the `displayIndex` is out of range.<br/>		/// **WARNING**: This reports the DPI that the hardware reports, and it is not<br/>		/// always reliable! It is almost always better to use SDL_GetWindowSize() to<br/>		/// find the window size, which might be in logical points instead of pixels,<br/>		/// and then SDL_GL_GetDrawableSize(), SDL_Vulkan_GetDrawableSize(),<br/>		/// SDL_Metal_GetDrawableSize(), or SDL_GetRendererOutputSize(), and compare<br/>		/// the two values to get an actual scaling value between the two. We will be<br/>		/// rethinking how high-dpi details should be managed in SDL3 to make things<br/>		/// more consistent, reliable, and clear.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayDPI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayDPI([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "ddpi")] [NativeName(NativeNameType.Type, "float*")] ref float ddpi, [NativeName(NativeNameType.Param, "hdpi")] [NativeName(NativeNameType.Type, "float*")] ref float hdpi, [NativeName(NativeNameType.Param, "vdpi")] [NativeName(NativeNameType.Type, "float*")] ref float vdpi)
		{
			fixed (float* pddpi = &ddpi)
			{
				fixed (float* phdpi = &hdpi)
				{
					fixed (float* pvdpi = &vdpi)
					{
						int ret = SDLGetDisplayDPINative(displayIndex, (float*)pddpi, (float*)phdpi, (float*)pvdpi);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the orientation of a display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayOrientation")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayOrientation")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDisplayOrientation")]
		internal static extern SDLDisplayOrientation SDLGetDisplayOrientationNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex);

		/// <summary>		/// Get the orientation of a display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayOrientation")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayOrientation")]
		public static SDLDisplayOrientation SDLGetDisplayOrientation([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex)
		{
			SDLDisplayOrientation ret = SDLGetDisplayOrientationNative(displayIndex);
			return ret;
		}

		/// <summary>
		/// Get the number of available display modes.<br/>
		/// The `displayIndex` needs to be in the range from 0 to<br/>
		/// SDL_GetNumVideoDisplays() - 1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumDisplayModes")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetNumDisplayModes")]
		internal static extern int SDLGetNumDisplayModesNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex);

		/// <summary>		/// Get the number of available display modes.<br/>		/// The `displayIndex` needs to be in the range from 0 to<br/>		/// SDL_GetNumVideoDisplays() - 1.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumDisplayModes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumDisplayModes([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex)
		{
			int ret = SDLGetNumDisplayModesNative(displayIndex);
			return ret;
		}

		/// <summary>
		/// Get information about a specific display mode.<br/>
		/// The display modes are sorted in this priority:<br/>
		/// - width -> largest to smallest<br/>
		/// - height -> largest to smallest<br/>
		/// - bits per pixel -> more colors to fewer colors<br/>
		/// - packed pixel layout -> largest to smallest<br/>
		/// - refresh rate -> highest to lowest<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDisplayMode")]
		internal static extern int SDLGetDisplayModeNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "modeIndex")] [NativeName(NativeNameType.Type, "int")] int modeIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode);

		/// <summary>		/// Get information about a specific display mode.<br/>		/// The display modes are sorted in this priority:<br/>		/// - width -> largest to smallest<br/>		/// - height -> largest to smallest<br/>		/// - bits per pixel -> more colors to fewer colors<br/>		/// - packed pixel layout -> largest to smallest<br/>		/// - refresh rate -> highest to lowest<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "modeIndex")] [NativeName(NativeNameType.Type, "int")] int modeIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			int ret = SDLGetDisplayModeNative(displayIndex, modeIndex, mode);
			return ret;
		}

		/// <summary>		/// Get information about a specific display mode.<br/>		/// The display modes are sorted in this priority:<br/>		/// - width -> largest to smallest<br/>		/// - height -> largest to smallest<br/>		/// - bits per pixel -> more colors to fewer colors<br/>		/// - packed pixel layout -> largest to smallest<br/>		/// - refresh rate -> highest to lowest<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "modeIndex")] [NativeName(NativeNameType.Type, "int")] int modeIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = SDLGetDisplayModeNative(displayIndex, modeIndex, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Get information about the desktop's display mode.<br/>
		/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the previous native display mode, and not the current<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDesktopDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDesktopDisplayMode")]
		internal static extern int SDLGetDesktopDisplayModeNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode);

		/// <summary>		/// Get information about the desktop's display mode.<br/>		/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>		/// function will return the previous native display mode, and not the current<br/>		/// display mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDesktopDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDesktopDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			int ret = SDLGetDesktopDisplayModeNative(displayIndex, mode);
			return ret;
		}

		/// <summary>		/// Get information about the desktop's display mode.<br/>		/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>		/// function will return the previous native display mode, and not the current<br/>		/// display mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDesktopDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetDesktopDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = SDLGetDesktopDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Get information about the current display mode.<br/>
		/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>
		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
		/// function will return the current display mode, and not the previous native<br/>
		/// display mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCurrentDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetCurrentDisplayMode")]
		internal static extern int SDLGetCurrentDisplayModeNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode);

		/// <summary>		/// Get information about the current display mode.<br/>		/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>		/// function will return the current display mode, and not the previous native<br/>		/// display mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetCurrentDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			int ret = SDLGetCurrentDisplayModeNative(displayIndex, mode);
			return ret;
		}

		/// <summary>		/// Get information about the current display mode.<br/>		/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>		/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>		/// function will return the current display mode, and not the previous native<br/>		/// display mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCurrentDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetCurrentDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = SDLGetCurrentDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// Get the closest match to the requested display mode.<br/>
		/// The available display modes are scanned and `closest` is filled in with the<br/>
		/// closest mode matching the requested mode and returned. The mode format and<br/>
		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>
		/// are scanned with size being first priority, format being second priority,<br/>
		/// and finally checking the refresh rate. If all the available modes are too<br/>
		/// small, then NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetClosestDisplayMode")]
		internal static extern SDLDisplayMode* SDLGetClosestDisplayModeNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* closest);

		/// <summary>		/// Get the closest match to the requested display mode.<br/>		/// The available display modes are scanned and `closest` is filled in with the<br/>		/// closest mode matching the requested mode and returned. The mode format and<br/>		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>		/// are scanned with size being first priority, format being second priority,<br/>		/// and finally checking the refresh rate. If all the available modes are too<br/>		/// small, then NULL is returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		public static SDLDisplayMode* SDLGetClosestDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* closest)
		{
			SDLDisplayMode* ret = SDLGetClosestDisplayModeNative(displayIndex, mode, closest);
			return ret;
		}

		/// <summary>		/// Get the closest match to the requested display mode.<br/>		/// The available display modes are scanned and `closest` is filled in with the<br/>		/// closest mode matching the requested mode and returned. The mode format and<br/>		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>		/// are scanned with size being first priority, format being second priority,<br/>		/// and finally checking the refresh rate. If all the available modes are too<br/>		/// small, then NULL is returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		public static SDLDisplayMode* SDLGetClosestDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] ref SDLDisplayMode mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* closest)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				SDLDisplayMode* ret = SDLGetClosestDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode, closest);
				return ret;
			}
		}

		/// <summary>		/// Get the closest match to the requested display mode.<br/>		/// The available display modes are scanned and `closest` is filled in with the<br/>		/// closest mode matching the requested mode and returned. The mode format and<br/>		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>		/// are scanned with size being first priority, format being second priority,<br/>		/// and finally checking the refresh rate. If all the available modes are too<br/>		/// small, then NULL is returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		public static SDLDisplayMode* SDLGetClosestDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode closest)
		{
			fixed (SDLDisplayMode* pclosest = &closest)
			{
				SDLDisplayMode* ret = SDLGetClosestDisplayModeNative(displayIndex, mode, (SDLDisplayMode*)pclosest);
				return ret;
			}
		}

		/// <summary>		/// Get the closest match to the requested display mode.<br/>		/// The available display modes are scanned and `closest` is filled in with the<br/>		/// closest mode matching the requested mode and returned. The mode format and<br/>		/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>		/// are scanned with size being first priority, format being second priority,<br/>		/// and finally checking the refresh rate. If all the available modes are too<br/>		/// small, then NULL is returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetClosestDisplayMode")]
		[return: NativeName(NativeNameType.Type, "SDL_DisplayMode*")]
		public static SDLDisplayMode* SDLGetClosestDisplayMode([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] ref SDLDisplayMode mode, [NativeName(NativeNameType.Param, "closest")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode closest)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				fixed (SDLDisplayMode* pclosest = &closest)
				{
					SDLDisplayMode* ret = SDLGetClosestDisplayModeNative(displayIndex, (SDLDisplayMode*)pmode, (SDLDisplayMode*)pclosest);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the index of the display containing a point<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPointDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetPointDisplayIndex")]
		internal static extern int SDLGetPointDisplayIndexNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* point);

		/// <summary>		/// Get the index of the display containing a point<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPointDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetPointDisplayIndex([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* point)
		{
			int ret = SDLGetPointDisplayIndexNative(point);
			return ret;
		}

		/// <summary>		/// Get the index of the display containing a point<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPointDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetPointDisplayIndex([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint point)
		{
			fixed (SDLPoint* ppoint = &point)
			{
				int ret = SDLGetPointDisplayIndexNative((SDLPoint*)ppoint);
				return ret;
			}
		}

		/// <summary>
		/// Get the index of the display primarily containing a rect<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRectDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRectDisplayIndex")]
		internal static extern int SDLGetRectDisplayIndexNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Get the index of the display primarily containing a rect<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRectDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRectDisplayIndex([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLGetRectDisplayIndexNative(rect);
			return ret;
		}

		/// <summary>		/// Get the index of the display primarily containing a rect<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRectDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRectDisplayIndex([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLGetRectDisplayIndexNative((SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>
		/// Get the index of the display associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowDisplayIndex")]
		internal static extern int SDLGetWindowDisplayIndexNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get the index of the display associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowDisplayIndex([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			int ret = SDLGetWindowDisplayIndexNative(window);
			return ret;
		}

		/// <summary>		/// Get the index of the display associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowDisplayIndex([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLGetWindowDisplayIndexNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the display mode to use when a window is visible at fullscreen.<br/>
		/// This only affects the display mode used when the window is fullscreen. To<br/>
		/// change the window size when the window is not fullscreen, use<br/>
		/// SDL_SetWindowSize().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowDisplayMode")]
		internal static extern int SDLSetWindowDisplayModeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode);

		/// <summary>		/// Set the display mode to use when a window is visible at fullscreen.<br/>		/// This only affects the display mode used when the window is fullscreen. To<br/>		/// change the window size when the window is not fullscreen, use<br/>		/// SDL_SetWindowSize().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowDisplayMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			int ret = SDLSetWindowDisplayModeNative(window, mode);
			return ret;
		}

		/// <summary>		/// Set the display mode to use when a window is visible at fullscreen.<br/>		/// This only affects the display mode used when the window is fullscreen. To<br/>		/// change the window size when the window is not fullscreen, use<br/>		/// SDL_SetWindowSize().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowDisplayMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowDisplayModeNative((SDLWindow*)pwindow, mode);
				return ret;
			}
		}

		/// <summary>		/// Set the display mode to use when a window is visible at fullscreen.<br/>		/// This only affects the display mode used when the window is fullscreen. To<br/>		/// change the window size when the window is not fullscreen, use<br/>		/// SDL_SetWindowSize().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowDisplayMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = SDLSetWindowDisplayModeNative(window, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>		/// Set the display mode to use when a window is visible at fullscreen.<br/>		/// This only affects the display mode used when the window is fullscreen. To<br/>		/// change the window size when the window is not fullscreen, use<br/>		/// SDL_SetWindowSize().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowDisplayMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "const SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDisplayMode* pmode = &mode)
				{
					int ret = SDLSetWindowDisplayModeNative((SDLWindow*)pwindow, (SDLDisplayMode*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the display mode to use when a window is visible at fullscreen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowDisplayMode")]
		internal static extern int SDLGetWindowDisplayModeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode);

		/// <summary>		/// Query the display mode to use when a window is visible at fullscreen.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowDisplayMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			int ret = SDLGetWindowDisplayModeNative(window, mode);
			return ret;
		}

		/// <summary>		/// Query the display mode to use when a window is visible at fullscreen.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowDisplayMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] SDLDisplayMode* mode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLGetWindowDisplayModeNative((SDLWindow*)pwindow, mode);
				return ret;
			}
		}

		/// <summary>		/// Query the display mode to use when a window is visible at fullscreen.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowDisplayMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLDisplayMode* pmode = &mode)
			{
				int ret = SDLGetWindowDisplayModeNative(window, (SDLDisplayMode*)pmode);
				return ret;
			}
		}

		/// <summary>		/// Query the display mode to use when a window is visible at fullscreen.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowDisplayMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowDisplayMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "mode")] [NativeName(NativeNameType.Type, "SDL_DisplayMode*")] ref SDLDisplayMode mode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLDisplayMode* pmode = &mode)
				{
					int ret = SDLGetWindowDisplayModeNative((SDLWindow*)pwindow, (SDLDisplayMode*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the raw ICC profile data for the screen the window is currently on.<br/>
		/// Data returned should be freed with SDL_free.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowICCProfile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowICCProfile")]
		internal static extern void* SDLGetWindowICCProfileNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t*")] nuint* size);

		/// <summary>		/// Get the raw ICC profile data for the screen the window is currently on.<br/>		/// Data returned should be freed with SDL_free.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowICCProfile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowICCProfile([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t*")] nuint* size)
		{
			void* ret = SDLGetWindowICCProfileNative(window, size);
			return ret;
		}

		/// <summary>		/// Get the raw ICC profile data for the screen the window is currently on.<br/>		/// Data returned should be freed with SDL_free.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowICCProfile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowICCProfile([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t*")] nuint* size)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = SDLGetWindowICCProfileNative((SDLWindow*)pwindow, size);
				return ret;
			}
		}

		/// <summary>		/// Get the raw ICC profile data for the screen the window is currently on.<br/>		/// Data returned should be freed with SDL_free.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowICCProfile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowICCProfile([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				void* ret = SDLGetWindowICCProfileNative(window, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>		/// Get the raw ICC profile data for the screen the window is currently on.<br/>		/// Data returned should be freed with SDL_free.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowICCProfile")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowICCProfile([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t*")] ref nuint size)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (nuint* psize = &size)
				{
					void* ret = SDLGetWindowICCProfileNative((SDLWindow*)pwindow, (nuint*)psize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the pixel format associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowPixelFormat")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowPixelFormat")]
		internal static extern uint SDLGetWindowPixelFormatNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get the pixel format associated with the window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPixelFormat")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetWindowPixelFormat([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			uint ret = SDLGetWindowPixelFormatNative(window);
			return ret;
		}

		/// <summary>		/// Get the pixel format associated with the window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPixelFormat")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetWindowPixelFormat([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				uint ret = SDLGetWindowPixelFormatNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Create a window with the specified position, dimensions, and flags.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window<br/>
		/// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution<br/>
		/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>
		/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>
		/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>
		/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>
		/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>
		/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>
		/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>
		/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>
		/// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus<br/>
		/// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if<br/>
		/// supported (>= SDL 2.0.1)<br/>
		/// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is<br/>
		/// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be<br/>
		/// queried later using SDL_GetWindowFlags().<br/>
		/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>
		/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>
		/// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size<br/>
		/// in pixels may differ from its size in screen coordinates on platforms with<br/>
		/// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the<br/>
		/// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that<br/>
		/// when this flag is set, the drawable size can vary after the window is<br/>
		/// created and should be queried after major window events such as when the<br/>
		/// window is resized or moved between displays.<br/>
		/// If the window is set fullscreen, the width and height parameters `w` and<br/>
		/// `h` will not be used. However, invalid size parameters (e.g. too large) may<br/>
		/// still fail. Window size is actually limited to 16384 x 16384 for all<br/>
		/// platforms at window creation.<br/>
		/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>
		/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>
		/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>
		/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>
		/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>
		/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>
		/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>
		/// SDL_CreateWindow() will fail.<br/>
		/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>
		/// loader or link to a dynamic library version. This limitation may be removed<br/>
		/// in a future version of SDL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateWindow")]
		internal static extern SDLWindow* SDLCreateWindowNative([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Create a window with the specified position, dimensions, and flags.<br/>		/// `flags` may be any of the following OR'd together:<br/>		/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window<br/>		/// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution<br/>		/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>		/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>		/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>		/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>		/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>		/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>		/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>		/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>		/// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus<br/>		/// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if<br/>		/// supported (>= SDL 2.0.1)<br/>		/// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is<br/>		/// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be<br/>		/// queried later using SDL_GetWindowFlags().<br/>		/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>		/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>		/// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size<br/>		/// in pixels may differ from its size in screen coordinates on platforms with<br/>		/// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the<br/>		/// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or<br/>		/// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that<br/>		/// when this flag is set, the drawable size can vary after the window is<br/>		/// created and should be queried after major window events such as when the<br/>		/// window is resized or moved between displays.<br/>		/// If the window is set fullscreen, the width and height parameters `w` and<br/>		/// `h` will not be used. However, invalid size parameters (e.g. too large) may<br/>		/// still fail. Window size is actually limited to 16384 x 16384 for all<br/>		/// platforms at window creation.<br/>		/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>		/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>		/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>		/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>		/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>		/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>		/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>		/// SDL_CreateWindow() will fail.<br/>		/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>		/// loader or link to a dynamic library version. This limitation may be removed<br/>		/// in a future version of SDL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLCreateWindow([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			SDLWindow* ret = SDLCreateWindowNative(title, x, y, w, h, flags);
			return ret;
		}

		/// <summary>		/// Create a window with the specified position, dimensions, and flags.<br/>		/// `flags` may be any of the following OR'd together:<br/>		/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window<br/>		/// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution<br/>		/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>		/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>		/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>		/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>		/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>		/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>		/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>		/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>		/// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus<br/>		/// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if<br/>		/// supported (>= SDL 2.0.1)<br/>		/// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is<br/>		/// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be<br/>		/// queried later using SDL_GetWindowFlags().<br/>		/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>		/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>		/// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size<br/>		/// in pixels may differ from its size in screen coordinates on platforms with<br/>		/// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the<br/>		/// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or<br/>		/// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that<br/>		/// when this flag is set, the drawable size can vary after the window is<br/>		/// created and should be queried after major window events such as when the<br/>		/// window is resized or moved between displays.<br/>		/// If the window is set fullscreen, the width and height parameters `w` and<br/>		/// `h` will not be used. However, invalid size parameters (e.g. too large) may<br/>		/// still fail. Window size is actually limited to 16384 x 16384 for all<br/>		/// platforms at window creation.<br/>		/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>		/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>		/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>		/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>		/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>		/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>		/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>		/// SDL_CreateWindow() will fail.<br/>		/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>		/// loader or link to a dynamic library version. This limitation may be removed<br/>		/// in a future version of SDL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLCreateWindow([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] ref byte title, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			fixed (byte* ptitle = &title)
			{
				SDLWindow* ret = SDLCreateWindowNative((byte*)ptitle, x, y, w, h, flags);
				return ret;
			}
		}

		/// <summary>		/// Create a window with the specified position, dimensions, and flags.<br/>		/// `flags` may be any of the following OR'd together:<br/>		/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window<br/>		/// - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution<br/>		/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>		/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>		/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>		/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>		/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>		/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>		/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>		/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>		/// - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus<br/>		/// - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if<br/>		/// supported (>= SDL 2.0.1)<br/>		/// `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is<br/>		/// implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be<br/>		/// queried later using SDL_GetWindowFlags().<br/>		/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>		/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>		/// If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size<br/>		/// in pixels may differ from its size in screen coordinates on platforms with<br/>		/// high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the<br/>		/// client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or<br/>		/// SDL_GetRendererOutputSize() to query the drawable size in pixels. Note that<br/>		/// when this flag is set, the drawable size can vary after the window is<br/>		/// created and should be queried after major window events such as when the<br/>		/// window is resized or moved between displays.<br/>		/// If the window is set fullscreen, the width and height parameters `w` and<br/>		/// `h` will not be used. However, invalid size parameters (e.g. too large) may<br/>		/// still fail. Window size is actually limited to 16384 x 16384 for all<br/>		/// platforms at window creation.<br/>		/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>		/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>		/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>		/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>		/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>		/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>		/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>		/// SDL_CreateWindow() will fail.<br/>		/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>		/// loader or link to a dynamic library version. This limitation may be removed<br/>		/// in a future version of SDL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLCreateWindow([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] string title, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLWindow* ret = SDLCreateWindowNative(pStr0, x, y, w, h, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Create an SDL window from an existing native window.<br/>
		/// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)<br/>
		/// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured<br/>
		/// before using SDL_CreateWindowFrom().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateWindowFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateWindowFrom")]
		internal static extern SDLWindow* SDLCreateWindowFromNative([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data);

		/// <summary>		/// Create an SDL window from an existing native window.<br/>		/// In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)<br/>		/// the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured<br/>		/// before using SDL_CreateWindowFrom().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateWindowFrom")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLCreateWindowFrom([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data)
		{
			SDLWindow* ret = SDLCreateWindowFromNative(data);
			return ret;
		}

		/// <summary>
		/// Get the numeric ID of a window.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowID")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowID")]
		internal static extern uint SDLGetWindowIDNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get the numeric ID of a window.<br/>		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>		/// these events to specific SDL_Window objects.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowID")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetWindowID([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			uint ret = SDLGetWindowIDNative(window);
			return ret;
		}

		/// <summary>		/// Get the numeric ID of a window.<br/>		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>		/// these events to specific SDL_Window objects.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowID")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetWindowID([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				uint ret = SDLGetWindowIDNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get a window from a stored ID.<br/>
		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
		/// these events to specific SDL_Window objects.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowFromID")]
		internal static extern SDLWindow* SDLGetWindowFromIDNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "Uint32")] uint id);

		/// <summary>		/// Get a window from a stored ID.<br/>		/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>		/// these events to specific SDL_Window objects.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowFromID")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLGetWindowFromID([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "Uint32")] uint id)
		{
			SDLWindow* ret = SDLGetWindowFromIDNative(id);
			return ret;
		}

		/// <summary>
		/// Get the window flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowFlags")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowFlags")]
		internal static extern uint SDLGetWindowFlagsNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get the window flags.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowFlags")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetWindowFlags([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			uint ret = SDLGetWindowFlagsNative(window);
			return ret;
		}

		/// <summary>		/// Get the window flags.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowFlags")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetWindowFlags([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				uint ret = SDLGetWindowFlagsNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the title of a window.<br/>
		/// This string is expected to be in UTF-8 encoding.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowTitle")]
		internal static extern void SDLSetWindowTitleNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title);

		/// <summary>		/// Set the title of a window.<br/>		/// This string is expected to be in UTF-8 encoding.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowTitle([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title)
		{
			SDLSetWindowTitleNative(window, title);
		}

		/// <summary>		/// Set the title of a window.<br/>		/// This string is expected to be in UTF-8 encoding.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowTitle([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowTitleNative((SDLWindow*)pwindow, title);
			}
		}

		/// <summary>		/// Set the title of a window.<br/>		/// This string is expected to be in UTF-8 encoding.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowTitle([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] ref byte title)
		{
			fixed (byte* ptitle = &title)
			{
				SDLSetWindowTitleNative(window, (byte*)ptitle);
			}
		}

		/// <summary>		/// Set the title of a window.<br/>		/// This string is expected to be in UTF-8 encoding.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowTitle([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] string title)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSetWindowTitleNative(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>		/// Set the title of a window.<br/>		/// This string is expected to be in UTF-8 encoding.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowTitle([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] ref byte title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* ptitle = &title)
				{
					SDLSetWindowTitleNative((SDLWindow*)pwindow, (byte*)ptitle);
				}
			}
		}

		/// <summary>		/// Set the title of a window.<br/>		/// This string is expected to be in UTF-8 encoding.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowTitle([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] string title)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (title != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(title);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLSetWindowTitleNative((SDLWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// Get the title of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowTitle")]
		internal static extern byte* SDLGetWindowTitleNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get the title of a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetWindowTitle([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			byte* ret = SDLGetWindowTitleNative(window);
			return ret;
		}

		/// <summary>		/// Get the title of a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetWindowTitleS([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetWindowTitleNative(window));
			return ret;
		}

		/// <summary>		/// Get the title of a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetWindowTitle([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* ret = SDLGetWindowTitleNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>		/// Get the title of a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowTitle")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetWindowTitleS([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetWindowTitleNative((SDLWindow*)pwindow));
				return ret;
			}
		}

		/// <summary>
		/// Set the icon for a window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowIcon")]
		internal static extern void SDLSetWindowIconNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* icon);

		/// <summary>		/// Set the icon for a window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowIcon([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* icon)
		{
			SDLSetWindowIconNative(window, icon);
		}

		/// <summary>		/// Set the icon for a window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowIcon([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* icon)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowIconNative((SDLWindow*)pwindow, icon);
			}
		}

		/// <summary>		/// Set the icon for a window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowIcon([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface icon)
		{
			fixed (SDLSurface* picon = &icon)
			{
				SDLSetWindowIconNative(window, (SDLSurface*)picon);
			}
		}

		/// <summary>		/// Set the icon for a window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowIcon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowIcon([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "icon")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface icon)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* picon = &icon)
				{
					SDLSetWindowIconNative((SDLWindow*)pwindow, (SDLSurface*)picon);
				}
			}
		}

		/// <summary>
		/// Associate an arbitrary named pointer with a window.<br/>
		/// `name` is case-sensitive.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowData")]
		internal static extern void* SDLSetWindowDataNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Associate an arbitrary named pointer with a window.<br/>		/// `name` is case-sensitive.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLSetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			void* ret = SDLSetWindowDataNative(window, name, userdata);
			return ret;
		}

		/// <summary>		/// Associate an arbitrary named pointer with a window.<br/>		/// `name` is case-sensitive.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLSetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = SDLSetWindowDataNative((SDLWindow*)pwindow, name, userdata);
				return ret;
			}
		}

		/// <summary>		/// Associate an arbitrary named pointer with a window.<br/>		/// `name` is case-sensitive.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLSetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				void* ret = SDLSetWindowDataNative(window, (byte*)pname, userdata);
				return ret;
			}
		}

		/// <summary>		/// Associate an arbitrary named pointer with a window.<br/>		/// `name` is case-sensitive.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLSetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SDLSetWindowDataNative(window, pStr0, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Associate an arbitrary named pointer with a window.<br/>		/// `name` is case-sensitive.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLSetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = &name)
				{
					void* ret = SDLSetWindowDataNative((SDLWindow*)pwindow, (byte*)pname, userdata);
					return ret;
				}
			}
		}

		/// <summary>		/// Associate an arbitrary named pointer with a window.<br/>		/// `name` is case-sensitive.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLSetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = SDLSetWindowDataNative((SDLWindow*)pwindow, pStr0, userdata);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the data pointer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowData")]
		internal static extern void* SDLGetWindowDataNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name);

		/// <summary>		/// Retrieve the data pointer associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			void* ret = SDLGetWindowDataNative(window, name);
			return ret;
		}

		/// <summary>		/// Retrieve the data pointer associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				void* ret = SDLGetWindowDataNative((SDLWindow*)pwindow, name);
				return ret;
			}
		}

		/// <summary>		/// Retrieve the data pointer associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				void* ret = SDLGetWindowDataNative(window, (byte*)pname);
				return ret;
			}
		}

		/// <summary>		/// Retrieve the data pointer associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SDLGetWindowDataNative(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Retrieve the data pointer associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (byte* pname = &name)
				{
					void* ret = SDLGetWindowDataNative((SDLWindow*)pwindow, (byte*)pname);
					return ret;
				}
			}
		}

		/// <summary>		/// Retrieve the data pointer associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetWindowData([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (name != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(name);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = SDLGetWindowDataNative((SDLWindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Set the position of a window.<br/>
		/// The window coordinate origin is the upper left of the display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowPosition")]
		internal static extern void SDLSetWindowPositionNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y);

		/// <summary>		/// Set the position of a window.<br/>		/// The window coordinate origin is the upper left of the display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			SDLSetWindowPositionNative(window, x, y);
		}

		/// <summary>		/// Set the position of a window.<br/>		/// The window coordinate origin is the upper left of the display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowPositionNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Get the position of a window.<br/>
		/// If you do not need the value for one of the positions a NULL may be passed<br/>
		/// in the `x` or `y` parameter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowPosition")]
		internal static extern void SDLGetWindowPositionNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y);

		/// <summary>		/// Get the position of a window.<br/>		/// If you do not need the value for one of the positions a NULL may be passed<br/>		/// in the `x` or `y` parameter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			SDLGetWindowPositionNative(window, x, y);
		}

		/// <summary>		/// Get the position of a window.<br/>		/// If you do not need the value for one of the positions a NULL may be passed<br/>		/// in the `x` or `y` parameter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGetWindowPositionNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>		/// Get the position of a window.<br/>		/// If you do not need the value for one of the positions a NULL may be passed<br/>		/// in the `x` or `y` parameter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			fixed (int* px = &x)
			{
				SDLGetWindowPositionNative(window, (int*)px, y);
			}
		}

		/// <summary>		/// Get the position of a window.<br/>		/// If you do not need the value for one of the positions a NULL may be passed<br/>		/// in the `x` or `y` parameter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* px = &x)
				{
					SDLGetWindowPositionNative((SDLWindow*)pwindow, (int*)px, y);
				}
			}
		}

		/// <summary>		/// Get the position of a window.<br/>		/// If you do not need the value for one of the positions a NULL may be passed<br/>		/// in the `x` or `y` parameter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* py = &y)
			{
				SDLGetWindowPositionNative(window, x, (int*)py);
			}
		}

		/// <summary>		/// Get the position of a window.<br/>		/// If you do not need the value for one of the positions a NULL may be passed<br/>		/// in the `x` or `y` parameter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* py = &y)
				{
					SDLGetWindowPositionNative((SDLWindow*)pwindow, x, (int*)py);
				}
			}
		}

		/// <summary>		/// Get the position of a window.<br/>		/// If you do not need the value for one of the positions a NULL may be passed<br/>		/// in the `x` or `y` parameter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					SDLGetWindowPositionNative(window, (int*)px, (int*)py);
				}
			}
		}

		/// <summary>		/// Get the position of a window.<br/>		/// If you do not need the value for one of the positions a NULL may be passed<br/>		/// in the `x` or `y` parameter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowPosition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowPosition([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* px = &x)
				{
					fixed (int* py = &y)
					{
						SDLGetWindowPositionNative((SDLWindow*)pwindow, (int*)px, (int*)py);
					}
				}
			}
		}

		/// <summary>
		/// Set the size of a window's client area.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or<br/>
		/// SDL_GetRendererOutputSize() to get the real client area size in pixels.<br/>
		/// Fullscreen windows automatically match the size of the display mode, and<br/>
		/// you should use SDL_SetWindowDisplayMode() to change their size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowSize")]
		internal static extern void SDLSetWindowSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h);

		/// <summary>		/// Set the size of a window's client area.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or<br/>		/// SDL_GetRendererOutputSize() to get the real client area size in pixels.<br/>		/// Fullscreen windows automatically match the size of the display mode, and<br/>		/// you should use SDL_SetWindowDisplayMode() to change their size.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			SDLSetWindowSizeNative(window, w, h);
		}

		/// <summary>		/// Set the size of a window's client area.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or<br/>		/// SDL_GetRendererOutputSize() to get the real client area size in pixels.<br/>		/// Fullscreen windows automatically match the size of the display mode, and<br/>		/// you should use SDL_SetWindowDisplayMode() to change their size.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>
		/// Get the size of a window's client area.<br/>
		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>
		/// height value is not desired.<br/>
		/// The window size in screen coordinates may differ from the size in pixels,<br/>
		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>
		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>
		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>
		/// real client area size in pixels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowSize")]
		internal static extern void SDLGetWindowSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h);

		/// <summary>		/// Get the size of a window's client area.<br/>		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>		/// height value is not desired.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>		/// real client area size in pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			SDLGetWindowSizeNative(window, w, h);
		}

		/// <summary>		/// Get the size of a window's client area.<br/>		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>		/// height value is not desired.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>		/// real client area size in pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGetWindowSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>		/// Get the size of a window's client area.<br/>		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>		/// height value is not desired.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>		/// real client area size in pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				SDLGetWindowSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>		/// Get the size of a window's client area.<br/>		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>		/// height value is not desired.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>		/// real client area size in pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					SDLGetWindowSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>		/// Get the size of a window's client area.<br/>		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>		/// height value is not desired.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>		/// real client area size in pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				SDLGetWindowSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>		/// Get the size of a window's client area.<br/>		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>		/// height value is not desired.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>		/// real client area size in pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					SDLGetWindowSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the size of a window's client area.<br/>		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>		/// height value is not desired.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>		/// real client area size in pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					SDLGetWindowSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the size of a window's client area.<br/>		/// NULL can safely be passed as the `w` or `h` parameter if the width or<br/>		/// height value is not desired.<br/>		/// The window size in screen coordinates may differ from the size in pixels,<br/>		/// if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform<br/>		/// with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),<br/>		/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the<br/>		/// real client area size in pixels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						SDLGetWindowSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window's borders (decorations) around the client area.<br/>
		/// Note: If this function fails (returns -1), the size values will be<br/>
		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
		/// window in question was borderless.<br/>
		/// Note: This function may fail on systems where the window has not yet been<br/>
		/// decorated by the display server (for example, immediately after calling<br/>
		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
		/// window has been presented and composited, so that the window system has a<br/>
		/// chance to decorate the window and provide the border dimensions to SDL.<br/>
		/// This function also returns -1 if getting the information is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowBordersSize")]
		internal static extern int SDLGetWindowBordersSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right);

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			int ret = SDLGetWindowBordersSizeNative(window, top, left, bottom, right);
			return ret;
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, right);
				return ret;
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (int* ptop = &top)
			{
				int ret = SDLGetWindowBordersSizeNative(window, (int*)ptop, left, bottom, right);
				return ret;
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, right);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (int* pleft = &left)
			{
				int ret = SDLGetWindowBordersSizeNative(window, top, (int*)pleft, bottom, right);
				return ret;
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, right);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					int ret = SDLGetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, bottom, right);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (int* pbottom = &bottom)
			{
				int ret = SDLGetWindowBordersSizeNative(window, top, left, (int*)pbottom, right);
				return ret;
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, right);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					int ret = SDLGetWindowBordersSizeNative(window, (int*)ptop, left, (int*)pbottom, right);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					int ret = SDLGetWindowBordersSizeNative(window, top, (int*)pleft, (int*)pbottom, right);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						int ret = SDLGetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, (int*)pbottom, right);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] int* right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, right);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (int* pright = &right)
			{
				int ret = SDLGetWindowBordersSizeNative(window, top, left, bottom, (int*)pright);
				return ret;
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pright = &right)
				{
					int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, bottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pright = &right)
				{
					int ret = SDLGetWindowBordersSizeNative(window, (int*)ptop, left, bottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pright = &right)
					{
						int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, bottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pright = &right)
				{
					int ret = SDLGetWindowBordersSizeNative(window, top, (int*)pleft, bottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, bottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pright = &right)
					{
						int ret = SDLGetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, bottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] int* bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pright = &right)
						{
							int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, bottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (int* pbottom = &bottom)
			{
				fixed (int* pright = &right)
				{
					int ret = SDLGetWindowBordersSizeNative(window, top, left, (int*)pbottom, (int*)pright);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, top, left, (int*)pbottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						int ret = SDLGetWindowBordersSizeNative(window, (int*)ptop, left, (int*)pbottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] int* left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, left, (int*)pbottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (int* pleft = &left)
			{
				fixed (int* pbottom = &bottom)
				{
					fixed (int* pright = &right)
					{
						int ret = SDLGetWindowBordersSizeNative(window, top, (int*)pleft, (int*)pbottom, (int*)pright);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] int* top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, top, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (int* ptop = &top)
			{
				fixed (int* pleft = &left)
				{
					fixed (int* pbottom = &bottom)
					{
						fixed (int* pright = &right)
						{
							int ret = SDLGetWindowBordersSizeNative(window, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the size of a window's borders (decorations) around the client area.<br/>		/// Note: If this function fails (returns -1), the size values will be<br/>		/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>		/// window in question was borderless.<br/>		/// Note: This function may fail on systems where the window has not yet been<br/>		/// decorated by the display server (for example, immediately after calling<br/>		/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>		/// window has been presented and composited, so that the window system has a<br/>		/// chance to decorate the window and provide the border dimensions to SDL.<br/>		/// This function also returns -1 if getting the information is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBordersSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowBordersSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "top")] [NativeName(NativeNameType.Type, "int*")] ref int top, [NativeName(NativeNameType.Param, "left")] [NativeName(NativeNameType.Type, "int*")] ref int left, [NativeName(NativeNameType.Param, "bottom")] [NativeName(NativeNameType.Type, "int*")] ref int bottom, [NativeName(NativeNameType.Param, "right")] [NativeName(NativeNameType.Type, "int*")] ref int right)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ptop = &top)
				{
					fixed (int* pleft = &left)
					{
						fixed (int* pbottom = &bottom)
						{
							fixed (int* pright = &right)
							{
								int ret = SDLGetWindowBordersSizeNative((SDLWindow*)pwindow, (int*)ptop, (int*)pleft, (int*)pbottom, (int*)pright);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the size of a window in pixels.<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowSizeInPixels")]
		internal static extern void SDLGetWindowSizeInPixelsNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h);

		/// <summary>		/// Get the size of a window in pixels.<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			SDLGetWindowSizeInPixelsNative(window, w, h);
		}

		/// <summary>		/// Get the size of a window in pixels.<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>		/// Get the size of a window in pixels.<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				SDLGetWindowSizeInPixelsNative(window, (int*)pw, h);
			}
		}

		/// <summary>		/// Get the size of a window in pixels.<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					SDLGetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>		/// Get the size of a window in pixels.<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				SDLGetWindowSizeInPixelsNative(window, w, (int*)ph);
			}
		}

		/// <summary>		/// Get the size of a window in pixels.<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					SDLGetWindowSizeInPixelsNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the size of a window in pixels.<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					SDLGetWindowSizeInPixelsNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the size of a window in pixels.<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSizeInPixels")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowSizeInPixels([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						SDLGetWindowSizeInPixelsNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowMinimumSize")]
		internal static extern void SDLSetWindowMinimumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_w")] [NativeName(NativeNameType.Type, "int")] int minW, [NativeName(NativeNameType.Param, "min_h")] [NativeName(NativeNameType.Type, "int")] int minH);

		/// <summary>		/// Set the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "min_w")] [NativeName(NativeNameType.Type, "int")] int minW, [NativeName(NativeNameType.Param, "min_h")] [NativeName(NativeNameType.Type, "int")] int minH)
		{
			SDLSetWindowMinimumSizeNative(window, minW, minH);
		}

		/// <summary>		/// Set the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "min_w")] [NativeName(NativeNameType.Type, "int")] int minW, [NativeName(NativeNameType.Param, "min_h")] [NativeName(NativeNameType.Type, "int")] int minH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowMinimumSizeNative((SDLWindow*)pwindow, minW, minH);
			}
		}

		/// <summary>
		/// Get the minimum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowMinimumSize")]
		internal static extern void SDLGetWindowMinimumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h);

		/// <summary>		/// Get the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			SDLGetWindowMinimumSizeNative(window, w, h);
		}

		/// <summary>		/// Get the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGetWindowMinimumSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>		/// Get the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				SDLGetWindowMinimumSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>		/// Get the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					SDLGetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>		/// Get the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				SDLGetWindowMinimumSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>		/// Get the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					SDLGetWindowMinimumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					SDLGetWindowMinimumSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the minimum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMinimumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMinimumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						SDLGetWindowMinimumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowMaximumSize")]
		internal static extern void SDLSetWindowMaximumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "max_w")] [NativeName(NativeNameType.Type, "int")] int maxW, [NativeName(NativeNameType.Param, "max_h")] [NativeName(NativeNameType.Type, "int")] int maxH);

		/// <summary>		/// Set the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "max_w")] [NativeName(NativeNameType.Type, "int")] int maxW, [NativeName(NativeNameType.Param, "max_h")] [NativeName(NativeNameType.Type, "int")] int maxH)
		{
			SDLSetWindowMaximumSizeNative(window, maxW, maxH);
		}

		/// <summary>		/// Set the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "max_w")] [NativeName(NativeNameType.Type, "int")] int maxW, [NativeName(NativeNameType.Param, "max_h")] [NativeName(NativeNameType.Type, "int")] int maxH)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowMaximumSizeNative((SDLWindow*)pwindow, maxW, maxH);
			}
		}

		/// <summary>
		/// Get the maximum size of a window's client area.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowMaximumSize")]
		internal static extern void SDLGetWindowMaximumSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h);

		/// <summary>		/// Get the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			SDLGetWindowMaximumSizeNative(window, w, h);
		}

		/// <summary>		/// Get the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGetWindowMaximumSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>		/// Get the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				SDLGetWindowMaximumSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>		/// Get the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					SDLGetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>		/// Get the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				SDLGetWindowMaximumSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>		/// Get the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					SDLGetWindowMaximumSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					SDLGetWindowMaximumSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the maximum size of a window's client area.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMaximumSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetWindowMaximumSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						SDLGetWindowMaximumSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the border state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
		/// or remove the border from the actual window. This is a no-op if the<br/>
		/// window's border already matches the requested state.<br/>
		/// You can't change the border state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowBordered")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowBordered")]
		internal static extern void SDLSetWindowBorderedNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "bordered")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool bordered);

		/// <summary>		/// Set the border state of a window.<br/>		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>		/// or remove the border from the actual window. This is a no-op if the<br/>		/// window's border already matches the requested state.<br/>		/// You can't change the border state of a fullscreen window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowBordered")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowBordered([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "bordered")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool bordered)
		{
			SDLSetWindowBorderedNative(window, bordered);
		}

		/// <summary>		/// Set the border state of a window.<br/>		/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>		/// or remove the border from the actual window. This is a no-op if the<br/>		/// window's border already matches the requested state.<br/>		/// You can't change the border state of a fullscreen window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowBordered")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowBordered([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "bordered")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool bordered)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowBorderedNative((SDLWindow*)pwindow, bordered);
			}
		}

		/// <summary>
		/// Set the user-resizable state of a window.<br/>
		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
		/// resizable state already matches the requested state.<br/>
		/// You can't change the resizable state of a fullscreen window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowResizable")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowResizable")]
		internal static extern void SDLSetWindowResizableNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "resizable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool resizable);

		/// <summary>		/// Set the user-resizable state of a window.<br/>		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>		/// resizable state already matches the requested state.<br/>		/// You can't change the resizable state of a fullscreen window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowResizable")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowResizable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "resizable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool resizable)
		{
			SDLSetWindowResizableNative(window, resizable);
		}

		/// <summary>		/// Set the user-resizable state of a window.<br/>		/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>		/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>		/// resizable state already matches the requested state.<br/>		/// You can't change the resizable state of a fullscreen window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowResizable")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowResizable([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "resizable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool resizable)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowResizableNative((SDLWindow*)pwindow, resizable);
			}
		}

		/// <summary>
		/// Set the window to always be above the others.<br/>
		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
		/// will bring the window to the front and keep the window above the rest.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowAlwaysOnTop")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowAlwaysOnTop")]
		internal static extern void SDLSetWindowAlwaysOnTopNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "on_top")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool onTop);

		/// <summary>		/// Set the window to always be above the others.<br/>		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>		/// will bring the window to the front and keep the window above the rest.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowAlwaysOnTop")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowAlwaysOnTop([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "on_top")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool onTop)
		{
			SDLSetWindowAlwaysOnTopNative(window, onTop);
		}

		/// <summary>		/// Set the window to always be above the others.<br/>		/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>		/// will bring the window to the front and keep the window above the rest.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowAlwaysOnTop")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowAlwaysOnTop([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "on_top")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool onTop)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowAlwaysOnTopNative((SDLWindow*)pwindow, onTop);
			}
		}

		/// <summary>
		/// Show a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ShowWindow")]
		internal static extern void SDLShowWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Show a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLShowWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLShowWindowNative(window);
		}

		/// <summary>		/// Show a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLShowWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLShowWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Hide a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HideWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HideWindow")]
		internal static extern void SDLHideWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Hide a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HideWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHideWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLHideWindowNative(window);
		}

		/// <summary>		/// Hide a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HideWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHideWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLHideWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Raise a window above other windows and set the input focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RaiseWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RaiseWindow")]
		internal static extern void SDLRaiseWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Raise a window above other windows and set the input focus.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RaiseWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRaiseWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLRaiseWindowNative(window);
		}

		/// <summary>		/// Raise a window above other windows and set the input focus.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RaiseWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRaiseWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRaiseWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Make a window as large as possible.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MaximizeWindow")]
		internal static extern void SDLMaximizeWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Make a window as large as possible.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMaximizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLMaximizeWindowNative(window);
		}

		/// <summary>		/// Make a window as large as possible.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MaximizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMaximizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLMaximizeWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Minimize a window to an iconic representation.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MinimizeWindow")]
		internal static extern void SDLMinimizeWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Minimize a window to an iconic representation.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMinimizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLMinimizeWindowNative(window);
		}

		/// <summary>		/// Minimize a window to an iconic representation.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MinimizeWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMinimizeWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLMinimizeWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Restore the size and position of a minimized or maximized window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RestoreWindow")]
		internal static extern void SDLRestoreWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Restore the size and position of a minimized or maximized window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRestoreWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLRestoreWindowNative(window);
		}

		/// <summary>		/// Restore the size and position of a minimized or maximized window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RestoreWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRestoreWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRestoreWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Set a window's fullscreen state.<br/>
		/// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a<br/>
		/// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen<br/>
		/// that takes the size of the desktop; and 0 for windowed mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowFullscreen")]
		internal static extern int SDLSetWindowFullscreenNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Set a window's fullscreen state.<br/>		/// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a<br/>		/// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen<br/>		/// that takes the size of the desktop; and 0 for windowed mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowFullscreen([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			int ret = SDLSetWindowFullscreenNative(window, flags);
			return ret;
		}

		/// <summary>		/// Set a window's fullscreen state.<br/>		/// `flags` may be `SDL_WINDOW_FULLSCREEN`, for "real" fullscreen with a<br/>		/// videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for "fake" fullscreen<br/>		/// that takes the size of the desktop; and 0 for windowed mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowFullscreen")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowFullscreen([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowFullscreenNative((SDLWindow*)pwindow, flags);
				return ret;
			}
		}

		/// <summary>
		/// Return whether the window has a surface associated with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasWindowSurface")]
		internal static extern SDLBool SDLHasWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Return whether the window has a surface associated with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLBool ret = SDLHasWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>		/// Return whether the window has a surface associated with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = SDLHasWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the SDL surface associated with the window.<br/>
		/// A new surface will be created with the optimal format for the window, if<br/>
		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
		/// free this surface.<br/>
		/// This surface will be invalidated if the window is resized. After resizing a<br/>
		/// window this function must be called again to return a valid surface.<br/>
		/// You may not combine this with 3D or the rendering API on this window.<br/>
		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowSurface")]
		internal static extern SDLSurface* SDLGetWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get the SDL surface associated with the window.<br/>		/// A new surface will be created with the optimal format for the window, if<br/>		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>		/// free this surface.<br/>		/// This surface will be invalidated if the window is resized. After resizing a<br/>		/// window this function must be called again to return a valid surface.<br/>		/// You may not combine this with 3D or the rendering API on this window.<br/>		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLGetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLSurface* ret = SDLGetWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>		/// Get the SDL surface associated with the window.<br/>		/// A new surface will be created with the optimal format for the window, if<br/>		/// necessary. This surface will be freed when the window is destroyed. Do not<br/>		/// free this surface.<br/>		/// This surface will be invalidated if the window is resized. After resizing a<br/>		/// window this function must be called again to return a valid surface.<br/>		/// You may not combine this with 3D or the rendering API on this window.<br/>		/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* SDLGetWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSurface* ret = SDLGetWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Copy the window surface to the screen.<br/>
		/// This is the function you use to reflect any changes to the surface on the<br/>
		/// screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UpdateWindowSurface")]
		internal static extern int SDLUpdateWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Copy the window surface to the screen.<br/>		/// This is the function you use to reflect any changes to the surface on the<br/>		/// screen.<br/>		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			int ret = SDLUpdateWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>		/// Copy the window surface to the screen.<br/>		/// This is the function you use to reflect any changes to the surface on the<br/>		/// screen.<br/>		/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLUpdateWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Copy areas of the window surface to the screen.<br/>
		/// This is the function you use to reflect changes to portions of the surface<br/>
		/// on the screen.<br/>
		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UpdateWindowSurfaceRects")]
		internal static extern int SDLUpdateWindowSurfaceRectsNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects);

		/// <summary>		/// Copy areas of the window surface to the screen.<br/>		/// This is the function you use to reflect changes to portions of the surface<br/>		/// on the screen.<br/>		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			int ret = SDLUpdateWindowSurfaceRectsNative(window, rects, numrects);
			return ret;
		}

		/// <summary>		/// Copy areas of the window surface to the screen.<br/>		/// This is the function you use to reflect changes to portions of the surface<br/>		/// on the screen.<br/>		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLUpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, rects, numrects);
				return ret;
			}
		}

		/// <summary>		/// Copy areas of the window surface to the screen.<br/>		/// This is the function you use to reflect changes to portions of the surface<br/>		/// on the screen.<br/>		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			fixed (SDLRect* prects = &rects)
			{
				int ret = SDLUpdateWindowSurfaceRectsNative(window, (SDLRect*)prects, numrects);
				return ret;
			}
		}

		/// <summary>		/// Copy areas of the window surface to the screen.<br/>		/// This is the function you use to reflect changes to portions of the surface<br/>		/// on the screen.<br/>		/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateWindowSurfaceRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateWindowSurfaceRects([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rects, [NativeName(NativeNameType.Param, "numrects")] [NativeName(NativeNameType.Type, "int")] int numrects)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prects = &rects)
				{
					int ret = SDLUpdateWindowSurfaceRectsNative((SDLWindow*)pwindow, (SDLRect*)prects, numrects);
					return ret;
				}
			}
		}

		/// <summary>
		/// Destroy the surface associated with the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindowSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DestroyWindowSurface")]
		internal static extern int SDLDestroyWindowSurfaceNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Destroy the surface associated with the window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyWindowSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLDestroyWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			int ret = SDLDestroyWindowSurfaceNative(window);
			return ret;
		}

		/// <summary>		/// Destroy the surface associated with the window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyWindowSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLDestroyWindowSurface([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLDestroyWindowSurfaceNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set a window's input grab mode.<br/>
		/// When input is grabbed, the mouse is confined to the window. This function<br/>
		/// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the<br/>
		/// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowGrab")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowGrab")]
		internal static extern void SDLSetWindowGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool grabbed);

		/// <summary>		/// Set a window's input grab mode.<br/>		/// When input is grabbed, the mouse is confined to the window. This function<br/>		/// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the<br/>		/// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().<br/>		/// If the caller enables a grab while another window is currently grabbed, the<br/>		/// other window loses its grab in favor of the caller's window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGrab")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool grabbed)
		{
			SDLSetWindowGrabNative(window, grabbed);
		}

		/// <summary>		/// Set a window's input grab mode.<br/>		/// When input is grabbed, the mouse is confined to the window. This function<br/>		/// will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the<br/>		/// keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().<br/>		/// If the caller enables a grab while another window is currently grabbed, the<br/>		/// other window loses its grab in favor of the caller's window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGrab")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowGrabNative((SDLWindow*)pwindow, grabbed);
			}
		}

		/// <summary>
		/// Set a window's keyboard grab mode.<br/>
		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
		/// This is primarily intended for specialized applications such as VNC clients<br/>
		/// or VM frontends. Normal games should not use keyboard grab.<br/>
		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
		/// window is full-screen to ensure the user is not trapped in your<br/>
		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
		/// mode, you may suppress this behavior with<br/>
		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
		/// If the caller enables a grab while another window is currently grabbed, the<br/>
		/// other window loses its grab in favor of the caller's window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowKeyboardGrab")]
		internal static extern void SDLSetWindowKeyboardGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool grabbed);

		/// <summary>		/// Set a window's keyboard grab mode.<br/>		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>		/// This is primarily intended for specialized applications such as VNC clients<br/>		/// or VM frontends. Normal games should not use keyboard grab.<br/>		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>		/// window is full-screen to ensure the user is not trapped in your<br/>		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>		/// mode, you may suppress this behavior with<br/>		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>		/// If the caller enables a grab while another window is currently grabbed, the<br/>		/// other window loses its grab in favor of the caller's window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool grabbed)
		{
			SDLSetWindowKeyboardGrabNative(window, grabbed);
		}

		/// <summary>		/// Set a window's keyboard grab mode.<br/>		/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>		/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>		/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>		/// This is primarily intended for specialized applications such as VNC clients<br/>		/// or VM frontends. Normal games should not use keyboard grab.<br/>		/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>		/// window is full-screen to ensure the user is not trapped in your<br/>		/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>		/// mode, you may suppress this behavior with<br/>		/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>		/// If the caller enables a grab while another window is currently grabbed, the<br/>		/// other window loses its grab in favor of the caller's window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowKeyboardGrabNative((SDLWindow*)pwindow, grabbed);
			}
		}

		/// <summary>
		/// Set a window's mouse grab mode.<br/>
		/// Mouse grab confines the mouse cursor to the window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowMouseGrab")]
		internal static extern void SDLSetWindowMouseGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool grabbed);

		/// <summary>		/// Set a window's mouse grab mode.<br/>		/// Mouse grab confines the mouse cursor to the window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool grabbed)
		{
			SDLSetWindowMouseGrabNative(window, grabbed);
		}

		/// <summary>		/// Set a window's mouse grab mode.<br/>		/// Mouse grab confines the mouse cursor to the window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "grabbed")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool grabbed)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLSetWindowMouseGrabNative((SDLWindow*)pwindow, grabbed);
			}
		}

		/// <summary>
		/// Get a window's input grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowGrab")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowGrab")]
		internal static extern SDLBool SDLGetWindowGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get a window's input grab mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGrab")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetWindowGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLBool ret = SDLGetWindowGrabNative(window);
			return ret;
		}

		/// <summary>		/// Get a window's input grab mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGrab")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetWindowGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = SDLGetWindowGrabNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get a window's keyboard grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowKeyboardGrab")]
		internal static extern SDLBool SDLGetWindowKeyboardGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get a window's keyboard grab mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLBool ret = SDLGetWindowKeyboardGrabNative(window);
			return ret;
		}

		/// <summary>		/// Get a window's keyboard grab mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowKeyboardGrab")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetWindowKeyboardGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = SDLGetWindowKeyboardGrabNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get a window's mouse grab mode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowMouseGrab")]
		internal static extern SDLBool SDLGetWindowMouseGrabNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get a window's mouse grab mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLBool ret = SDLGetWindowMouseGrabNative(window);
			return ret;
		}

		/// <summary>		/// Get a window's mouse grab mode.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseGrab")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetWindowMouseGrab([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = SDLGetWindowMouseGrabNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window that currently has an input grab enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGrabbedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetGrabbedWindow")]
		internal static extern SDLWindow* SDLGetGrabbedWindowNative();

		/// <summary>		/// Get the window that currently has an input grab enabled.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetGrabbedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLGetGrabbedWindow()
		{
			SDLWindow* ret = SDLGetGrabbedWindowNative();
			return ret;
		}

		/// <summary>
		/// Confines the cursor to the specified area of a window.<br/>
		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
		/// is restricted to when the window has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowMouseRect")]
		internal static extern int SDLSetWindowMouseRectNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Confines the cursor to the specified area of a window.<br/>		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>		/// is restricted to when the window has mouse focus.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLSetWindowMouseRectNative(window, rect);
			return ret;
		}

		/// <summary>		/// Confines the cursor to the specified area of a window.<br/>		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>		/// is restricted to when the window has mouse focus.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowMouseRectNative((SDLWindow*)pwindow, rect);
				return ret;
			}
		}

		/// <summary>		/// Confines the cursor to the specified area of a window.<br/>		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>		/// is restricted to when the window has mouse focus.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLSetWindowMouseRectNative(window, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>		/// Confines the cursor to the specified area of a window.<br/>		/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>		/// is restricted to when the window has mouse focus.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLSetWindowMouseRectNative((SDLWindow*)pwindow, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the mouse confinement rectangle of a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "const SDL_Rect*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowMouseRect")]
		internal static extern SDLRect* SDLGetWindowMouseRectNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get the mouse confinement rectangle of a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "const SDL_Rect*")]
		public static SDLRect* SDLGetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLRect* ret = SDLGetWindowMouseRectNative(window);
			return ret;
		}

		/// <summary>		/// Get the mouse confinement rectangle of a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowMouseRect")]
		[return: NativeName(NativeNameType.Type, "const SDL_Rect*")]
		public static SDLRect* SDLGetWindowMouseRect([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRect* ret = SDLGetWindowMouseRectNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method sets the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The<br/>
		/// brightness set will not follow the window if it is moved to another<br/>
		/// display.<br/>
		/// Many platforms will refuse to set the display brightness in modern times.<br/>
		/// You are better off using a shader to adjust gamma during rendering, or<br/>
		/// something similar.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowBrightness")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowBrightness")]
		internal static extern int SDLSetWindowBrightnessNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "brightness")] [NativeName(NativeNameType.Type, "float")] float brightness);

		/// <summary>		/// Set the brightness (gamma multiplier) for a given window's display.<br/>		/// Despite the name and signature, this method sets the brightness of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The<br/>		/// brightness set will not follow the window if it is moved to another<br/>		/// display.<br/>		/// Many platforms will refuse to set the display brightness in modern times.<br/>		/// You are better off using a shader to adjust gamma during rendering, or<br/>		/// something similar.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowBrightness")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowBrightness([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "brightness")] [NativeName(NativeNameType.Type, "float")] float brightness)
		{
			int ret = SDLSetWindowBrightnessNative(window, brightness);
			return ret;
		}

		/// <summary>		/// Set the brightness (gamma multiplier) for a given window's display.<br/>		/// Despite the name and signature, this method sets the brightness of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The<br/>		/// brightness set will not follow the window if it is moved to another<br/>		/// display.<br/>		/// Many platforms will refuse to set the display brightness in modern times.<br/>		/// You are better off using a shader to adjust gamma during rendering, or<br/>		/// something similar.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowBrightness")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowBrightness([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "brightness")] [NativeName(NativeNameType.Type, "float")] float brightness)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowBrightnessNative((SDLWindow*)pwindow, brightness);
				return ret;
			}
		}

		/// <summary>
		/// Get the brightness (gamma multiplier) for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the brightness of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowBrightness")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowBrightness")]
		internal static extern float SDLGetWindowBrightnessNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get the brightness (gamma multiplier) for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the brightness of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBrightness")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLGetWindowBrightness([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			float ret = SDLGetWindowBrightnessNative(window);
			return ret;
		}

		/// <summary>		/// Get the brightness (gamma multiplier) for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the brightness of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowBrightness")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLGetWindowBrightness([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				float ret = SDLGetWindowBrightnessNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the opacity for a window.<br/>
		/// The parameter `opacity` will be clamped internally between 0.0f<br/>
		/// (transparent) and 1.0f (opaque).<br/>
		/// This function also returns -1 if setting the opacity isn't supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowOpacity")]
		internal static extern int SDLSetWindowOpacityNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity);

		/// <summary>		/// Set the opacity for a window.<br/>		/// The parameter `opacity` will be clamped internally between 0.0f<br/>		/// (transparent) and 1.0f (opaque).<br/>		/// This function also returns -1 if setting the opacity isn't supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			int ret = SDLSetWindowOpacityNative(window, opacity);
			return ret;
		}

		/// <summary>		/// Set the opacity for a window.<br/>		/// The parameter `opacity` will be clamped internally between 0.0f<br/>		/// (transparent) and 1.0f (opaque).<br/>		/// This function also returns -1 if setting the opacity isn't supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "opacity")] [NativeName(NativeNameType.Type, "float")] float opacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowOpacityNative((SDLWindow*)pwindow, opacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the opacity of a window.<br/>
		/// If transparency isn't supported on this platform, opacity will be reported<br/>
		/// as 1.0f without error.<br/>
		/// The parameter `opacity` is ignored if it is NULL.<br/>
		/// This function also returns -1 if an invalid window was provided.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowOpacity")]
		internal static extern int SDLGetWindowOpacityNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "out_opacity")] [NativeName(NativeNameType.Type, "float*")] float* outOpacity);

		/// <summary>		/// Get the opacity of a window.<br/>		/// If transparency isn't supported on this platform, opacity will be reported<br/>		/// as 1.0f without error.<br/>		/// The parameter `opacity` is ignored if it is NULL.<br/>		/// This function also returns -1 if an invalid window was provided.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "out_opacity")] [NativeName(NativeNameType.Type, "float*")] float* outOpacity)
		{
			int ret = SDLGetWindowOpacityNative(window, outOpacity);
			return ret;
		}

		/// <summary>		/// Get the opacity of a window.<br/>		/// If transparency isn't supported on this platform, opacity will be reported<br/>		/// as 1.0f without error.<br/>		/// The parameter `opacity` is ignored if it is NULL.<br/>		/// This function also returns -1 if an invalid window was provided.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "out_opacity")] [NativeName(NativeNameType.Type, "float*")] float* outOpacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLGetWindowOpacityNative((SDLWindow*)pwindow, outOpacity);
				return ret;
			}
		}

		/// <summary>		/// Get the opacity of a window.<br/>		/// If transparency isn't supported on this platform, opacity will be reported<br/>		/// as 1.0f without error.<br/>		/// The parameter `opacity` is ignored if it is NULL.<br/>		/// This function also returns -1 if an invalid window was provided.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "out_opacity")] [NativeName(NativeNameType.Type, "float*")] ref float outOpacity)
		{
			fixed (float* poutOpacity = &outOpacity)
			{
				int ret = SDLGetWindowOpacityNative(window, (float*)poutOpacity);
				return ret;
			}
		}

		/// <summary>		/// Get the opacity of a window.<br/>		/// If transparency isn't supported on this platform, opacity will be reported<br/>		/// as 1.0f without error.<br/>		/// The parameter `opacity` is ignored if it is NULL.<br/>		/// This function also returns -1 if an invalid window was provided.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowOpacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowOpacity([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "out_opacity")] [NativeName(NativeNameType.Type, "float*")] ref float outOpacity)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (float* poutOpacity = &outOpacity)
				{
					int ret = SDLGetWindowOpacityNative((SDLWindow*)pwindow, (float*)poutOpacity);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the window as a modal for another window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowModalFor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowModalFor")]
		internal static extern int SDLSetWindowModalForNative([NativeName(NativeNameType.Param, "modal_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* modalWindow, [NativeName(NativeNameType.Param, "parent_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* parentWindow);

		/// <summary>		/// Set the window as a modal for another window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowModalFor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowModalFor([NativeName(NativeNameType.Param, "modal_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* modalWindow, [NativeName(NativeNameType.Param, "parent_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* parentWindow)
		{
			int ret = SDLSetWindowModalForNative(modalWindow, parentWindow);
			return ret;
		}

		/// <summary>		/// Set the window as a modal for another window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowModalFor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowModalFor([NativeName(NativeNameType.Param, "modal_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow modalWindow, [NativeName(NativeNameType.Param, "parent_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* parentWindow)
		{
			fixed (SDLWindow* pmodalWindow = &modalWindow)
			{
				int ret = SDLSetWindowModalForNative((SDLWindow*)pmodalWindow, parentWindow);
				return ret;
			}
		}

		/// <summary>		/// Set the window as a modal for another window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowModalFor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowModalFor([NativeName(NativeNameType.Param, "modal_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* modalWindow, [NativeName(NativeNameType.Param, "parent_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow parentWindow)
		{
			fixed (SDLWindow* pparentWindow = &parentWindow)
			{
				int ret = SDLSetWindowModalForNative(modalWindow, (SDLWindow*)pparentWindow);
				return ret;
			}
		}

		/// <summary>		/// Set the window as a modal for another window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowModalFor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowModalFor([NativeName(NativeNameType.Param, "modal_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow modalWindow, [NativeName(NativeNameType.Param, "parent_window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow parentWindow)
		{
			fixed (SDLWindow* pmodalWindow = &modalWindow)
			{
				fixed (SDLWindow* pparentWindow = &parentWindow)
				{
					int ret = SDLSetWindowModalForNative((SDLWindow*)pmodalWindow, (SDLWindow*)pparentWindow);
					return ret;
				}
			}
		}

		/// <summary>
		/// Explicitly set input focus to the window.<br/>
		/// You almost certainly want SDL_RaiseWindow() instead of this function. Use<br/>
		/// this with caution, as you might give focus to a window that is completely<br/>
		/// obscured by other windows.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowInputFocus")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowInputFocus")]
		internal static extern int SDLSetWindowInputFocusNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Explicitly set input focus to the window.<br/>		/// You almost certainly want SDL_RaiseWindow() instead of this function. Use<br/>		/// this with caution, as you might give focus to a window that is completely<br/>		/// obscured by other windows.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowInputFocus")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowInputFocus([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			int ret = SDLSetWindowInputFocusNative(window);
			return ret;
		}

		/// <summary>		/// Explicitly set input focus to the window.<br/>		/// You almost certainly want SDL_RaiseWindow() instead of this function. Use<br/>		/// this with caution, as you might give focus to a window that is completely<br/>		/// obscured by other windows.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowInputFocus")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowInputFocus([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowInputFocusNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the gamma ramp for the display that owns a given window.<br/>
		/// Set the gamma translation table for the red, green, and blue channels of<br/>
		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>
		/// representing a mapping between the input and output for that channel. The<br/>
		/// input is the index into the array, and the output is the 16-bit gamma value<br/>
		/// at that index, scaled to the output color precision.<br/>
		/// Despite the name and signature, this method sets the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>
		/// ramp set will not follow the window if it is moved to another display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowGammaRamp")]
		internal static extern int SDLSetWindowGammaRampNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* blue);

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* blue)
		{
			int ret = SDLSetWindowGammaRampNative(window, red, green, blue);
			return ret;
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowGammaRampNative((SDLWindow*)pwindow, red, green, blue);
				return ret;
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				int ret = SDLSetWindowGammaRampNative(window, (ushort*)pred, green, blue);
				return ret;
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					int ret = SDLSetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, blue);
					return ret;
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* blue)
		{
			fixed (ushort* pgreen = &green)
			{
				int ret = SDLSetWindowGammaRampNative(window, red, (ushort*)pgreen, blue);
				return ret;
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SDLSetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SDLSetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						int ret = SDLSetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, blue);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort blue)
		{
			fixed (ushort* pblue = &blue)
			{
				int ret = SDLSetWindowGammaRampNative(window, red, green, (ushort*)pblue);
				return ret;
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SDLSetWindowGammaRampNative((SDLWindow*)pwindow, red, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SDLSetWindowGammaRampNative(window, (ushort*)pred, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SDLSetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort blue)
		{
			fixed (ushort* pgreen = &green)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SDLSetWindowGammaRampNative(window, red, (ushort*)pgreen, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SDLSetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SDLSetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Set the gamma ramp for the display that owns a given window.<br/>		/// Set the gamma translation table for the red, green, and blue channels of<br/>		/// the video hardware. Each table is an array of 256 16-bit quantities,<br/>		/// representing a mapping between the input and output for that channel. The<br/>		/// input is the index into the array, and the output is the 16-bit gamma value<br/>		/// at that index, scaled to the output color precision.<br/>		/// Despite the name and signature, this method sets the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma<br/>		/// ramp set will not follow the window if it is moved to another display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "const Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						fixed (ushort* pblue = &blue)
						{
							int ret = SDLSetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the gamma ramp for a given window's display.<br/>
		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>
		/// entire display, not an individual window. A window is considered to be<br/>
		/// owned by the display that contains the window's center pixel. (The index of<br/>
		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetWindowGammaRamp")]
		internal static extern int SDLGetWindowGammaRampNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue);

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			int ret = SDLGetWindowGammaRampNative(window, red, green, blue);
			return ret;
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, red, green, blue);
				return ret;
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				int ret = SDLGetWindowGammaRampNative(window, (ushort*)pred, green, blue);
				return ret;
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, blue);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (ushort* pgreen = &green)
			{
				int ret = SDLGetWindowGammaRampNative(window, red, (ushort*)pgreen, blue);
				return ret;
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					int ret = SDLGetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, blue);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, blue);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (ushort* pblue = &blue)
			{
				int ret = SDLGetWindowGammaRampNative(window, red, green, (ushort*)pblue);
				return ret;
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, red, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SDLGetWindowGammaRampNative(window, (ushort*)pred, green, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, green, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (ushort* pgreen = &green)
			{
				fixed (ushort* pblue = &blue)
				{
					int ret = SDLGetWindowGammaRampNative(window, red, (ushort*)pgreen, (ushort*)pblue);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, red, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (ushort* pred = &red)
			{
				fixed (ushort* pgreen = &green)
				{
					fixed (ushort* pblue = &blue)
					{
						int ret = SDLGetWindowGammaRampNative(window, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the gamma ramp for a given window's display.<br/>		/// Despite the name and signature, this method retrieves the gamma ramp of the<br/>		/// entire display, not an individual window. A window is considered to be<br/>		/// owned by the display that contains the window's center pixel. (The index of<br/>		/// this display can be retrieved using SDL_GetWindowDisplayIndex().)<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetWindowGammaRamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetWindowGammaRamp([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort blue)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (ushort* pred = &red)
				{
					fixed (ushort* pgreen = &green)
					{
						fixed (ushort* pblue = &blue)
						{
							int ret = SDLGetWindowGammaRampNative((SDLWindow*)pwindow, (ushort*)pred, (ushort*)pgreen, (ushort*)pblue);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Provide a callback that decides if a window region has special properties.<br/>
		/// Normally windows are dragged and resized by decorations provided by the<br/>
		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
		/// makes sense to drag them from somewhere else inside the window itself; for<br/>
		/// example, one might have a borderless window that wants to be draggable from<br/>
		/// any part, or simulate its own title bar, etc.<br/>
		/// This function lets the app provide a callback that designates pieces of a<br/>
		/// given window as special. This callback is run during event processing if we<br/>
		/// need to tell the OS to treat a region of the window specially; the use of<br/>
		/// this callback is known as "hit testing."<br/>
		/// Mouse input may not be delivered to your application if it is within a<br/>
		/// special area; the OS will often apply that input to moving the window or<br/>
		/// resizing the window and not deliver it to the application.<br/>
		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
		/// disabled by default.<br/>
		/// Platforms that don't support this functionality will return -1<br/>
		/// unconditionally, even if you're attempting to disable hit-testing.<br/>
		/// Your callback may fire at any time, and its firing does not indicate any<br/>
		/// specific behavior (for example, on Windows, this certainly might fire when<br/>
		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
		/// other reasons, too, some unrelated to anything you probably care about _and<br/>
		/// when the mouse isn't actually at the location it is testing_). Since this<br/>
		/// can fire at any time, you should try to keep your callback efficient,<br/>
		/// devoid of allocations, etc.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowHitTest")]
		internal static extern int SDLSetWindowHitTestNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void*")] void* callbackData);

		/// <summary>		/// Provide a callback that decides if a window region has special properties.<br/>		/// Normally windows are dragged and resized by decorations provided by the<br/>		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>		/// makes sense to drag them from somewhere else inside the window itself; for<br/>		/// example, one might have a borderless window that wants to be draggable from<br/>		/// any part, or simulate its own title bar, etc.<br/>		/// This function lets the app provide a callback that designates pieces of a<br/>		/// given window as special. This callback is run during event processing if we<br/>		/// need to tell the OS to treat a region of the window specially; the use of<br/>		/// this callback is known as "hit testing."<br/>		/// Mouse input may not be delivered to your application if it is within a<br/>		/// special area; the OS will often apply that input to moving the window or<br/>		/// resizing the window and not deliver it to the application.<br/>		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>		/// disabled by default.<br/>		/// Platforms that don't support this functionality will return -1<br/>		/// unconditionally, even if you're attempting to disable hit-testing.<br/>		/// Your callback may fire at any time, and its firing does not indicate any<br/>		/// specific behavior (for example, on Windows, this certainly might fire when<br/>		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>		/// other reasons, too, some unrelated to anything you probably care about _and<br/>		/// when the mouse isn't actually at the location it is testing_). Since this<br/>		/// can fire at any time, you should try to keep your callback efficient,<br/>		/// devoid of allocations, etc.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void*")] void* callbackData)
		{
			int ret = SDLSetWindowHitTestNative(window, callback, callbackData);
			return ret;
		}

		/// <summary>		/// Provide a callback that decides if a window region has special properties.<br/>		/// Normally windows are dragged and resized by decorations provided by the<br/>		/// system window manager (a title bar, borders, etc), but for some apps, it<br/>		/// makes sense to drag them from somewhere else inside the window itself; for<br/>		/// example, one might have a borderless window that wants to be draggable from<br/>		/// any part, or simulate its own title bar, etc.<br/>		/// This function lets the app provide a callback that designates pieces of a<br/>		/// given window as special. This callback is run during event processing if we<br/>		/// need to tell the OS to treat a region of the window specially; the use of<br/>		/// this callback is known as "hit testing."<br/>		/// Mouse input may not be delivered to your application if it is within a<br/>		/// special area; the OS will often apply that input to moving the window or<br/>		/// resizing the window and not deliver it to the application.<br/>		/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>		/// disabled by default.<br/>		/// Platforms that don't support this functionality will return -1<br/>		/// unconditionally, even if you're attempting to disable hit-testing.<br/>		/// Your callback may fire at any time, and its firing does not indicate any<br/>		/// specific behavior (for example, on Windows, this certainly might fire when<br/>		/// the OS is deciding whether to drag your window, but it fires for lots of<br/>		/// other reasons, too, some unrelated to anything you probably care about _and<br/>		/// when the mouse isn't actually at the location it is testing_). Since this<br/>		/// can fire at any time, you should try to keep your callback efficient,<br/>		/// devoid of allocations, etc.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowHitTest")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowHitTest([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HitTest")] SDLHitTest callback, [NativeName(NativeNameType.Param, "callback_data")] [NativeName(NativeNameType.Type, "void*")] void* callbackData)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowHitTestNative((SDLWindow*)pwindow, callback, callbackData);
				return ret;
			}
		}

		/// <summary>
		/// Request a window to demand attention from the user.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FlashWindow")]
		internal static extern int SDLFlashWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation);

		/// <summary>		/// Request a window to demand attention from the user.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFlashWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			int ret = SDLFlashWindowNative(window, operation);
			return ret;
		}

		/// <summary>		/// Request a window to demand attention from the user.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FlashWindow")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLFlashWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "operation")] [NativeName(NativeNameType.Type, "SDL_FlashOperation")] SDLFlashOperation operation)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLFlashWindowNative((SDLWindow*)pwindow, operation);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a window.<br/>
		/// If `window` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DestroyWindow")]
		internal static extern void SDLDestroyWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Destroy a window.<br/>		/// If `window` is NULL, this function will return immediately after setting<br/>		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLDestroyWindowNative(window);
		}

		/// <summary>		/// Destroy a window.<br/>		/// If `window` is NULL, this function will return immediately after setting<br/>		/// the SDL error message to "Invalid window". See SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLDestroyWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Check whether the screensaver is currently enabled.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsScreenSaverEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IsScreenSaverEnabled")]
		internal static extern SDLBool SDLIsScreenSaverEnabledNative();

		/// <summary>		/// Check whether the screensaver is currently enabled.<br/>		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>		/// the screensaver was enabled by default.<br/>		/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsScreenSaverEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsScreenSaverEnabled()
		{
			SDLBool ret = SDLIsScreenSaverEnabledNative();
			return ret;
		}

		/// <summary>
		/// Allow the screen to be blanked by a screen saver.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EnableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_EnableScreenSaver")]
		internal static extern void SDLEnableScreenSaverNative();

		/// <summary>		/// Allow the screen to be blanked by a screen saver.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EnableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLEnableScreenSaver()
		{
			SDLEnableScreenSaverNative();
		}

		/// <summary>
		/// Prevent the screen from being blanked by a screen saver.<br/>
		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
		/// quits.<br/>
		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>
		/// the screensaver was enabled by default.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DisableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DisableScreenSaver")]
		internal static extern void SDLDisableScreenSaverNative();

		/// <summary>		/// Prevent the screen from being blanked by a screen saver.<br/>		/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>		/// quits.<br/>		/// The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2<br/>		/// the screensaver was enabled by default.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DisableScreenSaver")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDisableScreenSaver()
		{
			SDLDisableScreenSaverNative();
		}

		/// <summary>
		/// Dynamically load an OpenGL library.<br/>
		/// This should be done after initializing the video driver, but before<br/>
		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
		/// library will be loaded upon creation of the first OpenGL window.<br/>
		/// If you do this, you need to retrieve all of the GL functions used in your<br/>
		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_LoadLibrary")]
		internal static extern int SDLGLLoadLibraryNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] byte* path);

		/// <summary>		/// Dynamically load an OpenGL library.<br/>		/// This should be done after initializing the video driver, but before<br/>		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>		/// library will be loaded upon creation of the first OpenGL window.<br/>		/// If you do this, you need to retrieve all of the GL functions used in your<br/>		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] byte* path)
		{
			int ret = SDLGLLoadLibraryNative(path);
			return ret;
		}

		/// <summary>		/// Dynamically load an OpenGL library.<br/>		/// This should be done after initializing the video driver, but before<br/>		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>		/// library will be loaded upon creation of the first OpenGL window.<br/>		/// If you do this, you need to retrieve all of the GL functions used in your<br/>		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] ref byte path)
		{
			fixed (byte* ppath = &path)
			{
				int ret = SDLGLLoadLibraryNative((byte*)ppath);
				return ret;
			}
		}

		/// <summary>		/// Dynamically load an OpenGL library.<br/>		/// This should be done after initializing the video driver, but before<br/>		/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>		/// library will be loaded upon creation of the first OpenGL window.<br/>		/// If you do this, you need to retrieve all of the GL functions used in your<br/>		/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_LoadLibrary")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLLoadLibrary([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] string path)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLGLLoadLibraryNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get an OpenGL function by name.<br/>
		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
		/// function pointers to OpenGL extensions.<br/>
		/// There are some quirks to looking up OpenGL functions that require some<br/>
		/// extra care from the application. If you code carefully, you can handle<br/>
		/// these quirks without any platform-specific code, though:<br/>
		/// - On Windows, function pointers are specific to the current GL context;<br/>
		/// this means you need to have created a GL context and made it current<br/>
		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
		/// create a second context, you should assume that any existing function<br/>
		/// pointers aren't valid to use with it. This is (currently) a<br/>
		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
		/// this limitation, but it is still the way the wgl API is documented to<br/>
		/// work and you should expect crashes if you don't respect it. Store a copy<br/>
		/// of the function pointers that comes and goes with context lifespan.<br/>
		/// - On X11, function pointers returned by this function are valid for any<br/>
		/// context, and can even be looked up before a context is created at all.<br/>
		/// This means that, for at least some common OpenGL implementations, if you<br/>
		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
		/// available for a given GL context before calling it, by checking for the<br/>
		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
		/// or verifying that the version of OpenGL you're using offers the function<br/>
		/// as core functionality.<br/>
		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
		/// isn't supported, but you can't count on this behavior. Check for<br/>
		/// extensions you use, and if you get a NULL anyway, act as if that<br/>
		/// extension wasn't available. This is probably a bug in the driver, but you<br/>
		/// can code defensively for this scenario anyhow.<br/>
		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
		/// Next-gen display servers are waiting to replace it, and may or may not<br/>
		/// make the same promises about function pointers.<br/>
		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
		/// code. This will ensure the proper calling convention is followed on<br/>
		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_GetProcAddress")]
		internal static extern void* SDLGLGetProcAddressNative([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "const char*")] byte* proc);

		/// <summary>		/// Get an OpenGL function by name.<br/>		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>		/// function pointers to OpenGL extensions.<br/>		/// There are some quirks to looking up OpenGL functions that require some<br/>		/// extra care from the application. If you code carefully, you can handle<br/>		/// these quirks without any platform-specific code, though:<br/>		/// - On Windows, function pointers are specific to the current GL context;<br/>		/// this means you need to have created a GL context and made it current<br/>		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>		/// create a second context, you should assume that any existing function<br/>		/// pointers aren't valid to use with it. This is (currently) a<br/>		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>		/// this limitation, but it is still the way the wgl API is documented to<br/>		/// work and you should expect crashes if you don't respect it. Store a copy<br/>		/// of the function pointers that comes and goes with context lifespan.<br/>		/// - On X11, function pointers returned by this function are valid for any<br/>		/// context, and can even be looked up before a context is created at all.<br/>		/// This means that, for at least some common OpenGL implementations, if you<br/>		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>		/// available for a given GL context before calling it, by checking for the<br/>		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>		/// or verifying that the version of OpenGL you're using offers the function<br/>		/// as core functionality.<br/>		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>		/// isn't supported, but you can't count on this behavior. Check for<br/>		/// extensions you use, and if you get a NULL anyway, act as if that<br/>		/// extension wasn't available. This is probably a bug in the driver, but you<br/>		/// can code defensively for this scenario anyhow.<br/>		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>		/// Next-gen display servers are waiting to replace it, and may or may not<br/>		/// make the same promises about function pointers.<br/>		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>		/// code. This will ensure the proper calling convention is followed on<br/>		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "const char*")] byte* proc)
		{
			void* ret = SDLGLGetProcAddressNative(proc);
			return ret;
		}

		/// <summary>		/// Get an OpenGL function by name.<br/>		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>		/// function pointers to OpenGL extensions.<br/>		/// There are some quirks to looking up OpenGL functions that require some<br/>		/// extra care from the application. If you code carefully, you can handle<br/>		/// these quirks without any platform-specific code, though:<br/>		/// - On Windows, function pointers are specific to the current GL context;<br/>		/// this means you need to have created a GL context and made it current<br/>		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>		/// create a second context, you should assume that any existing function<br/>		/// pointers aren't valid to use with it. This is (currently) a<br/>		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>		/// this limitation, but it is still the way the wgl API is documented to<br/>		/// work and you should expect crashes if you don't respect it. Store a copy<br/>		/// of the function pointers that comes and goes with context lifespan.<br/>		/// - On X11, function pointers returned by this function are valid for any<br/>		/// context, and can even be looked up before a context is created at all.<br/>		/// This means that, for at least some common OpenGL implementations, if you<br/>		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>		/// available for a given GL context before calling it, by checking for the<br/>		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>		/// or verifying that the version of OpenGL you're using offers the function<br/>		/// as core functionality.<br/>		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>		/// isn't supported, but you can't count on this behavior. Check for<br/>		/// extensions you use, and if you get a NULL anyway, act as if that<br/>		/// extension wasn't available. This is probably a bug in the driver, but you<br/>		/// can code defensively for this scenario anyhow.<br/>		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>		/// Next-gen display servers are waiting to replace it, and may or may not<br/>		/// make the same promises about function pointers.<br/>		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>		/// code. This will ensure the proper calling convention is followed on<br/>		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "const char*")] ref byte proc)
		{
			fixed (byte* pproc = &proc)
			{
				void* ret = SDLGLGetProcAddressNative((byte*)pproc);
				return ret;
			}
		}

		/// <summary>		/// Get an OpenGL function by name.<br/>		/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>		/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>		/// function pointers to OpenGL extensions.<br/>		/// There are some quirks to looking up OpenGL functions that require some<br/>		/// extra care from the application. If you code carefully, you can handle<br/>		/// these quirks without any platform-specific code, though:<br/>		/// - On Windows, function pointers are specific to the current GL context;<br/>		/// this means you need to have created a GL context and made it current<br/>		/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>		/// create a second context, you should assume that any existing function<br/>		/// pointers aren't valid to use with it. This is (currently) a<br/>		/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>		/// this limitation, but it is still the way the wgl API is documented to<br/>		/// work and you should expect crashes if you don't respect it. Store a copy<br/>		/// of the function pointers that comes and goes with context lifespan.<br/>		/// - On X11, function pointers returned by this function are valid for any<br/>		/// context, and can even be looked up before a context is created at all.<br/>		/// This means that, for at least some common OpenGL implementations, if you<br/>		/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>		/// is _NOT_ safe to call. You must always make sure the function is actually<br/>		/// available for a given GL context before calling it, by checking for the<br/>		/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>		/// or verifying that the version of OpenGL you're using offers the function<br/>		/// as core functionality.<br/>		/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>		/// isn't supported, but you can't count on this behavior. Check for<br/>		/// extensions you use, and if you get a NULL anyway, act as if that<br/>		/// extension wasn't available. This is probably a bug in the driver, but you<br/>		/// can code defensively for this scenario anyhow.<br/>		/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>		/// Next-gen display servers are waiting to replace it, and may or may not<br/>		/// make the same promises about function pointers.<br/>		/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>		/// code. This will ensure the proper calling convention is followed on<br/>		/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetProcAddress")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGLGetProcAddress([NativeName(NativeNameType.Param, "proc")] [NativeName(NativeNameType.Type, "const char*")] string proc)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (proc != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(proc);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(proc, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SDLGLGetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_UnloadLibrary")]
		internal static extern void SDLGLUnloadLibraryNative();

		/// <summary>		/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_UnloadLibrary")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLUnloadLibrary()
		{
			SDLGLUnloadLibraryNative();
		}

		/// <summary>
		/// Check if an OpenGL extension is supported for the current context.<br/>
		/// This function operates on the current GL context; you must have created a<br/>
		/// context and it must be current before calling this function. Do not assume<br/>
		/// that all contexts you create will have the same set of extensions<br/>
		/// available, or that recreating an existing context will offer the same<br/>
		/// extensions again.<br/>
		/// While it's probably not a massive overhead, this function is not an O(1)<br/>
		/// operation. Check the extensions you care about after creating the GL<br/>
		/// context and save that information somewhere instead of calling the function<br/>
		/// every time you need to know.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_ExtensionSupported")]
		internal static extern SDLBool SDLGLExtensionSupportedNative([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] byte* extension);

		/// <summary>		/// Check if an OpenGL extension is supported for the current context.<br/>		/// This function operates on the current GL context; you must have created a<br/>		/// context and it must be current before calling this function. Do not assume<br/>		/// that all contexts you create will have the same set of extensions<br/>		/// available, or that recreating an existing context will offer the same<br/>		/// extensions again.<br/>		/// While it's probably not a massive overhead, this function is not an O(1)<br/>		/// operation. Check the extensions you care about after creating the GL<br/>		/// context and save that information somewhere instead of calling the function<br/>		/// every time you need to know.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] byte* extension)
		{
			SDLBool ret = SDLGLExtensionSupportedNative(extension);
			return ret;
		}

		/// <summary>		/// Check if an OpenGL extension is supported for the current context.<br/>		/// This function operates on the current GL context; you must have created a<br/>		/// context and it must be current before calling this function. Do not assume<br/>		/// that all contexts you create will have the same set of extensions<br/>		/// available, or that recreating an existing context will offer the same<br/>		/// extensions again.<br/>		/// While it's probably not a massive overhead, this function is not an O(1)<br/>		/// operation. Check the extensions you care about after creating the GL<br/>		/// context and save that information somewhere instead of calling the function<br/>		/// every time you need to know.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] ref byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				SDLBool ret = SDLGLExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>		/// Check if an OpenGL extension is supported for the current context.<br/>		/// This function operates on the current GL context; you must have created a<br/>		/// context and it must be current before calling this function. Do not assume<br/>		/// that all contexts you create will have the same set of extensions<br/>		/// available, or that recreating an existing context will offer the same<br/>		/// extensions again.<br/>		/// While it's probably not a massive overhead, this function is not an O(1)<br/>		/// operation. Check the extensions you care about after creating the GL<br/>		/// context and save that information somewhere instead of calling the function<br/>		/// every time you need to know.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_ExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGLExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = SDLGLExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Reset all previously set OpenGL context attributes to their default values.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_ResetAttributes")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_ResetAttributes")]
		internal static extern void SDLGLResetAttributesNative();

		/// <summary>		/// Reset all previously set OpenGL context attributes to their default values.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_ResetAttributes")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLResetAttributes()
		{
			SDLGLResetAttributesNative();
		}

		/// <summary>
		/// Set an OpenGL window attribute before window creation.<br/>
		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
		/// attributes should be set before creating an OpenGL window. You should use<br/>
		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
		/// context, since the values obtained can differ from the requested ones.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_SetAttribute")]
		internal static extern int SDLGLSetAttributeNative([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value);

		/// <summary>		/// Set an OpenGL window attribute before window creation.<br/>		/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>		/// attributes should be set before creating an OpenGL window. You should use<br/>		/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>		/// context, since the values obtained can differ from the requested ones.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_SetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLSetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int")] int value)
		{
			int ret = SDLGLSetAttributeNative(attr, value);
			return ret;
		}

		/// <summary>
		/// Get the actual value for an attribute from the current context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_GetAttribute")]
		internal static extern int SDLGLGetAttributeNative([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int*")] int* value);

		/// <summary>		/// Get the actual value for an attribute from the current context.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLGetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int*")] int* value)
		{
			int ret = SDLGLGetAttributeNative(attr, value);
			return ret;
		}

		/// <summary>		/// Get the actual value for an attribute from the current context.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetAttribute")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLGetAttribute([NativeName(NativeNameType.Param, "attr")] [NativeName(NativeNameType.Type, "SDL_GLattr")] SDLGLattr attr, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "int*")] ref int value)
		{
			fixed (int* pvalue = &value)
			{
				int ret = SDLGLGetAttributeNative(attr, (int*)pvalue);
				return ret;
			}
		}

		/// <summary>
		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
		/// functions added after OpenGL version 1.1 are not available by default.<br/>
		/// Those functions must be loaded at run-time, either with an OpenGL<br/>
		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
		/// functions.<br/>
		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_CreateContext")]
		internal static extern SDLGLContext SDLGLCreateContextNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>		/// functions added after OpenGL version 1.1 are not available by default.<br/>		/// Those functions must be loaded at run-time, either with an OpenGL<br/>		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>		/// functions.<br/>		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext SDLGLCreateContext([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLGLContext ret = SDLGLCreateContextNative(window);
			return ret;
		}

		/// <summary>		/// Create an OpenGL context for an OpenGL window, and make it current.<br/>		/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>		/// functions added after OpenGL version 1.1 are not available by default.<br/>		/// Those functions must be loaded at run-time, either with an OpenGL<br/>		/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>		/// functions.<br/>		/// SDL_GLContext is an alias for `void *`. It's opaque to the application.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_CreateContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext SDLGLCreateContext([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLContext ret = SDLGLCreateContextNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
		/// The context must have been created with a compatible window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_MakeCurrent")]
		internal static extern int SDLGLMakeCurrentNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context);

		/// <summary>		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>		/// The context must have been created with a compatible window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLMakeCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			int ret = SDLGLMakeCurrentNative(window, context);
			return ret;
		}

		/// <summary>		/// Set up an OpenGL context for rendering into an OpenGL window.<br/>		/// The context must have been created with a compatible window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_MakeCurrent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLMakeCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLGLMakeCurrentNative((SDLWindow*)pwindow, context);
				return ret;
			}
		}

		/// <summary>
		/// Get the currently active OpenGL window.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_GetCurrentWindow")]
		internal static extern SDLWindow* SDLGLGetCurrentWindowNative();

		/// <summary>		/// Get the currently active OpenGL window.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLGLGetCurrentWindow()
		{
			SDLWindow* ret = SDLGLGetCurrentWindowNative();
			return ret;
		}

		/// <summary>
		/// Get the currently active OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_GetCurrentContext")]
		internal static extern SDLGLContext SDLGLGetCurrentContextNative();

		/// <summary>		/// Get the currently active OpenGL context.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "SDL_GLContext")]
		public static SDLGLContext SDLGLGetCurrentContext()
		{
			SDLGLContext ret = SDLGLGetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels.<br/>
		/// This returns info useful for calling glViewport().<br/>
		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>
		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>
		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>
		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_GetDrawableSize")]
		internal static extern void SDLGLGetDrawableSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h);

		/// <summary>		/// Get the size of a window's underlying drawable in pixels.<br/>		/// This returns info useful for calling glViewport().<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			SDLGLGetDrawableSizeNative(window, w, h);
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels.<br/>		/// This returns info useful for calling glViewport().<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLGetDrawableSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels.<br/>		/// This returns info useful for calling glViewport().<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				SDLGLGetDrawableSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels.<br/>		/// This returns info useful for calling glViewport().<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					SDLGLGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels.<br/>		/// This returns info useful for calling glViewport().<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				SDLGLGetDrawableSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels.<br/>		/// This returns info useful for calling glViewport().<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					SDLGLGetDrawableSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels.<br/>		/// This returns info useful for calling glViewport().<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					SDLGLGetDrawableSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels.<br/>		/// This returns info useful for calling glViewport().<br/>		/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI<br/>		/// drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a<br/>		/// platform with high-DPI support (Apple calls this "Retina"), and not<br/>		/// disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						SDLGLGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set the swap interval for the current OpenGL context.<br/>
		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
		/// might be less jarring for the user during occasional framerate drops. If an<br/>
		/// application requests adaptive vsync and the system does not support it,<br/>
		/// this function will fail and return -1. In such a case, you should probably<br/>
		/// retry the call with 1 for the interval.<br/>
		/// Adaptive vsync is implemented for some glX drivers with<br/>
		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
		/// WGL_EXT_swap_control_tear.<br/>
		/// Read more on the Khronos wiki:<br/>
		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_SetSwapInterval")]
		internal static extern int SDLGLSetSwapIntervalNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval);

		/// <summary>		/// Set the swap interval for the current OpenGL context.<br/>		/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>		/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>		/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>		/// might be less jarring for the user during occasional framerate drops. If an<br/>		/// application requests adaptive vsync and the system does not support it,<br/>		/// this function will fail and return -1. In such a case, you should probably<br/>		/// retry the call with 1 for the interval.<br/>		/// Adaptive vsync is implemented for some glX drivers with<br/>		/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>		/// WGL_EXT_swap_control_tear.<br/>		/// Read more on the Khronos wiki:<br/>		/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_SetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLSetSwapInterval([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval)
		{
			int ret = SDLGLSetSwapIntervalNative(interval);
			return ret;
		}

		/// <summary>
		/// Get the swap interval for the current OpenGL context.<br/>
		/// If the system can't determine the swap interval, or there isn't a valid<br/>
		/// current context, this function will return 0 as a safe default.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_GetSwapInterval")]
		internal static extern int SDLGLGetSwapIntervalNative();

		/// <summary>		/// Get the swap interval for the current OpenGL context.<br/>		/// If the system can't determine the swap interval, or there isn't a valid<br/>		/// current context, this function will return 0 as a safe default.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_GetSwapInterval")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLGetSwapInterval()
		{
			int ret = SDLGLGetSwapIntervalNative();
			return ret;
		}

		/// <summary>
		/// Update a window with OpenGL rendering.<br/>
		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
		/// window, otherwise nothing will happen. If you aren't using<br/>
		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
		/// extra.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_SwapWindow")]
		internal static extern void SDLGLSwapWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Update a window with OpenGL rendering.<br/>		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>		/// window, otherwise nothing will happen. If you aren't using<br/>		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>		/// extra.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLSwapWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLGLSwapWindowNative(window);
		}

		/// <summary>		/// Update a window with OpenGL rendering.<br/>		/// This is used with double-buffered OpenGL contexts, which are the default.<br/>		/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>		/// window, otherwise nothing will happen. If you aren't using<br/>		/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>		/// extra.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_SwapWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLSwapWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLGLSwapWindowNative((SDLWindow*)pwindow);
			}
		}

		/// <summary>
		/// Delete an OpenGL context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_DeleteContext")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_DeleteContext")]
		internal static extern void SDLGLDeleteContextNative([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context);

		/// <summary>		/// Delete an OpenGL context.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_DeleteContext")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGLDeleteContext([NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "SDL_GLContext")] SDLGLContext context)
		{
			SDLGLDeleteContextNative(context);
		}

		/// <summary>
		/// Query the window which currently has keyboard focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetKeyboardFocus")]
		internal static extern SDLWindow* SDLGetKeyboardFocusNative();

		/// <summary>		/// Query the window which currently has keyboard focus.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyboardFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLGetKeyboardFocus()
		{
			SDLWindow* ret = SDLGetKeyboardFocusNative();
			return ret;
		}

		/// <summary>
		/// Get a snapshot of the current state of the keyboard.<br/>
		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
		/// valid for the whole lifetime of the application and should not be freed by<br/>
		/// the caller.<br/>
		/// A array element with a value of 1 means that the key is pressed and a value<br/>
		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>
		/// SDL_Scancode values.<br/>
		/// Use SDL_PumpEvents() to update the state array.<br/>
		/// This function gives you the current state after all events have been<br/>
		/// processed, so if a key or button has been pressed and released before you<br/>
		/// process events, then the pressed state will never show up in the<br/>
		/// SDL_GetKeyboardState() calls.<br/>
		/// Note: This function doesn't take into account whether shift has been<br/>
		/// pressed or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "const Uint8*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetKeyboardState")]
		internal static extern byte* SDLGetKeyboardStateNative([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int*")] int* numkeys);

		/// <summary>		/// Get a snapshot of the current state of the keyboard.<br/>		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>		/// valid for the whole lifetime of the application and should not be freed by<br/>		/// the caller.<br/>		/// A array element with a value of 1 means that the key is pressed and a value<br/>		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>		/// SDL_Scancode values.<br/>		/// Use SDL_PumpEvents() to update the state array.<br/>		/// This function gives you the current state after all events have been<br/>		/// processed, so if a key or button has been pressed and released before you<br/>		/// process events, then the pressed state will never show up in the<br/>		/// SDL_GetKeyboardState() calls.<br/>		/// Note: This function doesn't take into account whether shift has been<br/>		/// pressed or not.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "const Uint8*")]
		public static byte* SDLGetKeyboardState([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int*")] int* numkeys)
		{
			byte* ret = SDLGetKeyboardStateNative(numkeys);
			return ret;
		}

		/// <summary>		/// Get a snapshot of the current state of the keyboard.<br/>		/// The pointer returned is a pointer to an internal SDL array. It will be<br/>		/// valid for the whole lifetime of the application and should not be freed by<br/>		/// the caller.<br/>		/// A array element with a value of 1 means that the key is pressed and a value<br/>		/// of 0 means that it is not. Indexes into this array are obtained by using<br/>		/// SDL_Scancode values.<br/>		/// Use SDL_PumpEvents() to update the state array.<br/>		/// This function gives you the current state after all events have been<br/>		/// processed, so if a key or button has been pressed and released before you<br/>		/// process events, then the pressed state will never show up in the<br/>		/// SDL_GetKeyboardState() calls.<br/>		/// Note: This function doesn't take into account whether shift has been<br/>		/// pressed or not.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyboardState")]
		[return: NativeName(NativeNameType.Type, "const Uint8*")]
		public static byte* SDLGetKeyboardState([NativeName(NativeNameType.Param, "numkeys")] [NativeName(NativeNameType.Type, "int*")] ref int numkeys)
		{
			fixed (int* pnumkeys = &numkeys)
			{
				byte* ret = SDLGetKeyboardStateNative((int*)pnumkeys);
				return ret;
			}
		}

		/// <summary>
		/// Clear the state of the keyboard<br/>
		/// This function will generate key up events for all pressed keys.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ResetKeyboard")]
		internal static extern void SDLResetKeyboardNative();

		/// <summary>		/// Clear the state of the keyboard<br/>		/// This function will generate key up events for all pressed keys.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ResetKeyboard")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLResetKeyboard()
		{
			SDLResetKeyboardNative();
		}

		/// <summary>
		/// Get the current key modifier state for the keyboard.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetModState")]
		[return: NativeName(NativeNameType.Type, "SDL_Keymod")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetModState")]
		internal static extern SDLKeymod SDLGetModStateNative();

		/// <summary>		/// Get the current key modifier state for the keyboard.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetModState")]
		[return: NativeName(NativeNameType.Type, "SDL_Keymod")]
		public static SDLKeymod SDLGetModState()
		{
			SDLKeymod ret = SDLGetModStateNative();
			return ret;
		}

		/// <summary>
		/// Set the current key modifier state for the keyboard.<br/>
		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
		/// modifier key states on your application. Simply pass your desired modifier<br/>
		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
		/// SDL_Keymod values.<br/>
		/// This does not change the keyboard state, only the key modifier flags that<br/>
		/// SDL reports.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetModState")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetModState")]
		internal static extern void SDLSetModStateNative([NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] SDLKeymod modstate);

		/// <summary>		/// Set the current key modifier state for the keyboard.<br/>		/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>		/// modifier key states on your application. Simply pass your desired modifier<br/>		/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>		/// SDL_Keymod values.<br/>		/// This does not change the keyboard state, only the key modifier flags that<br/>		/// SDL reports.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetModState")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetModState([NativeName(NativeNameType.Param, "modstate")] [NativeName(NativeNameType.Type, "SDL_Keymod")] SDLKeymod modstate)
		{
			SDLSetModStateNative(modstate);
		}

		/// <summary>
		/// Get the key code corresponding to the given scancode according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromScancode")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetKeyFromScancode")]
		internal static extern int SDLGetKeyFromScancodeNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode);

		/// <summary>		/// Get the key code corresponding to the given scancode according to the<br/>		/// current keyboard layout.<br/>		/// See SDL_Keycode for details.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyFromScancode")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int SDLGetKeyFromScancode([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			int ret = SDLGetKeyFromScancodeNative(scancode);
			return ret;
		}

		/// <summary>
		/// Get the scancode corresponding to the given key code according to the<br/>
		/// current keyboard layout.<br/>
		/// See SDL_Scancode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetScancodeFromKey")]
		internal static extern SDLScancode SDLGetScancodeFromKeyNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key);

		/// <summary>		/// Get the scancode corresponding to the given key code according to the<br/>		/// current keyboard layout.<br/>		/// See SDL_Scancode for details.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromKey")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode SDLGetScancodeFromKey([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			SDLScancode ret = SDLGetScancodeFromKeyNative(key);
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a scancode.<br/>
		/// See SDL_Scancode for details.<br/>
		/// **Warning**: The returned name is by design not stable across platforms,<br/>
		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
		/// Windows" under Microsoft Windows, and some scancodes like<br/>
		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
		/// strings and scancodes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetScancodeName")]
		internal static extern byte* SDLGetScancodeNameNative([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode);

		/// <summary>		/// Get a human-readable name for a scancode.<br/>		/// See SDL_Scancode for details.<br/>		/// **Warning**: The returned name is by design not stable across platforms,<br/>		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>		/// Windows" under Microsoft Windows, and some scancodes like<br/>		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>		/// strings and scancodes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetScancodeName([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			byte* ret = SDLGetScancodeNameNative(scancode);
			return ret;
		}

		/// <summary>		/// Get a human-readable name for a scancode.<br/>		/// See SDL_Scancode for details.<br/>		/// **Warning**: The returned name is by design not stable across platforms,<br/>		/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>		/// Windows" under Microsoft Windows, and some scancodes like<br/>		/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>		/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>		/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>		/// unsuitable for creating a stable cross-platform two-way mapping between<br/>		/// strings and scancodes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetScancodeNameS([NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "SDL_Scancode")] SDLScancode scancode)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetScancodeNameNative(scancode));
			return ret;
		}

		/// <summary>
		/// Get a scancode from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetScancodeFromName")]
		internal static extern SDLScancode SDLGetScancodeFromNameNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name);

		/// <summary>		/// Get a scancode from a human-readable name.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode SDLGetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			SDLScancode ret = SDLGetScancodeFromNameNative(name);
			return ret;
		}

		/// <summary>		/// Get a scancode from a human-readable name.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode SDLGetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLScancode ret = SDLGetScancodeFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>		/// Get a scancode from a human-readable name.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetScancodeFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Scancode")]
		public static SDLScancode SDLGetScancodeFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLScancode ret = SDLGetScancodeFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get a human-readable name for a key.<br/>
		/// See SDL_Scancode and SDL_Keycode for details.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetKeyName")]
		internal static extern byte* SDLGetKeyNameNative([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key);

		/// <summary>		/// Get a human-readable name for a key.<br/>		/// See SDL_Scancode and SDL_Keycode for details.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetKeyName([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			byte* ret = SDLGetKeyNameNative(key);
			return ret;
		}

		/// <summary>		/// Get a human-readable name for a key.<br/>		/// See SDL_Scancode and SDL_Keycode for details.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetKeyNameS([NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "SDL_Keycode")] int key)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetKeyNameNative(key));
			return ret;
		}

		/// <summary>
		/// Get a key code from a human-readable name.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetKeyFromName")]
		internal static extern int SDLGetKeyFromNameNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name);

		/// <summary>		/// Get a key code from a human-readable name.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int SDLGetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			int ret = SDLGetKeyFromNameNative(name);
			return ret;
		}

		/// <summary>		/// Get a key code from a human-readable name.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int SDLGetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				int ret = SDLGetKeyFromNameNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>		/// Get a key code from a human-readable name.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetKeyFromName")]
		[return: NativeName(NativeNameType.Type, "SDL_Keycode")]
		public static int SDLGetKeyFromName([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLGetKeyFromNameNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Start accepting Unicode text input events.<br/>
		/// This function will start accepting Unicode text input events in the focused<br/>
		/// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and<br/>
		/// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in<br/>
		/// pair with SDL_StopTextInput().<br/>
		/// On some platforms using this function activates the screen keyboard.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_StartTextInput")]
		internal static extern void SDLStartTextInputNative();

		/// <summary>		/// Start accepting Unicode text input events.<br/>		/// This function will start accepting Unicode text input events in the focused<br/>		/// SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and<br/>		/// SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in<br/>		/// pair with SDL_StopTextInput().<br/>		/// On some platforms using this function activates the screen keyboard.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_StartTextInput")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLStartTextInput()
		{
			SDLStartTextInputNative();
		}

		/// <summary>
		/// Check whether or not Unicode text input events are enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsTextInputActive")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IsTextInputActive")]
		internal static extern SDLBool SDLIsTextInputActiveNative();

		/// <summary>		/// Check whether or not Unicode text input events are enabled.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsTextInputActive")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsTextInputActive()
		{
			SDLBool ret = SDLIsTextInputActiveNative();
			return ret;
		}

		/// <summary>
		/// Stop receiving any text input events.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_StopTextInput")]
		internal static extern void SDLStopTextInputNative();

		/// <summary>		/// Stop receiving any text input events.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_StopTextInput")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLStopTextInput()
		{
			SDLStopTextInputNative();
		}

		/// <summary>
		/// Dismiss the composition window/IME without disabling the subsystem.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ClearComposition")]
		internal static extern void SDLClearCompositionNative();

		/// <summary>		/// Dismiss the composition window/IME without disabling the subsystem.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ClearComposition")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLClearComposition()
		{
			SDLClearCompositionNative();
		}

		/// <summary>
		/// Returns if an IME Composite or Candidate window is currently shown.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsTextInputShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IsTextInputShown")]
		internal static extern SDLBool SDLIsTextInputShownNative();

		/// <summary>		/// Returns if an IME Composite or Candidate window is currently shown.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsTextInputShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsTextInputShown()
		{
			SDLBool ret = SDLIsTextInputShownNative();
			return ret;
		}

		/// <summary>
		/// Set the rectangle used to type Unicode text inputs.<br/>
		/// To start text input in a given location, this function is intended to be<br/>
		/// called before SDL_StartTextInput, although some platforms support moving<br/>
		/// the rectangle even while text input (and a composition) is active.<br/>
		/// Note: If you want to use the system native IME window, try setting hint<br/>
		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>
		/// any feedback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextInputRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetTextInputRect")]
		internal static extern void SDLSetTextInputRectNative([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Set the rectangle used to type Unicode text inputs.<br/>		/// To start text input in a given location, this function is intended to be<br/>		/// called before SDL_StartTextInput, although some platforms support moving<br/>		/// the rectangle even while text input (and a composition) is active.<br/>		/// Note: If you want to use the system native IME window, try setting hint<br/>		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>		/// any feedback.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextInputRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetTextInputRect([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			SDLSetTextInputRectNative(rect);
		}

		/// <summary>		/// Set the rectangle used to type Unicode text inputs.<br/>		/// To start text input in a given location, this function is intended to be<br/>		/// called before SDL_StartTextInput, although some platforms support moving<br/>		/// the rectangle even while text input (and a composition) is active.<br/>		/// Note: If you want to use the system native IME window, try setting hint<br/>		/// **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you<br/>		/// any feedback.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextInputRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetTextInputRect([NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLSetTextInputRectNative((SDLRect*)prect);
			}
		}

		/// <summary>
		/// Check whether the platform has screen keyboard support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasScreenKeyboardSupport")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasScreenKeyboardSupport")]
		internal static extern SDLBool SDLHasScreenKeyboardSupportNative();

		/// <summary>		/// Check whether the platform has screen keyboard support.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasScreenKeyboardSupport")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasScreenKeyboardSupport()
		{
			SDLBool ret = SDLHasScreenKeyboardSupportNative();
			return ret;
		}

		/// <summary>
		/// Check whether the screen keyboard is shown for given window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IsScreenKeyboardShown")]
		internal static extern SDLBool SDLIsScreenKeyboardShownNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Check whether the screen keyboard is shown for given window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsScreenKeyboardShown([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLBool ret = SDLIsScreenKeyboardShownNative(window);
			return ret;
		}

		/// <summary>		/// Check whether the screen keyboard is shown for given window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsScreenKeyboardShown")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsScreenKeyboardShown([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = SDLIsScreenKeyboardShownNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window which currently has mouse focus.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetMouseFocus")]
		internal static extern SDLWindow* SDLGetMouseFocusNative();

		/// <summary>		/// Get the window which currently has mouse focus.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseFocus")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLGetMouseFocus()
		{
			SDLWindow* ret = SDLGetMouseFocusNative();
			return ret;
		}

		/// <summary>
		/// Retrieve the current state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
		/// either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetMouseState")]
		internal static extern uint SDLGetMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y);

		/// <summary>		/// Retrieve the current state of the mouse.<br/>		/// The current button state is returned as a button bitmask, which can be<br/>		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>		/// either `x` or `y`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			uint ret = SDLGetMouseStateNative(x, y);
			return ret;
		}

		/// <summary>		/// Retrieve the current state of the mouse.<br/>		/// The current button state is returned as a button bitmask, which can be<br/>		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>		/// either `x` or `y`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = SDLGetMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>		/// Retrieve the current state of the mouse.<br/>		/// The current button state is returned as a button bitmask, which can be<br/>		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>		/// either `x` or `y`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = SDLGetMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>		/// Retrieve the current state of the mouse.<br/>		/// The current button state is returned as a button bitmask, which can be<br/>		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>		/// mouse cursor position relative to the focus window. You can pass NULL for<br/>		/// either `x` or `y`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = SDLGetMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of the mouse in relation to the desktop.<br/>
		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
		/// reported relative to the top-left of the desktop. This can be useful if you<br/>
		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
		/// doesn't fit your needs. For example, it could be useful if you need to<br/>
		/// track the mouse while dragging a window, where coordinates relative to a<br/>
		/// window might not be in sync at all times.<br/>
		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
		/// from the last pump of the event queue. This function, however, queries the<br/>
		/// OS for the current mouse position, and as such, might be a slightly less<br/>
		/// efficient function. Unless you know what you're doing and have a good<br/>
		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetGlobalMouseState")]
		internal static extern uint SDLGetGlobalMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y);

		/// <summary>		/// Get the current state of the mouse in relation to the desktop.<br/>		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>		/// reported relative to the top-left of the desktop. This can be useful if you<br/>		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>		/// doesn't fit your needs. For example, it could be useful if you need to<br/>		/// track the mouse while dragging a window, where coordinates relative to a<br/>		/// window might not be in sync at all times.<br/>		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>		/// from the last pump of the event queue. This function, however, queries the<br/>		/// OS for the current mouse position, and as such, might be a slightly less<br/>		/// efficient function. Unless you know what you're doing and have a good<br/>		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			uint ret = SDLGetGlobalMouseStateNative(x, y);
			return ret;
		}

		/// <summary>		/// Get the current state of the mouse in relation to the desktop.<br/>		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>		/// reported relative to the top-left of the desktop. This can be useful if you<br/>		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>		/// doesn't fit your needs. For example, it could be useful if you need to<br/>		/// track the mouse while dragging a window, where coordinates relative to a<br/>		/// window might not be in sync at all times.<br/>		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>		/// from the last pump of the event queue. This function, however, queries the<br/>		/// OS for the current mouse position, and as such, might be a slightly less<br/>		/// efficient function. Unless you know what you're doing and have a good<br/>		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = SDLGetGlobalMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of the mouse in relation to the desktop.<br/>		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>		/// reported relative to the top-left of the desktop. This can be useful if you<br/>		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>		/// doesn't fit your needs. For example, it could be useful if you need to<br/>		/// track the mouse while dragging a window, where coordinates relative to a<br/>		/// window might not be in sync at all times.<br/>		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>		/// from the last pump of the event queue. This function, however, queries the<br/>		/// OS for the current mouse position, and as such, might be a slightly less<br/>		/// efficient function. Unless you know what you're doing and have a good<br/>		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = SDLGetGlobalMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of the mouse in relation to the desktop.<br/>		/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>		/// reported relative to the top-left of the desktop. This can be useful if you<br/>		/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>		/// doesn't fit your needs. For example, it could be useful if you need to<br/>		/// track the mouse while dragging a window, where coordinates relative to a<br/>		/// window might not be in sync at all times.<br/>		/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>		/// from the last pump of the event queue. This function, however, queries the<br/>		/// OS for the current mouse position, and as such, might be a slightly less<br/>		/// efficient function. Unless you know what you're doing and have a good<br/>		/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetGlobalMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetGlobalMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = SDLGetGlobalMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve the relative state of the mouse.<br/>
		/// The current button state is returned as a button bitmask, which can be<br/>
		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>
		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>
		/// event initialization. You can pass NULL for either `x` or `y`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRelativeMouseState")]
		internal static extern uint SDLGetRelativeMouseStateNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y);

		/// <summary>		/// Retrieve the relative state of the mouse.<br/>		/// The current button state is returned as a button bitmask, which can be<br/>		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>		/// event initialization. You can pass NULL for either `x` or `y`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			uint ret = SDLGetRelativeMouseStateNative(x, y);
			return ret;
		}

		/// <summary>		/// Retrieve the relative state of the mouse.<br/>		/// The current button state is returned as a button bitmask, which can be<br/>		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>		/// event initialization. You can pass NULL for either `x` or `y`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] int* y)
		{
			fixed (int* px = &x)
			{
				uint ret = SDLGetRelativeMouseStateNative((int*)px, y);
				return ret;
			}
		}

		/// <summary>		/// Retrieve the relative state of the mouse.<br/>		/// The current button state is returned as a button bitmask, which can be<br/>		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>		/// event initialization. You can pass NULL for either `x` or `y`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] int* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* py = &y)
			{
				uint ret = SDLGetRelativeMouseStateNative(x, (int*)py);
				return ret;
			}
		}

		/// <summary>		/// Retrieve the relative state of the mouse.<br/>		/// The current button state is returned as a button bitmask, which can be<br/>		/// tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the<br/>		/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>		/// mouse deltas since the last call to SDL_GetRelativeMouseState() or since<br/>		/// event initialization. You can pass NULL for either `x` or `y`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseState")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetRelativeMouseState([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int*")] ref int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int*")] ref int y)
		{
			fixed (int* px = &x)
			{
				fixed (int* py = &y)
				{
					uint ret = SDLGetRelativeMouseStateNative((int*)px, (int*)py);
					return ret;
				}
			}
		}

		/// <summary>
		/// Move the mouse cursor to the given position within the window.<br/>
		/// This function generates a mouse motion event if relative mode is not<br/>
		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WarpMouseInWindow")]
		internal static extern void SDLWarpMouseInWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y);

		/// <summary>		/// Move the mouse cursor to the given position within the window.<br/>		/// This function generates a mouse motion event if relative mode is not<br/>		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>		/// Note that this function will appear to succeed, but not actually move the<br/>		/// mouse when used over Microsoft Remote Desktop.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWarpMouseInWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			SDLWarpMouseInWindowNative(window, x, y);
		}

		/// <summary>		/// Move the mouse cursor to the given position within the window.<br/>		/// This function generates a mouse motion event if relative mode is not<br/>		/// enabled. If relative mode is enabled, you can force mouse events for the<br/>		/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>		/// Note that this function will appear to succeed, but not actually move the<br/>		/// mouse when used over Microsoft Remote Desktop.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WarpMouseInWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLWarpMouseInWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLWarpMouseInWindowNative((SDLWindow*)pwindow, x, y);
			}
		}

		/// <summary>
		/// Move the mouse to the given position in global screen space.<br/>
		/// This function generates a mouse motion event.<br/>
		/// A failure of this function usually means that it is unsupported by a<br/>
		/// platform.<br/>
		/// Note that this function will appear to succeed, but not actually move the<br/>
		/// mouse when used over Microsoft Remote Desktop.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WarpMouseGlobal")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WarpMouseGlobal")]
		internal static extern int SDLWarpMouseGlobalNative([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y);

		/// <summary>		/// Move the mouse to the given position in global screen space.<br/>		/// This function generates a mouse motion event.<br/>		/// A failure of this function usually means that it is unsupported by a<br/>		/// platform.<br/>		/// Note that this function will appear to succeed, but not actually move the<br/>		/// mouse when used over Microsoft Remote Desktop.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WarpMouseGlobal")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWarpMouseGlobal([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			int ret = SDLWarpMouseGlobalNative(x, y);
			return ret;
		}

		/// <summary>
		/// Set relative mouse mode.<br/>
		/// While the mouse is in relative mode, the cursor is hidden, the mouse<br/>
		/// position is constrained to the window, and SDL will report continuous<br/>
		/// relative mouse motion even if the mouse is at the edge of the window.<br/>
		/// This function will flush any pending mouse motion.<br/>
		/// <br/>
		/// If relative mode is not supported, this returns -1.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetRelativeMouseMode")]
		internal static extern int SDLSetRelativeMouseModeNative([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled);

		/// <summary>		/// Set relative mouse mode.<br/>		/// While the mouse is in relative mode, the cursor is hidden, the mouse<br/>		/// position is constrained to the window, and SDL will report continuous<br/>		/// relative mouse motion even if the mouse is at the edge of the window.<br/>		/// This function will flush any pending mouse motion.<br/>		/// <br/>		/// If relative mode is not supported, this returns -1.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRelativeMouseMode([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			int ret = SDLSetRelativeMouseModeNative(enabled);
			return ret;
		}

		/// <summary>
		/// Capture the mouse and to track input outside an SDL window.<br/>
		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
		/// within your window. Not all video targets support this function. When<br/>
		/// capturing is enabled, the current window will get all mouse events, but<br/>
		/// unlike relative mode, no change is made to the cursor and it is not<br/>
		/// restrained to your window.<br/>
		/// This function may also deny mouse input to other windows--both those in<br/>
		/// your application and others on the system--so you should use this function<br/>
		/// sparingly, and in small bursts. For example, you might want to track the<br/>
		/// mouse while the user is dragging something, until the user releases a mouse<br/>
		/// button. It is not recommended that you capture the mouse for long periods<br/>
		/// of time, such as the entire time your app is running. For that, you should<br/>
		/// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending<br/>
		/// on your goals.<br/>
		/// While captured, mouse events still report coordinates relative to the<br/>
		/// current (foreground) window, but those coordinates may be outside the<br/>
		/// bounds of the window (including negative values). Capturing is only allowed<br/>
		/// for the foreground window. If the window loses focus while capturing, the<br/>
		/// capture will be disabled automatically.<br/>
		/// While capturing is enabled, the current window will have the<br/>
		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
		/// Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the<br/>
		/// mouse while the user is pressing a button; this is to try and make mouse<br/>
		/// behavior more consistent between platforms, and deal with the common case<br/>
		/// of a user dragging the mouse outside of the window. This means that if you<br/>
		/// are calling SDL_CaptureMouse() only to deal with this situation, you no<br/>
		/// longer have to (although it is safe to do so). If this causes problems for<br/>
		/// your app, you can disable auto capture by setting the<br/>
		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CaptureMouse")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CaptureMouse")]
		internal static extern int SDLCaptureMouseNative([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled);

		/// <summary>		/// Capture the mouse and to track input outside an SDL window.<br/>		/// Capturing enables your app to obtain mouse events globally, instead of just<br/>		/// within your window. Not all video targets support this function. When<br/>		/// capturing is enabled, the current window will get all mouse events, but<br/>		/// unlike relative mode, no change is made to the cursor and it is not<br/>		/// restrained to your window.<br/>		/// This function may also deny mouse input to other windows--both those in<br/>		/// your application and others on the system--so you should use this function<br/>		/// sparingly, and in small bursts. For example, you might want to track the<br/>		/// mouse while the user is dragging something, until the user releases a mouse<br/>		/// button. It is not recommended that you capture the mouse for long periods<br/>		/// of time, such as the entire time your app is running. For that, you should<br/>		/// probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending<br/>		/// on your goals.<br/>		/// While captured, mouse events still report coordinates relative to the<br/>		/// current (foreground) window, but those coordinates may be outside the<br/>		/// bounds of the window (including negative values). Capturing is only allowed<br/>		/// for the foreground window. If the window loses focus while capturing, the<br/>		/// capture will be disabled automatically.<br/>		/// While capturing is enabled, the current window will have the<br/>		/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>		/// Please note that as of SDL 2.0.22, SDL will attempt to "auto capture" the<br/>		/// mouse while the user is pressing a button; this is to try and make mouse<br/>		/// behavior more consistent between platforms, and deal with the common case<br/>		/// of a user dragging the mouse outside of the window. This means that if you<br/>		/// are calling SDL_CaptureMouse() only to deal with this situation, you no<br/>		/// longer have to (although it is safe to do so). If this causes problems for<br/>		/// your app, you can disable auto capture by setting the<br/>		/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CaptureMouse")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCaptureMouse([NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			int ret = SDLCaptureMouseNative(enabled);
			return ret;
		}

		/// <summary>
		/// Query whether relative mouse mode is enabled.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRelativeMouseMode")]
		internal static extern SDLBool SDLGetRelativeMouseModeNative();

		/// <summary>		/// Query whether relative mouse mode is enabled.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRelativeMouseMode")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetRelativeMouseMode()
		{
			SDLBool ret = SDLGetRelativeMouseModeNative();
			return ret;
		}

		/// <summary>
		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
		/// The cursor is created in black and white according to the following:<br/>
		/// - data=0, mask=1: white<br/>
		/// - data=1, mask=1: black<br/>
		/// - data=0, mask=0: transparent<br/>
		/// - data=1, mask=0: inverted color if possible, black if not.<br/>
		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>
		/// If you want to have a color cursor, or create your cursor from an<br/>
		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
		/// will be bound to the framerate.<br/>
		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>
		/// provides twelve readily available system cursors to pick from.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateCursor")]
		internal static extern SDLCursor* SDLCreateCursorNative([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY);

		/// <summary>		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>		/// The cursor is created in black and white according to the following:<br/>		/// - data=0, mask=1: white<br/>		/// - data=1, mask=1: black<br/>		/// - data=0, mask=0: transparent<br/>		/// - data=1, mask=0: inverted color if possible, black if not.<br/>		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>		/// If you want to have a color cursor, or create your cursor from an<br/>		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>		/// will be bound to the framerate.<br/>		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>		/// provides twelve readily available system cursors to pick from.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			SDLCursor* ret = SDLCreateCursorNative(data, mask, w, h, hotX, hotY);
			return ret;
		}

		/// <summary>		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>		/// The cursor is created in black and white according to the following:<br/>		/// - data=0, mask=1: white<br/>		/// - data=1, mask=1: black<br/>		/// - data=0, mask=0: transparent<br/>		/// - data=1, mask=0: inverted color if possible, black if not.<br/>		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>		/// If you want to have a color cursor, or create your cursor from an<br/>		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>		/// will be bound to the framerate.<br/>		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>		/// provides twelve readily available system cursors to pick from.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pdata = &data)
			{
				SDLCursor* ret = SDLCreateCursorNative((byte*)pdata, mask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>		/// The cursor is created in black and white according to the following:<br/>		/// - data=0, mask=1: white<br/>		/// - data=1, mask=1: black<br/>		/// - data=0, mask=0: transparent<br/>		/// - data=1, mask=0: inverted color if possible, black if not.<br/>		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>		/// If you want to have a color cursor, or create your cursor from an<br/>		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>		/// will be bound to the framerate.<br/>		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>		/// provides twelve readily available system cursors to pick from.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pmask = &mask)
			{
				SDLCursor* ret = SDLCreateCursorNative(data, (byte*)pmask, w, h, hotX, hotY);
				return ret;
			}
		}

		/// <summary>		/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>		/// `mask` has to be in MSB (Most Significant Bit) format.<br/>		/// The cursor width (`w`) must be a multiple of 8 bits.<br/>		/// The cursor is created in black and white according to the following:<br/>		/// - data=0, mask=1: white<br/>		/// - data=1, mask=1: black<br/>		/// - data=0, mask=0: transparent<br/>		/// - data=1, mask=0: inverted color if possible, black if not.<br/>		/// Cursors created with this function must be freed with SDL_FreeCursor().<br/>		/// If you want to have a color cursor, or create your cursor from an<br/>		/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>		/// hide the cursor and draw your own as part of your game's rendering, but it<br/>		/// will be bound to the framerate.<br/>		/// Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which<br/>		/// provides twelve readily available system cursors to pick from.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateCursor([NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte data, [NativeName(NativeNameType.Param, "mask")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte mask, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (byte* pdata = &data)
			{
				fixed (byte* pmask = &mask)
				{
					SDLCursor* ret = SDLCreateCursorNative((byte*)pdata, (byte*)pmask, w, h, hotX, hotY);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a color cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateColorCursor")]
		internal static extern SDLCursor* SDLCreateColorCursorNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY);

		/// <summary>		/// Create a color cursor.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateColorCursor([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			SDLCursor* ret = SDLCreateColorCursorNative(surface, hotX, hotY);
			return ret;
		}

		/// <summary>		/// Create a color cursor.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateColorCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateColorCursor([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "hot_x")] [NativeName(NativeNameType.Type, "int")] int hotX, [NativeName(NativeNameType.Param, "hot_y")] [NativeName(NativeNameType.Type, "int")] int hotY)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLCursor* ret = SDLCreateColorCursorNative((SDLSurface*)psurface, hotX, hotY);
				return ret;
			}
		}

		/// <summary>
		/// Create a system cursor.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSystemCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateSystemCursor")]
		internal static extern SDLCursor* SDLCreateSystemCursorNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_SystemCursor")] SDLSystemCursor id);

		/// <summary>		/// Create a system cursor.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateSystemCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLCreateSystemCursor([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_SystemCursor")] SDLSystemCursor id)
		{
			SDLCursor* ret = SDLCreateSystemCursorNative(id);
			return ret;
		}

		/// <summary>
		/// Set the active cursor.<br/>
		/// This function sets the currently active cursor to the specified one. If the<br/>
		/// cursor is currently visible, the change will be immediately represented on<br/>
		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
		/// this is desired for any reason.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetCursor")]
		internal static extern void SDLSetCursorNative([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] SDLCursor* cursor);

		/// <summary>		/// Set the active cursor.<br/>		/// This function sets the currently active cursor to the specified one. If the<br/>		/// cursor is currently visible, the change will be immediately represented on<br/>		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>		/// this is desired for any reason.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] SDLCursor* cursor)
		{
			SDLSetCursorNative(cursor);
		}

		/// <summary>		/// Set the active cursor.<br/>		/// This function sets the currently active cursor to the specified one. If the<br/>		/// cursor is currently visible, the change will be immediately represented on<br/>		/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>		/// this is desired for any reason.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				SDLSetCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Get the active cursor.<br/>
		/// This function returns a pointer to the current cursor which is owned by the<br/>
		/// library. It is not necessary to free the cursor with SDL_FreeCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetCursor")]
		internal static extern SDLCursor* SDLGetCursorNative();

		/// <summary>		/// Get the active cursor.<br/>		/// This function returns a pointer to the current cursor which is owned by the<br/>		/// library. It is not necessary to free the cursor with SDL_FreeCursor().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLGetCursor()
		{
			SDLCursor* ret = SDLGetCursorNative();
			return ret;
		}

		/// <summary>
		/// Get the default cursor.<br/>
		/// You do not have to call SDL_FreeCursor() on the return value, but it is<br/>
		/// safe to do so.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetDefaultCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetDefaultCursor")]
		internal static extern SDLCursor* SDLGetDefaultCursorNative();

		/// <summary>		/// Get the default cursor.<br/>		/// You do not have to call SDL_FreeCursor() on the return value, but it is<br/>		/// safe to do so.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetDefaultCursor")]
		[return: NativeName(NativeNameType.Type, "SDL_Cursor*")]
		public static SDLCursor* SDLGetDefaultCursor()
		{
			SDLCursor* ret = SDLGetDefaultCursorNative();
			return ret;
		}

		/// <summary>
		/// Free a previously-created cursor.<br/>
		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FreeCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FreeCursor")]
		internal static extern void SDLFreeCursorNative([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] SDLCursor* cursor);

		/// <summary>		/// Free a previously-created cursor.<br/>		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] SDLCursor* cursor)
		{
			SDLFreeCursorNative(cursor);
		}

		/// <summary>		/// Free a previously-created cursor.<br/>		/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>		/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FreeCursor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFreeCursor([NativeName(NativeNameType.Param, "cursor")] [NativeName(NativeNameType.Type, "SDL_Cursor*")] ref SDLCursor cursor)
		{
			fixed (SDLCursor* pcursor = &cursor)
			{
				SDLFreeCursorNative((SDLCursor*)pcursor);
			}
		}

		/// <summary>
		/// Toggle whether or not the cursor is shown.<br/>
		/// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`<br/>
		/// displays the cursor and passing `SDL_DISABLE` hides it.<br/>
		/// The current state of the mouse cursor can be queried by passing<br/>
		/// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ShowCursor")]
		internal static extern int SDLShowCursorNative([NativeName(NativeNameType.Param, "toggle")] [NativeName(NativeNameType.Type, "int")] int toggle);

		/// <summary>		/// Toggle whether or not the cursor is shown.<br/>		/// The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`<br/>		/// displays the cursor and passing `SDL_DISABLE` hides it.<br/>		/// The current state of the mouse cursor can be queried by passing<br/>		/// `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowCursor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowCursor([NativeName(NativeNameType.Param, "toggle")] [NativeName(NativeNameType.Type, "int")] int toggle)
		{
			int ret = SDLShowCursorNative(toggle);
			return ret;
		}

		/// <summary>
		/// Get an ASCII string representation for a given ::SDL_GUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GUIDToString")]
		internal static extern void SDLGUIDToStringNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdL_Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID);

		/// <summary>		/// Get an ASCII string representation for a given ::SDL_GUID.<br/>		/// You should supply at least 33 bytes for pszGUID.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdL_Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			SDLGUIDToStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>		/// Get an ASCII string representation for a given ::SDL_GUID.<br/>		/// You should supply at least 33 bytes for pszGUID.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdL_Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] ref byte pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				SDLGUIDToStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>		/// Get an ASCII string representation for a given ::SDL_GUID.<br/>		/// You should supply at least 33 bytes for pszGUID.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDToString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGUIDToString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_GUID")] SdL_Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] ref string pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGUIDToStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a ::SDL_GUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GUIDFromString")]
		internal static extern SdL_Guid SDLGUIDFromStringNative([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] byte* pchGUID);

		/// <summary>		/// Convert a GUID string into a ::SDL_GUID structure.<br/>		/// Performs no error checking. If this function is given a string containing<br/>		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>		/// will not be useful.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdL_Guid SDLGUIDFromString([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] byte* pchGUID)
		{
			SdL_Guid ret = SDLGUIDFromStringNative(pchGUID);
			return ret;
		}

		/// <summary>		/// Convert a GUID string into a ::SDL_GUID structure.<br/>		/// Performs no error checking. If this function is given a string containing<br/>		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>		/// will not be useful.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdL_Guid SDLGUIDFromString([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] ref byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				SdL_Guid ret = SDLGUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>		/// Convert a GUID string into a ::SDL_GUID structure.<br/>		/// Performs no error checking. If this function is given a string containing<br/>		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>		/// will not be useful.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GUID")]
		public static SdL_Guid SDLGUIDFromString([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SdL_Guid ret = SDLGUIDFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Locking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// As of SDL 2.26.0, you can take the joystick lock around reinitializing the<br/>
		/// joystick subsystem, to prevent other threads from seeing joysticks in an<br/>
		/// uninitialized state. However, all open joysticks will be closed and SDL<br/>
		/// functions called with them will fail.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LockJoysticks")]
		internal static extern void SDLLockJoysticksNative();

		/// <summary>		/// Locking for multi-threaded access to the joystick API<br/>		/// If you are using the joystick API or handling events from multiple threads<br/>		/// you should use these locking functions to protect access to the joysticks.<br/>		/// In particular, you are guaranteed that the joystick list won't change, so<br/>		/// the API functions that take a joystick index will be valid, and joystick<br/>		/// and game controller events will not be delivered.<br/>		/// As of SDL 2.26.0, you can take the joystick lock around reinitializing the<br/>		/// joystick subsystem, to prevent other threads from seeing joysticks in an<br/>		/// uninitialized state. However, all open joysticks will be closed and SDL<br/>		/// functions called with them will fail.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLockJoysticks()
		{
			SDLLockJoysticksNative();
		}

		/// <summary>
		/// Unlocking for multi-threaded access to the joystick API<br/>
		/// If you are using the joystick API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the joysticks.<br/>
		/// In particular, you are guaranteed that the joystick list won't change, so<br/>
		/// the API functions that take a joystick index will be valid, and joystick<br/>
		/// and game controller events will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnlockJoysticks")]
		internal static extern void SDLUnlockJoysticksNative();

		/// <summary>		/// Unlocking for multi-threaded access to the joystick API<br/>		/// If you are using the joystick API or handling events from multiple threads<br/>		/// you should use these locking functions to protect access to the joysticks.<br/>		/// In particular, you are guaranteed that the joystick list won't change, so<br/>		/// the API functions that take a joystick index will be valid, and joystick<br/>		/// and game controller events will not be delivered.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockJoysticks")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockJoysticks()
		{
			SDLUnlockJoysticksNative();
		}

		/// <summary>
		/// Count the number of joysticks attached to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_NumJoysticks")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_NumJoysticks")]
		internal static extern int SDLNumJoysticksNative();

		/// <summary>		/// Count the number of joysticks attached to the system.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_NumJoysticks")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLNumJoysticks()
		{
			int ret = SDLNumJoysticksNative();
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickNameForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickNameForIndex")]
		internal static extern byte* SDLJoystickNameForIndexNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the implementation dependent name of a joystick.<br/>		/// This can be called before any joysticks are opened.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNameForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickNameForIndex([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			byte* ret = SDLJoystickNameForIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>		/// Get the implementation dependent name of a joystick.<br/>		/// This can be called before any joysticks are opened.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNameForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickNameForIndexS([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickNameForIndexNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickPathForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickPathForIndex")]
		internal static extern byte* SDLJoystickPathForIndexNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the implementation dependent path of a joystick.<br/>		/// This can be called before any joysticks are opened.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPathForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickPathForIndex([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			byte* ret = SDLJoystickPathForIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>		/// Get the implementation dependent path of a joystick.<br/>		/// This can be called before any joysticks are opened.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPathForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickPathForIndexS([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickPathForIndexNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the player index of a joystick, or -1 if it's not available This can be<br/>
		/// called before any joysticks are opened.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDevicePlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetDevicePlayerIndex")]
		internal static extern int SDLJoystickGetDevicePlayerIndexNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the player index of a joystick, or -1 if it's not available This can be<br/>		/// called before any joysticks are opened.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDevicePlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetDevicePlayerIndex([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			int ret = SDLJoystickGetDevicePlayerIndexNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick at a given device<br/>
		/// index.<br/>
		/// This function can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetDeviceGUID")]
		internal static extern Guid SDLJoystickGetDeviceGUIDNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the implementation-dependent GUID for the joystick at a given device<br/>		/// index.<br/>		/// This function can be called before any joysticks are opened.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		public static Guid SDLJoystickGetDeviceGUID([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			Guid ret = SDLJoystickGetDeviceGUIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the USB vendor ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetDeviceVendor")]
		internal static extern ushort SDLJoystickGetDeviceVendorNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the USB vendor ID of a joystick, if available.<br/>		/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>		/// available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetDeviceVendor([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			ushort ret = SDLJoystickGetDeviceVendorNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the USB product ID of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product ID isn't<br/>
		/// available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetDeviceProduct")]
		internal static extern ushort SDLJoystickGetDeviceProductNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the USB product ID of a joystick, if available.<br/>		/// This can be called before any joysticks are opened. If the product ID isn't<br/>		/// available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetDeviceProduct([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			ushort ret = SDLJoystickGetDeviceProductNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the product version of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened. If the product version<br/>
		/// isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetDeviceProductVersion")]
		internal static extern ushort SDLJoystickGetDeviceProductVersionNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the product version of a joystick, if available.<br/>		/// This can be called before any joysticks are opened. If the product version<br/>		/// isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetDeviceProductVersion([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			ushort ret = SDLJoystickGetDeviceProductVersionNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the type of a joystick, if available.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetDeviceType")]
		internal static extern SDLJoystickType SDLJoystickGetDeviceTypeNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the type of a joystick, if available.<br/>		/// This can be called before any joysticks are opened.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType SDLJoystickGetDeviceType([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			SDLJoystickType ret = SDLJoystickGetDeviceTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a joystick.<br/>
		/// This can be called before any joysticks are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetDeviceInstanceID")]
		internal static extern int SDLJoystickGetDeviceInstanceIDNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the instance ID of a joystick.<br/>		/// This can be called before any joysticks are opened.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetDeviceInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int SDLJoystickGetDeviceInstanceID([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			int ret = SDLJoystickGetDeviceInstanceIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Open a joystick for use.<br/>
		/// The `device_index` argument refers to the N'th joystick presently<br/>
		/// recognized by SDL on the system. It is **NOT** the same as the instance ID<br/>
		/// used to identify the joystick in future events. See<br/>
		/// SDL_JoystickInstanceID() for more details about instance IDs.<br/>
		/// The joystick subsystem must be initialized before a joystick can be opened<br/>
		/// for use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickOpen")]
		internal static extern SDLJoystick* SDLJoystickOpenNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Open a joystick for use.<br/>		/// The `device_index` argument refers to the N'th joystick presently<br/>		/// recognized by SDL on the system. It is **NOT** the same as the instance ID<br/>		/// used to identify the joystick in future events. See<br/>		/// SDL_JoystickInstanceID() for more details about instance IDs.<br/>		/// The joystick subsystem must be initialized before a joystick can be opened<br/>		/// for use.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		public static SDLJoystick* SDLJoystickOpen([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			SDLJoystick* ret = SDLJoystickOpenNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickFromInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickFromInstanceID")]
		internal static extern SDLJoystick* SDLJoystickFromInstanceIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId);

		/// <summary>		/// Get the SDL_Joystick associated with an instance id.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickFromInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		public static SDLJoystick* SDLJoystickFromInstanceID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int instanceId)
		{
			SDLJoystick* ret = SDLJoystickFromInstanceIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the SDL_Joystick associated with a player index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickFromPlayerIndex")]
		internal static extern SDLJoystick* SDLJoystickFromPlayerIndexNative([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex);

		/// <summary>		/// Get the SDL_Joystick associated with a player index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		public static SDLJoystick* SDLJoystickFromPlayerIndex([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			SDLJoystick* ret = SDLJoystickFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtual")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickAttachVirtual")]
		internal static extern int SDLJoystickAttachVirtualNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_JoystickType")] SDLJoystickType type, [NativeName(NativeNameType.Param, "naxes")] [NativeName(NativeNameType.Type, "int")] int naxes, [NativeName(NativeNameType.Param, "nbuttons")] [NativeName(NativeNameType.Type, "int")] int nbuttons, [NativeName(NativeNameType.Param, "nhats")] [NativeName(NativeNameType.Type, "int")] int nhats);

		/// <summary>		/// Attach a new virtual joystick.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickAttachVirtual([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_JoystickType")] SDLJoystickType type, [NativeName(NativeNameType.Param, "naxes")] [NativeName(NativeNameType.Type, "int")] int naxes, [NativeName(NativeNameType.Param, "nbuttons")] [NativeName(NativeNameType.Type, "int")] int nbuttons, [NativeName(NativeNameType.Param, "nhats")] [NativeName(NativeNameType.Type, "int")] int nhats)
		{
			int ret = SDLJoystickAttachVirtualNative(type, naxes, nbuttons, nhats);
			return ret;
		}

		/// <summary>
		/// Attach a new virtual joystick with extended properties.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtualEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickAttachVirtualEx")]
		internal static extern int SDLJoystickAttachVirtualExNative([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "const SDL_VirtualJoystickDesc*")] SDLVirtualJoystickDesc* desc);

		/// <summary>		/// Attach a new virtual joystick with extended properties.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtualEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickAttachVirtualEx([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "const SDL_VirtualJoystickDesc*")] SDLVirtualJoystickDesc* desc)
		{
			int ret = SDLJoystickAttachVirtualExNative(desc);
			return ret;
		}

		/// <summary>		/// Attach a new virtual joystick with extended properties.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickAttachVirtualEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickAttachVirtualEx([NativeName(NativeNameType.Param, "desc")] [NativeName(NativeNameType.Type, "const SDL_VirtualJoystickDesc*")] ref SDLVirtualJoystickDesc desc)
		{
			fixed (SDLVirtualJoystickDesc* pdesc = &desc)
			{
				int ret = SDLJoystickAttachVirtualExNative((SDLVirtualJoystickDesc*)pdesc);
				return ret;
			}
		}

		/// <summary>
		/// Detach a virtual joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickDetachVirtual")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickDetachVirtual")]
		internal static extern int SDLJoystickDetachVirtualNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Detach a virtual joystick.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickDetachVirtual")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickDetachVirtual([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			int ret = SDLJoystickDetachVirtualNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Query whether or not the joystick at a given device index is virtual.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickIsVirtual")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickIsVirtual")]
		internal static extern SDLBool SDLJoystickIsVirtualNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Query whether or not the joystick at a given device index is virtual.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickIsVirtual")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickIsVirtual([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			SDLBool ret = SDLJoystickIsVirtualNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's axis.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// Note that when sending trigger axes, you should scale the value to the full<br/>
		/// range of Sint16. For example, a trigger at rest would have the value of<br/>
		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickSetVirtualAxis")]
		internal static extern int SDLJoystickSetVirtualAxisNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value);

		/// <summary>		/// Set values on an opened, virtual-joystick's axis.<br/>		/// Please note that values set here will not be applied until the next call to<br/>		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>		/// indirectly through various other SDL APIs, including, but not limited to<br/>		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>		/// SDL_WaitEvent.<br/>		/// Note that when sending trigger axes, you should scale the value to the full<br/>		/// range of Sint16. For example, a trigger at rest would have the value of<br/>		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			int ret = SDLJoystickSetVirtualAxisNative(joystick, axis, value);
			return ret;
		}

		/// <summary>		/// Set values on an opened, virtual-joystick's axis.<br/>		/// Please note that values set here will not be applied until the next call to<br/>		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>		/// indirectly through various other SDL APIs, including, but not limited to<br/>		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>		/// SDL_WaitEvent.<br/>		/// Note that when sending trigger axes, you should scale the value to the full<br/>		/// range of Sint16. For example, a trigger at rest would have the value of<br/>		/// `SDL_JOYSTICK_AXIS_MIN`.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualAxis")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Sint16")] short value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickSetVirtualAxisNative((SDLJoystick*)pjoystick, axis, value);
				return ret;
			}
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's button.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualButton")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickSetVirtualButton")]
		internal static extern int SDLJoystickSetVirtualButtonNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value);

		/// <summary>		/// Set values on an opened, virtual-joystick's button.<br/>		/// Please note that values set here will not be applied until the next call to<br/>		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>		/// indirectly through various other SDL APIs, including, but not limited to<br/>		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>		/// SDL_WaitEvent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualButton")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			int ret = SDLJoystickSetVirtualButtonNative(joystick, button, value);
			return ret;
		}

		/// <summary>		/// Set values on an opened, virtual-joystick's button.<br/>		/// Please note that values set here will not be applied until the next call to<br/>		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>		/// indirectly through various other SDL APIs, including, but not limited to<br/>		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>		/// SDL_WaitEvent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualButton")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickSetVirtualButtonNative((SDLJoystick*)pjoystick, button, value);
				return ret;
			}
		}

		/// <summary>
		/// Set values on an opened, virtual-joystick's hat.<br/>
		/// Please note that values set here will not be applied until the next call to<br/>
		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>
		/// indirectly through various other SDL APIs, including, but not limited to<br/>
		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
		/// SDL_WaitEvent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualHat")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickSetVirtualHat")]
		internal static extern int SDLJoystickSetVirtualHatNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value);

		/// <summary>		/// Set values on an opened, virtual-joystick's hat.<br/>		/// Please note that values set here will not be applied until the next call to<br/>		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>		/// indirectly through various other SDL APIs, including, but not limited to<br/>		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>		/// SDL_WaitEvent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualHat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			int ret = SDLJoystickSetVirtualHatNative(joystick, hat, value);
			return ret;
		}

		/// <summary>		/// Set values on an opened, virtual-joystick's hat.<br/>		/// Please note that values set here will not be applied until the next call to<br/>		/// SDL_JoystickUpdate, which can either be called directly, or can be called<br/>		/// indirectly through various other SDL APIs, including, but not limited to<br/>		/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>		/// SDL_WaitEvent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetVirtualHat")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetVirtualHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "Uint8")] byte value)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickSetVirtualHatNative((SDLJoystick*)pjoystick, hat, value);
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent name of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickName")]
		internal static extern byte* SDLJoystickNameNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the implementation dependent name of a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickName([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			byte* ret = SDLJoystickNameNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the implementation dependent name of a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickNameS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickNameNative(joystick));
			return ret;
		}

		/// <summary>		/// Get the implementation dependent name of a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickName([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = SDLJoystickNameNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>		/// Get the implementation dependent name of a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickNameS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(SDLJoystickNameNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation dependent path of a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickPath")]
		internal static extern byte* SDLJoystickPathNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the implementation dependent path of a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickPath([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			byte* ret = SDLJoystickPathNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the implementation dependent path of a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickPathS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickPathNative(joystick));
			return ret;
		}

		/// <summary>		/// Get the implementation dependent path of a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickPath([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = SDLJoystickPathNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>		/// Get the implementation dependent path of a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickPathS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(SDLJoystickPathNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened joystick.<br/>
		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
		/// will not be able to supply this information.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetPlayerIndex")]
		internal static extern int SDLJoystickGetPlayerIndexNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the player index of an opened joystick.<br/>		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>		/// will not be able to supply this information.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			int ret = SDLJoystickGetPlayerIndexNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the player index of an opened joystick.<br/>		/// For XInput controllers this returns the XInput user index. Many joysticks<br/>		/// will not be able to supply this information.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickGetPlayerIndexNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickSetPlayerIndex")]
		internal static extern void SDLJoystickSetPlayerIndexNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex);

		/// <summary>		/// Set the player index of an opened joystick.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickSetPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			SDLJoystickSetPlayerIndexNative(joystick, playerIndex);
		}

		/// <summary>		/// Set the player index of an opened joystick.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickSetPlayerIndex([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickSetPlayerIndexNative((SDLJoystick*)pjoystick, playerIndex);
			}
		}

		/// <summary>
		/// Get the implementation-dependent GUID for the joystick.<br/>
		/// This function requires an open joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetGUID")]
		internal static extern Guid SDLJoystickGetGUIDNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the implementation-dependent GUID for the joystick.<br/>		/// This function requires an open joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		public static Guid SDLJoystickGetGUID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			Guid ret = SDLJoystickGetGUIDNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the implementation-dependent GUID for the joystick.<br/>		/// This function requires an open joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		public static Guid SDLJoystickGetGUID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				Guid ret = SDLJoystickGetGUIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened joystick, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetVendor")]
		internal static extern ushort SDLJoystickGetVendorNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the USB vendor ID of an opened joystick, if available.<br/>		/// If the vendor ID isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetVendor([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			ushort ret = SDLJoystickGetVendorNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the USB vendor ID of an opened joystick, if available.<br/>		/// If the vendor ID isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetVendor([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = SDLJoystickGetVendorNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened joystick, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetProduct")]
		internal static extern ushort SDLJoystickGetProductNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the USB product ID of an opened joystick, if available.<br/>		/// If the product ID isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetProduct([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			ushort ret = SDLJoystickGetProductNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the USB product ID of an opened joystick, if available.<br/>		/// If the product ID isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetProduct([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = SDLJoystickGetProductNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened joystick, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetProductVersion")]
		internal static extern ushort SDLJoystickGetProductVersionNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the product version of an opened joystick, if available.<br/>		/// If the product version isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetProductVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			ushort ret = SDLJoystickGetProductVersionNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the product version of an opened joystick, if available.<br/>		/// If the product version isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetProductVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = SDLJoystickGetProductVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened joystick, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetFirmwareVersion")]
		internal static extern ushort SDLJoystickGetFirmwareVersionNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the firmware version of an opened joystick, if available.<br/>		/// If the firmware version isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetFirmwareVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			ushort ret = SDLJoystickGetFirmwareVersionNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the firmware version of an opened joystick, if available.<br/>		/// If the firmware version isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLJoystickGetFirmwareVersion([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				ushort ret = SDLJoystickGetFirmwareVersionNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened joystick, if available.<br/>
		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetSerial")]
		internal static extern byte* SDLJoystickGetSerialNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the serial number of an opened joystick, if available.<br/>		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickGetSerial([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			byte* ret = SDLJoystickGetSerialNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the serial number of an opened joystick, if available.<br/>		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickGetSerialS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			string ret = Utils.DecodeStringUTF8(SDLJoystickGetSerialNative(joystick));
			return ret;
		}

		/// <summary>		/// Get the serial number of an opened joystick, if available.<br/>		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLJoystickGetSerial([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte* ret = SDLJoystickGetSerialNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>		/// Get the serial number of an opened joystick, if available.<br/>		/// Returns the serial number of the joystick, or NULL if it is not available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLJoystickGetSerialS([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				string ret = Utils.DecodeStringUTF8(SDLJoystickGetSerialNative((SDLJoystick*)pjoystick));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetType")]
		internal static extern SDLJoystickType SDLJoystickGetTypeNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the type of an opened joystick.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType SDLJoystickGetType([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			SDLJoystickType ret = SDLJoystickGetTypeNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the type of an opened joystick.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickType")]
		public static SDLJoystickType SDLJoystickGetType([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickType ret = SDLJoystickGetTypeNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>
		/// You should supply at least 33 bytes for pszGUID.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetGUIDString")]
		internal static extern void SDLJoystickGetGUIDStringNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID);

		/// <summary>		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>		/// You should supply at least 33 bytes for pszGUID.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickGetGUIDString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] byte* pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			SDLJoystickGetGUIDStringNative(guid, pszGUID, cbGUID);
		}

		/// <summary>		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>		/// You should supply at least 33 bytes for pszGUID.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickGetGUIDString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] ref byte pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			fixed (byte* ppszGUID = &pszGUID)
			{
				SDLJoystickGetGUIDStringNative(guid, (byte*)ppszGUID, cbGUID);
			}
		}

		/// <summary>		/// Get an ASCII string representation for a given SDL_JoystickGUID.<br/>		/// You should supply at least 33 bytes for pszGUID.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickGetGUIDString([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "pszGUID")] [NativeName(NativeNameType.Type, "char*")] ref string pszGUID, [NativeName(NativeNameType.Param, "cbGUID")] [NativeName(NativeNameType.Type, "int")] int cbGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pszGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pszGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pszGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLJoystickGetGUIDStringNative(guid, pStr0, cbGUID);
			pszGUID = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>
		/// Performs no error checking. If this function is given a string containing<br/>
		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
		/// will not be useful.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetGUIDFromString")]
		internal static extern Guid SDLJoystickGetGUIDFromStringNative([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] byte* pchGUID);

		/// <summary>		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>		/// Performs no error checking. If this function is given a string containing<br/>		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>		/// will not be useful.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		public static Guid SDLJoystickGetGUIDFromString([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] byte* pchGUID)
		{
			Guid ret = SDLJoystickGetGUIDFromStringNative(pchGUID);
			return ret;
		}

		/// <summary>		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>		/// Performs no error checking. If this function is given a string containing<br/>		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>		/// will not be useful.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		public static Guid SDLJoystickGetGUIDFromString([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] ref byte pchGUID)
		{
			fixed (byte* ppchGUID = &pchGUID)
			{
				Guid ret = SDLJoystickGetGUIDFromStringNative((byte*)ppchGUID);
				return ret;
			}
		}

		/// <summary>		/// Convert a GUID string into a SDL_JoystickGUID structure.<br/>		/// Performs no error checking. If this function is given a string containing<br/>		/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>		/// will not be useful.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetGUIDFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickGUID")]
		public static Guid SDLJoystickGetGUIDFromString([NativeName(NativeNameType.Param, "pchGUID")] [NativeName(NativeNameType.Type, "const char*")] string pchGUID)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pchGUID != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pchGUID);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pchGUID, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Guid ret = SDLJoystickGetGUIDFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetJoystickGUIDInfo")]
		internal static extern void SDLGetJoystickGUIDInfoNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* crc16);

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* crc16)
		{
			SDLGetJoystickGUIDInfoNative(guid, vendor, product, version, crc16);
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				SDLGetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, version, crc16);
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				SDLGetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, version, crc16);
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					SDLGetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, version, crc16);
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* crc16)
		{
			fixed (ushort* pversion = &version)
			{
				SDLGetJoystickGUIDInfoNative(guid, vendor, product, (ushort*)pversion, crc16);
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pversion = &version)
				{
					SDLGetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, (ushort*)pversion, crc16);
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pversion = &version)
				{
					SDLGetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, (ushort*)pversion, crc16);
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pversion = &version)
					{
						SDLGetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, (ushort*)pversion, crc16);
					}
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort crc16)
		{
			fixed (ushort* pcrc16 = &crc16)
			{
				SDLGetJoystickGUIDInfoNative(guid, vendor, product, version, (ushort*)pcrc16);
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					SDLGetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, version, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					SDLGetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, version, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						SDLGetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, version, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort crc16)
		{
			fixed (ushort* pversion = &version)
			{
				fixed (ushort* pcrc16 = &crc16)
				{
					SDLGetJoystickGUIDInfoNative(guid, vendor, product, (ushort*)pversion, (ushort*)pcrc16);
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pversion = &version)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						SDLGetJoystickGUIDInfoNative(guid, (ushort*)pvendor, product, (ushort*)pversion, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ushort* vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort crc16)
		{
			fixed (ushort* pproduct = &product)
			{
				fixed (ushort* pversion = &version)
				{
					fixed (ushort* pcrc16 = &crc16)
					{
						SDLGetJoystickGUIDInfoNative(guid, vendor, (ushort*)pproduct, (ushort*)pversion, (ushort*)pcrc16);
					}
				}
			}
		}

		/// <summary>		/// Get the device information encoded in a SDL_JoystickGUID structure<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetJoystickGUIDInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetJoystickGUIDInfo([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid, [NativeName(NativeNameType.Param, "vendor")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort vendor, [NativeName(NativeNameType.Param, "product")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort product, [NativeName(NativeNameType.Param, "version")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort version, [NativeName(NativeNameType.Param, "crc16")] [NativeName(NativeNameType.Type, "Uint16*")] ref ushort crc16)
		{
			fixed (ushort* pvendor = &vendor)
			{
				fixed (ushort* pproduct = &product)
				{
					fixed (ushort* pversion = &version)
					{
						fixed (ushort* pcrc16 = &crc16)
						{
							SDLGetJoystickGUIDInfoNative(guid, (ushort*)pvendor, (ushort*)pproduct, (ushort*)pversion, (ushort*)pcrc16);
						}
					}
				}
			}
		}

		/// <summary>
		/// Get the status of a specified joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetAttached")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetAttached")]
		internal static extern SDLBool SDLJoystickGetAttachedNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the status of a specified joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetAttached")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickGetAttached([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			SDLBool ret = SDLJoystickGetAttachedNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the status of a specified joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetAttached")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickGetAttached([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = SDLJoystickGetAttachedNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of an opened joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickInstanceID")]
		internal static extern int SDLJoystickInstanceIDNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the instance ID of an opened joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int SDLJoystickInstanceID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			int ret = SDLJoystickInstanceIDNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the instance ID of an opened joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickID")]
		public static int SDLJoystickInstanceID([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickInstanceIDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of general axis controls on a joystick.<br/>
		/// Often, the directional pad on a game controller will either look like 4<br/>
		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
		/// device and platform.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickNumAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickNumAxes")]
		internal static extern int SDLJoystickNumAxesNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the number of general axis controls on a joystick.<br/>		/// Often, the directional pad on a game controller will either look like 4<br/>		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>		/// device and platform.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNumAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickNumAxes([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			int ret = SDLJoystickNumAxesNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the number of general axis controls on a joystick.<br/>		/// Often, the directional pad on a game controller will either look like 4<br/>		/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>		/// device and platform.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNumAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickNumAxes([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickNumAxesNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of trackballs on a joystick.<br/>
		/// Joystick trackballs have only relative motion events associated with them<br/>
		/// and their state cannot be polled.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickNumBalls")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickNumBalls")]
		internal static extern int SDLJoystickNumBallsNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the number of trackballs on a joystick.<br/>		/// Joystick trackballs have only relative motion events associated with them<br/>		/// and their state cannot be polled.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNumBalls")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickNumBalls([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			int ret = SDLJoystickNumBallsNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the number of trackballs on a joystick.<br/>		/// Joystick trackballs have only relative motion events associated with them<br/>		/// and their state cannot be polled.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNumBalls")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickNumBalls([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickNumBallsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of POV hats on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickNumHats")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickNumHats")]
		internal static extern int SDLJoystickNumHatsNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the number of POV hats on a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNumHats")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickNumHats([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			int ret = SDLJoystickNumHatsNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the number of POV hats on a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNumHats")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickNumHats([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickNumHatsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of buttons on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickNumButtons")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickNumButtons")]
		internal static extern int SDLJoystickNumButtonsNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the number of buttons on a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNumButtons")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickNumButtons([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			int ret = SDLJoystickNumButtonsNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the number of buttons on a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickNumButtons")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickNumButtons([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickNumButtonsNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Update the current state of the open joysticks.<br/>
		/// This is called automatically by the event loop if any joystick events are<br/>
		/// enabled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickUpdate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickUpdate")]
		internal static extern void SDLJoystickUpdateNative();

		/// <summary>		/// Update the current state of the open joysticks.<br/>		/// This is called automatically by the event loop if any joystick events are<br/>		/// enabled.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickUpdate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickUpdate()
		{
			SDLJoystickUpdateNative();
		}

		/// <summary>
		/// Enable/disable joystick event polling.<br/>
		/// If joystick events are disabled, you must call SDL_JoystickUpdate()<br/>
		/// yourself and manually check the state of the joystick when you want<br/>
		/// joystick information.<br/>
		/// It is recommended that you leave joystick event handling enabled.<br/>
		/// **WARNING**: Calling this function may delete all events currently in SDL's<br/>
		/// event queue.<br/>
		/// <br/>
		/// If `state` is `SDL_QUERY` then the current state is returned,<br/>
		/// otherwise the new processing state is returned.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickEventState")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickEventState")]
		internal static extern int SDLJoystickEventStateNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "int")] int state);

		/// <summary>		/// Enable/disable joystick event polling.<br/>		/// If joystick events are disabled, you must call SDL_JoystickUpdate()<br/>		/// yourself and manually check the state of the joystick when you want<br/>		/// joystick information.<br/>		/// It is recommended that you leave joystick event handling enabled.<br/>		/// **WARNING**: Calling this function may delete all events currently in SDL's<br/>		/// event queue.<br/>		/// <br/>		/// If `state` is `SDL_QUERY` then the current state is returned,<br/>		/// otherwise the new processing state is returned.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickEventState")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickEventState([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "int")] int state)
		{
			int ret = SDLJoystickEventStateNative(state);
			return ret;
		}

		/// <summary>
		/// Get the current state of an axis control on a joystick.<br/>
		/// SDL makes no promises about what part of the joystick any given axis refers<br/>
		/// to. Your game should have some sort of configuration UI to let users<br/>
		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
		/// Game Controller API makes a great effort to apply order to this lower-level<br/>
		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
		/// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to<br/>
		/// 32767) representing the current position of the axis. It may be necessary<br/>
		/// to impose certain tolerances on these values to account for jitter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetAxis")]
		internal static extern short SDLJoystickGetAxisNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis);

		/// <summary>		/// Get the current state of an axis control on a joystick.<br/>		/// SDL makes no promises about what part of the joystick any given axis refers<br/>		/// to. Your game should have some sort of configuration UI to let users<br/>		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>		/// Game Controller API makes a great effort to apply order to this lower-level<br/>		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>		/// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to<br/>		/// 32767) representing the current position of the axis. It may be necessary<br/>		/// to impose certain tolerances on these values to account for jitter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short SDLJoystickGetAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis)
		{
			short ret = SDLJoystickGetAxisNative(joystick, axis);
			return ret;
		}

		/// <summary>		/// Get the current state of an axis control on a joystick.<br/>		/// SDL makes no promises about what part of the joystick any given axis refers<br/>		/// to. Your game should have some sort of configuration UI to let users<br/>		/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>		/// Game Controller API makes a great effort to apply order to this lower-level<br/>		/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>		/// The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to<br/>		/// 32767) representing the current position of the axis. It may be necessary<br/>		/// to impose certain tolerances on these values to account for jitter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short SDLJoystickGetAxis([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				short ret = SDLJoystickGetAxisNative((SDLJoystick*)pjoystick, axis);
				return ret;
			}
		}

		/// <summary>
		/// Get the initial state of an axis control on a joystick.<br/>
		/// The state is a value ranging from -32768 to 32767.<br/>
		/// The axis indices start at index 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetAxisInitialState")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetAxisInitialState")]
		internal static extern SDLBool SDLJoystickGetAxisInitialStateNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Sint16*")] short* state);

		/// <summary>		/// Get the initial state of an axis control on a joystick.<br/>		/// The state is a value ranging from -32768 to 32767.<br/>		/// The axis indices start at index 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetAxisInitialState")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickGetAxisInitialState([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Sint16*")] short* state)
		{
			SDLBool ret = SDLJoystickGetAxisInitialStateNative(joystick, axis, state);
			return ret;
		}

		/// <summary>		/// Get the initial state of an axis control on a joystick.<br/>		/// The state is a value ranging from -32768 to 32767.<br/>		/// The axis indices start at index 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetAxisInitialState")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickGetAxisInitialState([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Sint16*")] short* state)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = SDLJoystickGetAxisInitialStateNative((SDLJoystick*)pjoystick, axis, state);
				return ret;
			}
		}

		/// <summary>		/// Get the initial state of an axis control on a joystick.<br/>		/// The state is a value ranging from -32768 to 32767.<br/>		/// The axis indices start at index 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetAxisInitialState")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickGetAxisInitialState([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Sint16*")] ref short state)
		{
			fixed (short* pstate = &state)
			{
				SDLBool ret = SDLJoystickGetAxisInitialStateNative(joystick, axis, (short*)pstate);
				return ret;
			}
		}

		/// <summary>		/// Get the initial state of an axis control on a joystick.<br/>		/// The state is a value ranging from -32768 to 32767.<br/>		/// The axis indices start at index 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetAxisInitialState")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickGetAxisInitialState([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "int")] int axis, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Sint16*")] ref short state)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (short* pstate = &state)
				{
					SDLBool ret = SDLJoystickGetAxisInitialStateNative((SDLJoystick*)pjoystick, axis, (short*)pstate);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a POV hat on a joystick.<br/>
		/// The returned value will be one of the following positions:<br/>
		/// - `SDL_HAT_CENTERED`<br/>
		/// - `SDL_HAT_UP`<br/>
		/// - `SDL_HAT_RIGHT`<br/>
		/// - `SDL_HAT_DOWN`<br/>
		/// - `SDL_HAT_LEFT`<br/>
		/// - `SDL_HAT_RIGHTUP`<br/>
		/// - `SDL_HAT_RIGHTDOWN`<br/>
		/// - `SDL_HAT_LEFTUP`<br/>
		/// - `SDL_HAT_LEFTDOWN`<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetHat")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetHat")]
		internal static extern byte SDLJoystickGetHatNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat);

		/// <summary>		/// Get the current state of a POV hat on a joystick.<br/>		/// The returned value will be one of the following positions:<br/>		/// - `SDL_HAT_CENTERED`<br/>		/// - `SDL_HAT_UP`<br/>		/// - `SDL_HAT_RIGHT`<br/>		/// - `SDL_HAT_DOWN`<br/>		/// - `SDL_HAT_LEFT`<br/>		/// - `SDL_HAT_RIGHTUP`<br/>		/// - `SDL_HAT_RIGHTDOWN`<br/>		/// - `SDL_HAT_LEFTUP`<br/>		/// - `SDL_HAT_LEFTDOWN`<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetHat")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLJoystickGetHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat)
		{
			byte ret = SDLJoystickGetHatNative(joystick, hat);
			return ret;
		}

		/// <summary>		/// Get the current state of a POV hat on a joystick.<br/>		/// The returned value will be one of the following positions:<br/>		/// - `SDL_HAT_CENTERED`<br/>		/// - `SDL_HAT_UP`<br/>		/// - `SDL_HAT_RIGHT`<br/>		/// - `SDL_HAT_DOWN`<br/>		/// - `SDL_HAT_LEFT`<br/>		/// - `SDL_HAT_RIGHTUP`<br/>		/// - `SDL_HAT_RIGHTDOWN`<br/>		/// - `SDL_HAT_LEFTUP`<br/>		/// - `SDL_HAT_LEFTDOWN`<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetHat")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLJoystickGetHat([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "hat")] [NativeName(NativeNameType.Type, "int")] int hat)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SDLJoystickGetHatNative((SDLJoystick*)pjoystick, hat);
				return ret;
			}
		}

		/// <summary>
		/// Get the ball axis change since the last poll.<br/>
		/// Trackballs can only return relative motion since the last call to<br/>
		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>
		/// Most joysticks do not have trackballs.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetBall")]
		internal static extern int SDLJoystickGetBallNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "dx")] [NativeName(NativeNameType.Type, "int*")] int* dx, [NativeName(NativeNameType.Param, "dy")] [NativeName(NativeNameType.Type, "int*")] int* dy);

		/// <summary>		/// Get the ball axis change since the last poll.<br/>		/// Trackballs can only return relative motion since the last call to<br/>		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "dx")] [NativeName(NativeNameType.Type, "int*")] int* dx, [NativeName(NativeNameType.Param, "dy")] [NativeName(NativeNameType.Type, "int*")] int* dy)
		{
			int ret = SDLJoystickGetBallNative(joystick, ball, dx, dy);
			return ret;
		}

		/// <summary>		/// Get the ball axis change since the last poll.<br/>		/// Trackballs can only return relative motion since the last call to<br/>		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "dx")] [NativeName(NativeNameType.Type, "int*")] int* dx, [NativeName(NativeNameType.Param, "dy")] [NativeName(NativeNameType.Type, "int*")] int* dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickGetBallNative((SDLJoystick*)pjoystick, ball, dx, dy);
				return ret;
			}
		}

		/// <summary>		/// Get the ball axis change since the last poll.<br/>		/// Trackballs can only return relative motion since the last call to<br/>		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "dx")] [NativeName(NativeNameType.Type, "int*")] ref int dx, [NativeName(NativeNameType.Param, "dy")] [NativeName(NativeNameType.Type, "int*")] int* dy)
		{
			fixed (int* pdx = &dx)
			{
				int ret = SDLJoystickGetBallNative(joystick, ball, (int*)pdx, dy);
				return ret;
			}
		}

		/// <summary>		/// Get the ball axis change since the last poll.<br/>		/// Trackballs can only return relative motion since the last call to<br/>		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "dx")] [NativeName(NativeNameType.Type, "int*")] ref int dx, [NativeName(NativeNameType.Param, "dy")] [NativeName(NativeNameType.Type, "int*")] int* dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdx = &dx)
				{
					int ret = SDLJoystickGetBallNative((SDLJoystick*)pjoystick, ball, (int*)pdx, dy);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the ball axis change since the last poll.<br/>		/// Trackballs can only return relative motion since the last call to<br/>		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "dx")] [NativeName(NativeNameType.Type, "int*")] int* dx, [NativeName(NativeNameType.Param, "dy")] [NativeName(NativeNameType.Type, "int*")] ref int dy)
		{
			fixed (int* pdy = &dy)
			{
				int ret = SDLJoystickGetBallNative(joystick, ball, dx, (int*)pdy);
				return ret;
			}
		}

		/// <summary>		/// Get the ball axis change since the last poll.<br/>		/// Trackballs can only return relative motion since the last call to<br/>		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "dx")] [NativeName(NativeNameType.Type, "int*")] int* dx, [NativeName(NativeNameType.Param, "dy")] [NativeName(NativeNameType.Type, "int*")] ref int dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdy = &dy)
				{
					int ret = SDLJoystickGetBallNative((SDLJoystick*)pjoystick, ball, dx, (int*)pdy);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the ball axis change since the last poll.<br/>		/// Trackballs can only return relative motion since the last call to<br/>		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "dx")] [NativeName(NativeNameType.Type, "int*")] ref int dx, [NativeName(NativeNameType.Param, "dy")] [NativeName(NativeNameType.Type, "int*")] ref int dy)
		{
			fixed (int* pdx = &dx)
			{
				fixed (int* pdy = &dy)
				{
					int ret = SDLJoystickGetBallNative(joystick, ball, (int*)pdx, (int*)pdy);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the ball axis change since the last poll.<br/>		/// Trackballs can only return relative motion since the last call to<br/>		/// SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`.<br/>		/// Most joysticks do not have trackballs.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetBall")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickGetBall([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "ball")] [NativeName(NativeNameType.Type, "int")] int ball, [NativeName(NativeNameType.Param, "dx")] [NativeName(NativeNameType.Type, "int*")] ref int dx, [NativeName(NativeNameType.Param, "dy")] [NativeName(NativeNameType.Type, "int*")] ref int dy)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				fixed (int* pdx = &dx)
				{
					fixed (int* pdy = &dy)
					{
						int ret = SDLJoystickGetBallNative((SDLJoystick*)pjoystick, ball, (int*)pdx, (int*)pdy);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the current state of a button on a joystick.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickGetButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickGetButton")]
		internal static extern byte SDLJoystickGetButtonNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button);

		/// <summary>		/// Get the current state of a button on a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLJoystickGetButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			byte ret = SDLJoystickGetButtonNative(joystick, button);
			return ret;
		}

		/// <summary>		/// Get the current state of a button on a joystick.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickGetButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLJoystickGetButton([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				byte ret = SDLJoystickGetButtonNative((SDLJoystick*)pjoystick, button);
				return ret;
			}
		}

		/// <summary>
		/// Start a rumble effect.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickRumble")]
		internal static extern int SDLJoystickRumbleNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs);

		/// <summary>		/// Start a rumble effect.<br/>		/// Each call to this function cancels any previous rumble effect, and calling<br/>		/// it with 0 intensity stops any rumbling.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickRumble([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			int ret = SDLJoystickRumbleNative(joystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
			return ret;
		}

		/// <summary>		/// Start a rumble effect.<br/>		/// Each call to this function cancels any previous rumble effect, and calling<br/>		/// it with 0 intensity stops any rumbling.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickRumble([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickRumbleNative((SDLJoystick*)pjoystick, lowFrequencyRumble, highFrequencyRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Start a rumble effect in the joystick's triggers<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use SDL_JoystickRumble()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickRumbleTriggers")]
		internal static extern int SDLJoystickRumbleTriggersNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs);

		/// <summary>		/// Start a rumble effect in the joystick's triggers<br/>		/// Each call to this function cancels any previous trigger rumble effect, and<br/>		/// calling it with 0 intensity stops any rumbling.<br/>		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>		/// want the (more common) whole-controller rumble, use SDL_JoystickRumble()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickRumbleTriggers([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			int ret = SDLJoystickRumbleTriggersNative(joystick, leftRumble, rightRumble, durationMs);
			return ret;
		}

		/// <summary>		/// Start a rumble effect in the joystick's triggers<br/>		/// Each call to this function cancels any previous trigger rumble effect, and<br/>		/// calling it with 0 intensity stops any rumbling.<br/>		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>		/// want the (more common) whole-controller rumble, use SDL_JoystickRumble()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickRumbleTriggers([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickRumbleTriggersNative((SDLJoystick*)pjoystick, leftRumble, rightRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a joystick has an LED.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickHasLED")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickHasLED")]
		internal static extern SDLBool SDLJoystickHasLEDNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Query whether a joystick has an LED.<br/>		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>		/// DualShock 4 controller.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickHasLED")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickHasLED([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			SDLBool ret = SDLJoystickHasLEDNative(joystick);
			return ret;
		}

		/// <summary>		/// Query whether a joystick has an LED.<br/>		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>		/// DualShock 4 controller.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickHasLED")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickHasLED([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = SDLJoystickHasLEDNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a joystick has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickHasRumble")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickHasRumble")]
		internal static extern SDLBool SDLJoystickHasRumbleNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Query whether a joystick has rumble support.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickHasRumble")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickHasRumble([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			SDLBool ret = SDLJoystickHasRumbleNative(joystick);
			return ret;
		}

		/// <summary>		/// Query whether a joystick has rumble support.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickHasRumble")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickHasRumble([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = SDLJoystickHasRumbleNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a joystick has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickHasRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickHasRumbleTriggers")]
		internal static extern SDLBool SDLJoystickHasRumbleTriggersNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Query whether a joystick has rumble support on triggers.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickHasRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickHasRumbleTriggers([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			SDLBool ret = SDLJoystickHasRumbleTriggersNative(joystick);
			return ret;
		}

		/// <summary>		/// Query whether a joystick has rumble support on triggers.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickHasRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLJoystickHasRumbleTriggers([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLBool ret = SDLJoystickHasRumbleTriggersNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Update a joystick's LED color.<br/>
		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
		/// DualShock 4 controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSetLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickSetLED")]
		internal static extern int SDLJoystickSetLEDNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue);

		/// <summary>		/// Update a joystick's LED color.<br/>		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>		/// DualShock 4 controller.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetLED([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			int ret = SDLJoystickSetLEDNative(joystick, red, green, blue);
			return ret;
		}

		/// <summary>		/// Update a joystick's LED color.<br/>		/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>		/// DualShock 4 controller.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSetLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSetLED([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickSetLEDNative((SDLJoystick*)pjoystick, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Send a joystick specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickSendEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickSendEffect")]
		internal static extern int SDLJoystickSendEffectNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size);

		/// <summary>		/// Send a joystick specific effect packet<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSendEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSendEffect([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			int ret = SDLJoystickSendEffectNative(joystick, data, size);
			return ret;
		}

		/// <summary>		/// Send a joystick specific effect packet<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickSendEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickSendEffect([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickSendEffectNative((SDLJoystick*)pjoystick, data, size);
				return ret;
			}
		}

		/// <summary>
		/// Close a joystick previously opened with SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickClose")]
		internal static extern void SDLJoystickCloseNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Close a joystick previously opened with SDL_JoystickOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickClose([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			SDLJoystickCloseNative(joystick);
		}

		/// <summary>		/// Close a joystick previously opened with SDL_JoystickOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLJoystickClose([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickCloseNative((SDLJoystick*)pjoystick);
			}
		}

		/// <summary>
		/// Get the battery level of a joystick as SDL_JoystickPowerLevel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickCurrentPowerLevel")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickPowerLevel")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickCurrentPowerLevel")]
		internal static extern SDLJoystickPowerLevel SDLJoystickCurrentPowerLevelNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Get the battery level of a joystick as SDL_JoystickPowerLevel.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickCurrentPowerLevel")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickPowerLevel")]
		public static SDLJoystickPowerLevel SDLJoystickCurrentPowerLevel([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			SDLJoystickPowerLevel ret = SDLJoystickCurrentPowerLevelNative(joystick);
			return ret;
		}

		/// <summary>		/// Get the battery level of a joystick as SDL_JoystickPowerLevel.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickCurrentPowerLevel")]
		[return: NativeName(NativeNameType.Type, "SDL_JoystickPowerLevel")]
		public static SDLJoystickPowerLevel SDLJoystickCurrentPowerLevel([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLJoystickPowerLevel ret = SDLJoystickCurrentPowerLevelNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Locking for multi-threaded access to the sensor API<br/>
		/// If you are using the sensor API or handling events from multiple threads<br/>
		/// you should use these locking functions to protect access to the sensors.<br/>
		/// In particular, you are guaranteed that the sensor list won't change, so the<br/>
		/// API functions that take a sensor index will be valid, and sensor events<br/>
		/// will not be delivered.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LockSensors")]
		internal static extern void SDLLockSensorsNative();

		/// <summary>		/// Locking for multi-threaded access to the sensor API<br/>		/// If you are using the sensor API or handling events from multiple threads<br/>		/// you should use these locking functions to protect access to the sensors.<br/>		/// In particular, you are guaranteed that the sensor list won't change, so the<br/>		/// API functions that take a sensor index will be valid, and sensor events<br/>		/// will not be delivered.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLockSensors()
		{
			SDLLockSensorsNative();
		}

		[NativeName(NativeNameType.Func, "SDL_UnlockSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnlockSensors")]
		internal static extern void SDLUnlockSensorsNative();

		[NativeName(NativeNameType.Func, "SDL_UnlockSensors")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockSensors()
		{
			SDLUnlockSensorsNative();
		}

		/// <summary>
		/// Count the number of sensors attached to the system right now.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_NumSensors")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_NumSensors")]
		internal static extern int SDLNumSensorsNative();

		/// <summary>		/// Count the number of sensors attached to the system right now.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_NumSensors")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLNumSensors()
		{
			int ret = SDLNumSensorsNative();
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetDeviceName")]
		internal static extern byte* SDLSensorGetDeviceNameNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the implementation dependent name of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLSensorGetDeviceName([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			byte* ret = SDLSensorGetDeviceNameNative(deviceIndex);
			return ret;
		}

		/// <summary>		/// Get the implementation dependent name of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDeviceName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLSensorGetDeviceNameS([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLSensorGetDeviceNameNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetDeviceType")]
		internal static extern SDLSensorType SDLSensorGetDeviceTypeNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the type of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType SDLSensorGetDeviceType([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			SDLSensorType ret = SDLSensorGetDeviceTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetDeviceNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetDeviceNonPortableType")]
		internal static extern int SDLSensorGetDeviceNonPortableTypeNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the platform dependent type of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDeviceNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetDeviceNonPortableType([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			int ret = SDLSensorGetDeviceNonPortableTypeNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetDeviceInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetDeviceInstanceID")]
		internal static extern int SDLSensorGetDeviceInstanceIDNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the instance ID of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDeviceInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		public static int SDLSensorGetDeviceInstanceID([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			int ret = SDLSensorGetDeviceInstanceIDNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Open a sensor for use.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorOpen")]
		internal static extern SDLSensor* SDLSensorOpenNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Open a sensor for use.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor*")]
		public static SDLSensor* SDLSensorOpen([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			SDLSensor* ret = SDLSensorOpenNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Return the SDL_Sensor associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorFromInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorFromInstanceID")]
		internal static extern SDLSensor* SDLSensorFromInstanceIDNative([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId);

		/// <summary>		/// Return the SDL_Sensor associated with an instance id.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorFromInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_Sensor*")]
		public static SDLSensor* SDLSensorFromInstanceID([NativeName(NativeNameType.Param, "instance_id")] [NativeName(NativeNameType.Type, "SDL_SensorID")] int instanceId)
		{
			SDLSensor* ret = SDLSensorFromInstanceIDNative(instanceId);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a sensor<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetName")]
		internal static extern byte* SDLSensorGetNameNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor);

		/// <summary>		/// Get the implementation dependent name of a sensor<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLSensorGetName([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor)
		{
			byte* ret = SDLSensorGetNameNative(sensor);
			return ret;
		}

		/// <summary>		/// Get the implementation dependent name of a sensor<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLSensorGetNameS([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor)
		{
			string ret = Utils.DecodeStringUTF8(SDLSensorGetNameNative(sensor));
			return ret;
		}

		/// <summary>		/// Get the implementation dependent name of a sensor<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLSensorGetName([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				byte* ret = SDLSensorGetNameNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>		/// Get the implementation dependent name of a sensor<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLSensorGetNameS([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				string ret = Utils.DecodeStringUTF8(SDLSensorGetNameNative((SDLSensor*)psensor));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetType")]
		internal static extern SDLSensorType SDLSensorGetTypeNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor);

		/// <summary>		/// Get the type of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType SDLSensorGetType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor)
		{
			SDLSensorType ret = SDLSensorGetTypeNative(sensor);
			return ret;
		}

		/// <summary>		/// Get the type of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorType")]
		public static SDLSensorType SDLSensorGetType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SDLSensorType ret = SDLSensorGetTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the platform dependent type of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetNonPortableType")]
		internal static extern int SDLSensorGetNonPortableTypeNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor);

		/// <summary>		/// Get the platform dependent type of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetNonPortableType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor)
		{
			int ret = SDLSensorGetNonPortableTypeNative(sensor);
			return ret;
		}

		/// <summary>		/// Get the platform dependent type of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetNonPortableType")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetNonPortableType([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SDLSensorGetNonPortableTypeNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the instance ID of a sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetInstanceID")]
		internal static extern int SDLSensorGetInstanceIDNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor);

		/// <summary>		/// Get the instance ID of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		public static int SDLSensorGetInstanceID([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor)
		{
			int ret = SDLSensorGetInstanceIDNative(sensor);
			return ret;
		}

		/// <summary>		/// Get the instance ID of a sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_SensorID")]
		public static int SDLSensorGetInstanceID([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SDLSensorGetInstanceIDNative((SDLSensor*)psensor);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetData")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetData")]
		internal static extern int SDLSensorGetDataNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues);

		/// <summary>		/// Get the current state of an opened sensor.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			int ret = SDLSensorGetDataNative(sensor, data, numValues);
			return ret;
		}

		/// <summary>		/// Get the current state of an opened sensor.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SDLSensorGetDataNative((SDLSensor*)psensor, data, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of an opened sensor.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SDLSensorGetDataNative(sensor, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of an opened sensor.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetData([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					int ret = SDLSensorGetDataNative((SDLSensor*)psensor, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of an opened sensor with the timestamp of the last<br/>
		/// update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorGetDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorGetDataWithTimestamp")]
		internal static extern int SDLSensorGetDataWithTimestampNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues);

		/// <summary>		/// Get the current state of an opened sensor with the timestamp of the last<br/>		/// update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetDataWithTimestamp([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			int ret = SDLSensorGetDataWithTimestampNative(sensor, timestamp, data, numValues);
			return ret;
		}

		/// <summary>		/// Get the current state of an opened sensor with the timestamp of the last<br/>		/// update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetDataWithTimestamp([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				int ret = SDLSensorGetDataWithTimestampNative((SDLSensor*)psensor, timestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of an opened sensor with the timestamp of the last<br/>		/// update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetDataWithTimestamp([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				int ret = SDLSensorGetDataWithTimestampNative(sensor, (ulong*)ptimestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of an opened sensor with the timestamp of the last<br/>		/// update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetDataWithTimestamp([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					int ret = SDLSensorGetDataWithTimestampNative((SDLSensor*)psensor, (ulong*)ptimestamp, data, numValues);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of an opened sensor with the timestamp of the last<br/>		/// update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetDataWithTimestamp([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SDLSensorGetDataWithTimestampNative(sensor, timestamp, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of an opened sensor with the timestamp of the last<br/>		/// update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetDataWithTimestamp([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (float* pdata = &data)
				{
					int ret = SDLSensorGetDataWithTimestampNative((SDLSensor*)psensor, timestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of an opened sensor with the timestamp of the last<br/>		/// update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetDataWithTimestamp([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				fixed (float* pdata = &data)
				{
					int ret = SDLSensorGetDataWithTimestampNative(sensor, (ulong*)ptimestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of an opened sensor with the timestamp of the last<br/>		/// update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorGetDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSensorGetDataWithTimestamp([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					fixed (float* pdata = &data)
					{
						int ret = SDLSensorGetDataWithTimestampNative((SDLSensor*)psensor, (ulong*)ptimestamp, (float*)pdata, numValues);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Close a sensor previously opened with SDL_SensorOpen().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorClose")]
		internal static extern void SDLSensorCloseNative([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor);

		/// <summary>		/// Close a sensor previously opened with SDL_SensorOpen().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSensorClose([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] SDLSensor* sensor)
		{
			SDLSensorCloseNative(sensor);
		}

		/// <summary>		/// Close a sensor previously opened with SDL_SensorOpen().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSensorClose([NativeName(NativeNameType.Param, "sensor")] [NativeName(NativeNameType.Type, "SDL_Sensor*")] ref SDLSensor sensor)
		{
			fixed (SDLSensor* psensor = &sensor)
			{
				SDLSensorCloseNative((SDLSensor*)psensor);
			}
		}

		/// <summary>
		/// Update the current state of the open sensors.<br/>
		/// This is called automatically by the event loop if sensor events are<br/>
		/// enabled.<br/>
		/// This needs to be called from the thread that initialized the sensor<br/>
		/// subsystem.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SensorUpdate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SensorUpdate")]
		internal static extern void SDLSensorUpdateNative();

		/// <summary>		/// Update the current state of the open sensors.<br/>		/// This is called automatically by the event loop if sensor events are<br/>		/// enabled.<br/>		/// This needs to be called from the thread that initialized the sensor<br/>		/// subsystem.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SensorUpdate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSensorUpdate()
		{
			SDLSensorUpdateNative();
		}

		/// <summary>
		/// Load a set of Game Controller mappings from a seekable SDL data stream.<br/>
		/// You can call this function several times, if needed, to load different<br/>
		/// database files.<br/>
		/// If a new mapping is loaded for an already known controller GUID, the later<br/>
		/// version will overwrite the one currently loaded.<br/>
		/// Mappings not belonging to the current platform or with no platform field<br/>
		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
		/// Windows, etc).<br/>
		/// This function will load the text database entirely in memory before<br/>
		/// processing it, so take this into consideration if you are in a memory<br/>
		/// constrained environment.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerAddMappingsFromRW")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerAddMappingsFromRW")]
		internal static extern int SDLGameControllerAddMappingsFromRWNative([NativeName(NativeNameType.Param, "rw")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* rw, [NativeName(NativeNameType.Param, "freerw")] [NativeName(NativeNameType.Type, "int")] int freerw);

		/// <summary>		/// Load a set of Game Controller mappings from a seekable SDL data stream.<br/>		/// You can call this function several times, if needed, to load different<br/>		/// database files.<br/>		/// If a new mapping is loaded for an already known controller GUID, the later<br/>		/// version will overwrite the one currently loaded.<br/>		/// Mappings not belonging to the current platform or with no platform field<br/>		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>		/// Windows, etc).<br/>		/// This function will load the text database entirely in memory before<br/>		/// processing it, so take this into consideration if you are in a memory<br/>		/// constrained environment.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerAddMappingsFromRW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerAddMappingsFromRW([NativeName(NativeNameType.Param, "rw")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* rw, [NativeName(NativeNameType.Param, "freerw")] [NativeName(NativeNameType.Type, "int")] int freerw)
		{
			int ret = SDLGameControllerAddMappingsFromRWNative(rw, freerw);
			return ret;
		}

		/// <summary>		/// Load a set of Game Controller mappings from a seekable SDL data stream.<br/>		/// You can call this function several times, if needed, to load different<br/>		/// database files.<br/>		/// If a new mapping is loaded for an already known controller GUID, the later<br/>		/// version will overwrite the one currently loaded.<br/>		/// Mappings not belonging to the current platform or with no platform field<br/>		/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>		/// Windows, etc).<br/>		/// This function will load the text database entirely in memory before<br/>		/// processing it, so take this into consideration if you are in a memory<br/>		/// constrained environment.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerAddMappingsFromRW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerAddMappingsFromRW([NativeName(NativeNameType.Param, "rw")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops rw, [NativeName(NativeNameType.Param, "freerw")] [NativeName(NativeNameType.Type, "int")] int freerw)
		{
			fixed (SDLRWops* prw = &rw)
			{
				int ret = SDLGameControllerAddMappingsFromRWNative((SDLRWops*)prw, freerw);
				return ret;
			}
		}

		/// <summary>
		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>
		/// controller to have a different binding.<br/>
		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>
		/// string for the device and mappings are controller mappings to joystick<br/>
		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>
		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>
		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>
		/// |} Buttons can be used as a controller axes and vice versa.<br/>
		/// This string shows an example of a valid mapping for a controller:<br/>
		/// ```c<br/>
		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerAddMapping")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerAddMapping")]
		internal static extern int SDLGameControllerAddMappingNative([NativeName(NativeNameType.Param, "mappingString")] [NativeName(NativeNameType.Type, "const char*")] byte* mappingString);

		/// <summary>		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>		/// controller to have a different binding.<br/>		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>		/// string for the device and mappings are controller mappings to joystick<br/>		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>		/// |} Buttons can be used as a controller axes and vice versa.<br/>		/// This string shows an example of a valid mapping for a controller:<br/>		/// ```c<br/>		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerAddMapping")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerAddMapping([NativeName(NativeNameType.Param, "mappingString")] [NativeName(NativeNameType.Type, "const char*")] byte* mappingString)
		{
			int ret = SDLGameControllerAddMappingNative(mappingString);
			return ret;
		}

		/// <summary>		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>		/// controller to have a different binding.<br/>		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>		/// string for the device and mappings are controller mappings to joystick<br/>		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>		/// |} Buttons can be used as a controller axes and vice versa.<br/>		/// This string shows an example of a valid mapping for a controller:<br/>		/// ```c<br/>		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerAddMapping")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerAddMapping([NativeName(NativeNameType.Param, "mappingString")] [NativeName(NativeNameType.Type, "const char*")] ref byte mappingString)
		{
			fixed (byte* pmappingString = &mappingString)
			{
				int ret = SDLGameControllerAddMappingNative((byte*)pmappingString);
				return ret;
			}
		}

		/// <summary>		/// Add support for controllers that SDL is unaware of or to cause an existing<br/>		/// controller to have a different binding.<br/>		/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>		/// string value from SDL_JoystickGetGUIDString(), name is the human readable<br/>		/// string for the device and mappings are controller mappings to joystick<br/>		/// ones. Under Windows there is a reserved GUID of "xinput" that covers all<br/>		/// XInput devices. The mapping format for joystick is: {| |bX |a joystick<br/>		/// button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick<br/>		/// |} Buttons can be used as a controller axes and vice versa.<br/>		/// This string shows an example of a valid mapping for a controller:<br/>		/// ```c<br/>		/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerAddMapping")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerAddMapping([NativeName(NativeNameType.Param, "mappingString")] [NativeName(NativeNameType.Type, "const char*")] string mappingString)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mappingString != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mappingString);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mappingString, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLGameControllerAddMappingNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the number of mappings installed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerNumMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerNumMappings")]
		internal static extern int SDLGameControllerNumMappingsNative();

		/// <summary>		/// Get the number of mappings installed.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerNumMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerNumMappings()
		{
			int ret = SDLGameControllerNumMappingsNative();
			return ret;
		}

		/// <summary>
		/// Get the mapping at a particular index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerMappingForIndex")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerMappingForIndex")]
		internal static extern byte* SDLGameControllerMappingForIndexNative([NativeName(NativeNameType.Param, "mapping_index")] [NativeName(NativeNameType.Type, "int")] int mappingIndex);

		/// <summary>		/// Get the mapping at a particular index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMappingForIndex")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGameControllerMappingForIndex([NativeName(NativeNameType.Param, "mapping_index")] [NativeName(NativeNameType.Type, "int")] int mappingIndex)
		{
			byte* ret = SDLGameControllerMappingForIndexNative(mappingIndex);
			return ret;
		}

		/// <summary>		/// Get the mapping at a particular index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMappingForIndex")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGameControllerMappingForIndexS([NativeName(NativeNameType.Param, "mapping_index")] [NativeName(NativeNameType.Type, "int")] int mappingIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerMappingForIndexNative(mappingIndex));
			return ret;
		}

		/// <summary>
		/// Get the game controller mapping string for a given GUID.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerMappingForGUID")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerMappingForGUID")]
		internal static extern byte* SDLGameControllerMappingForGUIDNative([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid);

		/// <summary>		/// Get the game controller mapping string for a given GUID.<br/>		/// The returned string must be freed with SDL_free().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMappingForGUID")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGameControllerMappingForGUID([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid)
		{
			byte* ret = SDLGameControllerMappingForGUIDNative(guid);
			return ret;
		}

		/// <summary>		/// Get the game controller mapping string for a given GUID.<br/>		/// The returned string must be freed with SDL_free().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMappingForGUID")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGameControllerMappingForGUIDS([NativeName(NativeNameType.Param, "guid")] [NativeName(NativeNameType.Type, "SDL_JoystickGUID")] Guid guid)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerMappingForGUIDNative(guid));
			return ret;
		}

		/// <summary>
		/// Get the current mapping of a Game Controller.<br/>
		/// The returned string must be freed with SDL_free().<br/>
		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerMapping")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerMapping")]
		internal static extern byte* SDLGameControllerMappingNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the current mapping of a Game Controller.<br/>		/// The returned string must be freed with SDL_free().<br/>		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMapping")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGameControllerMapping([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			byte* ret = SDLGameControllerMappingNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the current mapping of a Game Controller.<br/>		/// The returned string must be freed with SDL_free().<br/>		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMapping")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGameControllerMappingS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerMappingNative(gamecontroller));
			return ret;
		}

		/// <summary>		/// Get the current mapping of a Game Controller.<br/>		/// The returned string must be freed with SDL_free().<br/>		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMapping")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGameControllerMapping([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = SDLGameControllerMappingNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>		/// Get the current mapping of a Game Controller.<br/>		/// The returned string must be freed with SDL_free().<br/>		/// Details about mappings are discussed with SDL_GameControllerAddMapping().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMapping")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGameControllerMappingS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(SDLGameControllerMappingNative((SDLGameController*)pgamecontroller));
				return ret;
			}
		}

		/// <summary>
		/// Check if the given joystick is supported by the game controller interface.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsGameController")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IsGameController")]
		internal static extern SDLBool SDLIsGameControllerNative([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex);

		/// <summary>		/// Check if the given joystick is supported by the game controller interface.<br/>		/// `joystick_index` is the same as the `device_index` passed to<br/>		/// SDL_JoystickOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsGameController")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsGameController([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex)
		{
			SDLBool ret = SDLIsGameControllerNative(joystickIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name for the game controller.<br/>
		/// This function can be called before any controllers are opened.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerNameForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerNameForIndex")]
		internal static extern byte* SDLGameControllerNameForIndexNative([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex);

		/// <summary>		/// Get the implementation dependent name for the game controller.<br/>		/// This function can be called before any controllers are opened.<br/>		/// `joystick_index` is the same as the `device_index` passed to<br/>		/// SDL_JoystickOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerNameForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerNameForIndex([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex)
		{
			byte* ret = SDLGameControllerNameForIndexNative(joystickIndex);
			return ret;
		}

		/// <summary>		/// Get the implementation dependent name for the game controller.<br/>		/// This function can be called before any controllers are opened.<br/>		/// `joystick_index` is the same as the `device_index` passed to<br/>		/// SDL_JoystickOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerNameForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerNameForIndexS([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerNameForIndexNative(joystickIndex));
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent path for the game controller.<br/>
		/// This function can be called before any controllers are opened.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerPathForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerPathForIndex")]
		internal static extern byte* SDLGameControllerPathForIndexNative([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex);

		/// <summary>		/// Get the implementation dependent path for the game controller.<br/>		/// This function can be called before any controllers are opened.<br/>		/// `joystick_index` is the same as the `device_index` passed to<br/>		/// SDL_JoystickOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerPathForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerPathForIndex([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex)
		{
			byte* ret = SDLGameControllerPathForIndexNative(joystickIndex);
			return ret;
		}

		/// <summary>		/// Get the implementation dependent path for the game controller.<br/>		/// This function can be called before any controllers are opened.<br/>		/// `joystick_index` is the same as the `device_index` passed to<br/>		/// SDL_JoystickOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerPathForIndex")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerPathForIndexS([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerPathForIndexNative(joystickIndex));
			return ret;
		}

		/// <summary>
		/// Get the type of a game controller.<br/>
		/// This can be called before any controllers are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerTypeForIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerType")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerTypeForIndex")]
		internal static extern SDLGameControllerType SDLGameControllerTypeForIndexNative([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex);

		/// <summary>		/// Get the type of a game controller.<br/>		/// This can be called before any controllers are opened.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerTypeForIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerType")]
		public static SDLGameControllerType SDLGameControllerTypeForIndex([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex)
		{
			SDLGameControllerType ret = SDLGameControllerTypeForIndexNative(joystickIndex);
			return ret;
		}

		/// <summary>
		/// Get the mapping of a game controller.<br/>
		/// This can be called before any controllers are opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerMappingForDeviceIndex")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerMappingForDeviceIndex")]
		internal static extern byte* SDLGameControllerMappingForDeviceIndexNative([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex);

		/// <summary>		/// Get the mapping of a game controller.<br/>		/// This can be called before any controllers are opened.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMappingForDeviceIndex")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGameControllerMappingForDeviceIndex([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex)
		{
			byte* ret = SDLGameControllerMappingForDeviceIndexNative(joystickIndex);
			return ret;
		}

		/// <summary>		/// Get the mapping of a game controller.<br/>		/// This can be called before any controllers are opened.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerMappingForDeviceIndex")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGameControllerMappingForDeviceIndexS([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerMappingForDeviceIndexNative(joystickIndex));
			return ret;
		}

		/// <summary>
		/// Open a game controller for use.<br/>
		/// `joystick_index` is the same as the `device_index` passed to<br/>
		/// SDL_JoystickOpen().<br/>
		/// The index passed as an argument refers to the N'th game controller on the<br/>
		/// system. This index is not the value which will identify this controller in<br/>
		/// future controller events. The joystick's instance id (SDL_JoystickID) will<br/>
		/// be used there instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_GameController*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerOpen")]
		internal static extern SDLGameController* SDLGameControllerOpenNative([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex);

		/// <summary>		/// Open a game controller for use.<br/>		/// `joystick_index` is the same as the `device_index` passed to<br/>		/// SDL_JoystickOpen().<br/>		/// The index passed as an argument refers to the N'th game controller on the<br/>		/// system. This index is not the value which will identify this controller in<br/>		/// future controller events. The joystick's instance id (SDL_JoystickID) will<br/>		/// be used there instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_GameController*")]
		public static SDLGameController* SDLGameControllerOpen([NativeName(NativeNameType.Param, "joystick_index")] [NativeName(NativeNameType.Type, "int")] int joystickIndex)
		{
			SDLGameController* ret = SDLGameControllerOpenNative(joystickIndex);
			return ret;
		}

		/// <summary>
		/// Get the SDL_GameController associated with an instance id.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerFromInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_GameController*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerFromInstanceID")]
		internal static extern SDLGameController* SDLGameControllerFromInstanceIDNative([NativeName(NativeNameType.Param, "joyid")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int joyid);

		/// <summary>		/// Get the SDL_GameController associated with an instance id.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerFromInstanceID")]
		[return: NativeName(NativeNameType.Type, "SDL_GameController*")]
		public static SDLGameController* SDLGameControllerFromInstanceID([NativeName(NativeNameType.Param, "joyid")] [NativeName(NativeNameType.Type, "SDL_JoystickID")] int joyid)
		{
			SDLGameController* ret = SDLGameControllerFromInstanceIDNative(joyid);
			return ret;
		}

		/// <summary>
		/// Get the SDL_GameController associated with a player index.<br/>
		/// Please note that the player index is _not_ the device index, nor is it the<br/>
		/// instance id!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_GameController*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerFromPlayerIndex")]
		internal static extern SDLGameController* SDLGameControllerFromPlayerIndexNative([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex);

		/// <summary>		/// Get the SDL_GameController associated with a player index.<br/>		/// Please note that the player index is _not_ the device index, nor is it the<br/>		/// instance id!<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerFromPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "SDL_GameController*")]
		public static SDLGameController* SDLGameControllerFromPlayerIndex([NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			SDLGameController* ret = SDLGameControllerFromPlayerIndexNative(playerIndex);
			return ret;
		}

		/// <summary>
		/// Get the implementation-dependent name for an opened game controller.<br/>
		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerName")]
		internal static extern byte* SDLGameControllerNameNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the implementation-dependent name for an opened game controller.<br/>		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerName([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			byte* ret = SDLGameControllerNameNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the implementation-dependent name for an opened game controller.<br/>		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerNameS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerNameNative(gamecontroller));
			return ret;
		}

		/// <summary>		/// Get the implementation-dependent name for an opened game controller.<br/>		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerName([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = SDLGameControllerNameNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>		/// Get the implementation-dependent name for an opened game controller.<br/>		/// This is the same name as returned by SDL_GameControllerNameForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerNameS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(SDLGameControllerNameNative((SDLGameController*)pgamecontroller));
				return ret;
			}
		}

		/// <summary>
		/// Get the implementation-dependent path for an opened game controller.<br/>
		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerPath")]
		internal static extern byte* SDLGameControllerPathNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the implementation-dependent path for an opened game controller.<br/>		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerPath([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			byte* ret = SDLGameControllerPathNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the implementation-dependent path for an opened game controller.<br/>		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerPathS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerPathNative(gamecontroller));
			return ret;
		}

		/// <summary>		/// Get the implementation-dependent path for an opened game controller.<br/>		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerPath([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = SDLGameControllerPathNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>		/// Get the implementation-dependent path for an opened game controller.<br/>		/// This is the same path as returned by SDL_GameControllerNameForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerPath")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerPathS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(SDLGameControllerPathNative((SDLGameController*)pgamecontroller));
				return ret;
			}
		}

		/// <summary>
		/// Get the type of this currently opened controller<br/>
		/// This is the same name as returned by SDL_GameControllerTypeForIndex(), but<br/>
		/// it takes a controller identifier instead of the (unstable) device index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerType")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetType")]
		internal static extern SDLGameControllerType SDLGameControllerGetTypeNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the type of this currently opened controller<br/>		/// This is the same name as returned by SDL_GameControllerTypeForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerType")]
		public static SDLGameControllerType SDLGameControllerGetType([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLGameControllerType ret = SDLGameControllerGetTypeNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the type of this currently opened controller<br/>		/// This is the same name as returned by SDL_GameControllerTypeForIndex(), but<br/>		/// it takes a controller identifier instead of the (unstable) device index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetType")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerType")]
		public static SDLGameControllerType SDLGameControllerGetType([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerType ret = SDLGameControllerGetTypeNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the player index of an opened game controller.<br/>
		/// For XInput controllers this returns the XInput user index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetPlayerIndex")]
		internal static extern int SDLGameControllerGetPlayerIndexNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the player index of an opened game controller.<br/>		/// For XInput controllers this returns the XInput user index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetPlayerIndex([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			int ret = SDLGameControllerGetPlayerIndexNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the player index of an opened game controller.<br/>		/// For XInput controllers this returns the XInput user index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetPlayerIndex([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetPlayerIndexNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Set the player index of an opened game controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerSetPlayerIndex")]
		internal static extern void SDLGameControllerSetPlayerIndexNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex);

		/// <summary>		/// Set the player index of an opened game controller.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerSetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGameControllerSetPlayerIndex([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			SDLGameControllerSetPlayerIndexNative(gamecontroller, playerIndex);
		}

		/// <summary>		/// Set the player index of an opened game controller.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerSetPlayerIndex")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGameControllerSetPlayerIndex([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "player_index")] [NativeName(NativeNameType.Type, "int")] int playerIndex)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerSetPlayerIndexNative((SDLGameController*)pgamecontroller, playerIndex);
			}
		}

		/// <summary>
		/// Get the USB vendor ID of an opened controller, if available.<br/>
		/// If the vendor ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetVendor")]
		internal static extern ushort SDLGameControllerGetVendorNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the USB vendor ID of an opened controller, if available.<br/>		/// If the vendor ID isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLGameControllerGetVendor([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			ushort ret = SDLGameControllerGetVendorNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the USB vendor ID of an opened controller, if available.<br/>		/// If the vendor ID isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetVendor")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLGameControllerGetVendor([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				ushort ret = SDLGameControllerGetVendorNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the USB product ID of an opened controller, if available.<br/>
		/// If the product ID isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetProduct")]
		internal static extern ushort SDLGameControllerGetProductNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the USB product ID of an opened controller, if available.<br/>		/// If the product ID isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLGameControllerGetProduct([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			ushort ret = SDLGameControllerGetProductNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the USB product ID of an opened controller, if available.<br/>		/// If the product ID isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetProduct")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLGameControllerGetProduct([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				ushort ret = SDLGameControllerGetProductNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the product version of an opened controller, if available.<br/>
		/// If the product version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetProductVersion")]
		internal static extern ushort SDLGameControllerGetProductVersionNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the product version of an opened controller, if available.<br/>		/// If the product version isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLGameControllerGetProductVersion([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			ushort ret = SDLGameControllerGetProductVersionNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the product version of an opened controller, if available.<br/>		/// If the product version isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetProductVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLGameControllerGetProductVersion([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				ushort ret = SDLGameControllerGetProductVersionNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the firmware version of an opened controller, if available.<br/>
		/// If the firmware version isn't available this function returns 0.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetFirmwareVersion")]
		internal static extern ushort SDLGameControllerGetFirmwareVersionNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the firmware version of an opened controller, if available.<br/>		/// If the firmware version isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLGameControllerGetFirmwareVersion([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			ushort ret = SDLGameControllerGetFirmwareVersionNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the firmware version of an opened controller, if available.<br/>		/// If the firmware version isn't available this function returns 0.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetFirmwareVersion")]
		[return: NativeName(NativeNameType.Type, "Uint16")]
		public static ushort SDLGameControllerGetFirmwareVersion([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				ushort ret = SDLGameControllerGetFirmwareVersionNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the serial number of an opened controller, if available.<br/>
		/// Returns the serial number of the controller, or NULL if it is not<br/>
		/// available.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetSerial")]
		internal static extern byte* SDLGameControllerGetSerialNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the serial number of an opened controller, if available.<br/>		/// Returns the serial number of the controller, or NULL if it is not<br/>		/// available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetSerial([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			byte* ret = SDLGameControllerGetSerialNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the serial number of an opened controller, if available.<br/>		/// Returns the serial number of the controller, or NULL if it is not<br/>		/// available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetSerialS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerGetSerialNative(gamecontroller));
			return ret;
		}

		/// <summary>		/// Get the serial number of an opened controller, if available.<br/>		/// Returns the serial number of the controller, or NULL if it is not<br/>		/// available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetSerial([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = SDLGameControllerGetSerialNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>		/// Get the serial number of an opened controller, if available.<br/>		/// Returns the serial number of the controller, or NULL if it is not<br/>		/// available.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSerial")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetSerialS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(SDLGameControllerGetSerialNative((SDLGameController*)pgamecontroller));
				return ret;
			}
		}

		/// <summary>
		/// Check if a controller has been opened and is currently connected.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAttached")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetAttached")]
		internal static extern SDLBool SDLGameControllerGetAttachedNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Check if a controller has been opened and is currently connected.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAttached")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerGetAttached([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLBool ret = SDLGameControllerGetAttachedNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Check if a controller has been opened and is currently connected.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAttached")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerGetAttached([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerGetAttachedNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the Joystick ID from a Game Controller.<br/>
		/// This function will give you a SDL_Joystick object, which allows you to use<br/>
		/// the SDL_Joystick functions with a SDL_GameController object. This would be<br/>
		/// useful for getting a joystick's position at any given time, even if it<br/>
		/// hasn't moved (moving it would produce an event, which would have the axis'<br/>
		/// value).<br/>
		/// The pointer returned is owned by the SDL_GameController. You should not<br/>
		/// call SDL_JoystickClose() on it, for example, since doing so will likely<br/>
		/// cause SDL to crash.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetJoystick")]
		internal static extern SDLJoystick* SDLGameControllerGetJoystickNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the Joystick ID from a Game Controller.<br/>		/// This function will give you a SDL_Joystick object, which allows you to use<br/>		/// the SDL_Joystick functions with a SDL_GameController object. This would be<br/>		/// useful for getting a joystick's position at any given time, even if it<br/>		/// hasn't moved (moving it would produce an event, which would have the axis'<br/>		/// value).<br/>		/// The pointer returned is owned by the SDL_GameController. You should not<br/>		/// call SDL_JoystickClose() on it, for example, since doing so will likely<br/>		/// cause SDL to crash.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		public static SDLJoystick* SDLGameControllerGetJoystick([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLJoystick* ret = SDLGameControllerGetJoystickNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the Joystick ID from a Game Controller.<br/>		/// This function will give you a SDL_Joystick object, which allows you to use<br/>		/// the SDL_Joystick functions with a SDL_GameController object. This would be<br/>		/// useful for getting a joystick's position at any given time, even if it<br/>		/// hasn't moved (moving it would produce an event, which would have the axis'<br/>		/// value).<br/>		/// The pointer returned is owned by the SDL_GameController. You should not<br/>		/// call SDL_JoystickClose() on it, for example, since doing so will likely<br/>		/// cause SDL to crash.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Joystick*")]
		public static SDLJoystick* SDLGameControllerGetJoystick([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLJoystick* ret = SDLGameControllerGetJoystickNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Query or change current state of Game Controller events.<br/>
		/// If controller events are disabled, you must call SDL_GameControllerUpdate()<br/>
		/// yourself and check the state of the controller when you want controller<br/>
		/// information.<br/>
		/// Any number can be passed to SDL_GameControllerEventState(), but only -1, 0,<br/>
		/// and 1 will have any effect. Other numbers will just be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerEventState")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerEventState")]
		internal static extern int SDLGameControllerEventStateNative([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "int")] int state);

		/// <summary>		/// Query or change current state of Game Controller events.<br/>		/// If controller events are disabled, you must call SDL_GameControllerUpdate()<br/>		/// yourself and check the state of the controller when you want controller<br/>		/// information.<br/>		/// Any number can be passed to SDL_GameControllerEventState(), but only -1, 0,<br/>		/// and 1 will have any effect. Other numbers will just be returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerEventState")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerEventState([NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "int")] int state)
		{
			int ret = SDLGameControllerEventStateNative(state);
			return ret;
		}

		/// <summary>
		/// Manually pump game controller updates if not using the loop.<br/>
		/// This function is called automatically by the event loop if events are<br/>
		/// enabled. Under such circumstances, it will not be necessary to call this<br/>
		/// function.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerUpdate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerUpdate")]
		internal static extern void SDLGameControllerUpdateNative();

		/// <summary>		/// Manually pump game controller updates if not using the loop.<br/>		/// This function is called automatically by the event loop if events are<br/>		/// enabled. Under such circumstances, it will not be necessary to call this<br/>		/// function.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerUpdate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGameControllerUpdate()
		{
			SDLGameControllerUpdateNative();
		}

		/// <summary>
		/// Convert a string into SDL_GameControllerAxis enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>
		/// respectively.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerAxis")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetAxisFromString")]
		internal static extern SDLGameControllerAxis SDLGameControllerGetAxisFromStringNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str);

		/// <summary>		/// Convert a string into SDL_GameControllerAxis enum.<br/>		/// This function is called internally to translate SDL_GameController mapping<br/>		/// strings for the underlying joystick device into the consistent<br/>		/// SDL_GameController mapping. You do not normally need to call this function<br/>		/// unless you are parsing SDL_GameController mappings in your own code.<br/>		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>		/// respectively.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerAxis")]
		public static SDLGameControllerAxis SDLGameControllerGetAxisFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			SDLGameControllerAxis ret = SDLGameControllerGetAxisFromStringNative(str);
			return ret;
		}

		/// <summary>		/// Convert a string into SDL_GameControllerAxis enum.<br/>		/// This function is called internally to translate SDL_GameController mapping<br/>		/// strings for the underlying joystick device into the consistent<br/>		/// SDL_GameController mapping. You do not normally need to call this function<br/>		/// unless you are parsing SDL_GameController mappings in your own code.<br/>		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>		/// respectively.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerAxis")]
		public static SDLGameControllerAxis SDLGameControllerGetAxisFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGameControllerAxis ret = SDLGameControllerGetAxisFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>		/// Convert a string into SDL_GameControllerAxis enum.<br/>		/// This function is called internally to translate SDL_GameController mapping<br/>		/// strings for the underlying joystick device into the consistent<br/>		/// SDL_GameController mapping. You do not normally need to call this function<br/>		/// unless you are parsing SDL_GameController mappings in your own code.<br/>		/// Note specially that "righttrigger" and "lefttrigger" map to<br/>		/// `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,<br/>		/// respectively.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxisFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerAxis")]
		public static SDLGameControllerAxis SDLGameControllerGetAxisFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGameControllerAxis ret = SDLGameControllerGetAxisFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerAxis enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetStringForAxis")]
		internal static extern byte* SDLGameControllerGetStringForAxisNative([NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis);

		/// <summary>		/// Convert from an SDL_GameControllerAxis enum to a string.<br/>		/// The caller should not SDL_free() the returned string.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetStringForAxis([NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			byte* ret = SDLGameControllerGetStringForAxisNative(axis);
			return ret;
		}

		/// <summary>		/// Convert from an SDL_GameControllerAxis enum to a string.<br/>		/// The caller should not SDL_free() the returned string.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetStringForAxisS([NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerGetStringForAxisNative(axis));
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller axis mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetBindForAxis")]
		internal static extern SDLGameControllerButtonBind SDLGameControllerGetBindForAxisNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis);

		/// <summary>		/// Get the SDL joystick layer binding for a controller axis mapping.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		public static SDLGameControllerButtonBind SDLGameControllerGetBindForAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			SDLGameControllerButtonBind ret = SDLGameControllerGetBindForAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>		/// Get the SDL joystick layer binding for a controller axis mapping.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		public static SDLGameControllerButtonBind SDLGameControllerGetBindForAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerButtonBind ret = SDLGameControllerGetBindForAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has a given axis.<br/>
		/// This merely reports whether the controller's mapping defined this axis, as<br/>
		/// that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerHasAxis")]
		internal static extern SDLBool SDLGameControllerHasAxisNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis);

		/// <summary>		/// Query whether a game controller has a given axis.<br/>		/// This merely reports whether the controller's mapping defined this axis, as<br/>		/// that is all the information SDL has about the physical device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			SDLBool ret = SDLGameControllerHasAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>		/// Query whether a game controller has a given axis.<br/>		/// This merely reports whether the controller's mapping defined this axis, as<br/>		/// that is all the information SDL has about the physical device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasAxis")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of an axis control on a game controller.<br/>
		/// The axis indices start at index 0.<br/>
		/// The state is a value ranging from -32768 to 32767. Triggers, however, range<br/>
		/// from 0 to 32767 (they never return a negative value).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetAxis")]
		internal static extern short SDLGameControllerGetAxisNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis);

		/// <summary>		/// Get the current state of an axis control on a game controller.<br/>		/// The axis indices start at index 0.<br/>		/// The state is a value ranging from -32768 to 32767. Triggers, however, range<br/>		/// from 0 to 32767 (they never return a negative value).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short SDLGameControllerGetAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			short ret = SDLGameControllerGetAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>		/// Get the current state of an axis control on a game controller.<br/>		/// The axis indices start at index 0.<br/>		/// The state is a value ranging from -32768 to 32767. Triggers, however, range<br/>		/// from 0 to 32767 (they never return a negative value).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAxis")]
		[return: NativeName(NativeNameType.Type, "Sint16")]
		public static short SDLGameControllerGetAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				short ret = SDLGameControllerGetAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>
		/// Convert a string into an SDL_GameControllerButton enum.<br/>
		/// This function is called internally to translate SDL_GameController mapping<br/>
		/// strings for the underlying joystick device into the consistent<br/>
		/// SDL_GameController mapping. You do not normally need to call this function<br/>
		/// unless you are parsing SDL_GameController mappings in your own code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButton")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetButtonFromString")]
		internal static extern SDLGameControllerButton SDLGameControllerGetButtonFromStringNative([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str);

		/// <summary>		/// Convert a string into an SDL_GameControllerButton enum.<br/>		/// This function is called internally to translate SDL_GameController mapping<br/>		/// strings for the underlying joystick device into the consistent<br/>		/// SDL_GameController mapping. You do not normally need to call this function<br/>		/// unless you are parsing SDL_GameController mappings in your own code.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButton")]
		public static SDLGameControllerButton SDLGameControllerGetButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			SDLGameControllerButton ret = SDLGameControllerGetButtonFromStringNative(str);
			return ret;
		}

		/// <summary>		/// Convert a string into an SDL_GameControllerButton enum.<br/>		/// This function is called internally to translate SDL_GameController mapping<br/>		/// strings for the underlying joystick device into the consistent<br/>		/// SDL_GameController mapping. You do not normally need to call this function<br/>		/// unless you are parsing SDL_GameController mappings in your own code.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButton")]
		public static SDLGameControllerButton SDLGameControllerGetButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				SDLGameControllerButton ret = SDLGameControllerGetButtonFromStringNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>		/// Convert a string into an SDL_GameControllerButton enum.<br/>		/// This function is called internally to translate SDL_GameController mapping<br/>		/// strings for the underlying joystick device into the consistent<br/>		/// SDL_GameController mapping. You do not normally need to call this function<br/>		/// unless you are parsing SDL_GameController mappings in your own code.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButtonFromString")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButton")]
		public static SDLGameControllerButton SDLGameControllerGetButtonFromString([NativeName(NativeNameType.Param, "str")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLGameControllerButton ret = SDLGameControllerGetButtonFromStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert from an SDL_GameControllerButton enum to a string.<br/>
		/// The caller should not SDL_free() the returned string.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetStringForButton")]
		internal static extern byte* SDLGameControllerGetStringForButtonNative([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button);

		/// <summary>		/// Convert from an SDL_GameControllerButton enum to a string.<br/>		/// The caller should not SDL_free() the returned string.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetStringForButton([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			byte* ret = SDLGameControllerGetStringForButtonNative(button);
			return ret;
		}

		/// <summary>		/// Convert from an SDL_GameControllerButton enum to a string.<br/>		/// The caller should not SDL_free() the returned string.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetStringForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetStringForButtonS([NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerGetStringForButtonNative(button));
			return ret;
		}

		/// <summary>
		/// Get the SDL joystick layer binding for a controller button mapping.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForButton")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetBindForButton")]
		internal static extern SDLGameControllerButtonBind SDLGameControllerGetBindForButtonNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button);

		/// <summary>		/// Get the SDL joystick layer binding for a controller button mapping.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForButton")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		public static SDLGameControllerButtonBind SDLGameControllerGetBindForButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			SDLGameControllerButtonBind ret = SDLGameControllerGetBindForButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>		/// Get the SDL joystick layer binding for a controller button mapping.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetBindForButton")]
		[return: NativeName(NativeNameType.Type, "SDL_GameControllerButtonBind")]
		public static SDLGameControllerButtonBind SDLGameControllerGetBindForButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerButtonBind ret = SDLGameControllerGetBindForButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has a given button.<br/>
		/// This merely reports whether the controller's mapping defined this button,<br/>
		/// as that is all the information SDL has about the physical device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasButton")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerHasButton")]
		internal static extern SDLBool SDLGameControllerHasButtonNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button);

		/// <summary>		/// Query whether a game controller has a given button.<br/>		/// This merely reports whether the controller's mapping defined this button,<br/>		/// as that is all the information SDL has about the physical device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasButton")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			SDLBool ret = SDLGameControllerHasButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>		/// Query whether a game controller has a given button.<br/>		/// This merely reports whether the controller's mapping defined this button,<br/>		/// as that is all the information SDL has about the physical device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasButton")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a button on a game controller.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetButton")]
		internal static extern byte SDLGameControllerGetButtonNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button);

		/// <summary>		/// Get the current state of a button on a game controller.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLGameControllerGetButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			byte ret = SDLGameControllerGetButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>		/// Get the current state of a button on a game controller.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetButton")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLGameControllerGetButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte ret = SDLGameControllerGetButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of touchpads on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetNumTouchpads")]
		internal static extern int SDLGameControllerGetNumTouchpadsNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Get the number of touchpads on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetNumTouchpads([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			int ret = SDLGameControllerGetNumTouchpadsNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Get the number of touchpads on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpads")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetNumTouchpads([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetNumTouchpadsNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
		/// controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetNumTouchpadFingers")]
		internal static extern int SDLGameControllerGetNumTouchpadFingersNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad);

		/// <summary>		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>		/// controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetNumTouchpadFingers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			int ret = SDLGameControllerGetNumTouchpadFingersNative(gamecontroller, touchpad);
			return ret;
		}

		/// <summary>		/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>		/// controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetNumTouchpadFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetNumTouchpadFingers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetNumTouchpadFingersNative((SDLGameController*)pgamecontroller, touchpad);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a finger on a touchpad on a game controller.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetTouchpadFinger")]
		internal static extern int SDLGameControllerGetTouchpadFingerNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure);

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, x, y, pressure);
			return ret;
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, x, y, pressure);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, x, y, pressure);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, x, y, pressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (float* px = &x)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, (float*)px, y, pressure);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* px = &x)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, (float*)px, y, pressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, (float*)px, y, pressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, (float*)px, y, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (float* py = &y)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, x, (float*)py, pressure);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* py = &y)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, x, (float*)py, pressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* py = &y)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, x, (float*)py, pressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* py = &y)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, x, (float*)py, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, (float*)px, (float*)py, pressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, (float*)px, (float*)py, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, pressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] float* pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, pressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (float* ppressure = &pressure)
			{
				int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, x, y, (float*)ppressure);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, x, y, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, x, y, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, x, y, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, (float*)px, y, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, (float*)px, y, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, (float*)px, y, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] float* y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, (float*)px, y, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (float* py = &y)
			{
				fixed (float* ppressure = &pressure)
				{
					int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, x, (float*)py, (float*)ppressure);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, x, (float*)py, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, x, (float*)py, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] float* x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, x, (float*)py, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (float* px = &x)
			{
				fixed (float* py = &y)
				{
					fixed (float* ppressure = &pressure)
					{
						int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, state, (float*)px, (float*)py, (float*)ppressure);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] byte* state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, state, (float*)px, (float*)py, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (byte* pstate = &state)
			{
				fixed (float* px = &x)
				{
					fixed (float* py = &y)
					{
						fixed (float* ppressure = &pressure)
						{
							int ret = SDLGameControllerGetTouchpadFingerNative(gamecontroller, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, (float*)ppressure);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the current state of a finger on a touchpad on a game controller.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetTouchpadFinger")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetTouchpadFinger([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "touchpad")] [NativeName(NativeNameType.Type, "int")] int touchpad, [NativeName(NativeNameType.Param, "finger")] [NativeName(NativeNameType.Type, "int")] int finger, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte state, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float*")] ref float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float*")] ref float y, [NativeName(NativeNameType.Param, "pressure")] [NativeName(NativeNameType.Type, "float*")] ref float pressure)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (byte* pstate = &state)
				{
					fixed (float* px = &x)
					{
						fixed (float* py = &y)
						{
							fixed (float* ppressure = &pressure)
							{
								int ret = SDLGameControllerGetTouchpadFingerNative((SDLGameController*)pgamecontroller, touchpad, finger, (byte*)pstate, (float*)px, (float*)py, (float*)ppressure);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Return whether a game controller has a particular sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerHasSensor")]
		internal static extern SDLBool SDLGameControllerHasSensorNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type);

		/// <summary>		/// Return whether a game controller has a particular sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasSensor([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			SDLBool ret = SDLGameControllerHasSensorNative(gamecontroller, type);
			return ret;
		}

		/// <summary>		/// Return whether a game controller has a particular sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasSensor")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasSensor([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasSensorNative((SDLGameController*)pgamecontroller, type);
				return ret;
			}
		}

		/// <summary>
		/// Set whether data reporting for a game controller sensor is enabled.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSetSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerSetSensorEnabled")]
		internal static extern int SDLGameControllerSetSensorEnabledNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled);

		/// <summary>		/// Set whether data reporting for a game controller sensor is enabled.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerSetSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSetSensorEnabled([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			int ret = SDLGameControllerSetSensorEnabledNative(gamecontroller, type, enabled);
			return ret;
		}

		/// <summary>		/// Set whether data reporting for a game controller sensor is enabled.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerSetSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSetSensorEnabled([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "enabled")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enabled)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerSetSensorEnabledNative((SDLGameController*)pgamecontroller, type, enabled);
				return ret;
			}
		}

		/// <summary>
		/// Query whether sensor data reporting is enabled for a game controller.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerIsSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerIsSensorEnabled")]
		internal static extern SDLBool SDLGameControllerIsSensorEnabledNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type);

		/// <summary>		/// Query whether sensor data reporting is enabled for a game controller.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerIsSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerIsSensorEnabled([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			SDLBool ret = SDLGameControllerIsSensorEnabledNative(gamecontroller, type);
			return ret;
		}

		/// <summary>		/// Query whether sensor data reporting is enabled for a game controller.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerIsSensorEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerIsSensorEnabled([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerIsSensorEnabledNative((SDLGameController*)pgamecontroller, type);
				return ret;
			}
		}

		/// <summary>
		/// Get the data rate (number of events per second) of a game controller<br/>
		/// sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetSensorDataRate")]
		internal static extern float SDLGameControllerGetSensorDataRateNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type);

		/// <summary>		/// Get the data rate (number of events per second) of a game controller<br/>		/// sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLGameControllerGetSensorDataRate([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			float ret = SDLGameControllerGetSensorDataRateNative(gamecontroller, type);
			return ret;
		}

		/// <summary>		/// Get the data rate (number of events per second) of a game controller<br/>		/// sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataRate")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float SDLGameControllerGetSensorDataRate([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				float ret = SDLGameControllerGetSensorDataRateNative((SDLGameController*)pgamecontroller, type);
				return ret;
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetSensorData")]
		internal static extern int SDLGameControllerGetSensorDataNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues);

		/// <summary>		/// Get the current state of a game controller sensor.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorData([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			int ret = SDLGameControllerGetSensorDataNative(gamecontroller, type, data, numValues);
			return ret;
		}

		/// <summary>		/// Get the current state of a game controller sensor.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorData([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetSensorDataNative((SDLGameController*)pgamecontroller, type, data, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a game controller sensor.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorData([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SDLGameControllerGetSensorDataNative(gamecontroller, type, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a game controller sensor.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorData([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* pdata = &data)
				{
					int ret = SDLGameControllerGetSensorDataNative((SDLGameController*)pgamecontroller, type, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current state of a game controller sensor with the timestamp of the<br/>
		/// last update.<br/>
		/// The number of values and interpretation of the data is sensor dependent.<br/>
		/// See SDL_sensor.h for the details for each type of sensor.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetSensorDataWithTimestamp")]
		internal static extern int SDLGameControllerGetSensorDataWithTimestampNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues);

		/// <summary>		/// Get the current state of a game controller sensor with the timestamp of the<br/>		/// last update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			int ret = SDLGameControllerGetSensorDataWithTimestampNative(gamecontroller, type, timestamp, data, numValues);
			return ret;
		}

		/// <summary>		/// Get the current state of a game controller sensor with the timestamp of the<br/>		/// last update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerGetSensorDataWithTimestampNative((SDLGameController*)pgamecontroller, type, timestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a game controller sensor with the timestamp of the<br/>		/// last update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				int ret = SDLGameControllerGetSensorDataWithTimestampNative(gamecontroller, type, (ulong*)ptimestamp, data, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a game controller sensor with the timestamp of the<br/>		/// last update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] float* data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					int ret = SDLGameControllerGetSensorDataWithTimestampNative((SDLGameController*)pgamecontroller, type, (ulong*)ptimestamp, data, numValues);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a game controller sensor with the timestamp of the<br/>		/// last update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (float* pdata = &data)
			{
				int ret = SDLGameControllerGetSensorDataWithTimestampNative(gamecontroller, type, timestamp, (float*)pdata, numValues);
				return ret;
			}
		}

		/// <summary>		/// Get the current state of a game controller sensor with the timestamp of the<br/>		/// last update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ulong* timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (float* pdata = &data)
				{
					int ret = SDLGameControllerGetSensorDataWithTimestampNative((SDLGameController*)pgamecontroller, type, timestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a game controller sensor with the timestamp of the<br/>		/// last update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (ulong* ptimestamp = &timestamp)
			{
				fixed (float* pdata = &data)
				{
					int ret = SDLGameControllerGetSensorDataWithTimestampNative(gamecontroller, type, (ulong*)ptimestamp, (float*)pdata, numValues);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the current state of a game controller sensor with the timestamp of the<br/>		/// last update.<br/>		/// The number of values and interpretation of the data is sensor dependent.<br/>		/// See SDL_sensor.h for the details for each type of sensor.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetSensorDataWithTimestamp")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerGetSensorDataWithTimestamp([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "SDL_SensorType")] SDLSensorType type, [NativeName(NativeNameType.Param, "timestamp")] [NativeName(NativeNameType.Type, "Uint64*")] ref ulong timestamp, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "float*")] ref float data, [NativeName(NativeNameType.Param, "num_values")] [NativeName(NativeNameType.Type, "int")] int numValues)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				fixed (ulong* ptimestamp = &timestamp)
				{
					fixed (float* pdata = &data)
					{
						int ret = SDLGameControllerGetSensorDataWithTimestampNative((SDLGameController*)pgamecontroller, type, (ulong*)ptimestamp, (float*)pdata, numValues);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Start a rumble effect on a game controller.<br/>
		/// Each call to this function cancels any previous rumble effect, and calling<br/>
		/// it with 0 intensity stops any rumbling.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerRumble")]
		internal static extern int SDLGameControllerRumbleNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs);

		/// <summary>		/// Start a rumble effect on a game controller.<br/>		/// Each call to this function cancels any previous rumble effect, and calling<br/>		/// it with 0 intensity stops any rumbling.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerRumble([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			int ret = SDLGameControllerRumbleNative(gamecontroller, lowFrequencyRumble, highFrequencyRumble, durationMs);
			return ret;
		}

		/// <summary>		/// Start a rumble effect on a game controller.<br/>		/// Each call to this function cancels any previous rumble effect, and calling<br/>		/// it with 0 intensity stops any rumbling.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerRumble")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerRumble([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "low_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort lowFrequencyRumble, [NativeName(NativeNameType.Param, "high_frequency_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort highFrequencyRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerRumbleNative((SDLGameController*)pgamecontroller, lowFrequencyRumble, highFrequencyRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Start a rumble effect in the game controller's triggers.<br/>
		/// Each call to this function cancels any previous trigger rumble effect, and<br/>
		/// calling it with 0 intensity stops any rumbling.<br/>
		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
		/// want the (more common) whole-controller rumble, use<br/>
		/// SDL_GameControllerRumble() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerRumbleTriggers")]
		internal static extern int SDLGameControllerRumbleTriggersNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs);

		/// <summary>		/// Start a rumble effect in the game controller's triggers.<br/>		/// Each call to this function cancels any previous trigger rumble effect, and<br/>		/// calling it with 0 intensity stops any rumbling.<br/>		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>		/// want the (more common) whole-controller rumble, use<br/>		/// SDL_GameControllerRumble() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerRumbleTriggers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			int ret = SDLGameControllerRumbleTriggersNative(gamecontroller, leftRumble, rightRumble, durationMs);
			return ret;
		}

		/// <summary>		/// Start a rumble effect in the game controller's triggers.<br/>		/// Each call to this function cancels any previous trigger rumble effect, and<br/>		/// calling it with 0 intensity stops any rumbling.<br/>		/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>		/// a whole. This is currently only supported on Xbox One controllers. If you<br/>		/// want the (more common) whole-controller rumble, use<br/>		/// SDL_GameControllerRumble() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerRumbleTriggers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "left_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort leftRumble, [NativeName(NativeNameType.Param, "right_rumble")] [NativeName(NativeNameType.Type, "Uint16")] ushort rightRumble, [NativeName(NativeNameType.Param, "duration_ms")] [NativeName(NativeNameType.Type, "Uint32")] uint durationMs)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerRumbleTriggersNative((SDLGameController*)pgamecontroller, leftRumble, rightRumble, durationMs);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has an LED.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasLED")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerHasLED")]
		internal static extern SDLBool SDLGameControllerHasLEDNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Query whether a game controller has an LED.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasLED")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasLED([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLBool ret = SDLGameControllerHasLEDNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Query whether a game controller has an LED.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasLED")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasLED([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasLEDNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has rumble support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumble")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerHasRumble")]
		internal static extern SDLBool SDLGameControllerHasRumbleNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Query whether a game controller has rumble support.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumble")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasRumble([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLBool ret = SDLGameControllerHasRumbleNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Query whether a game controller has rumble support.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumble")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasRumble([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasRumbleNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Query whether a game controller has rumble support on triggers.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerHasRumbleTriggers")]
		internal static extern SDLBool SDLGameControllerHasRumbleTriggersNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Query whether a game controller has rumble support on triggers.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasRumbleTriggers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLBool ret = SDLGameControllerHasRumbleTriggersNative(gamecontroller);
			return ret;
		}

		/// <summary>		/// Query whether a game controller has rumble support on triggers.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerHasRumbleTriggers")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGameControllerHasRumbleTriggers([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLBool ret = SDLGameControllerHasRumbleTriggersNative((SDLGameController*)pgamecontroller);
				return ret;
			}
		}

		/// <summary>
		/// Update a game controller's LED color.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSetLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerSetLED")]
		internal static extern int SDLGameControllerSetLEDNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue);

		/// <summary>		/// Update a game controller's LED color.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerSetLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSetLED([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			int ret = SDLGameControllerSetLEDNative(gamecontroller, red, green, blue);
			return ret;
		}

		/// <summary>		/// Update a game controller's LED color.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerSetLED")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSetLED([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "red")] [NativeName(NativeNameType.Type, "Uint8")] byte red, [NativeName(NativeNameType.Param, "green")] [NativeName(NativeNameType.Type, "Uint8")] byte green, [NativeName(NativeNameType.Param, "blue")] [NativeName(NativeNameType.Type, "Uint8")] byte blue)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerSetLEDNative((SDLGameController*)pgamecontroller, red, green, blue);
				return ret;
			}
		}

		/// <summary>
		/// Send a controller specific effect packet<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerSendEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerSendEffect")]
		internal static extern int SDLGameControllerSendEffectNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size);

		/// <summary>		/// Send a controller specific effect packet<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerSendEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSendEffect([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			int ret = SDLGameControllerSendEffectNative(gamecontroller, data, size);
			return ret;
		}

		/// <summary>		/// Send a controller specific effect packet<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerSendEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGameControllerSendEffect([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const void*")] void* data, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "int")] int size)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				int ret = SDLGameControllerSendEffectNative((SDLGameController*)pgamecontroller, data, size);
				return ret;
			}
		}

		/// <summary>
		/// Close a game controller previously opened with SDL_GameControllerOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerClose")]
		internal static extern void SDLGameControllerCloseNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller);

		/// <summary>		/// Close a game controller previously opened with SDL_GameControllerOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGameControllerClose([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller)
		{
			SDLGameControllerCloseNative(gamecontroller);
		}

		/// <summary>		/// Close a game controller previously opened with SDL_GameControllerOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGameControllerClose([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				SDLGameControllerCloseNative((SDLGameController*)pgamecontroller);
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		internal static extern byte* SDLGameControllerGetAppleSFSymbolsNameForButtonNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button);

		/// <summary>		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>		/// platforms.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetAppleSFSymbolsNameForButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			byte* ret = SDLGameControllerGetAppleSFSymbolsNameForButtonNative(gamecontroller, button);
			return ret;
		}

		/// <summary>		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>		/// platforms.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetAppleSFSymbolsNameForButtonS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerGetAppleSFSymbolsNameForButtonNative(gamecontroller, button));
			return ret;
		}

		/// <summary>		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>		/// platforms.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetAppleSFSymbolsNameForButton([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = SDLGameControllerGetAppleSFSymbolsNameForButtonNative((SDLGameController*)pgamecontroller, button);
				return ret;
			}
		}

		/// <summary>		/// Return the sfSymbolsName for a given button on a game controller on Apple<br/>		/// platforms.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForButton")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetAppleSFSymbolsNameForButtonS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "SDL_GameControllerButton")] SDLGameControllerButton button)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(SDLGameControllerGetAppleSFSymbolsNameForButtonNative((SDLGameController*)pgamecontroller, button));
				return ret;
			}
		}

		/// <summary>
		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>
		/// platforms.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		internal static extern byte* SDLGameControllerGetAppleSFSymbolsNameForAxisNative([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis);

		/// <summary>		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>		/// platforms.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetAppleSFSymbolsNameForAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			byte* ret = SDLGameControllerGetAppleSFSymbolsNameForAxisNative(gamecontroller, axis);
			return ret;
		}

		/// <summary>		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>		/// platforms.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetAppleSFSymbolsNameForAxisS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] SDLGameController* gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			string ret = Utils.DecodeStringUTF8(SDLGameControllerGetAppleSFSymbolsNameForAxisNative(gamecontroller, axis));
			return ret;
		}

		/// <summary>		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>		/// platforms.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGameControllerGetAppleSFSymbolsNameForAxis([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				byte* ret = SDLGameControllerGetAppleSFSymbolsNameForAxisNative((SDLGameController*)pgamecontroller, axis);
				return ret;
			}
		}

		/// <summary>		/// Return the sfSymbolsName for a given axis on a game controller on Apple<br/>		/// platforms.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GameControllerGetAppleSFSymbolsNameForAxis")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGameControllerGetAppleSFSymbolsNameForAxisS([NativeName(NativeNameType.Param, "gamecontroller")] [NativeName(NativeNameType.Type, "SDL_GameController*")] ref SDLGameController gamecontroller, [NativeName(NativeNameType.Param, "axis")] [NativeName(NativeNameType.Type, "SDL_GameControllerAxis")] SDLGameControllerAxis axis)
		{
			fixed (SDLGameController* pgamecontroller = &gamecontroller)
			{
				string ret = Utils.DecodeStringUTF8(SDLGameControllerGetAppleSFSymbolsNameForAxisNative((SDLGameController*)pgamecontroller, axis));
				return ret;
			}
		}

		/// <summary>
		/// Get the number of registered touch devices.<br/>
		/// On some platforms SDL first sees the touch device if it was actually used.<br/>
		/// Therefore SDL_GetNumTouchDevices() may return 0 although devices are<br/>
		/// available. After using all devices at least once the number will be<br/>
		/// correct.<br/>
		/// This was fixed for Android in SDL 2.0.1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumTouchDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetNumTouchDevices")]
		internal static extern int SDLGetNumTouchDevicesNative();

		/// <summary>		/// Get the number of registered touch devices.<br/>		/// On some platforms SDL first sees the touch device if it was actually used.<br/>		/// Therefore SDL_GetNumTouchDevices() may return 0 although devices are<br/>		/// available. After using all devices at least once the number will be<br/>		/// correct.<br/>		/// This was fixed for Android in SDL 2.0.1.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumTouchDevices")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumTouchDevices()
		{
			int ret = SDLGetNumTouchDevicesNative();
			return ret;
		}

		/// <summary>
		/// Get the touch ID with the given index.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTouchDevice")]
		internal static extern long SDLGetTouchDeviceNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index);

		/// <summary>		/// Get the touch ID with the given index.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTouchDevice")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchID")]
		public static long SDLGetTouchDevice([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			long ret = SDLGetTouchDeviceNative(index);
			return ret;
		}

		/// <summary>
		/// Get the touch device name as reported from the driver or NULL if the index<br/>
		/// is invalid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTouchName")]
		internal static extern byte* SDLGetTouchNameNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index);

		/// <summary>		/// Get the touch device name as reported from the driver or NULL if the index<br/>		/// is invalid.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTouchName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetTouchName([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			byte* ret = SDLGetTouchNameNative(index);
			return ret;
		}

		/// <summary>		/// Get the touch device name as reported from the driver or NULL if the index<br/>		/// is invalid.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTouchName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetTouchNameS([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetTouchNameNative(index));
			return ret;
		}

		/// <summary>
		/// Get the type of the given touch device.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchDeviceType")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTouchDeviceType")]
		internal static extern SDLTouchDeviceType SDLGetTouchDeviceTypeNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID);

		/// <summary>		/// Get the type of the given touch device.<br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTouchDeviceType")]
		[return: NativeName(NativeNameType.Type, "SDL_TouchDeviceType")]
		public static SDLTouchDeviceType SDLGetTouchDeviceType([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			SDLTouchDeviceType ret = SDLGetTouchDeviceTypeNative(touchID);
			return ret;
		}

		/// <summary>
		/// Get the number of active fingers for a given touch device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumTouchFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetNumTouchFingers")]
		internal static extern int SDLGetNumTouchFingersNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID);

		/// <summary>		/// Get the number of active fingers for a given touch device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumTouchFingers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumTouchFingers([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID)
		{
			int ret = SDLGetNumTouchFingersNative(touchID);
			return ret;
		}

		/// <summary>
		/// Get the finger object for specified touch device ID and finger index.<br/>
		/// The returned resource is owned by SDL and should not be deallocated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTouchFinger")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTouchFinger")]
		internal static extern SDLFinger* SDLGetTouchFingerNative([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index);

		/// <summary>		/// Get the finger object for specified touch device ID and finger index.<br/>		/// The returned resource is owned by SDL and should not be deallocated.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTouchFinger")]
		[return: NativeName(NativeNameType.Type, "SDL_Finger*")]
		public static SDLFinger* SDLGetTouchFinger([NativeName(NativeNameType.Param, "touchID")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchID, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index)
		{
			SDLFinger* ret = SDLGetTouchFingerNative(touchID, index);
			return ret;
		}

		/// <summary>
		/// Begin recording a gesture on a specified touch device or all touch devices.<br/>
		/// If the parameter `touchId` is -1 (i.e., all devices), this function will<br/>
		/// always return 1, regardless of whether there actually are any devices.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RecordGesture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RecordGesture")]
		internal static extern int SDLRecordGestureNative([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId);

		/// <summary>		/// Begin recording a gesture on a specified touch device or all touch devices.<br/>		/// If the parameter `touchId` is -1 (i.e., all devices), this function will<br/>		/// always return 1, regardless of whether there actually are any devices.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RecordGesture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRecordGesture([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId)
		{
			int ret = SDLRecordGestureNative(touchId);
			return ret;
		}

		/// <summary>
		/// Save all currently loaded Dollar Gesture templates.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveAllDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SaveAllDollarTemplates")]
		internal static extern int SDLSaveAllDollarTemplatesNative([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst);

		/// <summary>		/// Save all currently loaded Dollar Gesture templates.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveAllDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveAllDollarTemplates([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst)
		{
			int ret = SDLSaveAllDollarTemplatesNative(dst);
			return ret;
		}

		/// <summary>		/// Save all currently loaded Dollar Gesture templates.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveAllDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveAllDollarTemplates([NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = SDLSaveAllDollarTemplatesNative((SDLRWops*)pdst);
				return ret;
			}
		}

		/// <summary>
		/// Save a currently loaded Dollar Gesture template.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SaveDollarTemplate")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SaveDollarTemplate")]
		internal static extern int SDLSaveDollarTemplateNative([NativeName(NativeNameType.Param, "gestureId")] [NativeName(NativeNameType.Type, "SDL_GestureID")] long gestureId, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst);

		/// <summary>		/// Save a currently loaded Dollar Gesture template.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveDollarTemplate")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveDollarTemplate([NativeName(NativeNameType.Param, "gestureId")] [NativeName(NativeNameType.Type, "SDL_GestureID")] long gestureId, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst)
		{
			int ret = SDLSaveDollarTemplateNative(gestureId, dst);
			return ret;
		}

		/// <summary>		/// Save a currently loaded Dollar Gesture template.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SaveDollarTemplate")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSaveDollarTemplate([NativeName(NativeNameType.Param, "gestureId")] [NativeName(NativeNameType.Type, "SDL_GestureID")] long gestureId, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = SDLSaveDollarTemplateNative(gestureId, (SDLRWops*)pdst);
				return ret;
			}
		}

		/// <summary>
		/// Load Dollar Gesture templates from a file.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LoadDollarTemplates")]
		internal static extern int SDLLoadDollarTemplatesNative([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src);

		/// <summary>		/// Load Dollar Gesture templates from a file.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLoadDollarTemplates([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = SDLLoadDollarTemplatesNative(touchId, src);
			return ret;
		}

		/// <summary>		/// Load Dollar Gesture templates from a file.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadDollarTemplates")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLoadDollarTemplates([NativeName(NativeNameType.Param, "touchId")] [NativeName(NativeNameType.Type, "SDL_TouchID")] long touchId, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = SDLLoadDollarTemplatesNative(touchId, (SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Pump the event loop, gathering events from the input devices.<br/>
		/// This function updates the event queue and internal input device state.<br/>
		/// **WARNING**: This should only be run in the thread that initialized the<br/>
		/// video subsystem, and for extra safety, you should consider only doing those<br/>
		/// things on the main thread in any case.<br/>
		/// SDL_PumpEvents() gathers all the pending input information from devices and<br/>
		/// places it in the event queue. Without calls to SDL_PumpEvents() no events<br/>
		/// would ever be placed on the queue. Often the need for calls to<br/>
		/// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and<br/>
		/// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not<br/>
		/// polling or waiting for events (e.g. you are filtering them), then you must<br/>
		/// call SDL_PumpEvents() to force an event queue update.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PumpEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_PumpEvents")]
		internal static extern void SDLPumpEventsNative();

		/// <summary>		/// Pump the event loop, gathering events from the input devices.<br/>		/// This function updates the event queue and internal input device state.<br/>		/// **WARNING**: This should only be run in the thread that initialized the<br/>		/// video subsystem, and for extra safety, you should consider only doing those<br/>		/// things on the main thread in any case.<br/>		/// SDL_PumpEvents() gathers all the pending input information from devices and<br/>		/// places it in the event queue. Without calls to SDL_PumpEvents() no events<br/>		/// would ever be placed on the queue. Often the need for calls to<br/>		/// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and<br/>		/// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not<br/>		/// polling or waiting for events (e.g. you are filtering them), then you must<br/>		/// call SDL_PumpEvents() to force an event queue update.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PumpEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLPumpEvents()
		{
			SDLPumpEventsNative();
		}

		/// <summary>
		/// Check the event queue for messages and optionally return them.<br/>
		/// `action` may be any of the following:<br/>
		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
		/// event queue.<br/>
		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will _not_ be removed from the queue.<br/>
		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
		/// within the specified minimum and maximum type, will be returned to the<br/>
		/// caller and will be removed from the queue.<br/>
		/// You may have to call SDL_PumpEvents() before calling this function.<br/>
		/// Otherwise, the events may not be ready to be filtered when you call<br/>
		/// SDL_PeepEvents().<br/>
		/// This function is thread-safe.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_PeepEvents")]
		internal static extern int SDLPeepEventsNative([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_eventaction")] SDLEventaction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType);

		/// <summary>		/// Check the event queue for messages and optionally return them.<br/>		/// `action` may be any of the following:<br/>		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>		/// event queue.<br/>		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>		/// within the specified minimum and maximum type, will be returned to the<br/>		/// caller and will _not_ be removed from the queue.<br/>		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>		/// within the specified minimum and maximum type, will be returned to the<br/>		/// caller and will be removed from the queue.<br/>		/// You may have to call SDL_PumpEvents() before calling this function.<br/>		/// Otherwise, the events may not be ready to be filtered when you call<br/>		/// SDL_PeepEvents().<br/>		/// This function is thread-safe.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPeepEvents([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_eventaction")] SDLEventaction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			int ret = SDLPeepEventsNative(events, numevents, action, minType, maxType);
			return ret;
		}

		/// <summary>		/// Check the event queue for messages and optionally return them.<br/>		/// `action` may be any of the following:<br/>		/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>		/// event queue.<br/>		/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>		/// within the specified minimum and maximum type, will be returned to the<br/>		/// caller and will _not_ be removed from the queue.<br/>		/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>		/// within the specified minimum and maximum type, will be returned to the<br/>		/// caller and will be removed from the queue.<br/>		/// You may have to call SDL_PumpEvents() before calling this function.<br/>		/// Otherwise, the events may not be ready to be filtered when you call<br/>		/// SDL_PeepEvents().<br/>		/// This function is thread-safe.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PeepEvents")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPeepEvents([NativeName(NativeNameType.Param, "events")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent events, [NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "SDL_eventaction")] SDLEventaction action, [NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			fixed (SDLEvent* pevents = &events)
			{
				int ret = SDLPeepEventsNative((SDLEvent*)pevents, numevents, action, minType, maxType);
				return ret;
			}
		}

		/// <summary>
		/// Check for the existence of a certain event type in the event queue.<br/>
		/// If you need to check for a range of event types, use SDL_HasEvents()<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvent")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasEvent")]
		internal static extern SDLBool SDLHasEventNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type);

		/// <summary>		/// Check for the existence of a certain event type in the event queue.<br/>		/// If you need to check for a range of event types, use SDL_HasEvents()<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasEvent")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasEvent([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			SDLBool ret = SDLHasEventNative(type);
			return ret;
		}

		/// <summary>
		/// Check for the existence of certain event types in the event queue.<br/>
		/// If you need to check for a single event type, use SDL_HasEvent() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HasEvents")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HasEvents")]
		internal static extern SDLBool SDLHasEventsNative([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType);

		/// <summary>		/// Check for the existence of certain event types in the event queue.<br/>		/// If you need to check for a single event type, use SDL_HasEvent() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HasEvents")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLHasEvents([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			SDLBool ret = SDLHasEventsNative(minType, maxType);
			return ret;
		}

		/// <summary>
		/// Clear events of a specific type from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that match<br/>
		/// `type`. If you need to remove a range of event types, use SDL_FlushEvents()<br/>
		/// instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FlushEvent")]
		internal static extern void SDLFlushEventNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type);

		/// <summary>		/// Clear events of a specific type from the event queue.<br/>		/// This will unconditionally remove any events from the queue that match<br/>		/// `type`. If you need to remove a range of event types, use SDL_FlushEvents()<br/>		/// instead.<br/>		/// It's also normal to just ignore events you don't care about in your event<br/>		/// loop without calling this function.<br/>		/// This function only affects currently queued events. If you want to make<br/>		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>		/// on the main thread immediately before the flush call.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FlushEvent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFlushEvent([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type)
		{
			SDLFlushEventNative(type);
		}

		/// <summary>
		/// Clear events of a range of types from the event queue.<br/>
		/// This will unconditionally remove any events from the queue that are in the<br/>
		/// range of `minType` to `maxType`, inclusive. If you need to remove a single<br/>
		/// event type, use SDL_FlushEvent() instead.<br/>
		/// It's also normal to just ignore events you don't care about in your event<br/>
		/// loop without calling this function.<br/>
		/// This function only affects currently queued events. If you want to make<br/>
		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
		/// on the main thread immediately before the flush call.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FlushEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FlushEvents")]
		internal static extern void SDLFlushEventsNative([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType);

		/// <summary>		/// Clear events of a range of types from the event queue.<br/>		/// This will unconditionally remove any events from the queue that are in the<br/>		/// range of `minType` to `maxType`, inclusive. If you need to remove a single<br/>		/// event type, use SDL_FlushEvent() instead.<br/>		/// It's also normal to just ignore events you don't care about in your event<br/>		/// loop without calling this function.<br/>		/// This function only affects currently queued events. If you want to make<br/>		/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>		/// on the main thread immediately before the flush call.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FlushEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFlushEvents([NativeName(NativeNameType.Param, "minType")] [NativeName(NativeNameType.Type, "Uint32")] uint minType, [NativeName(NativeNameType.Param, "maxType")] [NativeName(NativeNameType.Type, "Uint32")] uint maxType)
		{
			SDLFlushEventsNative(minType, maxType);
		}

		/// <summary>
		/// Poll for currently pending events.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>
		/// this event, immediately stored in the SDL Event structure -- not an event<br/>
		/// to follow.<br/>
		/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>
		/// but will not remove it from the queue.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that set the video mode.<br/>
		/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>
		/// be done from the main loop and does not suspend the main loop while waiting<br/>
		/// on an event to be posted.<br/>
		/// The common practice is to fully process the event queue once every frame,<br/>
		/// usually as a first step before updating the game's state:<br/>
		/// ```c<br/>
		/// while (game_is_still_running) {<br/>
		/// SDL_Event event;<br/>
		/// while (SDL_PollEvent(<br/>
		/// &event<br/>
		/// )) {  // poll until all events are handled!<br/>
		/// // decide what to do with this event.<br/>
		/// }<br/>
		/// // update game state, draw the current frame<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PollEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_PollEvent")]
		internal static extern int SDLPollEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt);

		/// <summary>		/// Poll for currently pending events.<br/>		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>		/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>		/// this event, immediately stored in the SDL Event structure -- not an event<br/>		/// to follow.<br/>		/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>		/// but will not remove it from the queue.<br/>		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>		/// this function in the thread that set the video mode.<br/>		/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>		/// be done from the main loop and does not suspend the main loop while waiting<br/>		/// on an event to be posted.<br/>		/// The common practice is to fully process the event queue once every frame,<br/>		/// usually as a first step before updating the game's state:<br/>		/// ```c<br/>		/// while (game_is_still_running) {<br/>		/// SDL_Event event;<br/>		/// while (SDL_PollEvent(<br/>		/// &event<br/>		/// )) {  // poll until all events are handled!<br/>		/// // decide what to do with this event.<br/>		/// }<br/>		/// // update game state, draw the current frame<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PollEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPollEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt)
		{
			int ret = SDLPollEventNative(evnt);
			return ret;
		}

		/// <summary>		/// Poll for currently pending events.<br/>		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>		/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>		/// this event, immediately stored in the SDL Event structure -- not an event<br/>		/// to follow.<br/>		/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>		/// but will not remove it from the queue.<br/>		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>		/// this function in the thread that set the video mode.<br/>		/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>		/// be done from the main loop and does not suspend the main loop while waiting<br/>		/// on an event to be posted.<br/>		/// The common practice is to fully process the event queue once every frame,<br/>		/// usually as a first step before updating the game's state:<br/>		/// ```c<br/>		/// while (game_is_still_running) {<br/>		/// SDL_Event event;<br/>		/// while (SDL_PollEvent(<br/>		/// &event<br/>		/// )) {  // poll until all events are handled!<br/>		/// // decide what to do with this event.<br/>		/// }<br/>		/// // update game state, draw the current frame<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PollEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPollEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				int ret = SDLPollEventNative((SDLEvent*)pevnt);
				return ret;
			}
		}

		/// <summary>
		/// Wait indefinitely for the next available event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WaitEvent")]
		internal static extern int SDLWaitEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt);

		/// <summary>		/// Wait indefinitely for the next available event.<br/>		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>		/// in the SDL_Event structure pointed to by `event`.<br/>		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>		/// this function in the thread that initialized the video subsystem.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWaitEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt)
		{
			int ret = SDLWaitEventNative(evnt);
			return ret;
		}

		/// <summary>		/// Wait indefinitely for the next available event.<br/>		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>		/// in the SDL_Event structure pointed to by `event`.<br/>		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>		/// this function in the thread that initialized the video subsystem.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWaitEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				int ret = SDLWaitEventNative((SDLEvent*)pevnt);
				return ret;
			}
		}

		/// <summary>
		/// Wait until the specified timeout (in milliseconds) for the next available<br/>
		/// event.<br/>
		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
		/// in the SDL_Event structure pointed to by `event`.<br/>
		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
		/// this function in the thread that initialized the video subsystem.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WaitEventTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WaitEventTimeout")]
		internal static extern int SDLWaitEventTimeoutNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "int")] int timeout);

		/// <summary>		/// Wait until the specified timeout (in milliseconds) for the next available<br/>		/// event.<br/>		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>		/// in the SDL_Event structure pointed to by `event`.<br/>		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>		/// this function in the thread that initialized the video subsystem.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitEventTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWaitEventTimeout([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "int")] int timeout)
		{
			int ret = SDLWaitEventTimeoutNative(evnt, timeout);
			return ret;
		}

		/// <summary>		/// Wait until the specified timeout (in milliseconds) for the next available<br/>		/// event.<br/>		/// If `event` is not NULL, the next event is removed from the queue and stored<br/>		/// in the SDL_Event structure pointed to by `event`.<br/>		/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>		/// this function in the thread that initialized the video subsystem.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WaitEventTimeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLWaitEventTimeout([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent evnt, [NativeName(NativeNameType.Param, "timeout")] [NativeName(NativeNameType.Type, "int")] int timeout)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				int ret = SDLWaitEventTimeoutNative((SDLEvent*)pevnt, timeout);
				return ret;
			}
		}

		/// <summary>
		/// Add an event to the event queue.<br/>
		/// The event queue can actually be used as a two way communication channel.<br/>
		/// Not only can events be read from the queue, but the user can also push<br/>
		/// their own events onto it. `event` is a pointer to the event structure you<br/>
		/// wish to push onto the queue. The event is copied into the queue, and the<br/>
		/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>
		/// Note: Pushing device input events onto the queue doesn't modify the state<br/>
		/// of the device within SDL.<br/>
		/// This function is thread-safe, and can be called from other threads safely.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter but events added with SDL_PeepEvents() do not.<br/>
		/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>
		/// get an event type that does not conflict with other code that also wants<br/>
		/// its own custom event types.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_PushEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_PushEvent")]
		internal static extern int SDLPushEventNative([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt);

		/// <summary>		/// Add an event to the event queue.<br/>		/// The event queue can actually be used as a two way communication channel.<br/>		/// Not only can events be read from the queue, but the user can also push<br/>		/// their own events onto it. `event` is a pointer to the event structure you<br/>		/// wish to push onto the queue. The event is copied into the queue, and the<br/>		/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>		/// Note: Pushing device input events onto the queue doesn't modify the state<br/>		/// of the device within SDL.<br/>		/// This function is thread-safe, and can be called from other threads safely.<br/>		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>		/// the event filter but events added with SDL_PeepEvents() do not.<br/>		/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>		/// get an event type that does not conflict with other code that also wants<br/>		/// its own custom event types.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PushEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPushEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] SDLEvent* evnt)
		{
			int ret = SDLPushEventNative(evnt);
			return ret;
		}

		/// <summary>		/// Add an event to the event queue.<br/>		/// The event queue can actually be used as a two way communication channel.<br/>		/// Not only can events be read from the queue, but the user can also push<br/>		/// their own events onto it. `event` is a pointer to the event structure you<br/>		/// wish to push onto the queue. The event is copied into the queue, and the<br/>		/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>		/// Note: Pushing device input events onto the queue doesn't modify the state<br/>		/// of the device within SDL.<br/>		/// This function is thread-safe, and can be called from other threads safely.<br/>		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>		/// the event filter but events added with SDL_PeepEvents() do not.<br/>		/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>		/// get an event type that does not conflict with other code that also wants<br/>		/// its own custom event types.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_PushEvent")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLPushEvent([NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "SDL_Event*")] ref SDLEvent evnt)
		{
			fixed (SDLEvent* pevnt = &evnt)
			{
				int ret = SDLPushEventNative((SDLEvent*)pevnt);
				return ret;
			}
		}

		/// <summary>
		/// Set up a filter to process all events before they change internal state and<br/>
		/// are posted to the internal event queue.<br/>
		/// If the filter function returns 1 when called, then the event will be added<br/>
		/// to the internal queue. If it returns 0, then the event will be dropped from<br/>
		/// the queue, but the internal state will still be updated. This allows<br/>
		/// selective filtering of dynamically arriving events.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// On platforms that support it, if the quit event is generated by an<br/>
		/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>
		/// application at the next event poll.<br/>
		/// There is one caveat when dealing with the ::SDL_QuitEvent event type. The<br/>
		/// event filter is only called when the window manager desires to close the<br/>
		/// application window. If the event filter returns 1, then the window will be<br/>
		/// closed, otherwise the window will remain open if possible.<br/>
		/// Note: Disabled events never make it to the event filter function; see<br/>
		/// SDL_EventState().<br/>
		/// Note: If you just want to inspect events without filtering, you should use<br/>
		/// SDL_AddEventWatch() instead.<br/>
		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
		/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>
		/// not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetEventFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetEventFilter")]
		internal static extern void SDLSetEventFilterNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Set up a filter to process all events before they change internal state and<br/>		/// are posted to the internal event queue.<br/>		/// If the filter function returns 1 when called, then the event will be added<br/>		/// to the internal queue. If it returns 0, then the event will be dropped from<br/>		/// the queue, but the internal state will still be updated. This allows<br/>		/// selective filtering of dynamically arriving events.<br/>		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>		/// as it may run in a different thread!<br/>		/// On platforms that support it, if the quit event is generated by an<br/>		/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>		/// application at the next event poll.<br/>		/// There is one caveat when dealing with the ::SDL_QuitEvent event type. The<br/>		/// event filter is only called when the window manager desires to close the<br/>		/// application window. If the event filter returns 1, then the window will be<br/>		/// closed, otherwise the window will remain open if possible.<br/>		/// Note: Disabled events never make it to the event filter function; see<br/>		/// SDL_EventState().<br/>		/// Note: If you just want to inspect events without filtering, you should use<br/>		/// SDL_AddEventWatch() instead.<br/>		/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>		/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>		/// not.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetEventFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLSetEventFilterNative(filter, userdata);
		}

		/// <summary>
		/// Query the current event filter.<br/>
		/// This function can be used to "chain" filters, by saving the existing filter<br/>
		/// before replacing it with a function that will call that saved filter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetEventFilter")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetEventFilter")]
		internal static extern SDLBool SDLGetEventFilterNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter*")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void**")] void** userdata);

		/// <summary>		/// Query the current event filter.<br/>		/// This function can be used to "chain" filters, by saving the existing filter<br/>		/// before replacing it with a function that will call that saved filter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetEventFilter")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetEventFilter([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter*")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void**")] void** userdata)
		{
			SDLBool ret = SDLGetEventFilterNative(filter, userdata);
			return ret;
		}

		/// <summary>
		/// Add a callback to be triggered when an event is added to the event queue.<br/>
		/// `filter` will be called when an event happens, and its return value is<br/>
		/// ignored.<br/>
		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
		/// as it may run in a different thread!<br/>
		/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>
		/// the internal queue and be delivered to the watch callback immediately, and<br/>
		/// arrive at the next event poll.<br/>
		/// Note: the callback is called for events posted by the user through<br/>
		/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>
		/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>
		/// through SDL_PeepEvents().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AddEventWatch")]
		internal static extern void SDLAddEventWatchNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Add a callback to be triggered when an event is added to the event queue.<br/>		/// `filter` will be called when an event happens, and its return value is<br/>		/// ignored.<br/>		/// **WARNING**: Be very careful of what you do in the event filter function,<br/>		/// as it may run in a different thread!<br/>		/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>		/// the internal queue and be delivered to the watch callback immediately, and<br/>		/// arrive at the next event poll.<br/>		/// Note: the callback is called for events posted by the user through<br/>		/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>		/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>		/// through SDL_PeepEvents().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AddEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAddEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLAddEventWatchNative(filter, userdata);
		}

		/// <summary>
		/// Remove an event watch callback added with SDL_AddEventWatch().<br/>
		/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>
		/// delete the corresponding callback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DelEventWatch")]
		internal static extern void SDLDelEventWatchNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Remove an event watch callback added with SDL_AddEventWatch().<br/>		/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>		/// delete the corresponding callback.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DelEventWatch")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDelEventWatch([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLDelEventWatchNative(filter, userdata);
		}

		/// <summary>
		/// Run a specific filter function on the current event queue, removing any<br/>
		/// events for which the filter returns 0.<br/>
		/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>
		/// this function does not change the filter permanently, it only uses the<br/>
		/// supplied filter until this function returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_FilterEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_FilterEvents")]
		internal static extern void SDLFilterEventsNative([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Run a specific filter function on the current event queue, removing any<br/>		/// events for which the filter returns 0.<br/>		/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>		/// this function does not change the filter permanently, it only uses the<br/>		/// supplied filter until this function returns.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_FilterEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLFilterEvents([NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "SDL_EventFilter")] SDLEventFilter filter, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLFilterEventsNative(filter, userdata);
		}

		/// <summary>
		/// Set the state of processing events by type.<br/>
		/// `state` may be any of the following:<br/>
		/// - `SDL_QUERY`: returns the current processing state of the specified event<br/>
		/// - `SDL_IGNORE` (aka `SDL_DISABLE`): the event will automatically be dropped<br/>
		/// from the event queue and will not be filtered<br/>
		/// - `SDL_ENABLE`: the event will be processed normally<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_EventState")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_EventState")]
		internal static extern byte SDLEventStateNative([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "int")] int state);

		/// <summary>		/// Set the state of processing events by type.<br/>		/// `state` may be any of the following:<br/>		/// - `SDL_QUERY`: returns the current processing state of the specified event<br/>		/// - `SDL_IGNORE` (aka `SDL_DISABLE`): the event will automatically be dropped<br/>		/// from the event queue and will not be filtered<br/>		/// - `SDL_ENABLE`: the event will be processed normally<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_EventState")]
		[return: NativeName(NativeNameType.Type, "Uint8")]
		public static byte SDLEventState([NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "Uint32")] uint type, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "int")] int state)
		{
			byte ret = SDLEventStateNative(type, state);
			return ret;
		}

		/// <summary>
		/// Allocate a set of user-defined events, and return the beginning event<br/>
		/// number for that set of events.<br/>
		/// Calling this function with `numevents` <br/>
		/// <<br/>
		/// = 0 is an error and will return<br/>
		/// (Uint32)-1.<br/>
		/// Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or<br/>
		/// 0xFFFFFFFF), but is clearer to write.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RegisterEvents")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RegisterEvents")]
		internal static extern uint SDLRegisterEventsNative([NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents);

		/// <summary>		/// Allocate a set of user-defined events, and return the beginning event<br/>		/// number for that set of events.<br/>		/// Calling this function with `numevents` <br/>		/// <<br/>		/// = 0 is an error and will return<br/>		/// (Uint32)-1.<br/>		/// Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or<br/>		/// 0xFFFFFFFF), but is clearer to write.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RegisterEvents")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLRegisterEvents([NativeName(NativeNameType.Param, "numevents")] [NativeName(NativeNameType.Type, "int")] int numevents)
		{
			uint ret = SDLRegisterEventsNative(numevents);
			return ret;
		}

		/// <summary>
		/// Get the directory where the application was run from.<br/>
		/// This is not necessarily a fast call, so you should call this once near<br/>
		/// startup and save the string if you need it.<br/>
		/// **Mac OS X and iOS Specific Functionality**: If the application is in a<br/>
		/// ".app" bundle, this function returns the Resource directory (e.g.<br/>
		/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>
		/// a property to the Info.plist file. Adding a string key with the name<br/>
		/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>
		/// behaviour.<br/>
		/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>
		/// application in /Applications/SDLApp/MyApp.app):<br/>
		/// - `resource`: bundle resource directory (the default). For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>
		/// - `bundle`: the Bundle directory. For example:<br/>
		/// `/Applications/SDLApp/MyApp.app/`<br/>
		/// - `parent`: the containing directory of the bundle. For example:<br/>
		/// `/Applications/SDLApp/`<br/>
		/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>
		/// directory of the application as it is uncommon to store resources outside<br/>
		/// the executable. As such it is not a writable directory.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetBasePath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetBasePath")]
		internal static extern byte* SDLGetBasePathNative();

		/// <summary>		/// Get the directory where the application was run from.<br/>		/// This is not necessarily a fast call, so you should call this once near<br/>		/// startup and save the string if you need it.<br/>		/// **Mac OS X and iOS Specific Functionality**: If the application is in a<br/>		/// ".app" bundle, this function returns the Resource directory (e.g.<br/>		/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>		/// a property to the Info.plist file. Adding a string key with the name<br/>		/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>		/// behaviour.<br/>		/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>		/// application in /Applications/SDLApp/MyApp.app):<br/>		/// - `resource`: bundle resource directory (the default). For example:<br/>		/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>		/// - `bundle`: the Bundle directory. For example:<br/>		/// `/Applications/SDLApp/MyApp.app/`<br/>		/// - `parent`: the containing directory of the bundle. For example:<br/>		/// `/Applications/SDLApp/`<br/>		/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>		/// directory of the application as it is uncommon to store resources outside<br/>		/// the executable. As such it is not a writable directory.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetBasePath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetBasePath()
		{
			byte* ret = SDLGetBasePathNative();
			return ret;
		}

		/// <summary>		/// Get the directory where the application was run from.<br/>		/// This is not necessarily a fast call, so you should call this once near<br/>		/// startup and save the string if you need it.<br/>		/// **Mac OS X and iOS Specific Functionality**: If the application is in a<br/>		/// ".app" bundle, this function returns the Resource directory (e.g.<br/>		/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>		/// a property to the Info.plist file. Adding a string key with the name<br/>		/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>		/// behaviour.<br/>		/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>		/// application in /Applications/SDLApp/MyApp.app):<br/>		/// - `resource`: bundle resource directory (the default). For example:<br/>		/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>		/// - `bundle`: the Bundle directory. For example:<br/>		/// `/Applications/SDLApp/MyApp.app/`<br/>		/// - `parent`: the containing directory of the bundle. For example:<br/>		/// `/Applications/SDLApp/`<br/>		/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>		/// directory of the application as it is uncommon to store resources outside<br/>		/// the executable. As such it is not a writable directory.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetBasePath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetBasePathS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetBasePathNative());
			return ret;
		}

		/// <summary>
		/// Get the user-and-app-specific path where files can be written.<br/>
		/// Get the "pref dir". This is meant to be where users can write personal<br/>
		/// files (preferences and save games, etc) that are specific to your<br/>
		/// application. This directory is unique per user, per application.<br/>
		/// This function will decide the appropriate location in the native<br/>
		/// filesystem, create the directory if necessary, and return a string of the<br/>
		/// absolute path to the directory in UTF-8 encoding.<br/>
		/// On Windows, the string might look like:<br/>
		/// `C:<br/>
		/// \<br/>
		/// Users<br/>
		/// \<br/>
		/// bob<br/>
		/// \<br/>
		/// AppData<br/>
		/// \<br/>
		/// Roaming<br/>
		/// \<br/>
		/// My Company<br/>
		/// \<br/>
		/// My Program Name<br/>
		/// \<br/>
		/// `<br/>
		/// On Linux, the string might look like:<br/>
		/// `/home/bob/.local/share/My Program Name/`<br/>
		/// On Mac OS X, the string might look like:<br/>
		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
		/// You should assume the path returned by this function is the only safe place<br/>
		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
		/// even the parent of the returned path, isn't where you should be writing<br/>
		/// things).<br/>
		/// Both the org and app strings may become part of a directory name, so please<br/>
		/// follow these rules:<br/>
		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
		/// your applications that use this function.<br/>
		/// - Always use a unique app string for each one, and make sure it never<br/>
		/// changes for an app once you've decided on it.<br/>
		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>
		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
		/// The returned path is guaranteed to end with a path separator ('<br/>
		/// \<br/>
		/// ' on<br/>
		/// Windows, '/' on most other platforms).<br/>
		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>
		/// pointer when done with it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetPrefPath")]
		internal static extern byte* SDLGetPrefPathNative([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app);

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			byte* ret = SDLGetPrefPathNative(org, app);
			return ret;
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(org, app));
			return ret;
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ref byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			fixed (byte* porg = &org)
			{
				byte* ret = SDLGetPrefPathNative((byte*)porg, app);
				return ret;
			}
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ref byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			fixed (byte* porg = &org)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative((byte*)porg, app));
				return ret;
			}
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLGetPrefPathNative(pStr0, app);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] byte* app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(pStr0, app));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ref byte app)
		{
			fixed (byte* papp = &app)
			{
				byte* ret = SDLGetPrefPathNative(org, (byte*)papp);
				return ret;
			}
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ref byte app)
		{
			fixed (byte* papp = &app)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(org, (byte*)papp));
				return ret;
			}
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (app != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(app);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(app, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLGetPrefPathNative(org, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] byte* org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (app != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(app);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(app, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(org, pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ref byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ref byte app)
		{
			fixed (byte* porg = &org)
			{
				fixed (byte* papp = &app)
				{
					byte* ret = SDLGetPrefPathNative((byte*)porg, (byte*)papp);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] ref byte org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] ref byte app)
		{
			fixed (byte* porg = &org)
			{
				fixed (byte* papp = &app)
				{
					string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative((byte*)porg, (byte*)papp));
					return ret;
				}
			}
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static byte* SDLGetPrefPath([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (app != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(app);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(app, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = SDLGetPrefPathNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get the user-and-app-specific path where files can be written.<br/>		/// Get the "pref dir". This is meant to be where users can write personal<br/>		/// files (preferences and save games, etc) that are specific to your<br/>		/// application. This directory is unique per user, per application.<br/>		/// This function will decide the appropriate location in the native<br/>		/// filesystem, create the directory if necessary, and return a string of the<br/>		/// absolute path to the directory in UTF-8 encoding.<br/>		/// On Windows, the string might look like:<br/>		/// `C:<br/>		/// \<br/>		/// Users<br/>		/// \<br/>		/// bob<br/>		/// \<br/>		/// AppData<br/>		/// \<br/>		/// Roaming<br/>		/// \<br/>		/// My Company<br/>		/// \<br/>		/// My Program Name<br/>		/// \<br/>		/// `<br/>		/// On Linux, the string might look like:<br/>		/// `/home/bob/.local/share/My Program Name/`<br/>		/// On Mac OS X, the string might look like:<br/>		/// `/Users/bob/Library/Application Support/My Program Name/`<br/>		/// You should assume the path returned by this function is the only safe place<br/>		/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>		/// even the parent of the returned path, isn't where you should be writing<br/>		/// things).<br/>		/// Both the org and app strings may become part of a directory name, so please<br/>		/// follow these rules:<br/>		/// - Try to use the same org string (_including case-sensitivity_) for all<br/>		/// your applications that use this function.<br/>		/// - Always use a unique app string for each one, and make sure it never<br/>		/// changes for an app once you've decided on it.<br/>		/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...<br/>		/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>		/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>		/// The returned path is guaranteed to end with a path separator ('<br/>		/// \<br/>		/// ' on<br/>		/// Windows, '/' on most other platforms).<br/>		/// The pointer returned is owned by the caller. Please call SDL_free() on the<br/>		/// pointer when done with it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPrefPath")]
		[return: NativeName(NativeNameType.Type, "char*")]
		public static string SDLGetPrefPathS([NativeName(NativeNameType.Param, "org")] [NativeName(NativeNameType.Type, "const char*")] string org, [NativeName(NativeNameType.Param, "app")] [NativeName(NativeNameType.Type, "const char*")] string app)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (org != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(org);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(org, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (app != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(app);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(app, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLGetPrefPathNative(pStr0, pStr1));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Count the number of haptic devices attached to the system.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_NumHaptics")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_NumHaptics")]
		internal static extern int SDLNumHapticsNative();

		/// <summary>		/// Count the number of haptic devices attached to the system.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_NumHaptics")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLNumHaptics()
		{
			int ret = SDLNumHapticsNative();
			return ret;
		}

		/// <summary>
		/// Get the implementation dependent name of a haptic device.<br/>
		/// This can be called before any joysticks are opened. If no name can be<br/>
		/// found, this function returns NULL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticName")]
		internal static extern byte* SDLHapticNameNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Get the implementation dependent name of a haptic device.<br/>		/// This can be called before any joysticks are opened. If no name can be<br/>		/// found, this function returns NULL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLHapticName([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			byte* ret = SDLHapticNameNative(deviceIndex);
			return ret;
		}

		/// <summary>		/// Get the implementation dependent name of a haptic device.<br/>		/// This can be called before any joysticks are opened. If no name can be<br/>		/// found, this function returns NULL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLHapticNameS([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			string ret = Utils.DecodeStringUTF8(SDLHapticNameNative(deviceIndex));
			return ret;
		}

		/// <summary>
		/// Open a haptic device for use.<br/>
		/// The index passed as an argument refers to the N'th haptic device on this<br/>
		/// system.<br/>
		/// When opening a haptic device, its gain will be set to maximum and<br/>
		/// autocenter will be disabled. To modify these values use SDL_HapticSetGain()<br/>
		/// and SDL_HapticSetAutocenter().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticOpen")]
		internal static extern SDLHaptic* SDLHapticOpenNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Open a haptic device for use.<br/>		/// The index passed as an argument refers to the N'th haptic device on this<br/>		/// system.<br/>		/// When opening a haptic device, its gain will be set to maximum and<br/>		/// autocenter will be disabled. To modify these values use SDL_HapticSetGain()<br/>		/// and SDL_HapticSetAutocenter().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticOpen")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic*")]
		public static SDLHaptic* SDLHapticOpen([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			SDLHaptic* ret = SDLHapticOpenNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Check if the haptic device at the designated index has been opened.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticOpened")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticOpened")]
		internal static extern int SDLHapticOpenedNative([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex);

		/// <summary>		/// Check if the haptic device at the designated index has been opened.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticOpened")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticOpened([NativeName(NativeNameType.Param, "device_index")] [NativeName(NativeNameType.Type, "int")] int deviceIndex)
		{
			int ret = SDLHapticOpenedNative(deviceIndex);
			return ret;
		}

		/// <summary>
		/// Get the index of a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticIndex")]
		internal static extern int SDLHapticIndexNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Get the index of a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticIndex([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticIndexNative(haptic);
			return ret;
		}

		/// <summary>		/// Get the index of a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticIndex([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticIndexNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Query whether or not the current mouse has haptic capabilities.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_MouseIsHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_MouseIsHaptic")]
		internal static extern int SDLMouseIsHapticNative();

		/// <summary>		/// Query whether or not the current mouse has haptic capabilities.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_MouseIsHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLMouseIsHaptic()
		{
			int ret = SDLMouseIsHapticNative();
			return ret;
		}

		/// <summary>
		/// Try to open a haptic device from the current mouse.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticOpenFromMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticOpenFromMouse")]
		internal static extern SDLHaptic* SDLHapticOpenFromMouseNative();

		/// <summary>		/// Try to open a haptic device from the current mouse.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticOpenFromMouse")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic*")]
		public static SDLHaptic* SDLHapticOpenFromMouse()
		{
			SDLHaptic* ret = SDLHapticOpenFromMouseNative();
			return ret;
		}

		/// <summary>
		/// Query if a joystick has haptic features.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_JoystickIsHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_JoystickIsHaptic")]
		internal static extern int SDLJoystickIsHapticNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Query if a joystick has haptic features.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickIsHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickIsHaptic([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			int ret = SDLJoystickIsHapticNative(joystick);
			return ret;
		}

		/// <summary>		/// Query if a joystick has haptic features.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_JoystickIsHaptic")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLJoystickIsHaptic([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				int ret = SDLJoystickIsHapticNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Open a haptic device for use from a joystick device.<br/>
		/// You must still close the haptic device separately. It will not be closed<br/>
		/// with the joystick.<br/>
		/// When opened from a joystick you should first close the haptic device before<br/>
		/// closing the joystick device. If not, on some implementations the haptic<br/>
		/// device will also get unallocated and you'll be unable to use force feedback<br/>
		/// on that device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticOpenFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticOpenFromJoystick")]
		internal static extern SDLHaptic* SDLHapticOpenFromJoystickNative([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick);

		/// <summary>		/// Open a haptic device for use from a joystick device.<br/>		/// You must still close the haptic device separately. It will not be closed<br/>		/// with the joystick.<br/>		/// When opened from a joystick you should first close the haptic device before<br/>		/// closing the joystick device. If not, on some implementations the haptic<br/>		/// device will also get unallocated and you'll be unable to use force feedback<br/>		/// on that device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticOpenFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic*")]
		public static SDLHaptic* SDLHapticOpenFromJoystick([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] SDLJoystick* joystick)
		{
			SDLHaptic* ret = SDLHapticOpenFromJoystickNative(joystick);
			return ret;
		}

		/// <summary>		/// Open a haptic device for use from a joystick device.<br/>		/// You must still close the haptic device separately. It will not be closed<br/>		/// with the joystick.<br/>		/// When opened from a joystick you should first close the haptic device before<br/>		/// closing the joystick device. If not, on some implementations the haptic<br/>		/// device will also get unallocated and you'll be unable to use force feedback<br/>		/// on that device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticOpenFromJoystick")]
		[return: NativeName(NativeNameType.Type, "SDL_Haptic*")]
		public static SDLHaptic* SDLHapticOpenFromJoystick([NativeName(NativeNameType.Param, "joystick")] [NativeName(NativeNameType.Type, "SDL_Joystick*")] ref SDLJoystick joystick)
		{
			fixed (SDLJoystick* pjoystick = &joystick)
			{
				SDLHaptic* ret = SDLHapticOpenFromJoystickNative((SDLJoystick*)pjoystick);
				return ret;
			}
		}

		/// <summary>
		/// Close a haptic device previously opened with SDL_HapticOpen().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticClose")]
		internal static extern void SDLHapticCloseNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Close a haptic device previously opened with SDL_HapticOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHapticClose([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			SDLHapticCloseNative(haptic);
		}

		/// <summary>		/// Close a haptic device previously opened with SDL_HapticOpen().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticClose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHapticClose([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				SDLHapticCloseNative((SDLHaptic*)phaptic);
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can store.<br/>
		/// On some platforms this isn't fully supported, and therefore is an<br/>
		/// approximation. Always check to see if your created effect was actually<br/>
		/// created and do not rely solely on SDL_HapticNumEffects().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticNumEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticNumEffects")]
		internal static extern int SDLHapticNumEffectsNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Get the number of effects a haptic device can store.<br/>		/// On some platforms this isn't fully supported, and therefore is an<br/>		/// approximation. Always check to see if your created effect was actually<br/>		/// created and do not rely solely on SDL_HapticNumEffects().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNumEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNumEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticNumEffectsNative(haptic);
			return ret;
		}

		/// <summary>		/// Get the number of effects a haptic device can store.<br/>		/// On some platforms this isn't fully supported, and therefore is an<br/>		/// approximation. Always check to see if your created effect was actually<br/>		/// created and do not rely solely on SDL_HapticNumEffects().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNumEffects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNumEffects([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticNumEffectsNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of effects a haptic device can play at the same time.<br/>
		/// This is not supported on all platforms, but will always return a value.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticNumEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticNumEffectsPlaying")]
		internal static extern int SDLHapticNumEffectsPlayingNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Get the number of effects a haptic device can play at the same time.<br/>		/// This is not supported on all platforms, but will always return a value.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNumEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNumEffectsPlaying([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticNumEffectsPlayingNative(haptic);
			return ret;
		}

		/// <summary>		/// Get the number of effects a haptic device can play at the same time.<br/>		/// This is not supported on all platforms, but will always return a value.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNumEffectsPlaying")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNumEffectsPlaying([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticNumEffectsPlayingNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the haptic device's supported features in bitwise manner.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticQuery")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticQuery")]
		internal static extern uint SDLHapticQueryNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Get the haptic device's supported features in bitwise manner.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticQuery")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint SDLHapticQuery([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			uint ret = SDLHapticQueryNative(haptic);
			return ret;
		}

		/// <summary>		/// Get the haptic device's supported features in bitwise manner.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticQuery")]
		[return: NativeName(NativeNameType.Type, "unsigned int")]
		public static uint SDLHapticQuery([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				uint ret = SDLHapticQueryNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of haptic axes the device has.<br/>
		/// The number of haptic axes might be useful if working with the<br/>
		/// SDL_HapticDirection effect.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticNumAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticNumAxes")]
		internal static extern int SDLHapticNumAxesNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Get the number of haptic axes the device has.<br/>		/// The number of haptic axes might be useful if working with the<br/>		/// SDL_HapticDirection effect.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNumAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNumAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticNumAxesNative(haptic);
			return ret;
		}

		/// <summary>		/// Get the number of haptic axes the device has.<br/>		/// The number of haptic axes might be useful if working with the<br/>		/// SDL_HapticDirection effect.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNumAxes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNumAxes([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticNumAxesNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Check to see if an effect is supported by a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticEffectSupported")]
		internal static extern int SDLHapticEffectSupportedNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] SDLHapticEffect* effect);

		/// <summary>		/// Check to see if an effect is supported by a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] SDLHapticEffect* effect)
		{
			int ret = SDLHapticEffectSupportedNative(haptic, effect);
			return ret;
		}

		/// <summary>		/// Check to see if an effect is supported by a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] SDLHapticEffect* effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticEffectSupportedNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>		/// Check to see if an effect is supported by a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] ref SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				int ret = SDLHapticEffectSupportedNative(haptic, (SDLHapticEffect*)peffect);
				return ret;
			}
		}

		/// <summary>		/// Check to see if an effect is supported by a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticEffectSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticEffectSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] ref SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					int ret = SDLHapticEffectSupportedNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a new haptic effect on a specified device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticNewEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticNewEffect")]
		internal static extern int SDLHapticNewEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] SDLHapticEffect* effect);

		/// <summary>		/// Create a new haptic effect on a specified device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNewEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNewEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] SDLHapticEffect* effect)
		{
			int ret = SDLHapticNewEffectNative(haptic, effect);
			return ret;
		}

		/// <summary>		/// Create a new haptic effect on a specified device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNewEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNewEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] SDLHapticEffect* effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticNewEffectNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>		/// Create a new haptic effect on a specified device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNewEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNewEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] ref SDLHapticEffect effect)
		{
			fixed (SDLHapticEffect* peffect = &effect)
			{
				int ret = SDLHapticNewEffectNative(haptic, (SDLHapticEffect*)peffect);
				return ret;
			}
		}

		/// <summary>		/// Create a new haptic effect on a specified device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticNewEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticNewEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] ref SDLHapticEffect effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* peffect = &effect)
				{
					int ret = SDLHapticNewEffectNative((SDLHaptic*)phaptic, (SDLHapticEffect*)peffect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update the properties of an effect.<br/>
		/// Can be used dynamically, although behavior when dynamically changing<br/>
		/// direction may be strange. Specifically the effect may re-upload itself and<br/>
		/// start playing from the start. You also cannot change the type either when<br/>
		/// running SDL_HapticUpdateEffect().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticUpdateEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticUpdateEffect")]
		internal static extern int SDLHapticUpdateEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] SDLHapticEffect* data);

		/// <summary>		/// Update the properties of an effect.<br/>		/// Can be used dynamically, although behavior when dynamically changing<br/>		/// direction may be strange. Specifically the effect may re-upload itself and<br/>		/// start playing from the start. You also cannot change the type either when<br/>		/// running SDL_HapticUpdateEffect().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticUpdateEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticUpdateEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] SDLHapticEffect* data)
		{
			int ret = SDLHapticUpdateEffectNative(haptic, effect, data);
			return ret;
		}

		/// <summary>		/// Update the properties of an effect.<br/>		/// Can be used dynamically, although behavior when dynamically changing<br/>		/// direction may be strange. Specifically the effect may re-upload itself and<br/>		/// start playing from the start. You also cannot change the type either when<br/>		/// running SDL_HapticUpdateEffect().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticUpdateEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticUpdateEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] SDLHapticEffect* data)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticUpdateEffectNative((SDLHaptic*)phaptic, effect, data);
				return ret;
			}
		}

		/// <summary>		/// Update the properties of an effect.<br/>		/// Can be used dynamically, although behavior when dynamically changing<br/>		/// direction may be strange. Specifically the effect may re-upload itself and<br/>		/// start playing from the start. You also cannot change the type either when<br/>		/// running SDL_HapticUpdateEffect().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticUpdateEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticUpdateEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] ref SDLHapticEffect data)
		{
			fixed (SDLHapticEffect* pdata = &data)
			{
				int ret = SDLHapticUpdateEffectNative(haptic, effect, (SDLHapticEffect*)pdata);
				return ret;
			}
		}

		/// <summary>		/// Update the properties of an effect.<br/>		/// Can be used dynamically, although behavior when dynamically changing<br/>		/// direction may be strange. Specifically the effect may re-upload itself and<br/>		/// start playing from the start. You also cannot change the type either when<br/>		/// running SDL_HapticUpdateEffect().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticUpdateEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticUpdateEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "SDL_HapticEffect*")] ref SDLHapticEffect data)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				fixed (SDLHapticEffect* pdata = &data)
				{
					int ret = SDLHapticUpdateEffectNative((SDLHaptic*)phaptic, effect, (SDLHapticEffect*)pdata);
					return ret;
				}
			}
		}

		/// <summary>
		/// Run the haptic effect on its associated haptic device.<br/>
		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
		/// instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRunEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticRunEffect")]
		internal static extern int SDLHapticRunEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations);

		/// <summary>		/// Run the haptic effect on its associated haptic device.<br/>		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRunEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRunEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			int ret = SDLHapticRunEffectNative(haptic, effect, iterations);
			return ret;
		}

		/// <summary>		/// Run the haptic effect on its associated haptic device.<br/>		/// To repeat the effect over and over indefinitely, set `iterations` to<br/>		/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>		/// one instance of the effect last indefinitely (so the effect does not fade),<br/>		/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>		/// instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRunEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRunEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect, [NativeName(NativeNameType.Param, "iterations")] [NativeName(NativeNameType.Type, "Uint32")] uint iterations)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticRunEffectNative((SDLHaptic*)phaptic, effect, iterations);
				return ret;
			}
		}

		/// <summary>
		/// Stop the haptic effect on its associated haptic device.<br/>
		/// *<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticStopEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticStopEffect")]
		internal static extern int SDLHapticStopEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect);

		/// <summary>		/// Stop the haptic effect on its associated haptic device.<br/>		/// *<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticStopEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticStopEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			int ret = SDLHapticStopEffectNative(haptic, effect);
			return ret;
		}

		/// <summary>		/// Stop the haptic effect on its associated haptic device.<br/>		/// *<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticStopEffect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticStopEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticStopEffectNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a haptic effect on the device.<br/>
		/// This will stop the effect if it's running. Effects are automatically<br/>
		/// destroyed when the device is closed.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticDestroyEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticDestroyEffect")]
		internal static extern void SDLHapticDestroyEffectNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect);

		/// <summary>		/// Destroy a haptic effect on the device.<br/>		/// This will stop the effect if it's running. Effects are automatically<br/>		/// destroyed when the device is closed.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticDestroyEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHapticDestroyEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			SDLHapticDestroyEffectNative(haptic, effect);
		}

		/// <summary>		/// Destroy a haptic effect on the device.<br/>		/// This will stop the effect if it's running. Effects are automatically<br/>		/// destroyed when the device is closed.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticDestroyEffect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHapticDestroyEffect([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				SDLHapticDestroyEffectNative((SDLHaptic*)phaptic, effect);
			}
		}

		/// <summary>
		/// Get the status of the current effect on the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticGetEffectStatus")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticGetEffectStatus")]
		internal static extern int SDLHapticGetEffectStatusNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect);

		/// <summary>		/// Get the status of the current effect on the specified haptic device.<br/>		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticGetEffectStatus")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticGetEffectStatus([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			int ret = SDLHapticGetEffectStatusNative(haptic, effect);
			return ret;
		}

		/// <summary>		/// Get the status of the current effect on the specified haptic device.<br/>		/// Device must support the SDL_HAPTIC_STATUS feature.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticGetEffectStatus")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticGetEffectStatus([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "effect")] [NativeName(NativeNameType.Type, "int")] int effect)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticGetEffectStatusNative((SDLHaptic*)phaptic, effect);
				return ret;
			}
		}

		/// <summary>
		/// Set the global gain of the specified haptic device.<br/>
		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
		/// The user may specify the maximum gain by setting the environment variable<br/>
		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
		/// SDL_HapticSetGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
		/// maximum.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticSetGain")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticSetGain")]
		internal static extern int SDLHapticSetGainNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain);

		/// <summary>		/// Set the global gain of the specified haptic device.<br/>		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>		/// The user may specify the maximum gain by setting the environment variable<br/>		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>		/// SDL_HapticSetGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>		/// maximum.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticSetGain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticSetGain([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			int ret = SDLHapticSetGainNative(haptic, gain);
			return ret;
		}

		/// <summary>		/// Set the global gain of the specified haptic device.<br/>		/// Device must support the SDL_HAPTIC_GAIN feature.<br/>		/// The user may specify the maximum gain by setting the environment variable<br/>		/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>		/// SDL_HapticSetGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>		/// maximum.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticSetGain")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticSetGain([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "gain")] [NativeName(NativeNameType.Type, "int")] int gain)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticSetGainNative((SDLHaptic*)phaptic, gain);
				return ret;
			}
		}

		/// <summary>
		/// Set the global autocenter of the device.<br/>
		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
		/// autocentering.<br/>
		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticSetAutocenter")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticSetAutocenter")]
		internal static extern int SDLHapticSetAutocenterNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter);

		/// <summary>		/// Set the global autocenter of the device.<br/>		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>		/// autocentering.<br/>		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticSetAutocenter")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticSetAutocenter([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			int ret = SDLHapticSetAutocenterNative(haptic, autocenter);
			return ret;
		}

		/// <summary>		/// Set the global autocenter of the device.<br/>		/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>		/// autocentering.<br/>		/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticSetAutocenter")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticSetAutocenter([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "autocenter")] [NativeName(NativeNameType.Type, "int")] int autocenter)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticSetAutocenterNative((SDLHaptic*)phaptic, autocenter);
				return ret;
			}
		}

		/// <summary>
		/// Pause a haptic device.<br/>
		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call<br/>
		/// SDL_HapticUnpause() to resume playback.<br/>
		/// Do not modify the effects nor add new ones while the device is paused. That<br/>
		/// can cause all sorts of weird errors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticPause")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticPause")]
		internal static extern int SDLHapticPauseNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Pause a haptic device.<br/>		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call<br/>		/// SDL_HapticUnpause() to resume playback.<br/>		/// Do not modify the effects nor add new ones while the device is paused. That<br/>		/// can cause all sorts of weird errors.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticPause")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticPause([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticPauseNative(haptic);
			return ret;
		}

		/// <summary>		/// Pause a haptic device.<br/>		/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call<br/>		/// SDL_HapticUnpause() to resume playback.<br/>		/// Do not modify the effects nor add new ones while the device is paused. That<br/>		/// can cause all sorts of weird errors.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticPause")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticPause([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticPauseNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Unpause a haptic device.<br/>
		/// Call to unpause after SDL_HapticPause().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticUnpause")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticUnpause")]
		internal static extern int SDLHapticUnpauseNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Unpause a haptic device.<br/>		/// Call to unpause after SDL_HapticPause().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticUnpause")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticUnpause([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticUnpauseNative(haptic);
			return ret;
		}

		/// <summary>		/// Unpause a haptic device.<br/>		/// Call to unpause after SDL_HapticPause().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticUnpause")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticUnpause([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticUnpauseNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Stop all the currently playing effects on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticStopAll")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticStopAll")]
		internal static extern int SDLHapticStopAllNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Stop all the currently playing effects on a haptic device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticStopAll")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticStopAll([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticStopAllNative(haptic);
			return ret;
		}

		/// <summary>		/// Stop all the currently playing effects on a haptic device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticStopAll")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticStopAll([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticStopAllNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Check whether rumble is supported on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticRumbleSupported")]
		internal static extern int SDLHapticRumbleSupportedNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Check whether rumble is supported on a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRumbleSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticRumbleSupportedNative(haptic);
			return ret;
		}

		/// <summary>		/// Check whether rumble is supported on a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRumbleSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRumbleSupported([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticRumbleSupportedNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Initialize a haptic device for simple rumble playback.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticRumbleInit")]
		internal static extern int SDLHapticRumbleInitNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Initialize a haptic device for simple rumble playback.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRumbleInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRumbleInit([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticRumbleInitNative(haptic);
			return ret;
		}

		/// <summary>		/// Initialize a haptic device for simple rumble playback.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRumbleInit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRumbleInit([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticRumbleInitNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Run a simple rumble effect on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumblePlay")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticRumblePlay")]
		internal static extern int SDLHapticRumblePlayNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length);

		/// <summary>		/// Run a simple rumble effect on a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRumblePlay")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRumblePlay([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			int ret = SDLHapticRumblePlayNative(haptic, strength, length);
			return ret;
		}

		/// <summary>		/// Run a simple rumble effect on a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRumblePlay")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRumblePlay([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "float")] float strength, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "Uint32")] uint length)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticRumblePlayNative((SDLHaptic*)phaptic, strength, length);
				return ret;
			}
		}

		/// <summary>
		/// Stop the simple rumble on a haptic device.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_HapticRumbleStop")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_HapticRumbleStop")]
		internal static extern int SDLHapticRumbleStopNative([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic);

		/// <summary>		/// Stop the simple rumble on a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRumbleStop")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRumbleStop([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] SDLHaptic* haptic)
		{
			int ret = SDLHapticRumbleStopNative(haptic);
			return ret;
		}

		/// <summary>		/// Stop the simple rumble on a haptic device.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_HapticRumbleStop")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHapticRumbleStop([NativeName(NativeNameType.Param, "haptic")] [NativeName(NativeNameType.Type, "SDL_Haptic*")] ref SDLHaptic haptic)
		{
			fixed (SDLHaptic* phaptic = &haptic)
			{
				int ret = SDLHapticRumbleStopNative((SDLHaptic*)phaptic);
				return ret;
			}
		}

		/// <summary>
		/// Initialize the HIDAPI library.<br/>
		/// This function initializes the HIDAPI library. Calling it is not strictly<br/>
		/// necessary, as it will be called automatically by SDL_hid_enumerate() and<br/>
		/// any of the SDL_hid_open_*() functions if it is needed. This function should<br/>
		/// be called at the beginning of execution however, if there is a chance of<br/>
		/// HIDAPI handles being opened by different threads simultaneously.<br/>
		/// Each call to this function should have a matching call to SDL_hid_exit()<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_init")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_init")]
		internal static extern int SDLHidInitNative();

		/// <summary>		/// Initialize the HIDAPI library.<br/>		/// This function initializes the HIDAPI library. Calling it is not strictly<br/>		/// necessary, as it will be called automatically by SDL_hid_enumerate() and<br/>		/// any of the SDL_hid_open_*() functions if it is needed. This function should<br/>		/// be called at the beginning of execution however, if there is a chance of<br/>		/// HIDAPI handles being opened by different threads simultaneously.<br/>		/// Each call to this function should have a matching call to SDL_hid_exit()<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_init")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidInit()
		{
			int ret = SDLHidInitNative();
			return ret;
		}

		/// <summary>
		/// Finalize the HIDAPI library.<br/>
		/// This function frees all of the static data associated with HIDAPI. It<br/>
		/// should be called at the end of execution to avoid memory leaks.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_exit")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_exit")]
		internal static extern int SDLHidExitNative();

		/// <summary>		/// Finalize the HIDAPI library.<br/>		/// This function frees all of the static data associated with HIDAPI. It<br/>		/// should be called at the end of execution to avoid memory leaks.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_exit")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidExit()
		{
			int ret = SDLHidExitNative();
			return ret;
		}

		/// <summary>
		/// Check to see if devices may have been added or removed.<br/>
		/// Enumerating the HID devices is an expensive operation, so you can call this<br/>
		/// to see if there have been any system device changes since the last call to<br/>
		/// this function. A change in the counter returned doesn't necessarily mean<br/>
		/// that anything has changed, but you can call SDL_hid_enumerate() to get an<br/>
		/// updated device list.<br/>
		/// Calling this function for the first time may cause a thread or other system<br/>
		/// resource to be allocated to track device change notifications.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_device_change_count")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_device_change_count")]
		internal static extern uint SDLHidDeviceChangeCountNative();

		/// <summary>		/// Check to see if devices may have been added or removed.<br/>		/// Enumerating the HID devices is an expensive operation, so you can call this<br/>		/// to see if there have been any system device changes since the last call to<br/>		/// this function. A change in the counter returned doesn't necessarily mean<br/>		/// that anything has changed, but you can call SDL_hid_enumerate() to get an<br/>		/// updated device list.<br/>		/// Calling this function for the first time may cause a thread or other system<br/>		/// resource to be allocated to track device change notifications.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_device_change_count")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLHidDeviceChangeCount()
		{
			uint ret = SDLHidDeviceChangeCountNative();
			return ret;
		}

		/// <summary>
		/// Enumerate the HID Devices.<br/>
		/// This function returns a linked list of all the HID devices attached to the<br/>
		/// system which match vendor_id and product_id. If `vendor_id` is set to 0<br/>
		/// then any vendor matches. If `product_id` is set to 0 then any product<br/>
		/// matches. If `vendor_id` and `product_id` are both set to 0, then all HID<br/>
		/// devices will be returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_enumerate")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_enumerate")]
		internal static extern SDLHidDeviceInfo* SDLHidEnumerateNative([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId);

		/// <summary>		/// Enumerate the HID Devices.<br/>		/// This function returns a linked list of all the HID devices attached to the<br/>		/// system which match vendor_id and product_id. If `vendor_id` is set to 0<br/>		/// then any vendor matches. If `product_id` is set to 0 then any product<br/>		/// matches. If `vendor_id` and `product_id` are both set to 0, then all HID<br/>		/// devices will be returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_enumerate")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device_info*")]
		public static SDLHidDeviceInfo* SDLHidEnumerate([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId)
		{
			SDLHidDeviceInfo* ret = SDLHidEnumerateNative(vendorId, productId);
			return ret;
		}

		/// <summary>
		/// Free an enumeration Linked List<br/>
		/// This function frees a linked list created by SDL_hid_enumerate().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_free_enumeration")]
		internal static extern void SDLHidFreeEnumerationNative([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info*")] SDLHidDeviceInfo* devs);

		/// <summary>		/// Free an enumeration Linked List<br/>		/// This function frees a linked list created by SDL_hid_enumerate().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHidFreeEnumeration([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info*")] SDLHidDeviceInfo* devs)
		{
			SDLHidFreeEnumerationNative(devs);
		}

		/// <summary>		/// Free an enumeration Linked List<br/>		/// This function frees a linked list created by SDL_hid_enumerate().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_free_enumeration")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHidFreeEnumeration([NativeName(NativeNameType.Param, "devs")] [NativeName(NativeNameType.Type, "SDL_hid_device_info*")] ref SDLHidDeviceInfo devs)
		{
			fixed (SDLHidDeviceInfo* pdevs = &devs)
			{
				SDLHidFreeEnumerationNative((SDLHidDeviceInfo*)pdevs);
			}
		}

		/// <summary>
		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
		/// a serial number.<br/>
		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
		/// is opened.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_open")]
		internal static extern SDLHidDevice* SDLHidOpenNative([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "const wchar*")] char* serialNumber);

		/// <summary>		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>		/// a serial number.<br/>		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>		/// is opened.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device*")]
		public static SDLHidDevice* SDLHidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "const wchar*")] char* serialNumber)
		{
			SDLHidDevice* ret = SDLHidOpenNative(vendorId, productId, serialNumber);
			return ret;
		}

		/// <summary>		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>		/// a serial number.<br/>		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>		/// is opened.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device*")]
		public static SDLHidDevice* SDLHidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "const wchar*")] ref char serialNumber)
		{
			fixed (char* pserialNumber = &serialNumber)
			{
				SDLHidDevice* ret = SDLHidOpenNative(vendorId, productId, (char*)pserialNumber);
				return ret;
			}
		}

		/// <summary>		/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>		/// a serial number.<br/>		/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>		/// is opened.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_open")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device*")]
		public static SDLHidDevice* SDLHidOpen([NativeName(NativeNameType.Param, "vendor_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort vendorId, [NativeName(NativeNameType.Param, "product_id")] [NativeName(NativeNameType.Type, "unsigned short")] ushort productId, [NativeName(NativeNameType.Param, "serial_number")] [NativeName(NativeNameType.Type, "const wchar*")] string serialNumber)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (serialNumber != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(serialNumber);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(serialNumber, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			SDLHidDevice* ret = SDLHidOpenNative(vendorId, productId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Open a HID device by its path name.<br/>
		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_open_path")]
		internal static extern SDLHidDevice* SDLHidOpenPathNative([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] byte* path, [NativeName(NativeNameType.Param, "bExclusive")] [NativeName(NativeNameType.Type, "int")] int bExclusive);

		/// <summary>		/// Open a HID device by its path name.<br/>		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device*")]
		public static SDLHidDevice* SDLHidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] byte* path, [NativeName(NativeNameType.Param, "bExclusive")] [NativeName(NativeNameType.Type, "int")] int bExclusive)
		{
			SDLHidDevice* ret = SDLHidOpenPathNative(path, bExclusive);
			return ret;
		}

		/// <summary>		/// Open a HID device by its path name.<br/>		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device*")]
		public static SDLHidDevice* SDLHidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] ref byte path, [NativeName(NativeNameType.Param, "bExclusive")] [NativeName(NativeNameType.Type, "int")] int bExclusive)
		{
			fixed (byte* ppath = &path)
			{
				SDLHidDevice* ret = SDLHidOpenPathNative((byte*)ppath, bExclusive);
				return ret;
			}
		}

		/// <summary>		/// Open a HID device by its path name.<br/>		/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>		/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_open_path")]
		[return: NativeName(NativeNameType.Type, "SDL_hid_device*")]
		public static SDLHidDevice* SDLHidOpenPath([NativeName(NativeNameType.Param, "path")] [NativeName(NativeNameType.Type, "const char*")] string path, [NativeName(NativeNameType.Param, "bExclusive")] [NativeName(NativeNameType.Type, "int")] int bExclusive)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (path != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(path);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(path, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLHidDevice* ret = SDLHidOpenPathNative(pStr0, bExclusive);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Write an Output report to a HID device.<br/>
		/// The first byte of `data` must contain the Report ID. For devices which only<br/>
		/// support a single report, this must be set to 0x0. The remaining bytes<br/>
		/// contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
		/// followed by the report data (16 bytes). In this example, the length passed<br/>
		/// in would be 17.<br/>
		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
		/// exists. If it does not, it will send the data through the Control Endpoint<br/>
		/// (Endpoint 0).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_write")]
		internal static extern int SDLHidWriteNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length);

		/// <summary>		/// Write an Output report to a HID device.<br/>		/// The first byte of `data` must contain the Report ID. For devices which only<br/>		/// support a single report, this must be set to 0x0. The remaining bytes<br/>		/// contain the report data. Since the Report ID is mandatory, calls to<br/>		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>		/// followed by the report data (16 bytes). In this example, the length passed<br/>		/// in would be 17.<br/>		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>		/// exists. If it does not, it will send the data through the Control Endpoint<br/>		/// (Endpoint 0).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = SDLHidWriteNative(dev, data, length);
			return ret;
		}

		/// <summary>		/// Write an Output report to a HID device.<br/>		/// The first byte of `data` must contain the Report ID. For devices which only<br/>		/// support a single report, this must be set to 0x0. The remaining bytes<br/>		/// contain the report data. Since the Report ID is mandatory, calls to<br/>		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>		/// followed by the report data (16 bytes). In this example, the length passed<br/>		/// in would be 17.<br/>		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>		/// exists. If it does not, it will send the data through the Control Endpoint<br/>		/// (Endpoint 0).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidWriteNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>		/// Write an Output report to a HID device.<br/>		/// The first byte of `data` must contain the Report ID. For devices which only<br/>		/// support a single report, this must be set to 0x0. The remaining bytes<br/>		/// contain the report data. Since the Report ID is mandatory, calls to<br/>		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>		/// followed by the report data (16 bytes). In this example, the length passed<br/>		/// in would be 17.<br/>		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>		/// exists. If it does not, it will send the data through the Control Endpoint<br/>		/// (Endpoint 0).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = SDLHidWriteNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>		/// Write an Output report to a HID device.<br/>		/// The first byte of `data` must contain the Report ID. For devices which only<br/>		/// support a single report, this must be set to 0x0. The remaining bytes<br/>		/// contain the report data. Since the Report ID is mandatory, calls to<br/>		/// SDL_hid_write() will always contain one more byte than the report contains.<br/>		/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>		/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>		/// followed by the report data (16 bytes). In this example, the length passed<br/>		/// in would be 17.<br/>		/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>		/// exists. If it does not, it will send the data through the Control Endpoint<br/>		/// (Endpoint 0).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_write")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidWrite([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = SDLHidWriteNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Read an Input report from a HID device with timeout.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_read_timeout")]
		internal static extern int SDLHidReadTimeoutNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds);

		/// <summary>		/// Read an Input report from a HID device with timeout.<br/>		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>		/// The first byte will contain the Report number if the device uses numbered<br/>		/// reports.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			int ret = SDLHidReadTimeoutNative(dev, data, length, milliseconds);
			return ret;
		}

		/// <summary>		/// Read an Input report from a HID device with timeout.<br/>		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>		/// The first byte will contain the Report number if the device uses numbered<br/>		/// reports.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidReadTimeoutNative((SDLHidDevice*)pdev, data, length, milliseconds);
				return ret;
			}
		}

		/// <summary>		/// Read an Input report from a HID device with timeout.<br/>		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>		/// The first byte will contain the Report number if the device uses numbered<br/>		/// reports.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (byte* pdata = &data)
			{
				int ret = SDLHidReadTimeoutNative(dev, (byte*)pdata, length, milliseconds);
				return ret;
			}
		}

		/// <summary>		/// Read an Input report from a HID device with timeout.<br/>		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>		/// The first byte will contain the Report number if the device uses numbered<br/>		/// reports.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_read_timeout")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidReadTimeout([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length, [NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = SDLHidReadTimeoutNative((SDLHidDevice*)pdev, (byte*)pdata, length, milliseconds);
					return ret;
				}
			}
		}

		/// <summary>
		/// Read an Input report from a HID device.<br/>
		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
		/// The first byte will contain the Report number if the device uses numbered<br/>
		/// reports.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_read")]
		internal static extern int SDLHidReadNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length);

		/// <summary>		/// Read an Input report from a HID device.<br/>		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>		/// The first byte will contain the Report number if the device uses numbered<br/>		/// reports.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = SDLHidReadNative(dev, data, length);
			return ret;
		}

		/// <summary>		/// Read an Input report from a HID device.<br/>		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>		/// The first byte will contain the Report number if the device uses numbered<br/>		/// reports.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidReadNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>		/// Read an Input report from a HID device.<br/>		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>		/// The first byte will contain the Report number if the device uses numbered<br/>		/// reports.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = SDLHidReadNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>		/// Read an Input report from a HID device.<br/>		/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>		/// The first byte will contain the Report number if the device uses numbered<br/>		/// reports.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_read")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidRead([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = SDLHidReadNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the device handle to be non-blocking.<br/>
		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
		/// will wait (block) until there is data to read before returning.<br/>
		/// Nonblocking can be turned on and off at any time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_set_nonblocking")]
		internal static extern int SDLHidSetNonblockingNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock);

		/// <summary>		/// Set the device handle to be non-blocking.<br/>		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>		/// will wait (block) until there is data to read before returning.<br/>		/// Nonblocking can be turned on and off at any time.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidSetNonblocking([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			int ret = SDLHidSetNonblockingNative(dev, nonblock);
			return ret;
		}

		/// <summary>		/// Set the device handle to be non-blocking.<br/>		/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>		/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>		/// will wait (block) until there is data to read before returning.<br/>		/// Nonblocking can be turned on and off at any time.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_set_nonblocking")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidSetNonblocking([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "nonblock")] [NativeName(NativeNameType.Type, "int")] int nonblock)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidSetNonblockingNative((SDLHidDevice*)pdev, nonblock);
				return ret;
			}
		}

		/// <summary>
		/// Send a Feature report to the device.<br/>
		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
		/// which only support a single report, this must be set to 0x0. The remaining<br/>
		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
		/// devices which do not use numbered reports), followed by the report data (16<br/>
		/// bytes). In this example, the length passed in would be 17.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_send_feature_report")]
		internal static extern int SDLHidSendFeatureReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length);

		/// <summary>		/// Send a Feature report to the device.<br/>		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>		/// which only support a single report, this must be set to 0x0. The remaining<br/>		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>		/// devices which do not use numbered reports), followed by the report data (16<br/>		/// bytes). In this example, the length passed in would be 17.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = SDLHidSendFeatureReportNative(dev, data, length);
			return ret;
		}

		/// <summary>		/// Send a Feature report to the device.<br/>		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>		/// which only support a single report, this must be set to 0x0. The remaining<br/>		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>		/// devices which do not use numbered reports), followed by the report data (16<br/>		/// bytes). In this example, the length passed in would be 17.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidSendFeatureReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>		/// Send a Feature report to the device.<br/>		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>		/// which only support a single report, this must be set to 0x0. The remaining<br/>		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>		/// devices which do not use numbered reports), followed by the report data (16<br/>		/// bytes). In this example, the length passed in would be 17.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = SDLHidSendFeatureReportNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>		/// Send a Feature report to the device.<br/>		/// Feature reports are sent over the Control endpoint as a Set_Report<br/>		/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>		/// which only support a single report, this must be set to 0x0. The remaining<br/>		/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>		/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>		/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>		/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>		/// devices which do not use numbered reports), followed by the report data (16<br/>		/// bytes). In this example, the length passed in would be 17.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_send_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidSendFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "const unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = SDLHidSendFeatureReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get a feature report from a HID device.<br/>
		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
		/// first byte will still contain the Report ID, and the report data will start<br/>
		/// in data[1].<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_get_feature_report")]
		internal static extern int SDLHidGetFeatureReportNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length);

		/// <summary>		/// Get a feature report from a HID device.<br/>		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>		/// first byte will still contain the Report ID, and the report data will start<br/>		/// in data[1].<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			int ret = SDLHidGetFeatureReportNative(dev, data, length);
			return ret;
		}

		/// <summary>		/// Get a feature report from a HID device.<br/>		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>		/// first byte will still contain the Report ID, and the report data will start<br/>		/// in data[1].<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] byte* data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidGetFeatureReportNative((SDLHidDevice*)pdev, data, length);
				return ret;
			}
		}

		/// <summary>		/// Get a feature report from a HID device.<br/>		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>		/// first byte will still contain the Report ID, and the report data will start<br/>		/// in data[1].<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (byte* pdata = &data)
			{
				int ret = SDLHidGetFeatureReportNative(dev, (byte*)pdata, length);
				return ret;
			}
		}

		/// <summary>		/// Get a feature report from a HID device.<br/>		/// Set the first byte of `data` to the Report ID of the report to be read.<br/>		/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>		/// first byte will still contain the Report ID, and the report data will start<br/>		/// in data[1].<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_feature_report")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetFeatureReport([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "data")] [NativeName(NativeNameType.Type, "unsigned char*")] ref byte data, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "size_t")] nuint length)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (byte* pdata = &data)
				{
					int ret = SDLHidGetFeatureReportNative((SDLHidDevice*)pdev, (byte*)pdata, length);
					return ret;
				}
			}
		}

		/// <summary>
		/// Close a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_close")]
		internal static extern void SDLHidCloseNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev);

		/// <summary>		/// Close a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHidClose([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev)
		{
			SDLHidCloseNative(dev);
		}

		/// <summary>		/// Close a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_close")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHidClose([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				SDLHidCloseNative((SDLHidDevice*)pdev);
			}
		}

		/// <summary>
		/// Get The Manufacturer String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_get_manufacturer_string")]
		internal static extern int SDLHidGetManufacturerStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		/// <summary>		/// Get The Manufacturer String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = SDLHidGetManufacturerStringNative(dev, str, maxlen);
			return ret;
		}

		/// <summary>		/// Get The Manufacturer String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidGetManufacturerStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>		/// Get The Manufacturer String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = SDLHidGetManufacturerStringNative(dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>		/// Get The Manufacturer String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLHidGetManufacturerStringNative(dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get The Manufacturer String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = SDLHidGetManufacturerStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>		/// Get The Manufacturer String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_manufacturer_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetManufacturerString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = SDLHidGetManufacturerStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get The Product String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_get_product_string")]
		internal static extern int SDLHidGetProductStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		/// <summary>		/// Get The Product String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = SDLHidGetProductStringNative(dev, str, maxlen);
			return ret;
		}

		/// <summary>		/// Get The Product String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidGetProductStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>		/// Get The Product String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = SDLHidGetProductStringNative(dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>		/// Get The Product String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLHidGetProductStringNative(dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get The Product String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = SDLHidGetProductStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>		/// Get The Product String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_product_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetProductString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = SDLHidGetProductStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get The Serial Number String from a HID device.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_get_serial_number_string")]
		internal static extern int SDLHidGetSerialNumberStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		/// <summary>		/// Get The Serial Number String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = SDLHidGetSerialNumberStringNative(dev, str, maxlen);
			return ret;
		}

		/// <summary>		/// Get The Serial Number String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidGetSerialNumberStringNative((SDLHidDevice*)pdev, str, maxlen);
				return ret;
			}
		}

		/// <summary>		/// Get The Serial Number String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = SDLHidGetSerialNumberStringNative(dev, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>		/// Get The Serial Number String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLHidGetSerialNumberStringNative(dev, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get The Serial Number String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = SDLHidGetSerialNumberStringNative((SDLHidDevice*)pdev, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>		/// Get The Serial Number String from a HID device.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_serial_number_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetSerialNumberString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = SDLHidGetSerialNumberStringNative((SDLHidDevice*)pdev, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Get a string from a HID device, based on its string index.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_get_indexed_string")]
		internal static extern int SDLHidGetIndexedStringNative([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen);

		/// <summary>		/// Get a string from a HID device, based on its string index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			int ret = SDLHidGetIndexedStringNative(dev, stringIndex, str, maxlen);
			return ret;
		}

		/// <summary>		/// Get a string from a HID device, based on its string index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] char* str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				int ret = SDLHidGetIndexedStringNative((SDLHidDevice*)pdev, stringIndex, str, maxlen);
				return ret;
			}
		}

		/// <summary>		/// Get a string from a HID device, based on its string index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (char* pstr = &str)
			{
				int ret = SDLHidGetIndexedStringNative(dev, stringIndex, (char*)pstr, maxlen);
				return ret;
			}
		}

		/// <summary>		/// Get a string from a HID device, based on its string index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] SDLHidDevice* dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			char* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF16(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = (char*)pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = '\0';
			}
			int ret = SDLHidGetIndexedStringNative(dev, stringIndex, pStr0, maxlen);
			str = Utils.DecodeStringUTF16(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get a string from a HID device, based on its string index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref char str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				fixed (char* pstr = &str)
				{
					int ret = SDLHidGetIndexedStringNative((SDLHidDevice*)pdev, stringIndex, (char*)pstr, maxlen);
					return ret;
				}
			}
		}

		/// <summary>		/// Get a string from a HID device, based on its string index.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_get_indexed_string")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLHidGetIndexedString([NativeName(NativeNameType.Param, "dev")] [NativeName(NativeNameType.Type, "SDL_hid_device*")] ref SDLHidDevice dev, [NativeName(NativeNameType.Param, "string_index")] [NativeName(NativeNameType.Type, "int")] int stringIndex, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "wchar*")] ref string str, [NativeName(NativeNameType.Param, "maxlen")] [NativeName(NativeNameType.Type, "size_t")] nuint maxlen)
		{
			fixed (SDLHidDevice* pdev = &dev)
			{
				char* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF16(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<char>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = (char*)pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF16(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = '\0';
				}
				int ret = SDLHidGetIndexedStringNative((SDLHidDevice*)pdev, stringIndex, pStr0, maxlen);
				str = Utils.DecodeStringUTF16(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_hid_ble_scan")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_hid_ble_scan")]
		internal static extern void SDLHidBleScanNative([NativeName(NativeNameType.Param, "active")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool active);

		/// <summary>		/// Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_hid_ble_scan")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLHidBleScan([NativeName(NativeNameType.Param, "active")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool active)
		{
			SDLHidBleScanNative(active);
		}

		/// <summary>
		/// Set a hint with a specific priority.<br/>
		/// The priority controls the behavior when setting a hint that already has a<br/>
		/// value. Hints will replace existing hints of their priority and lower.<br/>
		/// Environment variables are considered to have override priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetHintWithPriority")]
		internal static extern SDLBool SDLSetHintWithPriorityNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority);

		/// <summary>		/// Set a hint with a specific priority.<br/>		/// The priority controls the behavior when setting a hint that already has a<br/>		/// value. Hints will replace existing hints of their priority and lower.<br/>		/// Environment variables are considered to have override priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			SDLBool ret = SDLSetHintWithPriorityNative(name, value, priority);
			return ret;
		}

		/// <summary>		/// Set a hint with a specific priority.<br/>		/// The priority controls the behavior when setting a hint that already has a<br/>		/// value. Hints will replace existing hints of their priority and lower.<br/>		/// Environment variables are considered to have override priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = &name)
			{
				SDLBool ret = SDLSetHintWithPriorityNative((byte*)pname, value, priority);
				return ret;
			}
		}

		/// <summary>		/// Set a hint with a specific priority.<br/>		/// The priority controls the behavior when setting a hint that already has a<br/>		/// value. Hints will replace existing hints of their priority and lower.<br/>		/// Environment variables are considered to have override priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = SDLSetHintWithPriorityNative(pStr0, value, priority);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Set a hint with a specific priority.<br/>		/// The priority controls the behavior when setting a hint that already has a<br/>		/// value. Hints will replace existing hints of their priority and lower.<br/>		/// Environment variables are considered to have override priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pvalue = &value)
			{
				SDLBool ret = SDLSetHintWithPriorityNative(name, (byte*)pvalue, priority);
				return ret;
			}
		}

		/// <summary>		/// Set a hint with a specific priority.<br/>		/// The priority controls the behavior when setting a hint that already has a<br/>		/// value. Hints will replace existing hints of their priority and lower.<br/>		/// Environment variables are considered to have override priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = SDLSetHintWithPriorityNative(name, pStr0, priority);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Set a hint with a specific priority.<br/>		/// The priority controls the behavior when setting a hint that already has a<br/>		/// value. Hints will replace existing hints of their priority and lower.<br/>		/// Environment variables are considered to have override priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					SDLBool ret = SDLSetHintWithPriorityNative((byte*)pname, (byte*)pvalue, priority);
					return ret;
				}
			}
		}

		/// <summary>		/// Set a hint with a specific priority.<br/>		/// The priority controls the behavior when setting a hint that already has a<br/>		/// value. Hints will replace existing hints of their priority and lower.<br/>		/// Environment variables are considered to have override priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHintWithPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHintWithPriority([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_HintPriority")] SDLHintPriority priority)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLBool ret = SDLSetHintWithPriorityNative(pStr0, pStr1, priority);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Set a hint with normal priority.<br/>
		/// Hints will not be set if there is an existing override hint or environment<br/>
		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
		/// set the hint with override priority instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetHint")]
		internal static extern SDLBool SDLSetHintNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value);

		/// <summary>		/// Set a hint with normal priority.<br/>		/// Hints will not be set if there is an existing override hint or environment<br/>		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>		/// set the hint with override priority instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value)
		{
			SDLBool ret = SDLSetHintNative(name, value);
			return ret;
		}

		/// <summary>		/// Set a hint with normal priority.<br/>		/// Hints will not be set if there is an existing override hint or environment<br/>		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>		/// set the hint with override priority instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value)
		{
			fixed (byte* pname = &name)
			{
				SDLBool ret = SDLSetHintNative((byte*)pname, value);
				return ret;
			}
		}

		/// <summary>		/// Set a hint with normal priority.<br/>		/// Hints will not be set if there is an existing override hint or environment<br/>		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>		/// set the hint with override priority instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] byte* value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = SDLSetHintNative(pStr0, value);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Set a hint with normal priority.<br/>		/// Hints will not be set if there is an existing override hint or environment<br/>		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>		/// set the hint with override priority instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value)
		{
			fixed (byte* pvalue = &value)
			{
				SDLBool ret = SDLSetHintNative(name, (byte*)pvalue);
				return ret;
			}
		}

		/// <summary>		/// Set a hint with normal priority.<br/>		/// Hints will not be set if there is an existing override hint or environment<br/>		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>		/// set the hint with override priority instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (value != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(value);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(value, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = SDLSetHintNative(name, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Set a hint with normal priority.<br/>		/// Hints will not be set if there is an existing override hint or environment<br/>		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>		/// set the hint with override priority instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] ref byte value)
		{
			fixed (byte* pname = &name)
			{
				fixed (byte* pvalue = &value)
				{
					SDLBool ret = SDLSetHintNative((byte*)pname, (byte*)pvalue);
					return ret;
				}
			}
		}

		/// <summary>		/// Set a hint with normal priority.<br/>		/// Hints will not be set if there is an existing override hint or environment<br/>		/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>		/// set the hint with override priority instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLSetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "const char*")] string value)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (value != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(value);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(value, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SDLBool ret = SDLSetHintNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Reset a hint to the default value.<br/>
		/// This will reset a hint to the value of the environment variable, or NULL if<br/>
		/// the environment isn't set. Callbacks will be called normally with this<br/>
		/// change.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ResetHint")]
		internal static extern SDLBool SDLResetHintNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name);

		/// <summary>		/// Reset a hint to the default value.<br/>		/// This will reset a hint to the value of the environment variable, or NULL if<br/>		/// the environment isn't set. Callbacks will be called normally with this<br/>		/// change.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			SDLBool ret = SDLResetHintNative(name);
			return ret;
		}

		/// <summary>		/// Reset a hint to the default value.<br/>		/// This will reset a hint to the value of the environment variable, or NULL if<br/>		/// the environment isn't set. Callbacks will be called normally with this<br/>		/// change.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				SDLBool ret = SDLResetHintNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>		/// Reset a hint to the default value.<br/>		/// This will reset a hint to the value of the environment variable, or NULL if<br/>		/// the environment isn't set. Callbacks will be called normally with this<br/>		/// change.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ResetHint")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLResetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = SDLResetHintNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Reset all hints to the default values.<br/>
		/// This will reset all hints to the value of the associated environment<br/>
		/// variable, or NULL if the environment isn't set. Callbacks will be called<br/>
		/// normally with this change.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ResetHints")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ResetHints")]
		internal static extern void SDLResetHintsNative();

		/// <summary>		/// Reset all hints to the default values.<br/>		/// This will reset all hints to the value of the associated environment<br/>		/// variable, or NULL if the environment isn't set. Callbacks will be called<br/>		/// normally with this change.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ResetHints")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLResetHints()
		{
			SDLResetHintsNative();
		}

		/// <summary>
		/// Get the value of a hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetHint")]
		internal static extern byte* SDLGetHintNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name);

		/// <summary>		/// Get the value of a hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			byte* ret = SDLGetHintNative(name);
			return ret;
		}

		/// <summary>		/// Get the value of a hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			string ret = Utils.DecodeStringUTF8(SDLGetHintNative(name));
			return ret;
		}

		/// <summary>		/// Get the value of a hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = SDLGetHintNative((byte*)pname);
				return ret;
			}
		}

		/// <summary>		/// Get the value of a hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(SDLGetHintNative((byte*)pname));
				return ret;
			}
		}

		/// <summary>		/// Get the value of a hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetHint([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SDLGetHintNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Get the value of a hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetHint")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetHintS([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SDLGetHintNative(pStr0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Get the boolean value of a hint variable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetHintBoolean")]
		internal static extern SDLBool SDLGetHintBooleanNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool defaultValue);

		/// <summary>		/// Get the boolean value of a hint variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool defaultValue)
		{
			SDLBool ret = SDLGetHintBooleanNative(name, defaultValue);
			return ret;
		}

		/// <summary>		/// Get the boolean value of a hint variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool defaultValue)
		{
			fixed (byte* pname = &name)
			{
				SDLBool ret = SDLGetHintBooleanNative((byte*)pname, defaultValue);
				return ret;
			}
		}

		/// <summary>		/// Get the boolean value of a hint variable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetHintBoolean")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLGetHintBoolean([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "default_value")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLBool ret = SDLGetHintBooleanNative(pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Add a function to watch a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AddHintCallback")]
		internal static extern void SDLAddHintCallbackNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Add a function to watch a particular hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLAddHintCallbackNative(name, callback, userdata);
		}

		/// <summary>		/// Add a function to watch a particular hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				SDLAddHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>		/// Add a function to watch a particular hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AddHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLAddHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLAddHintCallbackNative(pStr0, callback, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Remove a function watching a particular hint.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DelHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DelHintCallback")]
		internal static extern void SDLDelHintCallbackNative([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Remove a function watching a particular hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DelHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDelHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLDelHintCallbackNative(name, callback, userdata);
		}

		/// <summary>		/// Remove a function watching a particular hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DelHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDelHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			fixed (byte* pname = &name)
			{
				SDLDelHintCallbackNative((byte*)pname, callback, userdata);
			}
		}

		/// <summary>		/// Remove a function watching a particular hint.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DelHintCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDelHintCallback([NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_HintCallback")] SDLHintCallback callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLDelHintCallbackNative(pStr0, callback, userdata);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Clear all hints.<br/>
		/// This function is automatically called during SDL_Quit(), and deletes all<br/>
		/// callbacks without calling them and frees all memory associated with hints.<br/>
		/// If you're calling this from application code you probably want to call<br/>
		/// SDL_ResetHints() instead.<br/>
		/// This function will be removed from the API the next time we rev the ABI.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ClearHints")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ClearHints")]
		internal static extern void SDLClearHintsNative();

		/// <summary>		/// Clear all hints.<br/>		/// This function is automatically called during SDL_Quit(), and deletes all<br/>		/// callbacks without calling them and frees all memory associated with hints.<br/>		/// If you're calling this from application code you probably want to call<br/>		/// SDL_ResetHints() instead.<br/>		/// This function will be removed from the API the next time we rev the ABI.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ClearHints")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLClearHints()
		{
			SDLClearHintsNative();
		}

		/// <summary>
		/// Dynamically load a shared object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadObject")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LoadObject")]
		internal static extern void* SDLLoadObjectNative([NativeName(NativeNameType.Param, "sofile")] [NativeName(NativeNameType.Type, "const char*")] byte* sofile);

		/// <summary>		/// Dynamically load a shared object.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadObject")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadObject([NativeName(NativeNameType.Param, "sofile")] [NativeName(NativeNameType.Type, "const char*")] byte* sofile)
		{
			void* ret = SDLLoadObjectNative(sofile);
			return ret;
		}

		/// <summary>		/// Dynamically load a shared object.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadObject")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadObject([NativeName(NativeNameType.Param, "sofile")] [NativeName(NativeNameType.Type, "const char*")] ref byte sofile)
		{
			fixed (byte* psofile = &sofile)
			{
				void* ret = SDLLoadObjectNative((byte*)psofile);
				return ret;
			}
		}

		/// <summary>		/// Dynamically load a shared object.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadObject")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadObject([NativeName(NativeNameType.Param, "sofile")] [NativeName(NativeNameType.Type, "const char*")] string sofile)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (sofile != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(sofile);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(sofile, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SDLLoadObjectNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Look up the address of the named function in a shared object.<br/>
		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
		/// This function can only look up C function names. Other languages may have<br/>
		/// name mangling and intrinsic language support that varies from compiler to<br/>
		/// compiler.<br/>
		/// Make sure you declare your function pointers with the same calling<br/>
		/// convention as the actual library function. Your code will crash<br/>
		/// mysteriously if you do not do this.<br/>
		/// If the requested function doesn't exist, NULL is returned.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LoadFunction")]
		internal static extern void* SDLLoadFunctionNative([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "void*")] void* handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name);

		/// <summary>		/// Look up the address of the named function in a shared object.<br/>		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>		/// This function can only look up C function names. Other languages may have<br/>		/// name mangling and intrinsic language support that varies from compiler to<br/>		/// compiler.<br/>		/// Make sure you declare your function pointers with the same calling<br/>		/// convention as the actual library function. Your code will crash<br/>		/// mysteriously if you do not do this.<br/>		/// If the requested function doesn't exist, NULL is returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFunction([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "void*")] void* handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] byte* name)
		{
			void* ret = SDLLoadFunctionNative(handle, name);
			return ret;
		}

		/// <summary>		/// Look up the address of the named function in a shared object.<br/>		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>		/// This function can only look up C function names. Other languages may have<br/>		/// name mangling and intrinsic language support that varies from compiler to<br/>		/// compiler.<br/>		/// Make sure you declare your function pointers with the same calling<br/>		/// convention as the actual library function. Your code will crash<br/>		/// mysteriously if you do not do this.<br/>		/// If the requested function doesn't exist, NULL is returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFunction([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "void*")] void* handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] ref byte name)
		{
			fixed (byte* pname = &name)
			{
				void* ret = SDLLoadFunctionNative(handle, (byte*)pname);
				return ret;
			}
		}

		/// <summary>		/// Look up the address of the named function in a shared object.<br/>		/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>		/// This function can only look up C function names. Other languages may have<br/>		/// name mangling and intrinsic language support that varies from compiler to<br/>		/// compiler.<br/>		/// Make sure you declare your function pointers with the same calling<br/>		/// convention as the actual library function. Your code will crash<br/>		/// mysteriously if you do not do this.<br/>		/// If the requested function doesn't exist, NULL is returned.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LoadFunction")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLLoadFunction([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "void*")] void* handle, [NativeName(NativeNameType.Param, "name")] [NativeName(NativeNameType.Type, "const char*")] string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = SDLLoadFunctionNative(handle, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Unload a shared object from memory.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnloadObject")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnloadObject")]
		internal static extern void SDLUnloadObjectNative([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "void*")] void* handle);

		/// <summary>		/// Unload a shared object from memory.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnloadObject")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnloadObject([NativeName(NativeNameType.Param, "handle")] [NativeName(NativeNameType.Type, "void*")] void* handle)
		{
			SDLUnloadObjectNative(handle);
		}

		/// <summary>
		/// Set the priority of all log categories.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogSetAllPriority")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogSetAllPriority")]
		internal static extern void SDLLogSetAllPriorityNative([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority);

		/// <summary>		/// Set the priority of all log categories.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogSetAllPriority")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogSetAllPriority([NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority)
		{
			SDLLogSetAllPriorityNative(priority);
		}

		/// <summary>
		/// Set the priority of a particular log category.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogSetPriority")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogSetPriority")]
		internal static extern void SDLLogSetPriorityNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority);

		/// <summary>		/// Set the priority of a particular log category.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogSetPriority")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogSetPriority([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority)
		{
			SDLLogSetPriorityNative(category, priority);
		}

		/// <summary>
		/// Get the priority of a particular log category.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogGetPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_LogPriority")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogGetPriority")]
		internal static extern SDLLogPriority SDLLogGetPriorityNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category);

		/// <summary>		/// Get the priority of a particular log category.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogGetPriority")]
		[return: NativeName(NativeNameType.Type, "SDL_LogPriority")]
		public static SDLLogPriority SDLLogGetPriority([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category)
		{
			SDLLogPriority ret = SDLLogGetPriorityNative(category);
			return ret;
		}

		/// <summary>
		/// Reset all priorities to default.<br/>
		/// This is called by SDL_Quit().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogResetPriorities")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogResetPriorities")]
		internal static extern void SDLLogResetPrioritiesNative();

		/// <summary>		/// Reset all priorities to default.<br/>		/// This is called by SDL_Quit().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogResetPriorities")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogResetPriorities()
		{
			SDLLogResetPrioritiesNative();
		}

		/// <summary>
		/// Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO.<br/>
		/// = * <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Log")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Log")]
		internal static extern void SDLLogNative([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		[NativeName(NativeNameType.Func, "SDL_Log")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLog([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			SDLLogNative(fmt);
		}

		[NativeName(NativeNameType.Func, "SDL_Log")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLog([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SDLLogNative((byte*)pfmt);
			}
		}

		[NativeName(NativeNameType.Func, "SDL_Log")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLog([NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLLogNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogVerbose")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogVerbose")]
		internal static extern void SDLLogVerboseNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogVerbose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogVerbose([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			SDLLogVerboseNative(category, fmt);
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogVerbose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogVerbose([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SDLLogVerboseNative(category, (byte*)pfmt);
			}
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogVerbose")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogVerbose([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLLogVerboseNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogDebug")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogDebug")]
		internal static extern void SDLLogDebugNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogDebug")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogDebug([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			SDLLogDebugNative(category, fmt);
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogDebug")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogDebug([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SDLLogDebugNative(category, (byte*)pfmt);
			}
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogDebug")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogDebug([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLLogDebugNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogInfo")]
		internal static extern void SDLLogInfoNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogInfo([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			SDLLogInfoNative(category, fmt);
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogInfo([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SDLLogInfoNative(category, (byte*)pfmt);
			}
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogInfo")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogInfo([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLLogInfoNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogWarn")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogWarn")]
		internal static extern void SDLLogWarnNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogWarn")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogWarn([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			SDLLogWarnNative(category, fmt);
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogWarn")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogWarn([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SDLLogWarnNative(category, (byte*)pfmt);
			}
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogWarn")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogWarn([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLLogWarnNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogError")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogError")]
		internal static extern void SDLLogErrorNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogError")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogError([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			SDLLogErrorNative(category, fmt);
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogError")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogError([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SDLLogErrorNative(category, (byte*)pfmt);
			}
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogError")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogError([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLLogErrorNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogCritical")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogCritical")]
		internal static extern void SDLLogCriticalNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogCritical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogCritical([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			SDLLogCriticalNative(category, fmt);
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogCritical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogCritical([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SDLLogCriticalNative(category, (byte*)pfmt);
			}
		}

		/// <summary>		/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogCritical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogCritical([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLLogCriticalNative(category, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogMessage")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogMessage")]
		internal static extern void SDLLogMessageNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt);

		/// <summary>		/// Log a message with the specified category and priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogMessage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogMessage([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt)
		{
			SDLLogMessageNative(category, priority, fmt);
		}

		/// <summary>		/// Log a message with the specified category and priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogMessage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogMessage([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				SDLLogMessageNative(category, priority, (byte*)pfmt);
			}
		}

		/// <summary>		/// Log a message with the specified category and priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogMessage")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogMessage([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLLogMessageNative(category, priority, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Log a message with the specified category and priority.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogMessageV")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogMessageV")]
		internal static extern void SDLLogMessageVNative([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap);

		/// <summary>		/// Log a message with the specified category and priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogMessageV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogMessageV([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] byte* fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			SDLLogMessageVNative(category, priority, fmt, ap);
		}

		/// <summary>		/// Log a message with the specified category and priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogMessageV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogMessageV([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] ref byte fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			fixed (byte* pfmt = &fmt)
			{
				SDLLogMessageVNative(category, priority, (byte*)pfmt, ap);
			}
		}

		/// <summary>		/// Log a message with the specified category and priority.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogMessageV")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogMessageV([NativeName(NativeNameType.Param, "category")] [NativeName(NativeNameType.Type, "int")] int category, [NativeName(NativeNameType.Param, "priority")] [NativeName(NativeNameType.Type, "SDL_LogPriority")] SDLLogPriority priority, [NativeName(NativeNameType.Param, "fmt")] [NativeName(NativeNameType.Type, "const char*")] string fmt, [NativeName(NativeNameType.Param, "ap")] [NativeName(NativeNameType.Type, "va_list")] nint ap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLLogMessageVNative(category, priority, pStr0, ap);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Get the current log output function.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogGetOutputFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogGetOutputFunction")]
		internal static extern void SDLLogGetOutputFunctionNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_LogOutputFunction*")] SDLLogOutputFunction callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void**")] void** userdata);

		/// <summary>		/// Get the current log output function.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogGetOutputFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogGetOutputFunction([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_LogOutputFunction*")] SDLLogOutputFunction callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void**")] void** userdata)
		{
			SDLLogGetOutputFunctionNative(callback, userdata);
		}

		/// <summary>
		/// Replace the default log output function with one of your own.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LogSetOutputFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LogSetOutputFunction")]
		internal static extern void SDLLogSetOutputFunctionNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_LogOutputFunction")] SDLLogOutputFunction callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Replace the default log output function with one of your own.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LogSetOutputFunction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLLogSetOutputFunction([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_LogOutputFunction")] SDLLogOutputFunction callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLLogSetOutputFunctionNative(callback, userdata);
		}

		/// <summary>
		/// Create a modal message box.<br/>
		/// If your needs aren't complex, it might be easier to use<br/>
		/// SDL_ShowSimpleMessageBox.<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ShowMessageBox")]
		internal static extern int SDLShowMessageBoxNative([NativeName(NativeNameType.Param, "messageboxdata")] [NativeName(NativeNameType.Type, "const SDL_MessageBoxData*")] SDLMessageBoxData* messageboxdata, [NativeName(NativeNameType.Param, "buttonid")] [NativeName(NativeNameType.Type, "int*")] int* buttonid);

		/// <summary>		/// Create a modal message box.<br/>		/// If your needs aren't complex, it might be easier to use<br/>		/// SDL_ShowSimpleMessageBox.<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowMessageBox([NativeName(NativeNameType.Param, "messageboxdata")] [NativeName(NativeNameType.Type, "const SDL_MessageBoxData*")] SDLMessageBoxData* messageboxdata, [NativeName(NativeNameType.Param, "buttonid")] [NativeName(NativeNameType.Type, "int*")] int* buttonid)
		{
			int ret = SDLShowMessageBoxNative(messageboxdata, buttonid);
			return ret;
		}

		/// <summary>		/// Create a modal message box.<br/>		/// If your needs aren't complex, it might be easier to use<br/>		/// SDL_ShowSimpleMessageBox.<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowMessageBox([NativeName(NativeNameType.Param, "messageboxdata")] [NativeName(NativeNameType.Type, "const SDL_MessageBoxData*")] ref SDLMessageBoxData messageboxdata, [NativeName(NativeNameType.Param, "buttonid")] [NativeName(NativeNameType.Type, "int*")] int* buttonid)
		{
			fixed (SDLMessageBoxData* pmessageboxdata = &messageboxdata)
			{
				int ret = SDLShowMessageBoxNative((SDLMessageBoxData*)pmessageboxdata, buttonid);
				return ret;
			}
		}

		/// <summary>		/// Create a modal message box.<br/>		/// If your needs aren't complex, it might be easier to use<br/>		/// SDL_ShowSimpleMessageBox.<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowMessageBox([NativeName(NativeNameType.Param, "messageboxdata")] [NativeName(NativeNameType.Type, "const SDL_MessageBoxData*")] SDLMessageBoxData* messageboxdata, [NativeName(NativeNameType.Param, "buttonid")] [NativeName(NativeNameType.Type, "int*")] ref int buttonid)
		{
			fixed (int* pbuttonid = &buttonid)
			{
				int ret = SDLShowMessageBoxNative(messageboxdata, (int*)pbuttonid);
				return ret;
			}
		}

		/// <summary>		/// Create a modal message box.<br/>		/// If your needs aren't complex, it might be easier to use<br/>		/// SDL_ShowSimpleMessageBox.<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowMessageBox([NativeName(NativeNameType.Param, "messageboxdata")] [NativeName(NativeNameType.Type, "const SDL_MessageBoxData*")] ref SDLMessageBoxData messageboxdata, [NativeName(NativeNameType.Param, "buttonid")] [NativeName(NativeNameType.Type, "int*")] ref int buttonid)
		{
			fixed (SDLMessageBoxData* pmessageboxdata = &messageboxdata)
			{
				fixed (int* pbuttonid = &buttonid)
				{
					int ret = SDLShowMessageBoxNative((SDLMessageBoxData*)pmessageboxdata, (int*)pbuttonid);
					return ret;
				}
			}
		}

		/// <summary>
		/// Display a simple modal message box.<br/>
		/// If your needs aren't complex, this function is preferred over<br/>
		/// SDL_ShowMessageBox.<br/>
		/// `flags` may be any of the following:<br/>
		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
		/// This function should be called on the thread that created the parent<br/>
		/// window, or on the main thread if the messagebox has no parent. It will<br/>
		/// block execution of that thread until the user clicks a button or closes the<br/>
		/// messagebox.<br/>
		/// This function may be called at any time, even before SDL_Init(). This makes<br/>
		/// it useful for reporting errors like a failure to create a renderer or<br/>
		/// OpenGL context.<br/>
		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
		/// formal toolkit like GTK+ or Qt.<br/>
		/// Note that if SDL_Init() would fail because there isn't any available video<br/>
		/// target, this function is likely to fail for the same reasons. If this is a<br/>
		/// concern, check the return value from this function and fall back to writing<br/>
		/// to stderr if you can.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_ShowSimpleMessageBox")]
		internal static extern int SDLShowSimpleMessageBoxNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] byte* message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] byte* message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			int ret = SDLShowSimpleMessageBoxNative(flags, title, message, window);
			return ret;
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] ref byte title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] byte* message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			fixed (byte* ptitle = &title)
			{
				int ret = SDLShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, window);
				return ret;
			}
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] string title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] byte* message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLShowSimpleMessageBoxNative(flags, pStr0, message, window);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] ref byte message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			fixed (byte* pmessage = &message)
			{
				int ret = SDLShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, window);
				return ret;
			}
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] string message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLShowSimpleMessageBoxNative(flags, title, pStr0, window);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] ref byte title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] ref byte message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (byte* pmessage = &message)
				{
					int ret = SDLShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, window);
					return ret;
				}
			}
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] string title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] string message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (message != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(message);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(message, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = SDLShowSimpleMessageBoxNative(flags, pStr0, pStr1, window);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] byte* message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLShowSimpleMessageBoxNative(flags, title, message, (SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] ref byte title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] byte* message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = SDLShowSimpleMessageBoxNative(flags, (byte*)ptitle, message, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] string title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] byte* message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLShowSimpleMessageBoxNative(flags, pStr0, message, (SDLWindow*)pwindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] ref byte message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (byte* pmessage = &message)
			{
				fixed (SDLWindow* pwindow = &window)
				{
					int ret = SDLShowSimpleMessageBoxNative(flags, title, (byte*)pmessage, (SDLWindow*)pwindow);
					return ret;
				}
			}
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] string message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLShowSimpleMessageBoxNative(flags, title, pStr0, (SDLWindow*)pwindow);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] ref byte title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] ref byte message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (byte* ptitle = &title)
			{
				fixed (byte* pmessage = &message)
				{
					fixed (SDLWindow* pwindow = &window)
					{
						int ret = SDLShowSimpleMessageBoxNative(flags, (byte*)ptitle, (byte*)pmessage, (SDLWindow*)pwindow);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Display a simple modal message box.<br/>		/// If your needs aren't complex, this function is preferred over<br/>		/// SDL_ShowMessageBox.<br/>		/// `flags` may be any of the following:<br/>		/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>		/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>		/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>		/// This function should be called on the thread that created the parent<br/>		/// window, or on the main thread if the messagebox has no parent. It will<br/>		/// block execution of that thread until the user clicks a button or closes the<br/>		/// messagebox.<br/>		/// This function may be called at any time, even before SDL_Init(). This makes<br/>		/// it useful for reporting errors like a failure to create a renderer or<br/>		/// OpenGL context.<br/>		/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>		/// formal toolkit like GTK+ or Qt.<br/>		/// Note that if SDL_Init() would fail because there isn't any available video<br/>		/// target, this function is likely to fail for the same reasons. If this is a<br/>		/// concern, check the return value from this function and fall back to writing<br/>		/// to stderr if you can.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_ShowSimpleMessageBox")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLShowSimpleMessageBox([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags, [NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] string title, [NativeName(NativeNameType.Param, "message")] [NativeName(NativeNameType.Type, "const char*")] string message, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (message != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(message);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(message, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLShowSimpleMessageBoxNative(flags, pStr0, pStr1, (SDLWindow*)pwindow);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>
		/// window.<br/>
		/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>
		/// its own. It is up to user code to do that.<br/>
		/// The returned handle can be casted directly to a NSView or UIView. To access<br/>
		/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Metal_CreateView")]
		[return: NativeName(NativeNameType.Type, "SDL_MetalView")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Metal_CreateView")]
		internal static extern SDLMetalView SDLMetalCreateViewNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>		/// window.<br/>		/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>		/// its own. It is up to user code to do that.<br/>		/// The returned handle can be casted directly to a NSView or UIView. To access<br/>		/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_CreateView")]
		[return: NativeName(NativeNameType.Type, "SDL_MetalView")]
		public static SDLMetalView SDLMetalCreateView([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLMetalView ret = SDLMetalCreateViewNative(window);
			return ret;
		}

		/// <summary>		/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>		/// window.<br/>		/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>		/// its own. It is up to user code to do that.<br/>		/// The returned handle can be casted directly to a NSView or UIView. To access<br/>		/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_CreateView")]
		[return: NativeName(NativeNameType.Type, "SDL_MetalView")]
		public static SDLMetalView SDLMetalCreateView([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLMetalView ret = SDLMetalCreateViewNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Destroy an existing SDL_MetalView object.<br/>
		/// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was<br/>
		/// called after SDL_CreateWindow.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Metal_DestroyView")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Metal_DestroyView")]
		internal static extern void SDLMetalDestroyViewNative([NativeName(NativeNameType.Param, "view")] [NativeName(NativeNameType.Type, "SDL_MetalView")] SDLMetalView view);

		/// <summary>		/// Destroy an existing SDL_MetalView object.<br/>		/// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was<br/>		/// called after SDL_CreateWindow.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_DestroyView")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMetalDestroyView([NativeName(NativeNameType.Param, "view")] [NativeName(NativeNameType.Type, "SDL_MetalView")] SDLMetalView view)
		{
			SDLMetalDestroyViewNative(view);
		}

		/// <summary>
		/// Get a pointer to the backing CAMetalLayer for the given view.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Metal_GetLayer")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Metal_GetLayer")]
		internal static extern void* SDLMetalGetLayerNative([NativeName(NativeNameType.Param, "view")] [NativeName(NativeNameType.Type, "SDL_MetalView")] SDLMetalView view);

		/// <summary>		/// Get a pointer to the backing CAMetalLayer for the given view.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_GetLayer")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLMetalGetLayer([NativeName(NativeNameType.Param, "view")] [NativeName(NativeNameType.Type, "SDL_MetalView")] SDLMetalView view)
		{
			void* ret = SDLMetalGetLayerNative(view);
			return ret;
		}

		/// <summary>
		/// Get the size of a window's underlying drawable in pixels (for use with<br/>
		/// setting viewport, scissor <br/>
		/// &<br/>
		/// etc).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Metal_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Metal_GetDrawableSize")]
		internal static extern void SDLMetalGetDrawableSizeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h);

		/// <summary>		/// Get the size of a window's underlying drawable in pixels (for use with<br/>		/// setting viewport, scissor <br/>		/// &<br/>		/// etc).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMetalGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			SDLMetalGetDrawableSizeNative(window, w, h);
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels (for use with<br/>		/// setting viewport, scissor <br/>		/// &<br/>		/// etc).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMetalGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLMetalGetDrawableSizeNative((SDLWindow*)pwindow, w, h);
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels (for use with<br/>		/// setting viewport, scissor <br/>		/// &<br/>		/// etc).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMetalGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				SDLMetalGetDrawableSizeNative(window, (int*)pw, h);
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels (for use with<br/>		/// setting viewport, scissor <br/>		/// &<br/>		/// etc).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMetalGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					SDLMetalGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, h);
				}
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels (for use with<br/>		/// setting viewport, scissor <br/>		/// &<br/>		/// etc).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMetalGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				SDLMetalGetDrawableSizeNative(window, w, (int*)ph);
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels (for use with<br/>		/// setting viewport, scissor <br/>		/// &<br/>		/// etc).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMetalGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* ph = &h)
				{
					SDLMetalGetDrawableSizeNative((SDLWindow*)pwindow, w, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels (for use with<br/>		/// setting viewport, scissor <br/>		/// &<br/>		/// etc).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMetalGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					SDLMetalGetDrawableSizeNative(window, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get the size of a window's underlying drawable in pixels (for use with<br/>		/// setting viewport, scissor <br/>		/// &<br/>		/// etc).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Metal_GetDrawableSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLMetalGetDrawableSize([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						SDLMetalGetDrawableSizeNative((SDLWindow*)pwindow, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Get the current power supply details.<br/>
		/// You should never take a battery status as absolute truth. Batteries<br/>
		/// (especially failing batteries) are delicate hardware, and the values<br/>
		/// reported here are best estimates based on what that hardware reports. It's<br/>
		/// not uncommon for older batteries to lose stored power much faster than it<br/>
		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
		/// Battery status can change at any time; if you are concerned with power<br/>
		/// state, you should call this function frequently, and perhaps ignore changes<br/>
		/// until they seem to be stable for a few seconds.<br/>
		/// It's possible a platform can only report battery percentage or time left<br/>
		/// but not both.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetPowerInfo")]
		internal static extern SDLPowerState SDLGetPowerInfoNative([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int*")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int*")] int* percent);

		/// <summary>		/// Get the current power supply details.<br/>		/// You should never take a battery status as absolute truth. Batteries<br/>		/// (especially failing batteries) are delicate hardware, and the values<br/>		/// reported here are best estimates based on what that hardware reports. It's<br/>		/// not uncommon for older batteries to lose stored power much faster than it<br/>		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>		/// Battery status can change at any time; if you are concerned with power<br/>		/// state, you should call this function frequently, and perhaps ignore changes<br/>		/// until they seem to be stable for a few seconds.<br/>		/// It's possible a platform can only report battery percentage or time left<br/>		/// but not both.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState SDLGetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int*")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int*")] int* percent)
		{
			SDLPowerState ret = SDLGetPowerInfoNative(seconds, percent);
			return ret;
		}

		/// <summary>		/// Get the current power supply details.<br/>		/// You should never take a battery status as absolute truth. Batteries<br/>		/// (especially failing batteries) are delicate hardware, and the values<br/>		/// reported here are best estimates based on what that hardware reports. It's<br/>		/// not uncommon for older batteries to lose stored power much faster than it<br/>		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>		/// Battery status can change at any time; if you are concerned with power<br/>		/// state, you should call this function frequently, and perhaps ignore changes<br/>		/// until they seem to be stable for a few seconds.<br/>		/// It's possible a platform can only report battery percentage or time left<br/>		/// but not both.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState SDLGetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int*")] ref int seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int*")] int* percent)
		{
			fixed (int* pseconds = &seconds)
			{
				SDLPowerState ret = SDLGetPowerInfoNative((int*)pseconds, percent);
				return ret;
			}
		}

		/// <summary>		/// Get the current power supply details.<br/>		/// You should never take a battery status as absolute truth. Batteries<br/>		/// (especially failing batteries) are delicate hardware, and the values<br/>		/// reported here are best estimates based on what that hardware reports. It's<br/>		/// not uncommon for older batteries to lose stored power much faster than it<br/>		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>		/// Battery status can change at any time; if you are concerned with power<br/>		/// state, you should call this function frequently, and perhaps ignore changes<br/>		/// until they seem to be stable for a few seconds.<br/>		/// It's possible a platform can only report battery percentage or time left<br/>		/// but not both.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState SDLGetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int*")] int* seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int*")] ref int percent)
		{
			fixed (int* ppercent = &percent)
			{
				SDLPowerState ret = SDLGetPowerInfoNative(seconds, (int*)ppercent);
				return ret;
			}
		}

		/// <summary>		/// Get the current power supply details.<br/>		/// You should never take a battery status as absolute truth. Batteries<br/>		/// (especially failing batteries) are delicate hardware, and the values<br/>		/// reported here are best estimates based on what that hardware reports. It's<br/>		/// not uncommon for older batteries to lose stored power much faster than it<br/>		/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>		/// Battery status can change at any time; if you are concerned with power<br/>		/// state, you should call this function frequently, and perhaps ignore changes<br/>		/// until they seem to be stable for a few seconds.<br/>		/// It's possible a platform can only report battery percentage or time left<br/>		/// but not both.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPowerInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_PowerState")]
		public static SDLPowerState SDLGetPowerInfo([NativeName(NativeNameType.Param, "seconds")] [NativeName(NativeNameType.Type, "int*")] ref int seconds, [NativeName(NativeNameType.Param, "percent")] [NativeName(NativeNameType.Type, "int*")] ref int percent)
		{
			fixed (int* pseconds = &seconds)
			{
				fixed (int* ppercent = &percent)
				{
					SDLPowerState ret = SDLGetPowerInfoNative((int*)pseconds, (int*)ppercent);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the number of 2D rendering drivers available for the current display.<br/>
		/// A render driver is a set of code that handles rendering and texture<br/>
		/// management on a particular display. Normally there is only one, but some<br/>
		/// drivers may have several available with different capabilities.<br/>
		/// There may be none if SDL was compiled without render support.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetNumRenderDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetNumRenderDrivers")]
		internal static extern int SDLGetNumRenderDriversNative();

		/// <summary>		/// Get the number of 2D rendering drivers available for the current display.<br/>		/// A render driver is a set of code that handles rendering and texture<br/>		/// management on a particular display. Normally there is only one, but some<br/>		/// drivers may have several available with different capabilities.<br/>		/// There may be none if SDL was compiled without render support.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetNumRenderDrivers")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetNumRenderDrivers()
		{
			int ret = SDLGetNumRenderDriversNative();
			return ret;
		}

		/// <summary>
		/// Get info about a specific 2D rendering driver for the current display.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDriverInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRenderDriverInfo")]
		internal static extern int SDLGetRenderDriverInfoNative([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_RendererInfo*")] SDLRendererInfo* info);

		/// <summary>		/// Get info about a specific 2D rendering driver for the current display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDriverInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDriverInfo([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_RendererInfo*")] SDLRendererInfo* info)
		{
			int ret = SDLGetRenderDriverInfoNative(index, info);
			return ret;
		}

		/// <summary>		/// Get info about a specific 2D rendering driver for the current display.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDriverInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDriverInfo([NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_RendererInfo*")] ref SDLRendererInfo info)
		{
			fixed (SDLRendererInfo* pinfo = &info)
			{
				int ret = SDLGetRenderDriverInfoNative(index, (SDLRendererInfo*)pinfo);
				return ret;
			}
		}

		/// <summary>
		/// Create a window and default renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateWindowAndRenderer")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateWindowAndRenderer")]
		internal static extern int SDLCreateWindowAndRendererNative([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "window_flags")] [NativeName(NativeNameType.Type, "Uint32")] uint windowFlags, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window**")] SDLWindow** window, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer**")] SDLRenderer** renderer);

		/// <summary>		/// Create a window and default renderer.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateWindowAndRenderer")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCreateWindowAndRenderer([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "window_flags")] [NativeName(NativeNameType.Type, "Uint32")] uint windowFlags, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window**")] SDLWindow** window, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer**")] SDLRenderer** renderer)
		{
			int ret = SDLCreateWindowAndRendererNative(width, height, windowFlags, window, renderer);
			return ret;
		}

		/// <summary>		/// Create a window and default renderer.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateWindowAndRenderer")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCreateWindowAndRenderer([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "window_flags")] [NativeName(NativeNameType.Type, "Uint32")] uint windowFlags, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window**")] ref SDLWindow* window, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer**")] SDLRenderer** renderer)
		{
			fixed (SDLWindow** pwindow = &window)
			{
				int ret = SDLCreateWindowAndRendererNative(width, height, windowFlags, (SDLWindow**)pwindow, renderer);
				return ret;
			}
		}

		/// <summary>		/// Create a window and default renderer.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateWindowAndRenderer")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCreateWindowAndRenderer([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "window_flags")] [NativeName(NativeNameType.Type, "Uint32")] uint windowFlags, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window**")] SDLWindow** window, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer**")] ref SDLRenderer* renderer)
		{
			fixed (SDLRenderer** prenderer = &renderer)
			{
				int ret = SDLCreateWindowAndRendererNative(width, height, windowFlags, window, (SDLRenderer**)prenderer);
				return ret;
			}
		}

		/// <summary>		/// Create a window and default renderer.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateWindowAndRenderer")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLCreateWindowAndRenderer([NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height, [NativeName(NativeNameType.Param, "window_flags")] [NativeName(NativeNameType.Type, "Uint32")] uint windowFlags, [NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window**")] ref SDLWindow* window, [NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer**")] ref SDLRenderer* renderer)
		{
			fixed (SDLWindow** pwindow = &window)
			{
				fixed (SDLRenderer** prenderer = &renderer)
				{
					int ret = SDLCreateWindowAndRendererNative(width, height, windowFlags, (SDLWindow**)pwindow, (SDLRenderer**)prenderer);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a 2D rendering context for a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateRenderer")]
		[return: NativeName(NativeNameType.Type, "SDL_Renderer*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateRenderer")]
		internal static extern SDLRenderer* SDLCreateRendererNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Create a 2D rendering context for a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRenderer")]
		[return: NativeName(NativeNameType.Type, "SDL_Renderer*")]
		public static SDLRenderer* SDLCreateRenderer([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			SDLRenderer* ret = SDLCreateRendererNative(window, index, flags);
			return ret;
		}

		/// <summary>		/// Create a 2D rendering context for a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateRenderer")]
		[return: NativeName(NativeNameType.Type, "SDL_Renderer*")]
		public static SDLRenderer* SDLCreateRenderer([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "index")] [NativeName(NativeNameType.Type, "int")] int index, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRenderer* ret = SDLCreateRendererNative((SDLWindow*)pwindow, index, flags);
				return ret;
			}
		}

		/// <summary>
		/// Create a 2D software rendering context for a surface.<br/>
		/// Two other API which can be used to create SDL_Renderer:<br/>
		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
		/// create a software renderer, but they are intended to be used with an<br/>
		/// SDL_Window as the final destination and not an SDL_Surface.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateSoftwareRenderer")]
		[return: NativeName(NativeNameType.Type, "SDL_Renderer*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateSoftwareRenderer")]
		internal static extern SDLRenderer* SDLCreateSoftwareRendererNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>		/// Create a 2D software rendering context for a surface.<br/>		/// Two other API which can be used to create SDL_Renderer:<br/>		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>		/// create a software renderer, but they are intended to be used with an<br/>		/// SDL_Window as the final destination and not an SDL_Surface.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateSoftwareRenderer")]
		[return: NativeName(NativeNameType.Type, "SDL_Renderer*")]
		public static SDLRenderer* SDLCreateSoftwareRenderer([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLRenderer* ret = SDLCreateSoftwareRendererNative(surface);
			return ret;
		}

		/// <summary>		/// Create a 2D software rendering context for a surface.<br/>		/// Two other API which can be used to create SDL_Renderer:<br/>		/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>		/// create a software renderer, but they are intended to be used with an<br/>		/// SDL_Window as the final destination and not an SDL_Surface.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateSoftwareRenderer")]
		[return: NativeName(NativeNameType.Type, "SDL_Renderer*")]
		public static SDLRenderer* SDLCreateSoftwareRenderer([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLRenderer* ret = SDLCreateSoftwareRendererNative((SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>
		/// Get the renderer associated with a window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderer")]
		[return: NativeName(NativeNameType.Type, "SDL_Renderer*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRenderer")]
		internal static extern SDLRenderer* SDLGetRendererNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Get the renderer associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderer")]
		[return: NativeName(NativeNameType.Type, "SDL_Renderer*")]
		public static SDLRenderer* SDLGetRenderer([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window)
		{
			SDLRenderer* ret = SDLGetRendererNative(window);
			return ret;
		}

		/// <summary>		/// Get the renderer associated with a window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderer")]
		[return: NativeName(NativeNameType.Type, "SDL_Renderer*")]
		public static SDLRenderer* SDLGetRenderer([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLRenderer* ret = SDLGetRendererNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Get the window associated with a renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetWindow")]
		internal static extern SDLWindow* SDLRenderGetWindowNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Get the window associated with a renderer.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLRenderGetWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLWindow* ret = SDLRenderGetWindowNative(renderer);
			return ret;
		}

		/// <summary>		/// Get the window associated with a renderer.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLRenderGetWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLWindow* ret = SDLRenderGetWindowNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get information about a rendering context.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRendererInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRendererInfo")]
		internal static extern int SDLGetRendererInfoNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_RendererInfo*")] SDLRendererInfo* info);

		/// <summary>		/// Get information about a rendering context.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_RendererInfo*")] SDLRendererInfo* info)
		{
			int ret = SDLGetRendererInfoNative(renderer, info);
			return ret;
		}

		/// <summary>		/// Get information about a rendering context.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_RendererInfo*")] SDLRendererInfo* info)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLGetRendererInfoNative((SDLRenderer*)prenderer, info);
				return ret;
			}
		}

		/// <summary>		/// Get information about a rendering context.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_RendererInfo*")] ref SDLRendererInfo info)
		{
			fixed (SDLRendererInfo* pinfo = &info)
			{
				int ret = SDLGetRendererInfoNative(renderer, (SDLRendererInfo*)pinfo);
				return ret;
			}
		}

		/// <summary>		/// Get information about a rendering context.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererInfo")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererInfo([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "info")] [NativeName(NativeNameType.Type, "SDL_RendererInfo*")] ref SDLRendererInfo info)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRendererInfo* pinfo = &info)
				{
					int ret = SDLGetRendererInfoNative((SDLRenderer*)prenderer, (SDLRendererInfo*)pinfo);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the output size in pixels of a rendering context.<br/>
		/// Due to high-dpi displays, you might end up with a rendering context that<br/>
		/// has more pixels than the window that contains it, so use this instead of<br/>
		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRendererOutputSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRendererOutputSize")]
		internal static extern int SDLGetRendererOutputSizeNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h);

		/// <summary>		/// Get the output size in pixels of a rendering context.<br/>		/// Due to high-dpi displays, you might end up with a rendering context that<br/>		/// has more pixels than the window that contains it, so use this instead of<br/>		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererOutputSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererOutputSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			int ret = SDLGetRendererOutputSizeNative(renderer, w, h);
			return ret;
		}

		/// <summary>		/// Get the output size in pixels of a rendering context.<br/>		/// Due to high-dpi displays, you might end up with a rendering context that<br/>		/// has more pixels than the window that contains it, so use this instead of<br/>		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererOutputSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererOutputSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLGetRendererOutputSizeNative((SDLRenderer*)prenderer, w, h);
				return ret;
			}
		}

		/// <summary>		/// Get the output size in pixels of a rendering context.<br/>		/// Due to high-dpi displays, you might end up with a rendering context that<br/>		/// has more pixels than the window that contains it, so use this instead of<br/>		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererOutputSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererOutputSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				int ret = SDLGetRendererOutputSizeNative(renderer, (int*)pw, h);
				return ret;
			}
		}

		/// <summary>		/// Get the output size in pixels of a rendering context.<br/>		/// Due to high-dpi displays, you might end up with a rendering context that<br/>		/// has more pixels than the window that contains it, so use this instead of<br/>		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererOutputSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererOutputSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					int ret = SDLGetRendererOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the output size in pixels of a rendering context.<br/>		/// Due to high-dpi displays, you might end up with a rendering context that<br/>		/// has more pixels than the window that contains it, so use this instead of<br/>		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererOutputSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererOutputSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				int ret = SDLGetRendererOutputSizeNative(renderer, w, (int*)ph);
				return ret;
			}
		}

		/// <summary>		/// Get the output size in pixels of a rendering context.<br/>		/// Due to high-dpi displays, you might end up with a rendering context that<br/>		/// has more pixels than the window that contains it, so use this instead of<br/>		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererOutputSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererOutputSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					int ret = SDLGetRendererOutputSizeNative((SDLRenderer*)prenderer, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the output size in pixels of a rendering context.<br/>		/// Due to high-dpi displays, you might end up with a rendering context that<br/>		/// has more pixels than the window that contains it, so use this instead of<br/>		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererOutputSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererOutputSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					int ret = SDLGetRendererOutputSizeNative(renderer, (int*)pw, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the output size in pixels of a rendering context.<br/>		/// Due to high-dpi displays, you might end up with a rendering context that<br/>		/// has more pixels than the window that contains it, so use this instead of<br/>		/// SDL_GetWindowSize() to decide how much drawing area you have.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRendererOutputSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRendererOutputSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = SDLGetRendererOutputSizeNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Create a texture for a rendering context.<br/>
		/// You can set the texture scaling method by setting<br/>
		/// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateTexture")]
		internal static extern SDLTexture* SDLCreateTextureNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int")] int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h);

		/// <summary>		/// Create a texture for a rendering context.<br/>		/// You can set the texture scaling method by setting<br/>		/// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLCreateTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int")] int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			SDLTexture* ret = SDLCreateTextureNative(renderer, format, access, w, h);
			return ret;
		}

		/// <summary>		/// Create a texture for a rendering context.<br/>		/// You can set the texture scaling method by setting<br/>		/// `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLCreateTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int")] int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = SDLCreateTextureNative((SDLRenderer*)prenderer, format, access, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Create a texture from an existing surface.<br/>
		/// The surface is not modified or freed by this function.<br/>
		/// The SDL_TextureAccess hint for the created texture is<br/>
		/// `SDL_TEXTUREACCESS_STATIC`.<br/>
		/// The pixel format of the created texture may be different from the pixel<br/>
		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>
		/// the texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateTextureFromSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateTextureFromSurface")]
		internal static extern SDLTexture* SDLCreateTextureFromSurfaceNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface);

		/// <summary>		/// Create a texture from an existing surface.<br/>		/// The surface is not modified or freed by this function.<br/>		/// The SDL_TextureAccess hint for the created texture is<br/>		/// `SDL_TEXTUREACCESS_STATIC`.<br/>		/// The pixel format of the created texture may be different from the pixel<br/>		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>		/// the texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateTextureFromSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLCreateTextureFromSurface([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			SDLTexture* ret = SDLCreateTextureFromSurfaceNative(renderer, surface);
			return ret;
		}

		/// <summary>		/// Create a texture from an existing surface.<br/>		/// The surface is not modified or freed by this function.<br/>		/// The SDL_TextureAccess hint for the created texture is<br/>		/// `SDL_TEXTUREACCESS_STATIC`.<br/>		/// The pixel format of the created texture may be different from the pixel<br/>		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>		/// the texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateTextureFromSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLCreateTextureFromSurface([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = SDLCreateTextureFromSurfaceNative((SDLRenderer*)prenderer, surface);
				return ret;
			}
		}

		/// <summary>		/// Create a texture from an existing surface.<br/>		/// The surface is not modified or freed by this function.<br/>		/// The SDL_TextureAccess hint for the created texture is<br/>		/// `SDL_TEXTUREACCESS_STATIC`.<br/>		/// The pixel format of the created texture may be different from the pixel<br/>		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>		/// the texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateTextureFromSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLCreateTextureFromSurface([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				SDLTexture* ret = SDLCreateTextureFromSurfaceNative(renderer, (SDLSurface*)psurface);
				return ret;
			}
		}

		/// <summary>		/// Create a texture from an existing surface.<br/>		/// The surface is not modified or freed by this function.<br/>		/// The SDL_TextureAccess hint for the created texture is<br/>		/// `SDL_TEXTUREACCESS_STATIC`.<br/>		/// The pixel format of the created texture may be different from the pixel<br/>		/// format of the surface. Use SDL_QueryTexture() to query the pixel format of<br/>		/// the texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateTextureFromSurface")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLCreateTextureFromSurface([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLSurface* psurface = &surface)
				{
					SDLTexture* ret = SDLCreateTextureFromSurfaceNative((SDLRenderer*)prenderer, (SDLSurface*)psurface);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query the attributes of a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_QueryTexture")]
		internal static extern int SDLQueryTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h);

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			int ret = SDLQueryTextureNative(texture, format, access, w, h);
			return ret;
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLQueryTextureNative((SDLTexture*)ptexture, format, access, w, h);
				return ret;
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (uint* pformat = &format)
			{
				int ret = SDLQueryTextureNative(texture, (uint*)pformat, access, w, h);
				return ret;
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					int ret = SDLQueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, w, h);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* paccess = &access)
			{
				int ret = SDLQueryTextureNative(texture, format, (int*)paccess, w, h);
				return ret;
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					int ret = SDLQueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, w, h);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					int ret = SDLQueryTextureNative(texture, (uint*)pformat, (int*)paccess, w, h);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						int ret = SDLQueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, w, h);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				int ret = SDLQueryTextureNative(texture, format, access, (int*)pw, h);
				return ret;
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pw = &w)
				{
					int ret = SDLQueryTextureNative((SDLTexture*)ptexture, format, access, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* pw = &w)
				{
					int ret = SDLQueryTextureNative(texture, (uint*)pformat, access, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* pw = &w)
					{
						int ret = SDLQueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* pw = &w)
				{
					int ret = SDLQueryTextureNative(texture, format, (int*)paccess, (int*)pw, h);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						int ret = SDLQueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						int ret = SDLQueryTextureNative(texture, (uint*)pformat, (int*)paccess, (int*)pw, h);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* pw = &w)
						{
							int ret = SDLQueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, (int*)pw, h);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				int ret = SDLQueryTextureNative(texture, format, access, w, (int*)ph);
				return ret;
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* ph = &h)
				{
					int ret = SDLQueryTextureNative((SDLTexture*)ptexture, format, access, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* ph = &h)
				{
					int ret = SDLQueryTextureNative(texture, (uint*)pformat, access, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* ph = &h)
					{
						int ret = SDLQueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* ph = &h)
				{
					int ret = SDLQueryTextureNative(texture, format, (int*)paccess, w, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* ph = &h)
					{
						int ret = SDLQueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* ph = &h)
					{
						int ret = SDLQueryTextureNative(texture, (uint*)pformat, (int*)paccess, w, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* ph = &h)
						{
							int ret = SDLQueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, w, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					int ret = SDLQueryTextureNative(texture, format, access, (int*)pw, (int*)ph);
					return ret;
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = SDLQueryTextureNative((SDLTexture*)ptexture, format, access, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = SDLQueryTextureNative(texture, (uint*)pformat, access, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] int* access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = SDLQueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, access, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* paccess = &access)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						int ret = SDLQueryTextureNative(texture, format, (int*)paccess, (int*)pw, (int*)ph);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] uint* format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = SDLQueryTextureNative((SDLTexture*)ptexture, format, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (uint* pformat = &format)
			{
				fixed (int* paccess = &access)
				{
					fixed (int* pw = &w)
					{
						fixed (int* ph = &h)
						{
							int ret = SDLQueryTextureNative(texture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Query the attributes of a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QueryTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLQueryTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32*")] ref uint format, [NativeName(NativeNameType.Param, "access")] [NativeName(NativeNameType.Type, "int*")] ref int access, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (uint* pformat = &format)
				{
					fixed (int* paccess = &access)
					{
						fixed (int* pw = &w)
						{
							fixed (int* ph = &h)
							{
								int ret = SDLQueryTextureNative((SDLTexture*)ptexture, (uint*)pformat, (int*)paccess, (int*)pw, (int*)ph);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional color value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation each source color<br/>
		/// channel is modulated by the appropriate color value according to the<br/>
		/// following formula:<br/>
		/// `srcC = srcC * (color / 255)`<br/>
		/// Color modulation is not always supported by the renderer; it will return -1<br/>
		/// if color modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetTextureColorMod")]
		internal static extern int SDLSetTextureColorModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b);

		/// <summary>		/// Set an additional color value multiplied into render copy operations.<br/>		/// When this texture is rendered, during the copy operation each source color<br/>		/// channel is modulated by the appropriate color value according to the<br/>		/// following formula:<br/>		/// `srcC = srcC * (color / 255)`<br/>		/// Color modulation is not always supported by the renderer; it will return -1<br/>		/// if color modulation is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			int ret = SDLSetTextureColorModNative(texture, r, g, b);
			return ret;
		}

		/// <summary>		/// Set an additional color value multiplied into render copy operations.<br/>		/// When this texture is rendered, during the copy operation each source color<br/>		/// channel is modulated by the appropriate color value according to the<br/>		/// following formula:<br/>		/// `srcC = srcC * (color / 255)`<br/>		/// Color modulation is not always supported by the renderer; it will return -1<br/>		/// if color modulation is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional color value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTextureColorMod")]
		internal static extern int SDLGetTextureColorModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b);

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			int ret = SDLGetTextureColorModNative(texture, r, g, b);
			return ret;
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, r, g, b);
				return ret;
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				int ret = SDLGetTextureColorModNative(texture, (byte*)pr, g, b);
				return ret;
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, b);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pg = &g)
			{
				int ret = SDLGetTextureColorModNative(texture, r, (byte*)pg, b);
				return ret;
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetTextureColorModNative(texture, (byte*)pr, (byte*)pg, b);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, b);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pb = &b)
			{
				int ret = SDLGetTextureColorModNative(texture, r, g, (byte*)pb);
				return ret;
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, r, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetTextureColorModNative(texture, (byte*)pr, g, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, g, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetTextureColorModNative(texture, r, (byte*)pg, (byte*)pb);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, r, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetTextureColorModNative(texture, (byte*)pr, (byte*)pg, (byte*)pb);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the additional color value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureColorMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureColorMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							int ret = SDLGetTextureColorModNative((SDLTexture*)ptexture, (byte*)pr, (byte*)pg, (byte*)pb);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Set an additional alpha value multiplied into render copy operations.<br/>
		/// When this texture is rendered, during the copy operation the source alpha<br/>
		/// value is modulated by this alpha value according to the following formula:<br/>
		/// `srcA = srcA * (alpha / 255)`<br/>
		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>
		/// if alpha modulation is not supported.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetTextureAlphaMod")]
		internal static extern int SDLSetTextureAlphaModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha);

		/// <summary>		/// Set an additional alpha value multiplied into render copy operations.<br/>		/// When this texture is rendered, during the copy operation the source alpha<br/>		/// value is modulated by this alpha value according to the following formula:<br/>		/// `srcA = srcA * (alpha / 255)`<br/>		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>		/// if alpha modulation is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			int ret = SDLSetTextureAlphaModNative(texture, alpha);
			return ret;
		}

		/// <summary>		/// Set an additional alpha value multiplied into render copy operations.<br/>		/// When this texture is rendered, during the copy operation the source alpha<br/>		/// value is modulated by this alpha value according to the following formula:<br/>		/// `srcA = srcA * (alpha / 255)`<br/>		/// Alpha modulation is not always supported by the renderer; it will return -1<br/>		/// if alpha modulation is not supported.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8")] byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>
		/// Get the additional alpha value multiplied into render copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTextureAlphaMod")]
		internal static extern int SDLGetTextureAlphaModNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha);

		/// <summary>		/// Get the additional alpha value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			int ret = SDLGetTextureAlphaModNative(texture, alpha);
			return ret;
		}

		/// <summary>		/// Get the additional alpha value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] byte* alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGetTextureAlphaModNative((SDLTexture*)ptexture, alpha);
				return ret;
			}
		}

		/// <summary>		/// Get the additional alpha value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte alpha)
		{
			fixed (byte* palpha = &alpha)
			{
				int ret = SDLGetTextureAlphaModNative(texture, (byte*)palpha);
				return ret;
			}
		}

		/// <summary>		/// Get the additional alpha value multiplied into render copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureAlphaMod")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureAlphaMod([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "alpha")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte alpha)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* palpha = &alpha)
				{
					int ret = SDLGetTextureAlphaModNative((SDLTexture*)ptexture, (byte*)palpha);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen<br/>
		/// and this function returns -1.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetTextureBlendMode")]
		internal static extern int SDLSetTextureBlendModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode);

		/// <summary>		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>		/// If the blend mode is not supported, the closest supported mode is chosen<br/>		/// and this function returns -1.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			int ret = SDLSetTextureBlendModeNative(texture, blendMode);
			return ret;
		}

		/// <summary>		/// Set the blend mode for a texture, used by SDL_RenderCopy().<br/>		/// If the blend mode is not supported, the closest supported mode is chosen<br/>		/// and this function returns -1.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for texture copy operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTextureBlendMode")]
		internal static extern int SDLGetTextureBlendModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode);

		/// <summary>		/// Get the blend mode used for texture copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			int ret = SDLGetTextureBlendModeNative(texture, blendMode);
			return ret;
		}

		/// <summary>		/// Get the blend mode used for texture copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGetTextureBlendModeNative((SDLTexture*)ptexture, blendMode);
				return ret;
			}
		}

		/// <summary>		/// Get the blend mode used for texture copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				int ret = SDLGetTextureBlendModeNative(texture, (SDLBlendMode*)pblendMode);
				return ret;
			}
		}

		/// <summary>		/// Get the blend mode used for texture copy operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureBlendMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					int ret = SDLGetTextureBlendModeNative((SDLTexture*)ptexture, (SDLBlendMode*)pblendMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set the scale mode used for texture scale operations.<br/>
		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetTextureScaleMode")]
		internal static extern int SDLSetTextureScaleModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode);

		/// <summary>		/// Set the scale mode used for texture scale operations.<br/>		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			int ret = SDLSetTextureScaleModeNative(texture, scaleMode);
			return ret;
		}

		/// <summary>		/// Set the scale mode used for texture scale operations.<br/>		/// If the scale mode is not supported, the closest supported mode is chosen.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode")] SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the scale mode used for texture scale operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTextureScaleMode")]
		internal static extern int SDLGetTextureScaleModeNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] SDLScaleMode* scaleMode);

		/// <summary>		/// Get the scale mode used for texture scale operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] SDLScaleMode* scaleMode)
		{
			int ret = SDLGetTextureScaleModeNative(texture, scaleMode);
			return ret;
		}

		/// <summary>		/// Get the scale mode used for texture scale operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] SDLScaleMode* scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGetTextureScaleModeNative((SDLTexture*)ptexture, scaleMode);
				return ret;
			}
		}

		/// <summary>		/// Get the scale mode used for texture scale operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] ref SDLScaleMode scaleMode)
		{
			fixed (SDLScaleMode* pscaleMode = &scaleMode)
			{
				int ret = SDLGetTextureScaleModeNative(texture, (SDLScaleMode*)pscaleMode);
				return ret;
			}
		}

		/// <summary>		/// Get the scale mode used for texture scale operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureScaleMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetTextureScaleMode([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "scaleMode")] [NativeName(NativeNameType.Type, "SDL_ScaleMode*")] ref SDLScaleMode scaleMode)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLScaleMode* pscaleMode = &scaleMode)
				{
					int ret = SDLGetTextureScaleModeNative((SDLTexture*)ptexture, (SDLScaleMode*)pscaleMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Associate a user-specified pointer with a texture.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetTextureUserData")]
		internal static extern int SDLSetTextureUserDataNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Associate a user-specified pointer with a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			int ret = SDLSetTextureUserDataNative(texture, userdata);
			return ret;
		}

		/// <summary>		/// Associate a user-specified pointer with a texture.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetTextureUserDataNative((SDLTexture*)ptexture, userdata);
				return ret;
			}
		}

		/// <summary>
		/// Get the user-specified pointer associated with a texture<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTextureUserData")]
		internal static extern void* SDLGetTextureUserDataNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture);

		/// <summary>		/// Get the user-specified pointer associated with a texture<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			void* ret = SDLGetTextureUserDataNative(texture);
			return ret;
		}

		/// <summary>		/// Get the user-specified pointer associated with a texture<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTextureUserData")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLGetTextureUserData([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				void* ret = SDLGetTextureUserDataNative((SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Update the given texture rectangle with new pixel data.<br/>
		/// The pixel data must be in the pixel format of the texture. Use<br/>
		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>
		/// This is a fairly slow function, intended for use with static textures that<br/>
		/// do not change often.<br/>
		/// If the texture is intended to be updated often, it is preferred to create<br/>
		/// the texture as streaming and use the locking functions referenced below.<br/>
		/// While this function will work with streaming textures, for optimization<br/>
		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UpdateTexture")]
		internal static extern int SDLUpdateTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch);

		/// <summary>		/// Update the given texture rectangle with new pixel data.<br/>		/// The pixel data must be in the pixel format of the texture. Use<br/>		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>		/// This is a fairly slow function, intended for use with static textures that<br/>		/// do not change often.<br/>		/// If the texture is intended to be updated often, it is preferred to create<br/>		/// the texture as streaming and use the locking functions referenced below.<br/>		/// While this function will work with streaming textures, for optimization<br/>		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			int ret = SDLUpdateTextureNative(texture, rect, pixels, pitch);
			return ret;
		}

		/// <summary>		/// Update the given texture rectangle with new pixel data.<br/>		/// The pixel data must be in the pixel format of the texture. Use<br/>		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>		/// This is a fairly slow function, intended for use with static textures that<br/>		/// do not change often.<br/>		/// If the texture is intended to be updated often, it is preferred to create<br/>		/// the texture as streaming and use the locking functions referenced below.<br/>		/// While this function will work with streaming textures, for optimization<br/>		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLUpdateTextureNative((SDLTexture*)ptexture, rect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>		/// Update the given texture rectangle with new pixel data.<br/>		/// The pixel data must be in the pixel format of the texture. Use<br/>		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>		/// This is a fairly slow function, intended for use with static textures that<br/>		/// do not change often.<br/>		/// If the texture is intended to be updated often, it is preferred to create<br/>		/// the texture as streaming and use the locking functions referenced below.<br/>		/// While this function will work with streaming textures, for optimization<br/>		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLUpdateTextureNative(texture, (SDLRect*)prect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>		/// Update the given texture rectangle with new pixel data.<br/>		/// The pixel data must be in the pixel format of the texture. Use<br/>		/// SDL_QueryTexture() to query the pixel format of the texture.<br/>		/// This is a fairly slow function, intended for use with static textures that<br/>		/// do not change often.<br/>		/// If the texture is intended to be updated often, it is preferred to create<br/>		/// the texture as streaming and use the locking functions referenced below.<br/>		/// While this function will work with streaming textures, for optimization<br/>		/// reasons you may not get the pixels back if you lock the texture afterward.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "const void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLUpdateTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
		/// data.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of Y and U/V planes in the proper order, but this function is<br/>
		/// available if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UpdateYUVTexture")]
		internal static extern int SDLUpdateYUVTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch);

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			int ret = SDLUpdateYUVTextureNative(texture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
			return ret;
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				int ret = SDLUpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* puplane = &uplane)
			{
				int ret = SDLUpdateYUVTextureNative(texture, rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
				return ret;
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puplane = &uplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puplane = &uplane)
						{
							int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, vplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pvplane = &vplane)
			{
				int ret = SDLUpdateYUVTextureNative(texture, rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
				return ret;
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* puplane = &uplane)
			{
				fixed (byte* pvplane = &vplane)
				{
					int ret = SDLUpdateYUVTextureNative(texture, rect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puplane = &uplane)
				{
					fixed (byte* pvplane = &vplane)
					{
						int ret = SDLUpdateYUVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puplane = &uplane)
					{
						fixed (byte* pvplane = &vplane)
						{
							int ret = SDLUpdateYUVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>		/// data.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of Y and U/V planes in the proper order, but this function is<br/>		/// available if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateYUVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateYUVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "Uplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uplane, [NativeName(NativeNameType.Param, "Upitch")] [NativeName(NativeNameType.Type, "int")] int upitch, [NativeName(NativeNameType.Param, "Vplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte vplane, [NativeName(NativeNameType.Param, "Vpitch")] [NativeName(NativeNameType.Type, "int")] int vpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puplane = &uplane)
						{
							fixed (byte* pvplane = &vplane)
							{
								int ret = SDLUpdateYUVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puplane, upitch, (byte*)pvplane, vpitch);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
		/// block of NV12/21 planes in the proper order, but this function is available<br/>
		/// if your pixel data is not contiguous.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UpdateNVTexture")]
		internal static extern int SDLUpdateNVTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch);

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			int ret = SDLUpdateNVTextureNative(texture, rect, yplane, ypitch, uVplane, uVpitch);
			return ret;
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, uVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLUpdateNVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, uVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, uVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				int ret = SDLUpdateNVTextureNative(texture, rect, (byte*)pyplane, ypitch, uVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, uVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					int ret = SDLUpdateNVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, uVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, uVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (byte* puVplane = &uVplane)
			{
				int ret = SDLUpdateNVTextureNative(texture, rect, yplane, ypitch, (byte*)puVplane, uVpitch);
				return ret;
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* puVplane = &uVplane)
				{
					int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, rect, yplane, ypitch, (byte*)puVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* puVplane = &uVplane)
				{
					int ret = SDLUpdateNVTextureNative(texture, (SDLRect*)prect, yplane, ypitch, (byte*)puVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] byte* yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* puVplane = &uVplane)
					{
						int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, yplane, ypitch, (byte*)puVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (byte* pyplane = &yplane)
			{
				fixed (byte* puVplane = &uVplane)
				{
					int ret = SDLUpdateNVTextureNative(texture, rect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puVplane = &uVplane)
					{
						int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, rect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (byte* pyplane = &yplane)
				{
					fixed (byte* puVplane = &uVplane)
					{
						int ret = SDLUpdateNVTextureNative(texture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>		/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>		/// block of NV12/21 planes in the proper order, but this function is available<br/>		/// if your pixel data is not contiguous.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UpdateNVTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLUpdateNVTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "Yplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte yplane, [NativeName(NativeNameType.Param, "Ypitch")] [NativeName(NativeNameType.Type, "int")] int ypitch, [NativeName(NativeNameType.Param, "UVplane")] [NativeName(NativeNameType.Type, "const Uint8*")] ref byte uVplane, [NativeName(NativeNameType.Param, "UVpitch")] [NativeName(NativeNameType.Type, "int")] int uVpitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (byte* pyplane = &yplane)
					{
						fixed (byte* puVplane = &uVplane)
						{
							int ret = SDLUpdateNVTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, (byte*)pyplane, ypitch, (byte*)puVplane, uVpitch);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LockTexture")]
		internal static extern int SDLLockTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch);

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			int ret = SDLLockTextureNative(texture, rect, pixels, pitch);
			return ret;
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLLockTextureNative((SDLTexture*)ptexture, rect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLLockTextureNative(texture, (SDLRect*)prect, pixels, pitch);
				return ret;
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] int* pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLLockTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (int* ppitch = &pitch)
			{
				int ret = SDLLockTextureNative(texture, rect, pixels, (int*)ppitch);
				return ret;
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* ppitch = &pitch)
				{
					int ret = SDLLockTextureNative((SDLTexture*)ptexture, rect, pixels, (int*)ppitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (int* ppitch = &pitch)
				{
					int ret = SDLLockTextureNative(texture, (SDLRect*)prect, pixels, (int*)ppitch);
					return ret;
				}
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void**")] void** pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int*")] ref int pitch)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (int* ppitch = &pitch)
					{
						int ret = SDLLockTextureNative((SDLTexture*)ptexture, (SDLRect*)prect, pixels, (int*)ppitch);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
		/// it as a SDL surface.<br/>
		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
		/// operates like SDL_LockTexture.<br/>
		/// As an optimization, the pixels made available for editing don't necessarily<br/>
		/// contain the old texture data. This is a write-only operation, and if you<br/>
		/// need to keep a copy of the texture data you should do that at the<br/>
		/// application level.<br/>
		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
		/// changes.<br/>
		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
		/// or SDL_DestroyTexture(). The caller should not free it.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_LockTextureToSurface")]
		internal static extern int SDLLockTextureToSurfaceNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface);

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>		/// it as a SDL surface.<br/>		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>		/// operates like SDL_LockTexture.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>		/// or SDL_DestroyTexture(). The caller should not free it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			int ret = SDLLockTextureToSurfaceNative(texture, rect, surface);
			return ret;
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>		/// it as a SDL surface.<br/>		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>		/// operates like SDL_LockTexture.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>		/// or SDL_DestroyTexture(). The caller should not free it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLLockTextureToSurfaceNative((SDLTexture*)ptexture, rect, surface);
				return ret;
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>		/// it as a SDL surface.<br/>		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>		/// operates like SDL_LockTexture.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>		/// or SDL_DestroyTexture(). The caller should not free it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLLockTextureToSurfaceNative(texture, (SDLRect*)prect, surface);
				return ret;
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>		/// it as a SDL surface.<br/>		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>		/// operates like SDL_LockTexture.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>		/// or SDL_DestroyTexture(). The caller should not free it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] SDLSurface** surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLLockTextureToSurfaceNative((SDLTexture*)ptexture, (SDLRect*)prect, surface);
					return ret;
				}
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>		/// it as a SDL surface.<br/>		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>		/// operates like SDL_LockTexture.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>		/// or SDL_DestroyTexture(). The caller should not free it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLSurface** psurface = &surface)
			{
				int ret = SDLLockTextureToSurfaceNative(texture, rect, (SDLSurface**)psurface);
				return ret;
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>		/// it as a SDL surface.<br/>		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>		/// operates like SDL_LockTexture.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>		/// or SDL_DestroyTexture(). The caller should not free it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLSurface** psurface = &surface)
				{
					int ret = SDLLockTextureToSurfaceNative((SDLTexture*)ptexture, rect, (SDLSurface**)psurface);
					return ret;
				}
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>		/// it as a SDL surface.<br/>		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>		/// operates like SDL_LockTexture.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>		/// or SDL_DestroyTexture(). The caller should not free it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLRect* prect = &rect)
			{
				fixed (SDLSurface** psurface = &surface)
				{
					int ret = SDLLockTextureToSurfaceNative(texture, (SDLRect*)prect, (SDLSurface**)psurface);
					return ret;
				}
			}
		}

		/// <summary>		/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>		/// it as a SDL surface.<br/>		/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>		/// operates like SDL_LockTexture.<br/>		/// As an optimization, the pixels made available for editing don't necessarily<br/>		/// contain the old texture data. This is a write-only operation, and if you<br/>		/// need to keep a copy of the texture data you should do that at the<br/>		/// application level.<br/>		/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>		/// changes.<br/>		/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>		/// or SDL_DestroyTexture(). The caller should not free it.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_LockTextureToSurface")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLLockTextureToSurface([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface**")] ref SDLSurface* surface)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* prect = &rect)
				{
					fixed (SDLSurface** psurface = &surface)
					{
						int ret = SDLLockTextureToSurfaceNative((SDLTexture*)ptexture, (SDLRect*)prect, (SDLSurface**)psurface);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
		/// write-only; it will not guarantee the previous contents of the texture will<br/>
		/// be provided. You must fully initialize any area of a texture that you lock<br/>
		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
		/// Which is to say: locking and immediately unlocking a texture can result in<br/>
		/// corrupted textures, depending on the renderer in use.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_UnlockTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_UnlockTexture")]
		internal static extern void SDLUnlockTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture);

		/// <summary>		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>		/// write-only; it will not guarantee the previous contents of the texture will<br/>		/// be provided. You must fully initialize any area of a texture that you lock<br/>		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>		/// Which is to say: locking and immediately unlocking a texture can result in<br/>		/// corrupted textures, depending on the renderer in use.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			SDLUnlockTextureNative(texture);
		}

		/// <summary>		/// Unlock a texture, uploading the changes to video memory, if needed.<br/>		/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>		/// write-only; it will not guarantee the previous contents of the texture will<br/>		/// be provided. You must fully initialize any area of a texture that you lock<br/>		/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>		/// Which is to say: locking and immediately unlocking a texture can result in<br/>		/// corrupted textures, depending on the renderer in use.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_UnlockTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLUnlockTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				SDLUnlockTextureNative((SDLTexture*)ptexture);
			}
		}

		/// <summary>
		/// Determine whether a renderer supports the use of render targets.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderTargetSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderTargetSupported")]
		internal static extern SDLBool SDLRenderTargetSupportedNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Determine whether a renderer supports the use of render targets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderTargetSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderTargetSupported([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLBool ret = SDLRenderTargetSupportedNative(renderer);
			return ret;
		}

		/// <summary>		/// Determine whether a renderer supports the use of render targets.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderTargetSupported")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderTargetSupported([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLBool ret = SDLRenderTargetSupportedNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set a texture as the current rendering target.<br/>
		/// Before using this function, you should check the<br/>
		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>
		/// render targets are supported.<br/>
		/// The default render target is the window for which the renderer was created.<br/>
		/// To stop rendering to a texture and render to the window again, call this<br/>
		/// function with a NULL `texture`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetRenderTarget")]
		internal static extern int SDLSetRenderTargetNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture);

		/// <summary>		/// Set a texture as the current rendering target.<br/>		/// Before using this function, you should check the<br/>		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>		/// render targets are supported.<br/>		/// The default render target is the window for which the renderer was created.<br/>		/// To stop rendering to a texture and render to the window again, call this<br/>		/// function with a NULL `texture`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			int ret = SDLSetRenderTargetNative(renderer, texture);
			return ret;
		}

		/// <summary>		/// Set a texture as the current rendering target.<br/>		/// Before using this function, you should check the<br/>		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>		/// render targets are supported.<br/>		/// The default render target is the window for which the renderer was created.<br/>		/// To stop rendering to a texture and render to the window again, call this<br/>		/// function with a NULL `texture`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLSetRenderTargetNative((SDLRenderer*)prenderer, texture);
				return ret;
			}
		}

		/// <summary>		/// Set a texture as the current rendering target.<br/>		/// Before using this function, you should check the<br/>		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>		/// render targets are supported.<br/>		/// The default render target is the window for which the renderer was created.<br/>		/// To stop rendering to a texture and render to the window again, call this<br/>		/// function with a NULL `texture`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLSetRenderTargetNative(renderer, (SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>		/// Set a texture as the current rendering target.<br/>		/// Before using this function, you should check the<br/>		/// `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if<br/>		/// render targets are supported.<br/>		/// The default render target is the window for which the renderer was created.<br/>		/// To stop rendering to a texture and render to the window again, call this<br/>		/// function with a NULL `texture`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = SDLSetRenderTargetNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the current render target.<br/>
		/// The default render target is the window for which the renderer was created,<br/>
		/// and is reported a NULL here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRenderTarget")]
		internal static extern SDLTexture* SDLGetRenderTargetNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Get the current render target.<br/>		/// The default render target is the window for which the renderer was created,<br/>		/// and is reported a NULL here.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLGetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLTexture* ret = SDLGetRenderTargetNative(renderer);
			return ret;
		}

		/// <summary>		/// Get the current render target.<br/>		/// The default render target is the window for which the renderer was created,<br/>		/// and is reported a NULL here.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderTarget")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* SDLGetRenderTarget([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = SDLGetRenderTargetNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set a device independent resolution for rendering.<br/>
		/// This function uses the viewport and scaling functionality to allow a fixed<br/>
		/// logical resolution for rendering, regardless of the actual output<br/>
		/// resolution. If the actual output resolution doesn't have the same aspect<br/>
		/// ratio the output rendering will be centered within the output display.<br/>
		/// If the output display is a window, mouse and touch events in the window<br/>
		/// will be filtered and scaled so they seem to arrive within the logical<br/>
		/// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether<br/>
		/// relative motion events are also scaled.<br/>
		/// If this function results in scaling or subpixel drawing by the rendering<br/>
		/// backend, it will be handled using the appropriate quality hints.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderSetLogicalSize")]
		internal static extern int SDLRenderSetLogicalSizeNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h);

		/// <summary>		/// Set a device independent resolution for rendering.<br/>		/// This function uses the viewport and scaling functionality to allow a fixed<br/>		/// logical resolution for rendering, regardless of the actual output<br/>		/// resolution. If the actual output resolution doesn't have the same aspect<br/>		/// ratio the output rendering will be centered within the output display.<br/>		/// If the output display is a window, mouse and touch events in the window<br/>		/// will be filtered and scaled so they seem to arrive within the logical<br/>		/// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether<br/>		/// relative motion events are also scaled.<br/>		/// If this function results in scaling or subpixel drawing by the rendering<br/>		/// backend, it will be handled using the appropriate quality hints.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			int ret = SDLRenderSetLogicalSizeNative(renderer, w, h);
			return ret;
		}

		/// <summary>		/// Set a device independent resolution for rendering.<br/>		/// This function uses the viewport and scaling functionality to allow a fixed<br/>		/// logical resolution for rendering, regardless of the actual output<br/>		/// resolution. If the actual output resolution doesn't have the same aspect<br/>		/// ratio the output rendering will be centered within the output display.<br/>		/// If the output display is a window, mouse and touch events in the window<br/>		/// will be filtered and scaled so they seem to arrive within the logical<br/>		/// resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether<br/>		/// relative motion events are also scaled.<br/>		/// If this function results in scaling or subpixel drawing by the rendering<br/>		/// backend, it will be handled using the appropriate quality hints.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int")] int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int")] int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetLogicalSizeNative((SDLRenderer*)prenderer, w, h);
				return ret;
			}
		}

		/// <summary>
		/// Get device independent resolution for rendering.<br/>
		/// When using the main rendering target (eg no target texture is set): this<br/>
		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>
		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>
		/// width and height.<br/>
		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>
		/// it returns the logical width and height that are set.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetLogicalSize")]
		internal static extern void SDLRenderGetLogicalSizeNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h);

		/// <summary>		/// Get device independent resolution for rendering.<br/>		/// When using the main rendering target (eg no target texture is set): this<br/>		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>		/// width and height.<br/>		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>		/// it returns the logical width and height that are set.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			SDLRenderGetLogicalSizeNative(renderer, w, h);
		}

		/// <summary>		/// Get device independent resolution for rendering.<br/>		/// When using the main rendering target (eg no target texture is set): this<br/>		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>		/// width and height.<br/>		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>		/// it returns the logical width and height that are set.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderGetLogicalSizeNative((SDLRenderer*)prenderer, w, h);
			}
		}

		/// <summary>		/// Get device independent resolution for rendering.<br/>		/// When using the main rendering target (eg no target texture is set): this<br/>		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>		/// width and height.<br/>		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>		/// it returns the logical width and height that are set.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (int* pw = &w)
			{
				SDLRenderGetLogicalSizeNative(renderer, (int*)pw, h);
			}
		}

		/// <summary>		/// Get device independent resolution for rendering.<br/>		/// When using the main rendering target (eg no target texture is set): this<br/>		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>		/// width and height.<br/>		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>		/// it returns the logical width and height that are set.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] int* h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					SDLRenderGetLogicalSizeNative((SDLRenderer*)prenderer, (int*)pw, h);
				}
			}
		}

		/// <summary>		/// Get device independent resolution for rendering.<br/>		/// When using the main rendering target (eg no target texture is set): this<br/>		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>		/// width and height.<br/>		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>		/// it returns the logical width and height that are set.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* ph = &h)
			{
				SDLRenderGetLogicalSizeNative(renderer, w, (int*)ph);
			}
		}

		/// <summary>		/// Get device independent resolution for rendering.<br/>		/// When using the main rendering target (eg no target texture is set): this<br/>		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>		/// width and height.<br/>		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>		/// it returns the logical width and height that are set.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] int* w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* ph = &h)
				{
					SDLRenderGetLogicalSizeNative((SDLRenderer*)prenderer, w, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get device independent resolution for rendering.<br/>		/// When using the main rendering target (eg no target texture is set): this<br/>		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>		/// width and height.<br/>		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>		/// it returns the logical width and height that are set.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (int* pw = &w)
			{
				fixed (int* ph = &h)
				{
					SDLRenderGetLogicalSizeNative(renderer, (int*)pw, (int*)ph);
				}
			}
		}

		/// <summary>		/// Get device independent resolution for rendering.<br/>		/// When using the main rendering target (eg no target texture is set): this<br/>		/// may return 0 for `w` and `h` if the SDL_Renderer has never had its logical<br/>		/// size set by SDL_RenderSetLogicalSize(). Otherwise it returns the logical<br/>		/// width and height.<br/>		/// When using a target texture: Never return 0 for `w` and `h` at first. Then<br/>		/// it returns the logical width and height that are set.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetLogicalSize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetLogicalSize([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "int*")] ref int w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "int*")] ref int h)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pw = &w)
				{
					fixed (int* ph = &h)
					{
						SDLRenderGetLogicalSizeNative((SDLRenderer*)prenderer, (int*)pw, (int*)ph);
					}
				}
			}
		}

		/// <summary>
		/// Set whether to force integer scales for resolution-independent rendering.<br/>
		/// This function restricts the logical viewport to integer values - that is,<br/>
		/// when a resolution is between two multiples of a logical size, the viewport<br/>
		/// size is rounded down to the lower multiple.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderSetIntegerScale")]
		internal static extern int SDLRenderSetIntegerScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "enable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enable);

		/// <summary>		/// Set whether to force integer scales for resolution-independent rendering.<br/>		/// This function restricts the logical viewport to integer values - that is,<br/>		/// when a resolution is between two multiples of a logical size, the viewport<br/>		/// size is rounded down to the lower multiple.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "enable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enable)
		{
			int ret = SDLRenderSetIntegerScaleNative(renderer, enable);
			return ret;
		}

		/// <summary>		/// Set whether to force integer scales for resolution-independent rendering.<br/>		/// This function restricts the logical viewport to integer values - that is,<br/>		/// when a resolution is between two multiples of a logical size, the viewport<br/>		/// size is rounded down to the lower multiple.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "enable")] [NativeName(NativeNameType.Type, "SDL_bool")] SDLBool enable)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetIntegerScaleNative((SDLRenderer*)prenderer, enable);
				return ret;
			}
		}

		/// <summary>
		/// Get whether integer scales are forced for resolution-independent rendering.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetIntegerScale")]
		internal static extern SDLBool SDLRenderGetIntegerScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Get whether integer scales are forced for resolution-independent rendering.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderGetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLBool ret = SDLRenderGetIntegerScaleNative(renderer);
			return ret;
		}

		/// <summary>		/// Get whether integer scales are forced for resolution-independent rendering.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetIntegerScale")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderGetIntegerScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLBool ret = SDLRenderGetIntegerScaleNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing area for rendering on the current target.<br/>
		/// When the window is resized, the viewport is reset to fill the entire new<br/>
		/// window size.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderSetViewport")]
		internal static extern int SDLRenderSetViewportNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Set the drawing area for rendering on the current target.<br/>		/// When the window is resized, the viewport is reset to fill the entire new<br/>		/// window size.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLRenderSetViewportNative(renderer, rect);
			return ret;
		}

		/// <summary>		/// Set the drawing area for rendering on the current target.<br/>		/// When the window is resized, the viewport is reset to fill the entire new<br/>		/// window size.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetViewportNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>		/// Set the drawing area for rendering on the current target.<br/>		/// When the window is resized, the viewport is reset to fill the entire new<br/>		/// window size.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLRenderSetViewportNative(renderer, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>		/// Set the drawing area for rendering on the current target.<br/>		/// When the window is resized, the viewport is reset to fill the entire new<br/>		/// window size.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetViewport")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLRenderSetViewportNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the drawing area for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetViewport")]
		internal static extern void SDLRenderGetViewportNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Get the drawing area for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			SDLRenderGetViewportNative(renderer, rect);
		}

		/// <summary>		/// Get the drawing area for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderGetViewportNative((SDLRenderer*)prenderer, rect);
			}
		}

		/// <summary>		/// Get the drawing area for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLRenderGetViewportNative(renderer, (SDLRect*)prect);
			}
		}

		/// <summary>		/// Get the drawing area for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetViewport")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetViewport([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					SDLRenderGetViewportNative((SDLRenderer*)prenderer, (SDLRect*)prect);
				}
			}
		}

		/// <summary>
		/// Set the clip rectangle for rendering on the specified target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderSetClipRect")]
		internal static extern int SDLRenderSetClipRectNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Set the clip rectangle for rendering on the specified target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLRenderSetClipRectNative(renderer, rect);
			return ret;
		}

		/// <summary>		/// Set the clip rectangle for rendering on the specified target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetClipRectNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>		/// Set the clip rectangle for rendering on the specified target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLRenderSetClipRectNative(renderer, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>		/// Set the clip rectangle for rendering on the specified target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetClipRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLRenderSetClipRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Get the clip rectangle for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetClipRect")]
		internal static extern void SDLRenderGetClipRectNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Get the clip rectangle for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			SDLRenderGetClipRectNative(renderer, rect);
		}

		/// <summary>		/// Get the clip rectangle for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderGetClipRectNative((SDLRenderer*)prenderer, rect);
			}
		}

		/// <summary>		/// Get the clip rectangle for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				SDLRenderGetClipRectNative(renderer, (SDLRect*)prect);
			}
		}

		/// <summary>		/// Get the clip rectangle for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetClipRect")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetClipRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					SDLRenderGetClipRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
				}
			}
		}

		/// <summary>
		/// Get whether clipping is enabled on the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderIsClipEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderIsClipEnabled")]
		internal static extern SDLBool SDLRenderIsClipEnabledNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Get whether clipping is enabled on the given renderer.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderIsClipEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderIsClipEnabled([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLBool ret = SDLRenderIsClipEnabledNative(renderer);
			return ret;
		}

		/// <summary>		/// Get whether clipping is enabled on the given renderer.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderIsClipEnabled")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRenderIsClipEnabled([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLBool ret = SDLRenderIsClipEnabledNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Set the drawing scale for rendering on the current target.<br/>
		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
		/// are used by the renderer. This allows resolution independent drawing with a<br/>
		/// single coordinate system.<br/>
		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
		/// will be handled using the appropriate quality hints. For best results use<br/>
		/// integer scaling factors.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderSetScale")]
		internal static extern int SDLRenderSetScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY);

		/// <summary>		/// Set the drawing scale for rendering on the current target.<br/>		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>		/// are used by the renderer. This allows resolution independent drawing with a<br/>		/// single coordinate system.<br/>		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>		/// will be handled using the appropriate quality hints. For best results use<br/>		/// integer scaling factors.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			int ret = SDLRenderSetScaleNative(renderer, scaleX, scaleY);
			return ret;
		}

		/// <summary>		/// Set the drawing scale for rendering on the current target.<br/>		/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>		/// are used by the renderer. This allows resolution independent drawing with a<br/>		/// single coordinate system.<br/>		/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>		/// will be handled using the appropriate quality hints. For best results use<br/>		/// integer scaling factors.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetScale")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float")] float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float")] float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetScaleNative((SDLRenderer*)prenderer, scaleX, scaleY);
				return ret;
			}
		}

		/// <summary>
		/// Get the drawing scale for the current target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetScale")]
		internal static extern void SDLRenderGetScaleNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY);

		/// <summary>		/// Get the drawing scale for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			SDLRenderGetScaleNative(renderer, scaleX, scaleY);
		}

		/// <summary>		/// Get the drawing scale for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderGetScaleNative((SDLRenderer*)prenderer, scaleX, scaleY);
			}
		}

		/// <summary>		/// Get the drawing scale for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			fixed (float* pscaleX = &scaleX)
			{
				SDLRenderGetScaleNative(renderer, (float*)pscaleX, scaleY);
			}
		}

		/// <summary>		/// Get the drawing scale for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] float* scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleX = &scaleX)
				{
					SDLRenderGetScaleNative((SDLRenderer*)prenderer, (float*)pscaleX, scaleY);
				}
			}
		}

		/// <summary>		/// Get the drawing scale for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (float* pscaleY = &scaleY)
			{
				SDLRenderGetScaleNative(renderer, scaleX, (float*)pscaleY);
			}
		}

		/// <summary>		/// Get the drawing scale for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] float* scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleY = &scaleY)
				{
					SDLRenderGetScaleNative((SDLRenderer*)prenderer, scaleX, (float*)pscaleY);
				}
			}
		}

		/// <summary>		/// Get the drawing scale for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (float* pscaleX = &scaleX)
			{
				fixed (float* pscaleY = &scaleY)
				{
					SDLRenderGetScaleNative(renderer, (float*)pscaleX, (float*)pscaleY);
				}
			}
		}

		/// <summary>		/// Get the drawing scale for the current target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderGetScale([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "scaleX")] [NativeName(NativeNameType.Type, "float*")] ref float scaleX, [NativeName(NativeNameType.Param, "scaleY")] [NativeName(NativeNameType.Type, "float*")] ref float scaleY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pscaleX = &scaleX)
				{
					fixed (float* pscaleY = &scaleY)
					{
						SDLRenderGetScaleNative((SDLRenderer*)prenderer, (float*)pscaleX, (float*)pscaleY);
					}
				}
			}
		}

		/// <summary>
		/// Get logical coordinates of point in renderer when given real coordinates of<br/>
		/// point in window.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderWindowToLogical")]
		internal static extern void SDLRenderWindowToLogicalNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY);

		/// <summary>		/// Get logical coordinates of point in renderer when given real coordinates of<br/>		/// point in window.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			SDLRenderWindowToLogicalNative(renderer, windowX, windowY, logicalX, logicalY);
		}

		/// <summary>		/// Get logical coordinates of point in renderer when given real coordinates of<br/>		/// point in window.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, logicalX, logicalY);
			}
		}

		/// <summary>		/// Get logical coordinates of point in renderer when given real coordinates of<br/>		/// point in window.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			fixed (float* plogicalX = &logicalX)
			{
				SDLRenderWindowToLogicalNative(renderer, windowX, windowY, (float*)plogicalX, logicalY);
			}
		}

		/// <summary>		/// Get logical coordinates of point in renderer when given real coordinates of<br/>		/// point in window.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] float* logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* plogicalX = &logicalX)
				{
					SDLRenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, (float*)plogicalX, logicalY);
				}
			}
		}

		/// <summary>		/// Get logical coordinates of point in renderer when given real coordinates of<br/>		/// point in window.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (float* plogicalY = &logicalY)
			{
				SDLRenderWindowToLogicalNative(renderer, windowX, windowY, logicalX, (float*)plogicalY);
			}
		}

		/// <summary>		/// Get logical coordinates of point in renderer when given real coordinates of<br/>		/// point in window.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] float* logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* plogicalY = &logicalY)
				{
					SDLRenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, logicalX, (float*)plogicalY);
				}
			}
		}

		/// <summary>		/// Get logical coordinates of point in renderer when given real coordinates of<br/>		/// point in window.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (float* plogicalX = &logicalX)
			{
				fixed (float* plogicalY = &logicalY)
				{
					SDLRenderWindowToLogicalNative(renderer, windowX, windowY, (float*)plogicalX, (float*)plogicalY);
				}
			}
		}

		/// <summary>		/// Get logical coordinates of point in renderer when given real coordinates of<br/>		/// point in window.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderWindowToLogical")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderWindowToLogical([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int")] int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int")] int windowY, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float*")] ref float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float*")] ref float logicalY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* plogicalX = &logicalX)
				{
					fixed (float* plogicalY = &logicalY)
					{
						SDLRenderWindowToLogicalNative((SDLRenderer*)prenderer, windowX, windowY, (float*)plogicalX, (float*)plogicalY);
					}
				}
			}
		}

		/// <summary>
		/// Get real coordinates of point in window when given logical coordinates of<br/>
		/// point in renderer.<br/>
		/// Logical coordinates will differ from real coordinates when render is scaled<br/>
		/// and logical renderer size set<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderLogicalToWindow")]
		internal static extern void SDLRenderLogicalToWindowNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY);

		/// <summary>		/// Get real coordinates of point in window when given logical coordinates of<br/>		/// point in renderer.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY)
		{
			SDLRenderLogicalToWindowNative(renderer, logicalX, logicalY, windowX, windowY);
		}

		/// <summary>		/// Get real coordinates of point in window when given logical coordinates of<br/>		/// point in renderer.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderLogicalToWindowNative((SDLRenderer*)prenderer, logicalX, logicalY, windowX, windowY);
			}
		}

		/// <summary>		/// Get real coordinates of point in window when given logical coordinates of<br/>		/// point in renderer.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] ref int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY)
		{
			fixed (int* pwindowX = &windowX)
			{
				SDLRenderLogicalToWindowNative(renderer, logicalX, logicalY, (int*)pwindowX, windowY);
			}
		}

		/// <summary>		/// Get real coordinates of point in window when given logical coordinates of<br/>		/// point in renderer.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] ref int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] int* windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pwindowX = &windowX)
				{
					SDLRenderLogicalToWindowNative((SDLRenderer*)prenderer, logicalX, logicalY, (int*)pwindowX, windowY);
				}
			}
		}

		/// <summary>		/// Get real coordinates of point in window when given logical coordinates of<br/>		/// point in renderer.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] ref int windowY)
		{
			fixed (int* pwindowY = &windowY)
			{
				SDLRenderLogicalToWindowNative(renderer, logicalX, logicalY, windowX, (int*)pwindowY);
			}
		}

		/// <summary>		/// Get real coordinates of point in window when given logical coordinates of<br/>		/// point in renderer.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] int* windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] ref int windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pwindowY = &windowY)
				{
					SDLRenderLogicalToWindowNative((SDLRenderer*)prenderer, logicalX, logicalY, windowX, (int*)pwindowY);
				}
			}
		}

		/// <summary>		/// Get real coordinates of point in window when given logical coordinates of<br/>		/// point in renderer.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] ref int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] ref int windowY)
		{
			fixed (int* pwindowX = &windowX)
			{
				fixed (int* pwindowY = &windowY)
				{
					SDLRenderLogicalToWindowNative(renderer, logicalX, logicalY, (int*)pwindowX, (int*)pwindowY);
				}
			}
		}

		/// <summary>		/// Get real coordinates of point in window when given logical coordinates of<br/>		/// point in renderer.<br/>		/// Logical coordinates will differ from real coordinates when render is scaled<br/>		/// and logical renderer size set<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderLogicalToWindow")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderLogicalToWindow([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "logicalX")] [NativeName(NativeNameType.Type, "float")] float logicalX, [NativeName(NativeNameType.Param, "logicalY")] [NativeName(NativeNameType.Type, "float")] float logicalY, [NativeName(NativeNameType.Param, "windowX")] [NativeName(NativeNameType.Type, "int*")] ref int windowX, [NativeName(NativeNameType.Param, "windowY")] [NativeName(NativeNameType.Type, "int*")] ref int windowY)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pwindowX = &windowX)
				{
					fixed (int* pwindowY = &windowY)
					{
						SDLRenderLogicalToWindowNative((SDLRenderer*)prenderer, logicalX, logicalY, (int*)pwindowX, (int*)pwindowY);
					}
				}
			}
		}

		/// <summary>
		/// Set the color used for drawing operations (Rect, Line and Clear).<br/>
		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
		/// SDL_RenderClear().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetRenderDrawColor")]
		internal static extern int SDLSetRenderDrawColorNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a);

		/// <summary>		/// Set the color used for drawing operations (Rect, Line and Clear).<br/>		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>		/// SDL_RenderClear().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			int ret = SDLSetRenderDrawColorNative(renderer, r, g, b, a);
			return ret;
		}

		/// <summary>		/// Set the color used for drawing operations (Rect, Line and Clear).<br/>		/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>		/// SDL_RenderClear().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8")] byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8")] byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8")] byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8")] byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLSetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, b, a);
				return ret;
			}
		}

		/// <summary>
		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRenderDrawColor")]
		internal static extern int SDLGetRenderDrawColorNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a);

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			int ret = SDLGetRenderDrawColorNative(renderer, r, g, b, a);
			return ret;
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, b, a);
				return ret;
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, g, b, a);
				return ret;
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, b, a);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pg = &g)
			{
				int ret = SDLGetRenderDrawColorNative(renderer, r, (byte*)pg, b, a);
				return ret;
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, b, a);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, b, a);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, b, a);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pb = &b)
			{
				int ret = SDLGetRenderDrawColorNative(renderer, r, g, (byte*)pb, a);
				return ret;
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, (byte*)pb, a);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, g, (byte*)pb, a);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, (byte*)pb, a);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, r, (byte*)pg, (byte*)pb, a);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, (byte*)pb, a);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, (byte*)pb, a);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] byte* a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, (byte*)pb, a);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pa = &a)
			{
				int ret = SDLGetRenderDrawColorNative(renderer, r, g, b, (byte*)pa);
				return ret;
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pa = &a)
				{
					int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, b, (byte*)pa);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pa = &a)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, g, b, (byte*)pa);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pa = &a)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, b, (byte*)pa);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pa = &a)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, r, (byte*)pg, b, (byte*)pa);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, b, (byte*)pa);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pa = &a)
					{
						int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, b, (byte*)pa);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] byte* b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pa = &a)
						{
							int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, b, (byte*)pa);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pb = &b)
			{
				fixed (byte* pa = &a)
				{
					int ret = SDLGetRenderDrawColorNative(renderer, r, g, (byte*)pb, (byte*)pa);
					return ret;
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, g, (byte*)pb, (byte*)pa);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, g, (byte*)pb, (byte*)pa);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] byte* g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, g, (byte*)pb, (byte*)pa);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pg = &g)
			{
				fixed (byte* pb = &b)
				{
					fixed (byte* pa = &a)
					{
						int ret = SDLGetRenderDrawColorNative(renderer, r, (byte*)pg, (byte*)pb, (byte*)pa);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] byte* r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, r, (byte*)pg, (byte*)pb, (byte*)pa);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (byte* pr = &r)
			{
				fixed (byte* pg = &g)
				{
					fixed (byte* pb = &b)
					{
						fixed (byte* pa = &a)
						{
							int ret = SDLGetRenderDrawColorNative(renderer, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Get the color used for drawing operations (Rect, Line and Clear).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawColor")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawColor([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "r")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte r, [NativeName(NativeNameType.Param, "g")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte g, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte b, [NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "Uint8*")] ref byte a)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pr = &r)
				{
					fixed (byte* pg = &g)
					{
						fixed (byte* pb = &b)
						{
							fixed (byte* pa = &a)
							{
								int ret = SDLGetRenderDrawColorNative((SDLRenderer*)prenderer, (byte*)pr, (byte*)pg, (byte*)pb, (byte*)pa);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Set the blend mode used for drawing operations (Fill and Line).<br/>
		/// If the blend mode is not supported, the closest supported mode is chosen.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetRenderDrawBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetRenderDrawBlendMode")]
		internal static extern int SDLSetRenderDrawBlendModeNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode);

		/// <summary>		/// Set the blend mode used for drawing operations (Fill and Line).<br/>		/// If the blend mode is not supported, the closest supported mode is chosen.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRenderDrawBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderDrawBlendMode([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			int ret = SDLSetRenderDrawBlendModeNative(renderer, blendMode);
			return ret;
		}

		/// <summary>		/// Set the blend mode used for drawing operations (Fill and Line).<br/>		/// If the blend mode is not supported, the closest supported mode is chosen.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetRenderDrawBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetRenderDrawBlendMode([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode")] SDLBlendMode blendMode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLSetRenderDrawBlendModeNative((SDLRenderer*)prenderer, blendMode);
				return ret;
			}
		}

		/// <summary>
		/// Get the blend mode used for drawing operations.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRenderDrawBlendMode")]
		internal static extern int SDLGetRenderDrawBlendModeNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode);

		/// <summary>		/// Get the blend mode used for drawing operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawBlendMode([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			int ret = SDLGetRenderDrawBlendModeNative(renderer, blendMode);
			return ret;
		}

		/// <summary>		/// Get the blend mode used for drawing operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawBlendMode([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] SDLBlendMode* blendMode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLGetRenderDrawBlendModeNative((SDLRenderer*)prenderer, blendMode);
				return ret;
			}
		}

		/// <summary>		/// Get the blend mode used for drawing operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawBlendMode([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLBlendMode* pblendMode = &blendMode)
			{
				int ret = SDLGetRenderDrawBlendModeNative(renderer, (SDLBlendMode*)pblendMode);
				return ret;
			}
		}

		/// <summary>		/// Get the blend mode used for drawing operations.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRenderDrawBlendMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRenderDrawBlendMode([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "blendMode")] [NativeName(NativeNameType.Type, "SDL_BlendMode*")] ref SDLBlendMode blendMode)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLBlendMode* pblendMode = &blendMode)
				{
					int ret = SDLGetRenderDrawBlendModeNative((SDLRenderer*)prenderer, (SDLBlendMode*)pblendMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Clear the current rendering target with the drawing color.<br/>
		/// This function clears the entire rendering target, ignoring the viewport and<br/>
		/// the clip rectangle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderClear")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderClear")]
		internal static extern int SDLRenderClearNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Clear the current rendering target with the drawing color.<br/>		/// This function clears the entire rendering target, ignoring the viewport and<br/>		/// the clip rectangle.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderClear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderClear([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			int ret = SDLRenderClearNative(renderer);
			return ret;
		}

		/// <summary>		/// Clear the current rendering target with the drawing color.<br/>		/// This function clears the entire rendering target, ignoring the viewport and<br/>		/// the clip rectangle.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderClear")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderClear([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderClearNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Draw a point on the current rendering target.<br/>
		/// SDL_RenderDrawPoint() draws a single point. If you want to draw multiple,<br/>
		/// use SDL_RenderDrawPoints() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawPoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawPoint")]
		internal static extern int SDLRenderDrawPointNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y);

		/// <summary>		/// Draw a point on the current rendering target.<br/>		/// SDL_RenderDrawPoint() draws a single point. If you want to draw multiple,<br/>		/// use SDL_RenderDrawPoints() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPoint([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			int ret = SDLRenderDrawPointNative(renderer, x, y);
			return ret;
		}

		/// <summary>		/// Draw a point on the current rendering target.<br/>		/// SDL_RenderDrawPoint() draws a single point. If you want to draw multiple,<br/>		/// use SDL_RenderDrawPoints() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPoint")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPoint([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "int")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "int")] int y)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawPointNative((SDLRenderer*)prenderer, x, y);
				return ret;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawPoints")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawPoints")]
		internal static extern int SDLRenderDrawPointsNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count);

		/// <summary>		/// Draw multiple points on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPoints")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPoints([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			int ret = SDLRenderDrawPointsNative(renderer, points, count);
			return ret;
		}

		/// <summary>		/// Draw multiple points on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPoints")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPoints([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawPointsNative((SDLRenderer*)prenderer, points, count);
				return ret;
			}
		}

		/// <summary>		/// Draw multiple points on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPoints")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPoints([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				int ret = SDLRenderDrawPointsNative(renderer, (SDLPoint*)ppoints, count);
				return ret;
			}
		}

		/// <summary>		/// Draw multiple points on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPoints")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPoints([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLPoint* ppoints = &points)
				{
					int ret = SDLRenderDrawPointsNative((SDLRenderer*)prenderer, (SDLPoint*)ppoints, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw a line on the current rendering target.<br/>
		/// SDL_RenderDrawLine() draws the line to include both end points. If you want<br/>
		/// to draw multiple, connecting lines use SDL_RenderDrawLines() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawLine")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawLine")]
		internal static extern int SDLRenderDrawLineNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x1")] [NativeName(NativeNameType.Type, "int")] int x1, [NativeName(NativeNameType.Param, "y1")] [NativeName(NativeNameType.Type, "int")] int y1, [NativeName(NativeNameType.Param, "x2")] [NativeName(NativeNameType.Type, "int")] int x2, [NativeName(NativeNameType.Param, "y2")] [NativeName(NativeNameType.Type, "int")] int y2);

		/// <summary>		/// Draw a line on the current rendering target.<br/>		/// SDL_RenderDrawLine() draws the line to include both end points. If you want<br/>		/// to draw multiple, connecting lines use SDL_RenderDrawLines() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLine")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLine([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x1")] [NativeName(NativeNameType.Type, "int")] int x1, [NativeName(NativeNameType.Param, "y1")] [NativeName(NativeNameType.Type, "int")] int y1, [NativeName(NativeNameType.Param, "x2")] [NativeName(NativeNameType.Type, "int")] int x2, [NativeName(NativeNameType.Param, "y2")] [NativeName(NativeNameType.Type, "int")] int y2)
		{
			int ret = SDLRenderDrawLineNative(renderer, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>		/// Draw a line on the current rendering target.<br/>		/// SDL_RenderDrawLine() draws the line to include both end points. If you want<br/>		/// to draw multiple, connecting lines use SDL_RenderDrawLines() instead.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLine")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLine([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x1")] [NativeName(NativeNameType.Type, "int")] int x1, [NativeName(NativeNameType.Param, "y1")] [NativeName(NativeNameType.Type, "int")] int y1, [NativeName(NativeNameType.Param, "x2")] [NativeName(NativeNameType.Type, "int")] int x2, [NativeName(NativeNameType.Param, "y2")] [NativeName(NativeNameType.Type, "int")] int y2)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawLineNative((SDLRenderer*)prenderer, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawLines")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawLines")]
		internal static extern int SDLRenderDrawLinesNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count);

		/// <summary>		/// Draw a series of connected lines on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLines")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLines([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			int ret = SDLRenderDrawLinesNative(renderer, points, count);
			return ret;
		}

		/// <summary>		/// Draw a series of connected lines on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLines")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLines([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawLinesNative((SDLRenderer*)prenderer, points, count);
				return ret;
			}
		}

		/// <summary>		/// Draw a series of connected lines on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLines")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLines([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLPoint* ppoints = &points)
			{
				int ret = SDLRenderDrawLinesNative(renderer, (SDLPoint*)ppoints, count);
				return ret;
			}
		}

		/// <summary>		/// Draw a series of connected lines on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLines")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLines([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLPoint* ppoints = &points)
				{
					int ret = SDLRenderDrawLinesNative((SDLRenderer*)prenderer, (SDLPoint*)ppoints, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawRect")]
		internal static extern int SDLRenderDrawRectNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Draw a rectangle on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLRenderDrawRectNative(renderer, rect);
			return ret;
		}

		/// <summary>		/// Draw a rectangle on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawRectNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>		/// Draw a rectangle on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLRenderDrawRectNative(renderer, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>		/// Draw a rectangle on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLRenderDrawRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawRects")]
		internal static extern int SDLRenderDrawRectsNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count);

		/// <summary>		/// Draw some number of rectangles on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRects([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			int ret = SDLRenderDrawRectsNative(renderer, rects, count);
			return ret;
		}

		/// <summary>		/// Draw some number of rectangles on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRects([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawRectsNative((SDLRenderer*)prenderer, rects, count);
				return ret;
			}
		}

		/// <summary>		/// Draw some number of rectangles on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRects([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRect* prects = &rects)
			{
				int ret = SDLRenderDrawRectsNative(renderer, (SDLRect*)prects, count);
				return ret;
			}
		}

		/// <summary>		/// Draw some number of rectangles on the current rendering target.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRects([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prects = &rects)
				{
					int ret = SDLRenderDrawRectsNative((SDLRenderer*)prenderer, (SDLRect*)prects, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color.<br/>
		/// The current drawing color is set by SDL_SetRenderDrawColor(), and the<br/>
		/// color's alpha value is ignored unless blending is enabled with the<br/>
		/// appropriate call to SDL_SetRenderDrawBlendMode().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderFillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderFillRect")]
		internal static extern int SDLRenderFillRectNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect);

		/// <summary>		/// Fill a rectangle on the current rendering target with the drawing color.<br/>		/// The current drawing color is set by SDL_SetRenderDrawColor(), and the<br/>		/// color's alpha value is ignored unless blending is enabled with the<br/>		/// appropriate call to SDL_SetRenderDrawBlendMode().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			int ret = SDLRenderFillRectNative(renderer, rect);
			return ret;
		}

		/// <summary>		/// Fill a rectangle on the current rendering target with the drawing color.<br/>		/// The current drawing color is set by SDL_SetRenderDrawColor(), and the<br/>		/// color's alpha value is ignored unless blending is enabled with the<br/>		/// appropriate call to SDL_SetRenderDrawBlendMode().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderFillRectNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>		/// Fill a rectangle on the current rendering target with the drawing color.<br/>		/// The current drawing color is set by SDL_SetRenderDrawColor(), and the<br/>		/// color's alpha value is ignored unless blending is enabled with the<br/>		/// appropriate call to SDL_SetRenderDrawBlendMode().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLRenderFillRectNative(renderer, (SDLRect*)prect);
				return ret;
			}
		}

		/// <summary>		/// Fill a rectangle on the current rendering target with the drawing color.<br/>		/// The current drawing color is set by SDL_SetRenderDrawColor(), and the<br/>		/// color's alpha value is ignored unless blending is enabled with the<br/>		/// appropriate call to SDL_SetRenderDrawBlendMode().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRect")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRect([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLRenderFillRectNative((SDLRenderer*)prenderer, (SDLRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderFillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderFillRects")]
		internal static extern int SDLRenderFillRectsNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count);

		/// <summary>		/// Fill some number of rectangles on the current rendering target with the<br/>		/// drawing color.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRects([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			int ret = SDLRenderFillRectsNative(renderer, rects, count);
			return ret;
		}

		/// <summary>		/// Fill some number of rectangles on the current rendering target with the<br/>		/// drawing color.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRects([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderFillRectsNative((SDLRenderer*)prenderer, rects, count);
				return ret;
			}
		}

		/// <summary>		/// Fill some number of rectangles on the current rendering target with the<br/>		/// drawing color.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRects([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRect* prects = &rects)
			{
				int ret = SDLRenderFillRectsNative(renderer, (SDLRect*)prects, count);
				return ret;
			}
		}

		/// <summary>		/// Fill some number of rectangles on the current rendering target with the<br/>		/// drawing color.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRects")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRects([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prects = &rects)
				{
					int ret = SDLRenderFillRectsNative((SDLRenderer*)prenderer, (SDLRect*)prects, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderCopy")]
		internal static extern int SDLRenderCopyNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect);

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			int ret = SDLRenderCopyNative(renderer, texture, srcrect, dstrect);
			return ret;
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderCopyNative((SDLRenderer*)prenderer, texture, srcrect, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLRenderCopyNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = SDLRenderCopyNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLRenderCopyNative(renderer, texture, (SDLRect*)psrcrect, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLRenderCopyNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLRenderCopyNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = SDLRenderCopyNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLRenderCopyNative(renderer, texture, srcrect, (SDLRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyNative((SDLRenderer*)prenderer, texture, srcrect, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyNative(renderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopy")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopy([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = SDLRenderCopyNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering, with optional<br/>
		/// rotation and flipping.<br/>
		/// Copy a portion of the texture to the current rendering target, optionally<br/>
		/// rotating it by angle around the given center and also flipping it<br/>
		/// top-bottom and/or left-right.<br/>
		/// The texture is blended with the destination based on its blend mode set<br/>
		/// with SDL_SetTextureBlendMode().<br/>
		/// The texture color is affected based on its color modulation set by<br/>
		/// SDL_SetTextureColorMod().<br/>
		/// The texture alpha is affected based on its alpha modulation set by<br/>
		/// SDL_SetTextureAlphaMod().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderCopyEx")]
		internal static extern int SDLRenderCopyExNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip);

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			int ret = SDLRenderCopyExNative(renderer, texture, srcrect, dstrect, angle, center, flip);
			return ret;
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLRenderCopyExNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLRenderCopyExNative(renderer, texture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLRenderCopyExNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				int ret = SDLRenderCopyExNative(renderer, texture, srcrect, (SDLRect*)pdstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, texture, srcrect, (SDLRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyExNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyExNative(renderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyExNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] SDLPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, center, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLPoint* pcenter = &center)
			{
				int ret = SDLRenderCopyExNative(renderer, texture, srcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = SDLRenderCopyExNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = SDLRenderCopyExNative(renderer, texture, (SDLRect*)psrcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* pdstrect = &dstrect)
			{
				fixed (SDLPoint* pcenter = &center)
				{
					int ret = SDLRenderCopyExNative(renderer, texture, srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, texture, srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLRect* pdstrect = &dstrect)
				{
					fixed (SDLPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExNative(renderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLRect* pdstrect = &dstrect)
					{
						fixed (SDLPoint* pcenter = &center)
						{
							int ret = SDLRenderCopyExNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering, with optional<br/>		/// rotation and flipping.<br/>		/// Copy a portion of the texture to the current rendering target, optionally<br/>		/// rotating it by angle around the given center and also flipping it<br/>		/// top-bottom and/or left-right.<br/>		/// The texture is blended with the destination based on its blend mode set<br/>		/// with SDL_SetTextureBlendMode().<br/>		/// The texture color is affected based on its color modulation set by<br/>		/// SDL_SetTextureColorMod().<br/>		/// The texture alpha is affected based on its alpha modulation set by<br/>		/// SDL_SetTextureAlphaMod().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyEx")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyEx([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_Point*")] ref SDLPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLRect* pdstrect = &dstrect)
						{
							fixed (SDLPoint* pcenter = &center)
							{
								int ret = SDLRenderCopyExNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLRect*)pdstrect, angle, (SDLPoint*)pcenter, flip);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Draw a point on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawPointF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawPointF")]
		internal static extern int SDLRenderDrawPointFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y);

		/// <summary>		/// Draw a point on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPointF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPointF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			int ret = SDLRenderDrawPointFNative(renderer, x, y);
			return ret;
		}

		/// <summary>		/// Draw a point on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPointF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPointF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "float")] float x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "float")] float y)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawPointFNative((SDLRenderer*)prenderer, x, y);
				return ret;
			}
		}

		/// <summary>
		/// Draw multiple points on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawPointsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawPointsF")]
		internal static extern int SDLRenderDrawPointsFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count);

		/// <summary>		/// Draw multiple points on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPointsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPointsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			int ret = SDLRenderDrawPointsFNative(renderer, points, count);
			return ret;
		}

		/// <summary>		/// Draw multiple points on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPointsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPointsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawPointsFNative((SDLRenderer*)prenderer, points, count);
				return ret;
			}
		}

		/// <summary>		/// Draw multiple points on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPointsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPointsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				int ret = SDLRenderDrawPointsFNative(renderer, (SDLFPoint*)ppoints, count);
				return ret;
			}
		}

		/// <summary>		/// Draw multiple points on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawPointsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawPointsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* ppoints = &points)
				{
					int ret = SDLRenderDrawPointsFNative((SDLRenderer*)prenderer, (SDLFPoint*)ppoints, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw a line on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawLineF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawLineF")]
		internal static extern int SDLRenderDrawLineFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x1")] [NativeName(NativeNameType.Type, "float")] float x1, [NativeName(NativeNameType.Param, "y1")] [NativeName(NativeNameType.Type, "float")] float y1, [NativeName(NativeNameType.Param, "x2")] [NativeName(NativeNameType.Type, "float")] float x2, [NativeName(NativeNameType.Param, "y2")] [NativeName(NativeNameType.Type, "float")] float y2);

		/// <summary>		/// Draw a line on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLineF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLineF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "x1")] [NativeName(NativeNameType.Type, "float")] float x1, [NativeName(NativeNameType.Param, "y1")] [NativeName(NativeNameType.Type, "float")] float y1, [NativeName(NativeNameType.Param, "x2")] [NativeName(NativeNameType.Type, "float")] float x2, [NativeName(NativeNameType.Param, "y2")] [NativeName(NativeNameType.Type, "float")] float y2)
		{
			int ret = SDLRenderDrawLineFNative(renderer, x1, y1, x2, y2);
			return ret;
		}

		/// <summary>		/// Draw a line on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLineF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLineF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "x1")] [NativeName(NativeNameType.Type, "float")] float x1, [NativeName(NativeNameType.Param, "y1")] [NativeName(NativeNameType.Type, "float")] float y1, [NativeName(NativeNameType.Param, "x2")] [NativeName(NativeNameType.Type, "float")] float x2, [NativeName(NativeNameType.Param, "y2")] [NativeName(NativeNameType.Type, "float")] float y2)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawLineFNative((SDLRenderer*)prenderer, x1, y1, x2, y2);
				return ret;
			}
		}

		/// <summary>
		/// Draw a series of connected lines on the current rendering target at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawLinesF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawLinesF")]
		internal static extern int SDLRenderDrawLinesFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count);

		/// <summary>		/// Draw a series of connected lines on the current rendering target at<br/>		/// subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLinesF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLinesF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			int ret = SDLRenderDrawLinesFNative(renderer, points, count);
			return ret;
		}

		/// <summary>		/// Draw a series of connected lines on the current rendering target at<br/>		/// subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLinesF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLinesF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawLinesFNative((SDLRenderer*)prenderer, points, count);
				return ret;
			}
		}

		/// <summary>		/// Draw a series of connected lines on the current rendering target at<br/>		/// subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLinesF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLinesF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLFPoint* ppoints = &points)
			{
				int ret = SDLRenderDrawLinesFNative(renderer, (SDLFPoint*)ppoints, count);
				return ret;
			}
		}

		/// <summary>		/// Draw a series of connected lines on the current rendering target at<br/>		/// subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawLinesF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawLinesF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* ppoints = &points)
				{
					int ret = SDLRenderDrawLinesFNative((SDLRenderer*)prenderer, (SDLFPoint*)ppoints, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawRectF")]
		internal static extern int SDLRenderDrawRectFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect);

		/// <summary>		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRectF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect)
		{
			int ret = SDLRenderDrawRectFNative(renderer, rect);
			return ret;
		}

		/// <summary>		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRectF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawRectFNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRectF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect)
		{
			fixed (SDLFRect* prect = &rect)
			{
				int ret = SDLRenderDrawRectFNative(renderer, (SDLFRect*)prect);
				return ret;
			}
		}

		/// <summary>		/// Draw a rectangle on the current rendering target at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRectF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prect = &rect)
				{
					int ret = SDLRenderDrawRectFNative((SDLRenderer*)prenderer, (SDLFRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Draw some number of rectangles on the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderDrawRectsF")]
		internal static extern int SDLRenderDrawRectsFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count);

		/// <summary>		/// Draw some number of rectangles on the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRectsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			int ret = SDLRenderDrawRectsFNative(renderer, rects, count);
			return ret;
		}

		/// <summary>		/// Draw some number of rectangles on the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRectsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderDrawRectsFNative((SDLRenderer*)prenderer, rects, count);
				return ret;
			}
		}

		/// <summary>		/// Draw some number of rectangles on the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRectsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLFRect* prects = &rects)
			{
				int ret = SDLRenderDrawRectsFNative(renderer, (SDLFRect*)prects, count);
				return ret;
			}
		}

		/// <summary>		/// Draw some number of rectangles on the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderDrawRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderDrawRectsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prects = &rects)
				{
					int ret = SDLRenderDrawRectsFNative((SDLRenderer*)prenderer, (SDLFRect*)prects, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Fill a rectangle on the current rendering target with the drawing color at<br/>
		/// subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderFillRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderFillRectF")]
		internal static extern int SDLRenderFillRectFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect);

		/// <summary>		/// Fill a rectangle on the current rendering target with the drawing color at<br/>		/// subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRectF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect)
		{
			int ret = SDLRenderFillRectFNative(renderer, rect);
			return ret;
		}

		/// <summary>		/// Fill a rectangle on the current rendering target with the drawing color at<br/>		/// subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRectF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderFillRectFNative((SDLRenderer*)prenderer, rect);
				return ret;
			}
		}

		/// <summary>		/// Fill a rectangle on the current rendering target with the drawing color at<br/>		/// subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRectF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect)
		{
			fixed (SDLFRect* prect = &rect)
			{
				int ret = SDLRenderFillRectFNative(renderer, (SDLFRect*)prect);
				return ret;
			}
		}

		/// <summary>		/// Fill a rectangle on the current rendering target with the drawing color at<br/>		/// subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRectF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRectF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prect = &rect)
				{
					int ret = SDLRenderFillRectFNative((SDLRenderer*)prenderer, (SDLFRect*)prect);
					return ret;
				}
			}
		}

		/// <summary>
		/// Fill some number of rectangles on the current rendering target with the<br/>
		/// drawing color at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderFillRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderFillRectsF")]
		internal static extern int SDLRenderFillRectsFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count);

		/// <summary>		/// Fill some number of rectangles on the current rendering target with the<br/>		/// drawing color at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRectsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			int ret = SDLRenderFillRectsFNative(renderer, rects, count);
			return ret;
		}

		/// <summary>		/// Fill some number of rectangles on the current rendering target with the<br/>		/// drawing color at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRectsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderFillRectsFNative((SDLRenderer*)prenderer, rects, count);
				return ret;
			}
		}

		/// <summary>		/// Fill some number of rectangles on the current rendering target with the<br/>		/// drawing color at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRectsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLFRect* prects = &rects)
			{
				int ret = SDLRenderFillRectsFNative(renderer, (SDLFRect*)prects, count);
				return ret;
			}
		}

		/// <summary>		/// Fill some number of rectangles on the current rendering target with the<br/>		/// drawing color at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFillRectsF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFillRectsF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rects")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect rects, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int")] int count)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* prects = &rects)
				{
					int ret = SDLRenderFillRectsFNative((SDLRenderer*)prenderer, (SDLFRect*)prects, count);
					return ret;
				}
			}
		}

		/// <summary>
		/// Copy a portion of the texture to the current rendering target at subpixel<br/>
		/// precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderCopyF")]
		internal static extern int SDLRenderCopyFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect);

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect)
		{
			int ret = SDLRenderCopyFNative(renderer, texture, srcrect, dstrect);
			return ret;
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderCopyFNative((SDLRenderer*)prenderer, texture, srcrect, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLRenderCopyFNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = SDLRenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLRenderCopyFNative(renderer, texture, (SDLRect*)psrcrect, dstrect);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLRenderCopyFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLRenderCopyFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = SDLRenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				int ret = SDLRenderCopyFNative(renderer, texture, srcrect, (SDLFRect*)pdstrect);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyFNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyFNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyFNative(renderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the texture to the current rendering target at subpixel<br/>		/// precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							int ret = SDLRenderCopyFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Copy a portion of the source texture to the current rendering target, with<br/>
		/// rotation and flipping, at subpixel precision.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderCopyExF")]
		internal static extern int SDLRenderCopyExFNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip);

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			int ret = SDLRenderCopyExFNative(renderer, texture, srcrect, dstrect, angle, center, flip);
			return ret;
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLRenderCopyExFNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				int ret = SDLRenderCopyExFNative(renderer, texture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					int ret = SDLRenderCopyExFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				int ret = SDLRenderCopyExFNative(renderer, texture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyExFNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					int ret = SDLRenderCopyExFNative(renderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						int ret = SDLRenderCopyExFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] SDLFPoint* center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, center, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLFPoint* pcenter = &center)
			{
				int ret = SDLRenderCopyExFNative(renderer, texture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
				return ret;
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, texture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = SDLRenderCopyExFNative(renderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = SDLRenderCopyExFNative(renderer, texture, (SDLRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] SDLFRect* dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, dstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLFRect* pdstrect = &dstrect)
			{
				fixed (SDLFPoint* pcenter = &center)
				{
					int ret = SDLRenderCopyExFNative(renderer, texture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
					return ret;
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, texture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExFNative(renderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, srcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRect* psrcrect = &srcrect)
			{
				fixed (SDLFRect* pdstrect = &dstrect)
				{
					fixed (SDLFPoint* pcenter = &center)
					{
						int ret = SDLRenderCopyExFNative(renderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, texture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLRect* psrcrect = &srcrect)
				{
					fixed (SDLFRect* pdstrect = &dstrect)
					{
						fixed (SDLFPoint* pcenter = &center)
						{
							int ret = SDLRenderCopyExFNative(renderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Copy a portion of the source texture to the current rendering target, with<br/>		/// rotation and flipping, at subpixel precision.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderCopyExF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderCopyExF([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "srcrect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect srcrect, [NativeName(NativeNameType.Param, "dstrect")] [NativeName(NativeNameType.Type, "const SDL_FRect*")] ref SDLFRect dstrect, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "const double")] double angle, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "const SDL_FPoint*")] ref SDLFPoint center, [NativeName(NativeNameType.Param, "flip")] [NativeName(NativeNameType.Type, "const SDL_RendererFlip")] SDLRendererFlip flip)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLRect* psrcrect = &srcrect)
					{
						fixed (SDLFRect* pdstrect = &dstrect)
						{
							fixed (SDLFPoint* pcenter = &center)
							{
								int ret = SDLRenderCopyExFNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLRect*)psrcrect, (SDLFRect*)pdstrect, angle, (SDLFPoint*)pcenter, flip);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex array Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGeometry")]
		internal static extern int SDLRenderGeometryNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] SDLVertex* vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] int* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices);

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] SDLVertex* vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] int* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			int ret = SDLRenderGeometryNative(renderer, texture, vertices, numVertices, indices, numIndices);
			return ret;
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] SDLVertex* vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] int* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderGeometryNative((SDLRenderer*)prenderer, texture, vertices, numVertices, indices, numIndices);
				return ret;
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] SDLVertex* vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] int* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLRenderGeometryNative(renderer, (SDLTexture*)ptexture, vertices, numVertices, indices, numIndices);
				return ret;
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] SDLVertex* vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] int* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = SDLRenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, vertices, numVertices, indices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] ref SDLVertex vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] int* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLVertex* pvertices = &vertices)
			{
				int ret = SDLRenderGeometryNative(renderer, texture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
				return ret;
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] ref SDLVertex vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] int* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					int ret = SDLRenderGeometryNative((SDLRenderer*)prenderer, texture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] ref SDLVertex vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] int* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					int ret = SDLRenderGeometryNative(renderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] ref SDLVertex vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] int* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLVertex* pvertices = &vertices)
					{
						int ret = SDLRenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, indices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] SDLVertex* vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] ref int indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (int* pindices = &indices)
			{
				int ret = SDLRenderGeometryNative(renderer, texture, vertices, numVertices, (int*)pindices, numIndices);
				return ret;
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] SDLVertex* vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] ref int indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (int* pindices = &indices)
				{
					int ret = SDLRenderGeometryNative((SDLRenderer*)prenderer, texture, vertices, numVertices, (int*)pindices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] SDLVertex* vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] ref int indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (int* pindices = &indices)
				{
					int ret = SDLRenderGeometryNative(renderer, (SDLTexture*)ptexture, vertices, numVertices, (int*)pindices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] SDLVertex* vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] ref int indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (int* pindices = &indices)
					{
						int ret = SDLRenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, vertices, numVertices, (int*)pindices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] ref SDLVertex vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] ref int indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLVertex* pvertices = &vertices)
			{
				fixed (int* pindices = &indices)
				{
					int ret = SDLRenderGeometryNative(renderer, texture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] ref SDLVertex vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] ref int indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					fixed (int* pindices = &indices)
					{
						int ret = SDLRenderGeometryNative((SDLRenderer*)prenderer, texture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] ref SDLVertex vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] ref int indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLVertex* pvertices = &vertices)
				{
					fixed (int* pindices = &indices)
					{
						int ret = SDLRenderGeometryNative(renderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex array Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometry")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometry([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const SDL_Vertex*")] ref SDLVertex vertices, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const int*")] ref int indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLVertex* pvertices = &vertices)
					{
						fixed (int* pindices = &indices)
						{
							int ret = SDLRenderGeometryNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (SDLVertex*)pvertices, numVertices, (int*)pindices, numIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// Render a list of triangles, optionally using a texture and indices into the<br/>
		/// vertex arrays Color and alpha modulation is done per vertex<br/>
		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGeometryRaw")]
		internal static extern int SDLRenderGeometryRawNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices);

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			int ret = SDLRenderGeometryRawNative(renderer, texture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
			return ret;
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLRenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				int ret = SDLRenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					int ret = SDLRenderGeometryRawNative(renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLColor* pcolor = &color)
			{
				int ret = SDLRenderGeometryRawNative(renderer, texture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = SDLRenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (SDLColor* pcolor = &color)
				{
					int ret = SDLRenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						int ret = SDLRenderGeometryRawNative(renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] float* uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (SDLColor* pcolor = &color)
						{
							int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, uv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (float* puv = &uv)
			{
				int ret = SDLRenderGeometryRawNative(renderer, texture, xy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
				return ret;
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* puv = &uv)
				{
					int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* puv = &uv)
				{
					int ret = SDLRenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* puv = &uv)
					{
						int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (float* puv = &uv)
				{
					int ret = SDLRenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (float* puv = &uv)
					{
						int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (float* puv = &uv)
					{
						int ret = SDLRenderGeometryRawNative(renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] SDLColor* color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (float* puv = &uv)
						{
							int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, color, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLColor* pcolor = &color)
			{
				fixed (float* puv = &uv)
				{
					int ret = SDLRenderGeometryRawNative(renderer, texture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
					return ret;
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, texture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = SDLRenderGeometryRawNative(renderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] float* xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, xy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (float* pxy = &xy)
			{
				fixed (SDLColor* pcolor = &color)
				{
					fixed (float* puv = &uv)
					{
						int ret = SDLRenderGeometryRawNative(renderer, texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
						return ret;
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, texture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* pxy = &xy)
				{
					fixed (SDLColor* pcolor = &color)
					{
						fixed (float* puv = &uv)
						{
							int ret = SDLRenderGeometryRawNative(renderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>		/// Render a list of triangles, optionally using a texture and indices into the<br/>		/// vertex arrays Color and alpha modulation is done per vertex<br/>		/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGeometryRaw")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderGeometryRaw([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "xy")] [NativeName(NativeNameType.Type, "const float*")] ref float xy, [NativeName(NativeNameType.Param, "xy_stride")] [NativeName(NativeNameType.Type, "int")] int xyStride, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "const SDL_Color*")] ref SDLColor color, [NativeName(NativeNameType.Param, "color_stride")] [NativeName(NativeNameType.Type, "int")] int colorStride, [NativeName(NativeNameType.Param, "uv")] [NativeName(NativeNameType.Type, "const float*")] ref float uv, [NativeName(NativeNameType.Param, "uv_stride")] [NativeName(NativeNameType.Type, "int")] int uvStride, [NativeName(NativeNameType.Param, "num_vertices")] [NativeName(NativeNameType.Type, "int")] int numVertices, [NativeName(NativeNameType.Param, "indices")] [NativeName(NativeNameType.Type, "const void*")] void* indices, [NativeName(NativeNameType.Param, "num_indices")] [NativeName(NativeNameType.Type, "int")] int numIndices, [NativeName(NativeNameType.Param, "size_indices")] [NativeName(NativeNameType.Type, "int")] int sizeIndices)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLTexture* ptexture = &texture)
				{
					fixed (float* pxy = &xy)
					{
						fixed (SDLColor* pcolor = &color)
						{
							fixed (float* puv = &uv)
							{
								int ret = SDLRenderGeometryRawNative((SDLRenderer*)prenderer, (SDLTexture*)ptexture, (float*)pxy, xyStride, (SDLColor*)pcolor, colorStride, (float*)puv, uvStride, numVertices, indices, numIndices, sizeIndices);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Read pixels from the current rendering target to an array of pixels.<br/>
		/// **WARNING**: This is a very slow operation, and should not be used<br/>
		/// frequently. If you're using this on the main rendering target, it should be<br/>
		/// called after rendering and before SDL_RenderPresent().<br/>
		/// `pitch` specifies the number of bytes between rows in the destination<br/>
		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>
		/// rows in the destination. Generally, `pitch` should equal the number of<br/>
		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>
		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>
		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderReadPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderReadPixels")]
		internal static extern int SDLRenderReadPixelsNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch);

		/// <summary>		/// Read pixels from the current rendering target to an array of pixels.<br/>		/// **WARNING**: This is a very slow operation, and should not be used<br/>		/// frequently. If you're using this on the main rendering target, it should be<br/>		/// called after rendering and before SDL_RenderPresent().<br/>		/// `pitch` specifies the number of bytes between rows in the destination<br/>		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>		/// rows in the destination. Generally, `pitch` should equal the number of<br/>		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderReadPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderReadPixels([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			int ret = SDLRenderReadPixelsNative(renderer, rect, format, pixels, pitch);
			return ret;
		}

		/// <summary>		/// Read pixels from the current rendering target to an array of pixels.<br/>		/// **WARNING**: This is a very slow operation, and should not be used<br/>		/// frequently. If you're using this on the main rendering target, it should be<br/>		/// called after rendering and before SDL_RenderPresent().<br/>		/// `pitch` specifies the number of bytes between rows in the destination<br/>		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>		/// rows in the destination. Generally, `pitch` should equal the number of<br/>		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderReadPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderReadPixels([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] SDLRect* rect, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderReadPixelsNative((SDLRenderer*)prenderer, rect, format, pixels, pitch);
				return ret;
			}
		}

		/// <summary>		/// Read pixels from the current rendering target to an array of pixels.<br/>		/// **WARNING**: This is a very slow operation, and should not be used<br/>		/// frequently. If you're using this on the main rendering target, it should be<br/>		/// called after rendering and before SDL_RenderPresent().<br/>		/// `pitch` specifies the number of bytes between rows in the destination<br/>		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>		/// rows in the destination. Generally, `pitch` should equal the number of<br/>		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderReadPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderReadPixels([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLRect* prect = &rect)
			{
				int ret = SDLRenderReadPixelsNative(renderer, (SDLRect*)prect, format, pixels, pitch);
				return ret;
			}
		}

		/// <summary>		/// Read pixels from the current rendering target to an array of pixels.<br/>		/// **WARNING**: This is a very slow operation, and should not be used<br/>		/// frequently. If you're using this on the main rendering target, it should be<br/>		/// called after rendering and before SDL_RenderPresent().<br/>		/// `pitch` specifies the number of bytes between rows in the destination<br/>		/// `pixels` data. This allows you to write to a subrectangle or have padded<br/>		/// rows in the destination. Generally, `pitch` should equal the number of<br/>		/// pixels per row in the `pixels` data times the number of bytes per pixel,<br/>		/// but it might contain additional padding (for example, 24bit RGB Windows<br/>		/// Bitmap data pads all rows to multiples of 4 bytes).<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderReadPixels")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderReadPixels([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "rect")] [NativeName(NativeNameType.Type, "const SDL_Rect*")] ref SDLRect rect, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "Uint32")] uint format, [NativeName(NativeNameType.Param, "pixels")] [NativeName(NativeNameType.Type, "void*")] void* pixels, [NativeName(NativeNameType.Param, "pitch")] [NativeName(NativeNameType.Type, "int")] int pitch)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRect* prect = &rect)
				{
					int ret = SDLRenderReadPixelsNative((SDLRenderer*)prenderer, (SDLRect*)prect, format, pixels, pitch);
					return ret;
				}
			}
		}

		/// <summary>
		/// Update the screen with any rendering performed since the previous call.<br/>
		/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>
		/// rendering function such as SDL_RenderDrawLine() does not directly put a<br/>
		/// line on the screen, but rather updates the backbuffer. As such, you compose<br/>
		/// your entire scene and *present* the composed backbuffer to the screen as a<br/>
		/// complete picture.<br/>
		/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>
		/// for the frame, and then calls this function once per frame to present the<br/>
		/// final drawing to the user.<br/>
		/// The backbuffer should be considered invalidated after each present; do not<br/>
		/// assume that previous contents will exist between frames. You are strongly<br/>
		/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>
		/// starting each new frame's drawing, even if you plan to overwrite every<br/>
		/// pixel.<br/>
		/// <br/>
		/// <br/>
		/// You may only call this function on the main thread. If this<br/>
		/// happens to work on a background thread on any given platform<br/>
		/// or backend, it's purely by luck and you should not rely on it<br/>
		/// to work next time.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderPresent")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderPresent")]
		internal static extern void SDLRenderPresentNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Update the screen with any rendering performed since the previous call.<br/>		/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>		/// rendering function such as SDL_RenderDrawLine() does not directly put a<br/>		/// line on the screen, but rather updates the backbuffer. As such, you compose<br/>		/// your entire scene and *present* the composed backbuffer to the screen as a<br/>		/// complete picture.<br/>		/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>		/// for the frame, and then calls this function once per frame to present the<br/>		/// final drawing to the user.<br/>		/// The backbuffer should be considered invalidated after each present; do not<br/>		/// assume that previous contents will exist between frames. You are strongly<br/>		/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>		/// starting each new frame's drawing, even if you plan to overwrite every<br/>		/// pixel.<br/>		/// <br/>		/// <br/>		/// You may only call this function on the main thread. If this<br/>		/// happens to work on a background thread on any given platform<br/>		/// or backend, it's purely by luck and you should not rely on it<br/>		/// to work next time.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderPresent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderPresent([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLRenderPresentNative(renderer);
		}

		/// <summary>		/// Update the screen with any rendering performed since the previous call.<br/>		/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>		/// rendering function such as SDL_RenderDrawLine() does not directly put a<br/>		/// line on the screen, but rather updates the backbuffer. As such, you compose<br/>		/// your entire scene and *present* the composed backbuffer to the screen as a<br/>		/// complete picture.<br/>		/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>		/// for the frame, and then calls this function once per frame to present the<br/>		/// final drawing to the user.<br/>		/// The backbuffer should be considered invalidated after each present; do not<br/>		/// assume that previous contents will exist between frames. You are strongly<br/>		/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>		/// starting each new frame's drawing, even if you plan to overwrite every<br/>		/// pixel.<br/>		/// <br/>		/// <br/>		/// You may only call this function on the main thread. If this<br/>		/// happens to work on a background thread on any given platform<br/>		/// or backend, it's purely by luck and you should not rely on it<br/>		/// to work next time.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderPresent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLRenderPresent([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLRenderPresentNative((SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// Destroy the specified texture.<br/>
		/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>
		/// to "Invalid texture".<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DestroyTexture")]
		internal static extern void SDLDestroyTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture);

		/// <summary>		/// Destroy the specified texture.<br/>		/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>		/// to "Invalid texture".<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			SDLDestroyTextureNative(texture);
		}

		/// <summary>		/// Destroy the specified texture.<br/>		/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>		/// to "Invalid texture".<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyTexture")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				SDLDestroyTextureNative((SDLTexture*)ptexture);
			}
		}

		/// <summary>
		/// Destroy the rendering context for a window and free associated textures.<br/>
		/// If `renderer` is NULL, this function will return immediately after setting<br/>
		/// the SDL error message to "Invalid renderer". See SDL_GetError().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DestroyRenderer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DestroyRenderer")]
		internal static extern void SDLDestroyRendererNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Destroy the rendering context for a window and free associated textures.<br/>		/// If `renderer` is NULL, this function will return immediately after setting<br/>		/// the SDL error message to "Invalid renderer". See SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyRenderer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyRenderer([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			SDLDestroyRendererNative(renderer);
		}

		/// <summary>		/// Destroy the rendering context for a window and free associated textures.<br/>		/// If `renderer` is NULL, this function will return immediately after setting<br/>		/// the SDL error message to "Invalid renderer". See SDL_GetError().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DestroyRenderer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDestroyRenderer([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLDestroyRendererNative((SDLRenderer*)prenderer);
			}
		}

		/// <summary>
		/// Force the rendering context to flush any pending commands to the underlying<br/>
		/// rendering API.<br/>
		/// You do not need to (and in fact, shouldn't) call this function unless you<br/>
		/// are planning to call into OpenGL/Direct3D/Metal/whatever directly in<br/>
		/// addition to using an SDL_Renderer.<br/>
		/// This is for a very-specific case: if you are using SDL's render API, you<br/>
		/// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set<br/>
		/// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever<br/>
		/// calls in addition to SDL render API calls. If all of this applies, you<br/>
		/// should call SDL_RenderFlush() between calls to SDL's render API and the<br/>
		/// low-level API you're using in cooperation.<br/>
		/// In all other cases, you can ignore this function. This is only here to get<br/>
		/// maximum performance out of a specific situation. In all other cases, SDL<br/>
		/// will do the right thing, perhaps at a performance loss.<br/>
		/// This function is first available in SDL 2.0.10, and is not needed in 2.0.9<br/>
		/// and earlier, as earlier versions did not queue rendering commands at all,<br/>
		/// instead flushing them to the OS immediately.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderFlush")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderFlush")]
		internal static extern int SDLRenderFlushNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Force the rendering context to flush any pending commands to the underlying<br/>		/// rendering API.<br/>		/// You do not need to (and in fact, shouldn't) call this function unless you<br/>		/// are planning to call into OpenGL/Direct3D/Metal/whatever directly in<br/>		/// addition to using an SDL_Renderer.<br/>		/// This is for a very-specific case: if you are using SDL's render API, you<br/>		/// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set<br/>		/// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever<br/>		/// calls in addition to SDL render API calls. If all of this applies, you<br/>		/// should call SDL_RenderFlush() between calls to SDL's render API and the<br/>		/// low-level API you're using in cooperation.<br/>		/// In all other cases, you can ignore this function. This is only here to get<br/>		/// maximum performance out of a specific situation. In all other cases, SDL<br/>		/// will do the right thing, perhaps at a performance loss.<br/>		/// This function is first available in SDL 2.0.10, and is not needed in 2.0.9<br/>		/// and earlier, as earlier versions did not queue rendering commands at all,<br/>		/// instead flushing them to the OS immediately.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFlush")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFlush([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			int ret = SDLRenderFlushNative(renderer);
			return ret;
		}

		/// <summary>		/// Force the rendering context to flush any pending commands to the underlying<br/>		/// rendering API.<br/>		/// You do not need to (and in fact, shouldn't) call this function unless you<br/>		/// are planning to call into OpenGL/Direct3D/Metal/whatever directly in<br/>		/// addition to using an SDL_Renderer.<br/>		/// This is for a very-specific case: if you are using SDL's render API, you<br/>		/// asked for a specific renderer backend (OpenGL, Direct3D, etc), you set<br/>		/// SDL_HINT_RENDER_BATCHING to "1", and you plan to make OpenGL/D3D/whatever<br/>		/// calls in addition to SDL render API calls. If all of this applies, you<br/>		/// should call SDL_RenderFlush() between calls to SDL's render API and the<br/>		/// low-level API you're using in cooperation.<br/>		/// In all other cases, you can ignore this function. This is only here to get<br/>		/// maximum performance out of a specific situation. In all other cases, SDL<br/>		/// will do the right thing, perhaps at a performance loss.<br/>		/// This function is first available in SDL 2.0.10, and is not needed in 2.0.9<br/>		/// and earlier, as earlier versions did not queue rendering commands at all,<br/>		/// instead flushing them to the OS immediately.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderFlush")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderFlush([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderFlushNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>
		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>
		/// directly.<br/>
		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>
		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>
		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>
		/// these values will actually be the pixel width and height used to create the<br/>
		/// texture, so this factor needs to be taken into account when providing<br/>
		/// texture coordinates to OpenGL.<br/>
		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>
		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>
		/// not with your own OpenGL context. If you need control over your OpenGL<br/>
		/// context, you need to write your own texture-loading methods.<br/>
		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>
		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>
		/// may have swapped color channels.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_BindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_BindTexture")]
		internal static extern int SDLGLBindTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "texw")] [NativeName(NativeNameType.Type, "float*")] float* texw, [NativeName(NativeNameType.Param, "texh")] [NativeName(NativeNameType.Type, "float*")] float* texh);

		/// <summary>		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>		/// directly.<br/>		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>		/// these values will actually be the pixel width and height used to create the<br/>		/// texture, so this factor needs to be taken into account when providing<br/>		/// texture coordinates to OpenGL.<br/>		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>		/// not with your own OpenGL context. If you need control over your OpenGL<br/>		/// context, you need to write your own texture-loading methods.<br/>		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>		/// may have swapped color channels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_BindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLBindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "texw")] [NativeName(NativeNameType.Type, "float*")] float* texw, [NativeName(NativeNameType.Param, "texh")] [NativeName(NativeNameType.Type, "float*")] float* texh)
		{
			int ret = SDLGLBindTextureNative(texture, texw, texh);
			return ret;
		}

		/// <summary>		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>		/// directly.<br/>		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>		/// these values will actually be the pixel width and height used to create the<br/>		/// texture, so this factor needs to be taken into account when providing<br/>		/// texture coordinates to OpenGL.<br/>		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>		/// not with your own OpenGL context. If you need control over your OpenGL<br/>		/// context, you need to write your own texture-loading methods.<br/>		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>		/// may have swapped color channels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_BindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLBindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "texw")] [NativeName(NativeNameType.Type, "float*")] float* texw, [NativeName(NativeNameType.Param, "texh")] [NativeName(NativeNameType.Type, "float*")] float* texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGLBindTextureNative((SDLTexture*)ptexture, texw, texh);
				return ret;
			}
		}

		/// <summary>		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>		/// directly.<br/>		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>		/// these values will actually be the pixel width and height used to create the<br/>		/// texture, so this factor needs to be taken into account when providing<br/>		/// texture coordinates to OpenGL.<br/>		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>		/// not with your own OpenGL context. If you need control over your OpenGL<br/>		/// context, you need to write your own texture-loading methods.<br/>		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>		/// may have swapped color channels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_BindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLBindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "texw")] [NativeName(NativeNameType.Type, "float*")] ref float texw, [NativeName(NativeNameType.Param, "texh")] [NativeName(NativeNameType.Type, "float*")] float* texh)
		{
			fixed (float* ptexw = &texw)
			{
				int ret = SDLGLBindTextureNative(texture, (float*)ptexw, texh);
				return ret;
			}
		}

		/// <summary>		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>		/// directly.<br/>		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>		/// these values will actually be the pixel width and height used to create the<br/>		/// texture, so this factor needs to be taken into account when providing<br/>		/// texture coordinates to OpenGL.<br/>		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>		/// not with your own OpenGL context. If you need control over your OpenGL<br/>		/// context, you need to write your own texture-loading methods.<br/>		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>		/// may have swapped color channels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_BindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLBindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "texw")] [NativeName(NativeNameType.Type, "float*")] ref float texw, [NativeName(NativeNameType.Param, "texh")] [NativeName(NativeNameType.Type, "float*")] float* texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ptexw = &texw)
				{
					int ret = SDLGLBindTextureNative((SDLTexture*)ptexture, (float*)ptexw, texh);
					return ret;
				}
			}
		}

		/// <summary>		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>		/// directly.<br/>		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>		/// these values will actually be the pixel width and height used to create the<br/>		/// texture, so this factor needs to be taken into account when providing<br/>		/// texture coordinates to OpenGL.<br/>		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>		/// not with your own OpenGL context. If you need control over your OpenGL<br/>		/// context, you need to write your own texture-loading methods.<br/>		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>		/// may have swapped color channels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_BindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLBindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "texw")] [NativeName(NativeNameType.Type, "float*")] float* texw, [NativeName(NativeNameType.Param, "texh")] [NativeName(NativeNameType.Type, "float*")] ref float texh)
		{
			fixed (float* ptexh = &texh)
			{
				int ret = SDLGLBindTextureNative(texture, texw, (float*)ptexh);
				return ret;
			}
		}

		/// <summary>		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>		/// directly.<br/>		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>		/// these values will actually be the pixel width and height used to create the<br/>		/// texture, so this factor needs to be taken into account when providing<br/>		/// texture coordinates to OpenGL.<br/>		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>		/// not with your own OpenGL context. If you need control over your OpenGL<br/>		/// context, you need to write your own texture-loading methods.<br/>		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>		/// may have swapped color channels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_BindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLBindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "texw")] [NativeName(NativeNameType.Type, "float*")] float* texw, [NativeName(NativeNameType.Param, "texh")] [NativeName(NativeNameType.Type, "float*")] ref float texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ptexh = &texh)
				{
					int ret = SDLGLBindTextureNative((SDLTexture*)ptexture, texw, (float*)ptexh);
					return ret;
				}
			}
		}

		/// <summary>		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>		/// directly.<br/>		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>		/// these values will actually be the pixel width and height used to create the<br/>		/// texture, so this factor needs to be taken into account when providing<br/>		/// texture coordinates to OpenGL.<br/>		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>		/// not with your own OpenGL context. If you need control over your OpenGL<br/>		/// context, you need to write your own texture-loading methods.<br/>		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>		/// may have swapped color channels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_BindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLBindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture, [NativeName(NativeNameType.Param, "texw")] [NativeName(NativeNameType.Type, "float*")] ref float texw, [NativeName(NativeNameType.Param, "texh")] [NativeName(NativeNameType.Type, "float*")] ref float texh)
		{
			fixed (float* ptexw = &texw)
			{
				fixed (float* ptexh = &texh)
				{
					int ret = SDLGLBindTextureNative(texture, (float*)ptexw, (float*)ptexh);
					return ret;
				}
			}
		}

		/// <summary>		/// Bind an OpenGL/ES/ES2 texture to the current context.<br/>		/// This is for use with OpenGL instructions when rendering OpenGL primitives<br/>		/// directly.<br/>		/// If not NULL, `texw` and `texh` will be filled with the width and height<br/>		/// values suitable for the provided texture. In most cases, both will be 1.0,<br/>		/// however, on systems that support the GL_ARB_texture_rectangle extension,<br/>		/// these values will actually be the pixel width and height used to create the<br/>		/// texture, so this factor needs to be taken into account when providing<br/>		/// texture coordinates to OpenGL.<br/>		/// You need a renderer to create an SDL_Texture, therefore you can only use<br/>		/// this function with an implicit OpenGL context from SDL_CreateRenderer(),<br/>		/// not with your own OpenGL context. If you need control over your OpenGL<br/>		/// context, you need to write your own texture-loading methods.<br/>		/// Also note that SDL may upload RGB textures as BGR (or vice-versa), and<br/>		/// re-order the color channels in the shaders phase, so the uploaded texture<br/>		/// may have swapped color channels.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_BindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLBindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture, [NativeName(NativeNameType.Param, "texw")] [NativeName(NativeNameType.Type, "float*")] ref float texw, [NativeName(NativeNameType.Param, "texh")] [NativeName(NativeNameType.Type, "float*")] ref float texh)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				fixed (float* ptexw = &texw)
				{
					fixed (float* ptexh = &texh)
					{
						int ret = SDLGLBindTextureNative((SDLTexture*)ptexture, (float*)ptexw, (float*)ptexh);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Unbind an OpenGL/ES/ES2 texture from the current context.<br/>
		/// See SDL_GL_BindTexture() for examples on how to use these functions<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GL_UnbindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GL_UnbindTexture")]
		internal static extern int SDLGLUnbindTextureNative([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture);

		/// <summary>		/// Unbind an OpenGL/ES/ES2 texture from the current context.<br/>		/// See SDL_GL_BindTexture() for examples on how to use these functions<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_UnbindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLUnbindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] SDLTexture* texture)
		{
			int ret = SDLGLUnbindTextureNative(texture);
			return ret;
		}

		/// <summary>		/// Unbind an OpenGL/ES/ES2 texture from the current context.<br/>		/// See SDL_GL_BindTexture() for examples on how to use these functions<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GL_UnbindTexture")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGLUnbindTexture([NativeName(NativeNameType.Param, "texture")] [NativeName(NativeNameType.Type, "SDL_Texture*")] ref SDLTexture texture)
		{
			fixed (SDLTexture* ptexture = &texture)
			{
				int ret = SDLGLUnbindTextureNative((SDLTexture*)ptexture);
				return ret;
			}
		}

		/// <summary>
		/// Get the CAMetalLayer associated with the given Metal renderer.<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetMetalLayer")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetMetalLayer")]
		internal static extern void* SDLRenderGetMetalLayerNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Get the CAMetalLayer associated with the given Metal renderer.<br/>		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>		/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetMetalLayer")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLRenderGetMetalLayer([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			void* ret = SDLRenderGetMetalLayerNative(renderer);
			return ret;
		}

		/// <summary>		/// Get the CAMetalLayer associated with the given Metal renderer.<br/>		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>		/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetMetalLayer")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLRenderGetMetalLayer([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				void* ret = SDLRenderGetMetalLayerNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the Metal command encoder for the current frame<br/>
		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
		/// headers, but it can be safely cast to an `id<br/>
		/// <MTLRenderCommandEncoder<br/>
		/// >`.<br/>
		/// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give<br/>
		/// SDL a drawable to render to, which might happen if the window is<br/>
		/// hidden/minimized/offscreen. This doesn't apply to command encoders for<br/>
		/// render targets, just the window's backbacker. Check your return values!<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetMetalCommandEncoder")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetMetalCommandEncoder")]
		internal static extern void* SDLRenderGetMetalCommandEncoderNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Get the Metal command encoder for the current frame<br/>		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>		/// headers, but it can be safely cast to an `id<br/>		/// <MTLRenderCommandEncoder<br/>		/// >`.<br/>		/// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give<br/>		/// SDL a drawable to render to, which might happen if the window is<br/>		/// hidden/minimized/offscreen. This doesn't apply to command encoders for<br/>		/// render targets, just the window's backbacker. Check your return values!<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetMetalCommandEncoder")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLRenderGetMetalCommandEncoder([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			void* ret = SDLRenderGetMetalCommandEncoderNative(renderer);
			return ret;
		}

		/// <summary>		/// Get the Metal command encoder for the current frame<br/>		/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>		/// headers, but it can be safely cast to an `id<br/>		/// <MTLRenderCommandEncoder<br/>		/// >`.<br/>		/// Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give<br/>		/// SDL a drawable to render to, which might happen if the window is<br/>		/// hidden/minimized/offscreen. This doesn't apply to command encoders for<br/>		/// render targets, just the window's backbacker. Check your return values!<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetMetalCommandEncoder")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* SDLRenderGetMetalCommandEncoder([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				void* ret = SDLRenderGetMetalCommandEncoderNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Toggle VSync of the given renderer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderSetVSync")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderSetVSync")]
		internal static extern int SDLRenderSetVSyncNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int")] int vsync);

		/// <summary>		/// Toggle VSync of the given renderer.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetVSync")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetVSync([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int")] int vsync)
		{
			int ret = SDLRenderSetVSyncNative(renderer, vsync);
			return ret;
		}

		/// <summary>		/// Toggle VSync of the given renderer.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderSetVSync")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLRenderSetVSync([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "vsync")] [NativeName(NativeNameType.Type, "int")] int vsync)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				int ret = SDLRenderSetVSyncNative((SDLRenderer*)prenderer, vsync);
				return ret;
			}
		}

		/// <summary>
		/// Create a window that can be shaped with the specified position, dimensions,<br/>
		/// and flags.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_CreateShapedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_CreateShapedWindow")]
		internal static extern SDLWindow* SDLCreateShapedWindowNative([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "unsigned int")] uint x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "unsigned int")] uint y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "unsigned int")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "unsigned int")] uint h, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Create a window that can be shaped with the specified position, dimensions,<br/>		/// and flags.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateShapedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLCreateShapedWindow([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] byte* title, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "unsigned int")] uint x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "unsigned int")] uint y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "unsigned int")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "unsigned int")] uint h, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			SDLWindow* ret = SDLCreateShapedWindowNative(title, x, y, w, h, flags);
			return ret;
		}

		/// <summary>		/// Create a window that can be shaped with the specified position, dimensions,<br/>		/// and flags.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateShapedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLCreateShapedWindow([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] ref byte title, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "unsigned int")] uint x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "unsigned int")] uint y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "unsigned int")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "unsigned int")] uint h, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			fixed (byte* ptitle = &title)
			{
				SDLWindow* ret = SDLCreateShapedWindowNative((byte*)ptitle, x, y, w, h, flags);
				return ret;
			}
		}

		/// <summary>		/// Create a window that can be shaped with the specified position, dimensions,<br/>		/// and flags.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_CreateShapedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_Window*")]
		public static SDLWindow* SDLCreateShapedWindow([NativeName(NativeNameType.Param, "title")] [NativeName(NativeNameType.Type, "const char*")] string title, [NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "unsigned int")] uint x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "unsigned int")] uint y, [NativeName(NativeNameType.Param, "w")] [NativeName(NativeNameType.Type, "unsigned int")] uint w, [NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "unsigned int")] uint h, [NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (title != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(title);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(title, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLWindow* ret = SDLCreateShapedWindowNative(pStr0, x, y, w, h, flags);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Return whether the given window is a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsShapedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IsShapedWindow")]
		internal static extern SDLBool SDLIsShapedWindowNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "const SDL_Window*")] SDLWindow* window);

		/// <summary>		/// Return whether the given window is a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsShapedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsShapedWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "const SDL_Window*")] SDLWindow* window)
		{
			SDLBool ret = SDLIsShapedWindowNative(window);
			return ret;
		}

		/// <summary>		/// Return whether the given window is a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsShapedWindow")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsShapedWindow([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "const SDL_Window*")] ref SDLWindow window)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				SDLBool ret = SDLIsShapedWindowNative((SDLWindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// Set the shape and parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowShape")]
		internal static extern int SDLSetWindowShapeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* shape, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] SDLWindowShapeMode* shapeMode);

		/// <summary>		/// Set the shape and parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* shape, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] SDLWindowShapeMode* shapeMode)
		{
			int ret = SDLSetWindowShapeNative(window, shape, shapeMode);
			return ret;
		}

		/// <summary>		/// Set the shape and parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* shape, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] SDLWindowShapeMode* shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLSetWindowShapeNative((SDLWindow*)pwindow, shape, shapeMode);
				return ret;
			}
		}

		/// <summary>		/// Set the shape and parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface shape, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] SDLWindowShapeMode* shapeMode)
		{
			fixed (SDLSurface* pshape = &shape)
			{
				int ret = SDLSetWindowShapeNative(window, (SDLSurface*)pshape, shapeMode);
				return ret;
			}
		}

		/// <summary>		/// Set the shape and parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface shape, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] SDLWindowShapeMode* shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* pshape = &shape)
				{
					int ret = SDLSetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)pshape, shapeMode);
					return ret;
				}
			}
		}

		/// <summary>		/// Set the shape and parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* shape, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
			{
				int ret = SDLSetWindowShapeNative(window, shape, (SDLWindowShapeMode*)pshapeMode);
				return ret;
			}
		}

		/// <summary>		/// Set the shape and parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* shape, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
				{
					int ret = SDLSetWindowShapeNative((SDLWindow*)pwindow, shape, (SDLWindowShapeMode*)pshapeMode);
					return ret;
				}
			}
		}

		/// <summary>		/// Set the shape and parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface shape, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLSurface* pshape = &shape)
			{
				fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
				{
					int ret = SDLSetWindowShapeNative(window, (SDLSurface*)pshape, (SDLWindowShapeMode*)pshapeMode);
					return ret;
				}
			}
		}

		/// <summary>		/// Set the shape and parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowShape")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLSetWindowShape([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface shape, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLSurface* pshape = &shape)
				{
					fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
					{
						int ret = SDLSetWindowShapeNative((SDLWindow*)pwindow, (SDLSurface*)pshape, (SDLWindowShapeMode*)pshapeMode);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Get the shape parameters of a shaped window.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetShapedWindowMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetShapedWindowMode")]
		internal static extern int SDLGetShapedWindowModeNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] SDLWindowShapeMode* shapeMode);

		/// <summary>		/// Get the shape parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetShapedWindowMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetShapedWindowMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] SDLWindowShapeMode* shapeMode)
		{
			int ret = SDLGetShapedWindowModeNative(window, shapeMode);
			return ret;
		}

		/// <summary>		/// Get the shape parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetShapedWindowMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetShapedWindowMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] SDLWindowShapeMode* shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				int ret = SDLGetShapedWindowModeNative((SDLWindow*)pwindow, shapeMode);
				return ret;
			}
		}

		/// <summary>		/// Get the shape parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetShapedWindowMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetShapedWindowMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] SDLWindow* window, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
			{
				int ret = SDLGetShapedWindowModeNative(window, (SDLWindowShapeMode*)pshapeMode);
				return ret;
			}
		}

		/// <summary>		/// Get the shape parameters of a shaped window.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetShapedWindowMode")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetShapedWindowMode([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "SDL_Window*")] ref SDLWindow window, [NativeName(NativeNameType.Param, "shape_mode")] [NativeName(NativeNameType.Type, "SDL_WindowShapeMode*")] ref SDLWindowShapeMode shapeMode)
		{
			fixed (SDLWindow* pwindow = &window)
			{
				fixed (SDLWindowShapeMode* pshapeMode = &shapeMode)
				{
					int ret = SDLGetShapedWindowModeNative((SDLWindow*)pwindow, (SDLWindowShapeMode*)pshapeMode);
					return ret;
				}
			}
		}

		/// <summary>
		/// Set a callback for every Windows message, run before TranslateMessage().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_SetWindowsMessageHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_SetWindowsMessageHook")]
		internal static extern void SDLSetWindowsMessageHookNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_WindowsMessageHook")] SDLWindowsMessageHook callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata);

		/// <summary>		/// Set a callback for every Windows message, run before TranslateMessage().<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_SetWindowsMessageHook")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLSetWindowsMessageHook([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_WindowsMessageHook")] SDLWindowsMessageHook callback, [NativeName(NativeNameType.Param, "userdata")] [NativeName(NativeNameType.Type, "void*")] void* userdata)
		{
			SDLSetWindowsMessageHookNative(callback, userdata);
		}

		/// <summary>
		/// Get the D3D9 adapter index that matches the specified display index.<br/>
		/// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and<br/>
		/// controls on which monitor a full screen application will appear.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Direct3D9GetAdapterIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Direct3D9GetAdapterIndex")]
		internal static extern int SDLDirect3D9GetAdapterIndexNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex);

		/// <summary>		/// Get the D3D9 adapter index that matches the specified display index.<br/>		/// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and<br/>		/// controls on which monitor a full screen application will appear.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Direct3D9GetAdapterIndex")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLDirect3D9GetAdapterIndex([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex)
		{
			int ret = SDLDirect3D9GetAdapterIndexNative(displayIndex);
			return ret;
		}

		/// <summary>
		/// Get the D3D9 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetD3D9Device")]
		[return: NativeName(NativeNameType.Type, "IDirect3DDevice9*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetD3D9Device")]
		internal static extern IDirect3DDevice9* SDLRenderGetD3D9DeviceNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Get the D3D9 device associated with a renderer.<br/>		/// Once you are done using the device, you should release it to avoid a<br/>		/// resource leak.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetD3D9Device")]
		[return: NativeName(NativeNameType.Type, "IDirect3DDevice9*")]
		public static IDirect3DDevice9* SDLRenderGetD3D9Device([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			IDirect3DDevice9* ret = SDLRenderGetD3D9DeviceNative(renderer);
			return ret;
		}

		/// <summary>		/// Get the D3D9 device associated with a renderer.<br/>		/// Once you are done using the device, you should release it to avoid a<br/>		/// resource leak.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetD3D9Device")]
		[return: NativeName(NativeNameType.Type, "IDirect3DDevice9*")]
		public static IDirect3DDevice9* SDLRenderGetD3D9Device([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				IDirect3DDevice9* ret = SDLRenderGetD3D9DeviceNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the D3D11 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetD3D11Device")]
		[return: NativeName(NativeNameType.Type, "ID3D11Device*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetD3D11Device")]
		internal static extern ID3D11Device* SDLRenderGetD3D11DeviceNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Get the D3D11 device associated with a renderer.<br/>		/// Once you are done using the device, you should release it to avoid a<br/>		/// resource leak.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetD3D11Device")]
		[return: NativeName(NativeNameType.Type, "ID3D11Device*")]
		public static ID3D11Device* SDLRenderGetD3D11Device([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			ID3D11Device* ret = SDLRenderGetD3D11DeviceNative(renderer);
			return ret;
		}

		/// <summary>		/// Get the D3D11 device associated with a renderer.<br/>		/// Once you are done using the device, you should release it to avoid a<br/>		/// resource leak.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetD3D11Device")]
		[return: NativeName(NativeNameType.Type, "ID3D11Device*")]
		public static ID3D11Device* SDLRenderGetD3D11Device([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				ID3D11Device* ret = SDLRenderGetD3D11DeviceNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the D3D12 device associated with a renderer.<br/>
		/// Once you are done using the device, you should release it to avoid a<br/>
		/// resource leak.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RenderGetD3D12Device")]
		[return: NativeName(NativeNameType.Type, "ID3D12Device*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RenderGetD3D12Device")]
		internal static extern ID3D12Device* SDLRenderGetD3D12DeviceNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer);

		/// <summary>		/// Get the D3D12 device associated with a renderer.<br/>		/// Once you are done using the device, you should release it to avoid a<br/>		/// resource leak.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetD3D12Device")]
		[return: NativeName(NativeNameType.Type, "ID3D12Device*")]
		public static ID3D12Device* SDLRenderGetD3D12Device([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer)
		{
			ID3D12Device* ret = SDLRenderGetD3D12DeviceNative(renderer);
			return ret;
		}

		/// <summary>		/// Get the D3D12 device associated with a renderer.<br/>		/// Once you are done using the device, you should release it to avoid a<br/>		/// resource leak.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RenderGetD3D12Device")]
		[return: NativeName(NativeNameType.Type, "ID3D12Device*")]
		public static ID3D12Device* SDLRenderGetD3D12Device([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				ID3D12Device* ret = SDLRenderGetD3D12DeviceNative((SDLRenderer*)prenderer);
				return ret;
			}
		}

		/// <summary>
		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>
		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
		/// DX11 device and swap chain.<br/>
		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>
		/// returns an SDL_bool.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_DXGIGetOutputInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_DXGIGetOutputInfo")]
		internal static extern SDLBool SDLDXGIGetOutputInfoNative([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int*")] int* adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int*")] int* outputIndex);

		/// <summary>		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>		/// DX11 device and swap chain.<br/>		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>		/// returns an SDL_bool.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DXGIGetOutputInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLDXGIGetOutputInfo([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int*")] int* adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int*")] int* outputIndex)
		{
			SDLBool ret = SDLDXGIGetOutputInfoNative(displayIndex, adapterIndex, outputIndex);
			return ret;
		}

		/// <summary>		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>		/// DX11 device and swap chain.<br/>		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>		/// returns an SDL_bool.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DXGIGetOutputInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLDXGIGetOutputInfo([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int*")] ref int adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int*")] int* outputIndex)
		{
			fixed (int* padapterIndex = &adapterIndex)
			{
				SDLBool ret = SDLDXGIGetOutputInfoNative(displayIndex, (int*)padapterIndex, outputIndex);
				return ret;
			}
		}

		/// <summary>		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>		/// DX11 device and swap chain.<br/>		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>		/// returns an SDL_bool.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DXGIGetOutputInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLDXGIGetOutputInfo([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int*")] int* adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int*")] ref int outputIndex)
		{
			fixed (int* poutputIndex = &outputIndex)
			{
				SDLBool ret = SDLDXGIGetOutputInfoNative(displayIndex, adapterIndex, (int*)poutputIndex);
				return ret;
			}
		}

		/// <summary>		/// Get the DXGI Adapter and Output indices for the specified display index.<br/>		/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>		/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>		/// DX11 device and swap chain.<br/>		/// Before SDL 2.0.4 this function did not return a value. Since SDL 2.0.4 it<br/>		/// returns an SDL_bool.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_DXGIGetOutputInfo")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLDXGIGetOutputInfo([NativeName(NativeNameType.Param, "displayIndex")] [NativeName(NativeNameType.Type, "int")] int displayIndex, [NativeName(NativeNameType.Param, "adapterIndex")] [NativeName(NativeNameType.Type, "int*")] ref int adapterIndex, [NativeName(NativeNameType.Param, "outputIndex")] [NativeName(NativeNameType.Type, "int*")] ref int outputIndex)
		{
			fixed (int* padapterIndex = &adapterIndex)
			{
				fixed (int* poutputIndex = &outputIndex)
				{
					SDLBool ret = SDLDXGIGetOutputInfoNative(displayIndex, (int*)padapterIndex, (int*)poutputIndex);
					return ret;
				}
			}
		}

		/// <summary>
		/// Query if the current device is a tablet.<br/>
		/// If SDL can't determine this, it will return SDL_FALSE.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_IsTablet")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_IsTablet")]
		internal static extern SDLBool SDLIsTabletNative();

		/// <summary>		/// Query if the current device is a tablet.<br/>		/// If SDL can't determine this, it will return SDL_FALSE.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_IsTablet")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLIsTablet()
		{
			SDLBool ret = SDLIsTabletNative();
			return ret;
		}

		/// <summary>
		/// Functions used by iOS application delegates to notify SDL about state changes <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillTerminate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_OnApplicationWillTerminate")]
		internal static extern void SDLOnApplicationWillTerminateNative();

		/// <summary>		/// Functions used by iOS application delegates to notify SDL about state changes <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillTerminate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLOnApplicationWillTerminate()
		{
			SDLOnApplicationWillTerminateNative();
		}

		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidReceiveMemoryWarning")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_OnApplicationDidReceiveMemoryWarning")]
		internal static extern void SDLOnApplicationDidReceiveMemoryWarningNative();

		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidReceiveMemoryWarning")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLOnApplicationDidReceiveMemoryWarning()
		{
			SDLOnApplicationDidReceiveMemoryWarningNative();
		}

		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillResignActive")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_OnApplicationWillResignActive")]
		internal static extern void SDLOnApplicationWillResignActiveNative();

		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillResignActive")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLOnApplicationWillResignActive()
		{
			SDLOnApplicationWillResignActiveNative();
		}

		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidEnterBackground")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_OnApplicationDidEnterBackground")]
		internal static extern void SDLOnApplicationDidEnterBackgroundNative();

		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidEnterBackground")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLOnApplicationDidEnterBackground()
		{
			SDLOnApplicationDidEnterBackgroundNative();
		}

		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillEnterForeground")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_OnApplicationWillEnterForeground")]
		internal static extern void SDLOnApplicationWillEnterForegroundNative();

		[NativeName(NativeNameType.Func, "SDL_OnApplicationWillEnterForeground")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLOnApplicationWillEnterForeground()
		{
			SDLOnApplicationWillEnterForegroundNative();
		}

		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidBecomeActive")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_OnApplicationDidBecomeActive")]
		internal static extern void SDLOnApplicationDidBecomeActiveNative();

		[NativeName(NativeNameType.Func, "SDL_OnApplicationDidBecomeActive")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLOnApplicationDidBecomeActive()
		{
			SDLOnApplicationDidBecomeActiveNative();
		}

		/// <summary>
		/// Get the number of milliseconds since SDL library initialization.<br/>
		/// This value wraps if the program runs for more than ~49 days.<br/>
		/// This function is not recommended as of SDL 2.0.18; use SDL_GetTicks64()<br/>
		/// instead, where the value doesn't wrap every ~49 days. There are places in<br/>
		/// SDL where we provide a 32-bit timestamp that can not change without<br/>
		/// breaking binary compatibility, though, so this function isn't officially<br/>
		/// deprecated.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTicks")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTicks")]
		internal static extern uint SDLGetTicksNative();

		/// <summary>		/// Get the number of milliseconds since SDL library initialization.<br/>		/// This value wraps if the program runs for more than ~49 days.<br/>		/// This function is not recommended as of SDL 2.0.18; use SDL_GetTicks64()<br/>		/// instead, where the value doesn't wrap every ~49 days. There are places in<br/>		/// SDL where we provide a 32-bit timestamp that can not change without<br/>		/// breaking binary compatibility, though, so this function isn't officially<br/>		/// deprecated.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTicks")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLGetTicks()
		{
			uint ret = SDLGetTicksNative();
			return ret;
		}

		/// <summary>
		/// Get the number of milliseconds since SDL library initialization.<br/>
		/// Note that you should not use the SDL_TICKS_PASSED macro with values<br/>
		/// returned by this function, as that macro does clever math to compensate for<br/>
		/// the 32-bit overflow every ~49 days that SDL_GetTicks() suffers from. 64-bit<br/>
		/// values from this function can be safely compared directly.<br/>
		/// For example, if you want to wait 100 ms, you could do this:<br/>
		/// ```c<br/>
		/// const Uint64 timeout = SDL_GetTicks64() + 100;<br/>
		/// while (SDL_GetTicks64() <br/>
		/// <<br/>
		/// timeout) {<br/>
		/// // ... do work until timeout has elapsed<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetTicks64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetTicks64")]
		internal static extern ulong SDLGetTicks64Native();

		/// <summary>		/// Get the number of milliseconds since SDL library initialization.<br/>		/// Note that you should not use the SDL_TICKS_PASSED macro with values<br/>		/// returned by this function, as that macro does clever math to compensate for<br/>		/// the 32-bit overflow every ~49 days that SDL_GetTicks() suffers from. 64-bit<br/>		/// values from this function can be safely compared directly.<br/>		/// For example, if you want to wait 100 ms, you could do this:<br/>		/// ```c<br/>		/// const Uint64 timeout = SDL_GetTicks64() + 100;<br/>		/// while (SDL_GetTicks64() <br/>		/// <<br/>		/// timeout) {<br/>		/// // ... do work until timeout has elapsed<br/>		/// }<br/>		/// ```<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetTicks64")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLGetTicks64()
		{
			ulong ret = SDLGetTicks64Native();
			return ret;
		}

		/// <summary>
		/// Get the current value of the high resolution counter.<br/>
		/// This function is typically used for profiling.<br/>
		/// The counter values are only meaningful relative to each other. Differences<br/>
		/// between values can be converted to times by using<br/>
		/// SDL_GetPerformanceFrequency().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPerformanceCounter")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetPerformanceCounter")]
		internal static extern ulong SDLGetPerformanceCounterNative();

		/// <summary>		/// Get the current value of the high resolution counter.<br/>		/// This function is typically used for profiling.<br/>		/// The counter values are only meaningful relative to each other. Differences<br/>		/// between values can be converted to times by using<br/>		/// SDL_GetPerformanceFrequency().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPerformanceCounter")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLGetPerformanceCounter()
		{
			ulong ret = SDLGetPerformanceCounterNative();
			return ret;
		}

		/// <summary>
		/// Get the count per second of the high resolution counter.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPerformanceFrequency")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetPerformanceFrequency")]
		internal static extern ulong SDLGetPerformanceFrequencyNative();

		/// <summary>		/// Get the count per second of the high resolution counter.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPerformanceFrequency")]
		[return: NativeName(NativeNameType.Type, "Uint64")]
		public static ulong SDLGetPerformanceFrequency()
		{
			ulong ret = SDLGetPerformanceFrequencyNative();
			return ret;
		}

		/// <summary>
		/// Wait a specified number of milliseconds before returning.<br/>
		/// This function waits a specified number of milliseconds before returning. It<br/>
		/// waits at least the specified time, but possibly longer due to OS<br/>
		/// scheduling.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Delay")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Delay")]
		internal static extern void SDLDelayNative([NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms);

		/// <summary>		/// Wait a specified number of milliseconds before returning.<br/>		/// This function waits a specified number of milliseconds before returning. It<br/>		/// waits at least the specified time, but possibly longer due to OS<br/>		/// scheduling.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Delay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLDelay([NativeName(NativeNameType.Param, "ms")] [NativeName(NativeNameType.Type, "Uint32")] uint ms)
		{
			SDLDelayNative(ms);
		}

		/// <summary>
		/// Call a callback function at a future time.<br/>
		/// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().<br/>
		/// The callback function is passed the current timer interval and the user<br/>
		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
		/// timer interval. If the value returned from the callback is 0, the timer is<br/>
		/// canceled.<br/>
		/// The callback is run on a separate thread.<br/>
		/// Timers take into account the amount of time it took to execute the<br/>
		/// callback. For example, if the callback took 250 ms to execute and returned<br/>
		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
		/// iteration.<br/>
		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
		/// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your<br/>
		/// callback needs to adjust for variances.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_AddTimer")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_AddTimer")]
		internal static extern int SDLAddTimerNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint32")] uint interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TimerCallback")] SDLTimerCallback callback, [NativeName(NativeNameType.Param, "param")] [NativeName(NativeNameType.Type, "void*")] void* param);

		/// <summary>		/// Call a callback function at a future time.<br/>		/// If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().<br/>		/// The callback function is passed the current timer interval and the user<br/>		/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>		/// timer interval. If the value returned from the callback is 0, the timer is<br/>		/// canceled.<br/>		/// The callback is run on a separate thread.<br/>		/// Timers take into account the amount of time it took to execute the<br/>		/// callback. For example, if the callback took 250 ms to execute and returned<br/>		/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>		/// iteration.<br/>		/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>		/// time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your<br/>		/// callback needs to adjust for variances.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_AddTimer")]
		[return: NativeName(NativeNameType.Type, "SDL_TimerID")]
		public static int SDLAddTimer([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "Uint32")] uint interval, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "SDL_TimerCallback")] SDLTimerCallback callback, [NativeName(NativeNameType.Param, "param")] [NativeName(NativeNameType.Type, "void*")] void* param)
		{
			int ret = SDLAddTimerNative(interval, callback, param);
			return ret;
		}

		/// <summary>
		/// Remove a timer created with SDL_AddTimer().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_RemoveTimer")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_RemoveTimer")]
		internal static extern SDLBool SDLRemoveTimerNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TimerID")] int id);

		/// <summary>		/// Remove a timer created with SDL_AddTimer().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_RemoveTimer")]
		[return: NativeName(NativeNameType.Type, "SDL_bool")]
		public static SDLBool SDLRemoveTimer([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "SDL_TimerID")] int id)
		{
			SDLBool ret = SDLRemoveTimerNative(id);
			return ret;
		}

		/// <summary>
		/// Get the version of SDL that is linked against your program.<br/>
		/// If you are linking to SDL dynamically, then it is possible that the current<br/>
		/// version will be different than the version you compiled against. This<br/>
		/// function returns the current version, while SDL_VERSION() is a macro that<br/>
		/// tells you what version you compiled with.<br/>
		/// This function may be called safely at any time, even before SDL_Init().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetVersion")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetVersion")]
		internal static extern void SDLGetVersionNative([NativeName(NativeNameType.Param, "ver")] [NativeName(NativeNameType.Type, "SDL_version*")] SDLVersion* ver);

		/// <summary>		/// Get the version of SDL that is linked against your program.<br/>		/// If you are linking to SDL dynamically, then it is possible that the current<br/>		/// version will be different than the version you compiled against. This<br/>		/// function returns the current version, while SDL_VERSION() is a macro that<br/>		/// tells you what version you compiled with.<br/>		/// This function may be called safely at any time, even before SDL_Init().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetVersion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetVersion([NativeName(NativeNameType.Param, "ver")] [NativeName(NativeNameType.Type, "SDL_version*")] SDLVersion* ver)
		{
			SDLGetVersionNative(ver);
		}

		/// <summary>		/// Get the version of SDL that is linked against your program.<br/>		/// If you are linking to SDL dynamically, then it is possible that the current<br/>		/// version will be different than the version you compiled against. This<br/>		/// function returns the current version, while SDL_VERSION() is a macro that<br/>		/// tells you what version you compiled with.<br/>		/// This function may be called safely at any time, even before SDL_Init().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetVersion")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLGetVersion([NativeName(NativeNameType.Param, "ver")] [NativeName(NativeNameType.Type, "SDL_version*")] ref SDLVersion ver)
		{
			fixed (SDLVersion* pver = &ver)
			{
				SDLGetVersionNative((SDLVersion*)pver);
			}
		}

		/// <summary>
		/// Get the code revision of SDL that is linked against your program.<br/>
		/// This value is the revision of the code you are linked with and may be<br/>
		/// different from the code you are compiling with, which is found in the<br/>
		/// constant SDL_REVISION.<br/>
		/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>
		/// exact revision of the SDL library in use, and is only useful in comparing<br/>
		/// against other revisions. It is NOT an incrementing number.<br/>
		/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>
		/// will return an empty string.<br/>
		/// Prior to SDL 2.0.16, before development moved to GitHub, this returned a<br/>
		/// hash for a Mercurial repository.<br/>
		/// You shouldn't use this function for anything but logging it for debugging<br/>
		/// purposes. The string is not intended to be reliable in any way.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRevision")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRevision")]
		internal static extern byte* SDLGetRevisionNative();

		/// <summary>		/// Get the code revision of SDL that is linked against your program.<br/>		/// This value is the revision of the code you are linked with and may be<br/>		/// different from the code you are compiling with, which is found in the<br/>		/// constant SDL_REVISION.<br/>		/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>		/// exact revision of the SDL library in use, and is only useful in comparing<br/>		/// against other revisions. It is NOT an incrementing number.<br/>		/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>		/// will return an empty string.<br/>		/// Prior to SDL 2.0.16, before development moved to GitHub, this returned a<br/>		/// hash for a Mercurial repository.<br/>		/// You shouldn't use this function for anything but logging it for debugging<br/>		/// purposes. The string is not intended to be reliable in any way.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRevision")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* SDLGetRevision()
		{
			byte* ret = SDLGetRevisionNative();
			return ret;
		}

		/// <summary>		/// Get the code revision of SDL that is linked against your program.<br/>		/// This value is the revision of the code you are linked with and may be<br/>		/// different from the code you are compiling with, which is found in the<br/>		/// constant SDL_REVISION.<br/>		/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>		/// exact revision of the SDL library in use, and is only useful in comparing<br/>		/// against other revisions. It is NOT an incrementing number.<br/>		/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>		/// will return an empty string.<br/>		/// Prior to SDL 2.0.16, before development moved to GitHub, this returned a<br/>		/// hash for a Mercurial repository.<br/>		/// You shouldn't use this function for anything but logging it for debugging<br/>		/// purposes. The string is not intended to be reliable in any way.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRevision")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string SDLGetRevisionS()
		{
			string ret = Utils.DecodeStringUTF8(SDLGetRevisionNative());
			return ret;
		}

		/// <summary>
		/// Obsolete function, do not use.<br/>
		/// When SDL was hosted in a Mercurial repository, and was built carefully,<br/>
		/// this would return the revision number that the build was created from. This<br/>
		/// number was not reliable for several reasons, but more importantly, SDL is<br/>
		/// now hosted in a git repository, which does not offer numbers at all, only<br/>
		/// hashes. This function only ever returns zero now. Don't use it.<br/>
		/// Before SDL 2.0.16, this might have returned an unreliable, but non-zero<br/>
		/// number.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetRevisionNumber")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetRevisionNumber")]
		internal static extern int SDLGetRevisionNumberNative();

		/// <summary>		/// Obsolete function, do not use.<br/>		/// When SDL was hosted in a Mercurial repository, and was built carefully,<br/>		/// this would return the revision number that the build was created from. This<br/>		/// number was not reliable for several reasons, but more importantly, SDL is<br/>		/// now hosted in a git repository, which does not offer numbers at all, only<br/>		/// hashes. This function only ever returns zero now. Don't use it.<br/>		/// Before SDL 2.0.16, this might have returned an unreliable, but non-zero<br/>		/// number.<br/>		/// <br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetRevisionNumber")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLGetRevisionNumber()
		{
			int ret = SDLGetRevisionNumberNative();
			return ret;
		}

		/// <summary>
		/// Report the user's preferred locale.<br/>
		/// This returns an array of SDL_Locale structs, the final item zeroed out.<br/>
		/// When the caller is done with this array, it should call SDL_free() on the<br/>
		/// returned value; all the memory involved is allocated in a single block, so<br/>
		/// a single SDL_free() will suffice.<br/>
		/// Returned language strings are in the format xx, where 'xx' is an ISO-639<br/>
		/// language specifier (such as "en" for English, "de" for German, etc).<br/>
		/// Country strings are in the format YY, where "YY" is an ISO-3166 country<br/>
		/// code (such as "US" for the United States, "CA" for Canada, etc). Country<br/>
		/// might be NULL if there's no specific guidance on them (so you might get {<br/>
		/// "en", "US" } for American English, but { "en", NULL } means "English<br/>
		/// language, generically"). Language strings are never NULL, except to<br/>
		/// terminate the array.<br/>
		/// Please note that not all of these strings are 2 characters; some are three<br/>
		/// or more.<br/>
		/// The returned list of locales are in the order of the user's preference. For<br/>
		/// example, a German citizen that is fluent in US English and knows enough<br/>
		/// Japanese to navigate around Tokyo might have a list like: { "de", "en_US",<br/>
		/// "jp", NULL }. Someone from England might prefer British English (where<br/>
		/// "color" is spelled "colour", etc), but will settle for anything like it: {<br/>
		/// "en_GB", "en", NULL }.<br/>
		/// This function returns NULL on error, including when the platform does not<br/>
		/// supply this information at all.<br/>
		/// This might be a "slow" call that has to query the operating system. It's<br/>
		/// best to ask for this once and save the results. However, this list can<br/>
		/// change, usually because the user has changed a system preference outside of<br/>
		/// your program; SDL will send an SDL_LOCALECHANGED event in this case, if<br/>
		/// possible, and you can call this function again to get an updated copy of<br/>
		/// preferred locales.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_GetPreferredLocales")]
		[return: NativeName(NativeNameType.Type, "SDL_Locale*")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_GetPreferredLocales")]
		internal static extern SDLLocale* SDLGetPreferredLocalesNative();

		/// <summary>		/// Report the user's preferred locale.<br/>		/// This returns an array of SDL_Locale structs, the final item zeroed out.<br/>		/// When the caller is done with this array, it should call SDL_free() on the<br/>		/// returned value; all the memory involved is allocated in a single block, so<br/>		/// a single SDL_free() will suffice.<br/>		/// Returned language strings are in the format xx, where 'xx' is an ISO-639<br/>		/// language specifier (such as "en" for English, "de" for German, etc).<br/>		/// Country strings are in the format YY, where "YY" is an ISO-3166 country<br/>		/// code (such as "US" for the United States, "CA" for Canada, etc). Country<br/>		/// might be NULL if there's no specific guidance on them (so you might get {<br/>		/// "en", "US" } for American English, but { "en", NULL } means "English<br/>		/// language, generically"). Language strings are never NULL, except to<br/>		/// terminate the array.<br/>		/// Please note that not all of these strings are 2 characters; some are three<br/>		/// or more.<br/>		/// The returned list of locales are in the order of the user's preference. For<br/>		/// example, a German citizen that is fluent in US English and knows enough<br/>		/// Japanese to navigate around Tokyo might have a list like: { "de", "en_US",<br/>		/// "jp", NULL }. Someone from England might prefer British English (where<br/>		/// "color" is spelled "colour", etc), but will settle for anything like it: {<br/>		/// "en_GB", "en", NULL }.<br/>		/// This function returns NULL on error, including when the platform does not<br/>		/// supply this information at all.<br/>		/// This might be a "slow" call that has to query the operating system. It's<br/>		/// best to ask for this once and save the results. However, this list can<br/>		/// change, usually because the user has changed a system preference outside of<br/>		/// your program; SDL will send an SDL_LOCALECHANGED event in this case, if<br/>		/// possible, and you can call this function again to get an updated copy of<br/>		/// preferred locales.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_GetPreferredLocales")]
		[return: NativeName(NativeNameType.Type, "SDL_Locale*")]
		public static SDLLocale* SDLGetPreferredLocales()
		{
			SDLLocale* ret = SDLGetPreferredLocalesNative();
			return ret;
		}

		/// <summary>
		/// Open a URL/URI in the browser or other appropriate external application.<br/>
		/// Open a URL in a separate, system-provided application. How this works will<br/>
		/// vary wildly depending on the platform. This will likely launch what makes<br/>
		/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>
		/// etc), but it might also be able to launch file managers for directories and<br/>
		/// other things.<br/>
		/// What happens when you open a URL varies wildly as well: your game window<br/>
		/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>
		/// or grabbing input at the time). On mobile devices, your app will likely<br/>
		/// move to the background or your process might be paused. Any given platform<br/>
		/// may or may not handle a given URL.<br/>
		/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>
		/// fail with an error. A successful result does not mean the URL loaded, just<br/>
		/// that we launched _something_ to handle it (or at least believe we did).<br/>
		/// All this to say: this function can be useful, but you should definitely<br/>
		/// test it on every platform you target.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_OpenURL")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_OpenURL")]
		internal static extern int SDLOpenURLNative([NativeName(NativeNameType.Param, "url")] [NativeName(NativeNameType.Type, "const char*")] byte* url);

		/// <summary>		/// Open a URL/URI in the browser or other appropriate external application.<br/>		/// Open a URL in a separate, system-provided application. How this works will<br/>		/// vary wildly depending on the platform. This will likely launch what makes<br/>		/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>		/// etc), but it might also be able to launch file managers for directories and<br/>		/// other things.<br/>		/// What happens when you open a URL varies wildly as well: your game window<br/>		/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>		/// or grabbing input at the time). On mobile devices, your app will likely<br/>		/// move to the background or your process might be paused. Any given platform<br/>		/// may or may not handle a given URL.<br/>		/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>		/// fail with an error. A successful result does not mean the URL loaded, just<br/>		/// that we launched _something_ to handle it (or at least believe we did).<br/>		/// All this to say: this function can be useful, but you should definitely<br/>		/// test it on every platform you target.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenURL")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenURL([NativeName(NativeNameType.Param, "url")] [NativeName(NativeNameType.Type, "const char*")] byte* url)
		{
			int ret = SDLOpenURLNative(url);
			return ret;
		}

		/// <summary>		/// Open a URL/URI in the browser or other appropriate external application.<br/>		/// Open a URL in a separate, system-provided application. How this works will<br/>		/// vary wildly depending on the platform. This will likely launch what makes<br/>		/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>		/// etc), but it might also be able to launch file managers for directories and<br/>		/// other things.<br/>		/// What happens when you open a URL varies wildly as well: your game window<br/>		/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>		/// or grabbing input at the time). On mobile devices, your app will likely<br/>		/// move to the background or your process might be paused. Any given platform<br/>		/// may or may not handle a given URL.<br/>		/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>		/// fail with an error. A successful result does not mean the URL loaded, just<br/>		/// that we launched _something_ to handle it (or at least believe we did).<br/>		/// All this to say: this function can be useful, but you should definitely<br/>		/// test it on every platform you target.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenURL")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenURL([NativeName(NativeNameType.Param, "url")] [NativeName(NativeNameType.Type, "const char*")] ref byte url)
		{
			fixed (byte* purl = &url)
			{
				int ret = SDLOpenURLNative((byte*)purl);
				return ret;
			}
		}

		/// <summary>		/// Open a URL/URI in the browser or other appropriate external application.<br/>		/// Open a URL in a separate, system-provided application. How this works will<br/>		/// vary wildly depending on the platform. This will likely launch what makes<br/>		/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>		/// etc), but it might also be able to launch file managers for directories and<br/>		/// other things.<br/>		/// What happens when you open a URL varies wildly as well: your game window<br/>		/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>		/// or grabbing input at the time). On mobile devices, your app will likely<br/>		/// move to the background or your process might be paused. Any given platform<br/>		/// may or may not handle a given URL.<br/>		/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>		/// fail with an error. A successful result does not mean the URL loaded, just<br/>		/// that we launched _something_ to handle it (or at least believe we did).<br/>		/// All this to say: this function can be useful, but you should definitely<br/>		/// test it on every platform you target.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_OpenURL")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLOpenURL([NativeName(NativeNameType.Param, "url")] [NativeName(NativeNameType.Type, "const char*")] string url)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (url != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(url);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(url, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SDLOpenURLNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Initialize the SDL library.<br/>
		/// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the<br/>
		/// two may be used interchangeably. Though for readability of your code<br/>
		/// SDL_InitSubSystem() might be preferred.<br/>
		/// The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)<br/>
		/// subsystems are initialized by default. Message boxes<br/>
		/// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the<br/>
		/// video subsystem, in hopes of being useful in showing an error dialog when<br/>
		/// SDL_Init fails. You must specifically initialize other subsystems if you<br/>
		/// use them in your application.<br/>
		/// Logging (such as SDL_Log) works without initialization, too.<br/>
		/// `flags` may be any of the following OR'd together:<br/>
		/// - `SDL_INIT_TIMER`: timer subsystem<br/>
		/// - `SDL_INIT_AUDIO`: audio subsystem<br/>
		/// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events<br/>
		/// subsystem<br/>
		/// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the<br/>
		/// events subsystem<br/>
		/// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem<br/>
		/// - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically<br/>
		/// initializes the joystick subsystem<br/>
		/// - `SDL_INIT_EVENTS`: events subsystem<br/>
		/// - `SDL_INIT_EVERYTHING`: all of the above subsystems<br/>
		/// - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored<br/>
		/// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()<br/>
		/// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or<br/>
		/// call SDL_Quit() to force shutdown). If a subsystem is already loaded then<br/>
		/// this call will increase the ref-count and return.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Init")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Init")]
		internal static extern int SDLInitNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Initialize the SDL library.<br/>		/// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the<br/>		/// two may be used interchangeably. Though for readability of your code<br/>		/// SDL_InitSubSystem() might be preferred.<br/>		/// The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)<br/>		/// subsystems are initialized by default. Message boxes<br/>		/// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the<br/>		/// video subsystem, in hopes of being useful in showing an error dialog when<br/>		/// SDL_Init fails. You must specifically initialize other subsystems if you<br/>		/// use them in your application.<br/>		/// Logging (such as SDL_Log) works without initialization, too.<br/>		/// `flags` may be any of the following OR'd together:<br/>		/// - `SDL_INIT_TIMER`: timer subsystem<br/>		/// - `SDL_INIT_AUDIO`: audio subsystem<br/>		/// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events<br/>		/// subsystem<br/>		/// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the<br/>		/// events subsystem<br/>		/// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem<br/>		/// - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically<br/>		/// initializes the joystick subsystem<br/>		/// - `SDL_INIT_EVENTS`: events subsystem<br/>		/// - `SDL_INIT_EVERYTHING`: all of the above subsystems<br/>		/// - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored<br/>		/// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()<br/>		/// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or<br/>		/// call SDL_Quit() to force shutdown). If a subsystem is already loaded then<br/>		/// this call will increase the ref-count and return.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Init")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLInit([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			int ret = SDLInitNative(flags);
			return ret;
		}

		/// <summary>
		/// Compatibility function to initialize the SDL library.<br/>
		/// In SDL2, this function and SDL_Init() are interchangeable.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_InitSubSystem")]
		[return: NativeName(NativeNameType.Type, "int")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_InitSubSystem")]
		internal static extern int SDLInitSubSystemNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Compatibility function to initialize the SDL library.<br/>		/// In SDL2, this function and SDL_Init() are interchangeable.<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_InitSubSystem")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SDLInitSubSystem([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			int ret = SDLInitSubSystemNative(flags);
			return ret;
		}

		/// <summary>
		/// Shut down specific SDL subsystems.<br/>
		/// If you start a subsystem using a call to that subsystem's init function<br/>
		/// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),<br/>
		/// SDL_QuitSubSystem() and SDL_WasInit() will not work. You will need to use<br/>
		/// that subsystem's quit function (SDL_VideoQuit()) directly instead. But<br/>
		/// generally, you should not be using those functions directly anyhow; use<br/>
		/// SDL_Init() instead.<br/>
		/// You still need to call SDL_Quit() even if you close all open subsystems<br/>
		/// with SDL_QuitSubSystem().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_QuitSubSystem")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_QuitSubSystem")]
		internal static extern void SDLQuitSubSystemNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Shut down specific SDL subsystems.<br/>		/// If you start a subsystem using a call to that subsystem's init function<br/>		/// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),<br/>		/// SDL_QuitSubSystem() and SDL_WasInit() will not work. You will need to use<br/>		/// that subsystem's quit function (SDL_VideoQuit()) directly instead. But<br/>		/// generally, you should not be using those functions directly anyhow; use<br/>		/// SDL_Init() instead.<br/>		/// You still need to call SDL_Quit() even if you close all open subsystems<br/>		/// with SDL_QuitSubSystem().<br/>		/// <br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_QuitSubSystem")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLQuitSubSystem([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			SDLQuitSubSystemNative(flags);
		}

		/// <summary>
		/// Get a mask of the specified subsystems which are currently initialized.<br/>
		/// <br/>
		/// The return value does not include SDL_INIT_NOPARACHUTE.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_WasInit")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_WasInit")]
		internal static extern uint SDLWasInitNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags);

		/// <summary>		/// Get a mask of the specified subsystems which are currently initialized.<br/>		/// <br/>		/// The return value does not include SDL_INIT_NOPARACHUTE.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_WasInit")]
		[return: NativeName(NativeNameType.Type, "Uint32")]
		public static uint SDLWasInit([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "Uint32")] uint flags)
		{
			uint ret = SDLWasInitNative(flags);
			return ret;
		}

		/// <summary>
		/// Clean up all initialized subsystems.<br/>
		/// You should call this function even if you have already shutdown each<br/>
		/// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this<br/>
		/// function even in the case of errors in initialization.<br/>
		/// If you start a subsystem using a call to that subsystem's init function<br/>
		/// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),<br/>
		/// then you must use that subsystem's quit function (SDL_VideoQuit()) to shut<br/>
		/// it down before calling SDL_Quit(). But generally, you should not be using<br/>
		/// those functions directly anyhow; use SDL_Init() instead.<br/>
		/// You can use this function with atexit() to ensure that it is run when your<br/>
		/// application is shutdown, but it is not wise to do this from a library or<br/>
		/// other dynamically loaded code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "SDL_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "SDL_Quit")]
		internal static extern void SDLQuitNative();

		/// <summary>		/// Clean up all initialized subsystems.<br/>		/// You should call this function even if you have already shutdown each<br/>		/// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this<br/>		/// function even in the case of errors in initialization.<br/>		/// If you start a subsystem using a call to that subsystem's init function<br/>		/// (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),<br/>		/// then you must use that subsystem's quit function (SDL_VideoQuit()) to shut<br/>		/// it down before calling SDL_Quit(). But generally, you should not be using<br/>		/// those functions directly anyhow; use SDL_Init() instead.<br/>		/// You can use this function with atexit() to ensure that it is run when your<br/>		/// application is shutdown, but it is not wise to do this from a library or<br/>		/// other dynamically loaded code.<br/>		/// <br/>		/// <br/>		/// </summary>		[NativeName(NativeNameType.Func, "SDL_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SDLQuit()
		{
			SDLQuitNative();
		}

	}
}
